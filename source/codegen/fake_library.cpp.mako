<%
import common_helpers
import handler_helpers
driver_name_pascal = common_helpers.driver_name_to_pascal(data["config"]["driver_name"])
driver_name_caps_underscore = common_helpers.driver_name_add_underscore(data["config"]["driver_name"])
module_name = data["config"]["module_name"]

driver_name_camel = common_helpers.pascal_to_camel(driver_name_pascal)
c_function_prefix = data["config"]["c_function_prefix"]

functions = data["functions"]
%>\
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Source file for mocking shared library functions for ${driver_name_camel}.
// This should only be used for writing tests.
//---------------------------------------------------------------------

#include "${module_name}_fake_library.h"

namespace ni
{
namespace tests
{
namespace unit
{
namespace hardware
{
namespace grpc
{
namespace internal
{

  ${driver_name_pascal}SharedLibrary::${driver_name_pascal}SharedLibrary(const char* library_name)
    : FakeSharedLibrary(library_name)
  {
  }

  ${driver_name_pascal}SharedLibrary::~${driver_name_pascal}SharedLibrary()
  {
    unload();
  }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpmf-conversions"

  void ${driver_name_pascal}SharedLibrary::create_function_map()
  {
% for method_name in functions:
<%
  f = functions[method_name]
  if not handler_helpers.should_gen_function_pointer(f) :
    continue
  parameters = f["parameters"]
  handler_helpers.sanitize_names(parameters)
%>\
% if not common_helpers.has_array_parameter(f) :
      // Register function mock of ${c_function_prefix}${method_name} to map.
      int (ni::tests::unit::hardware::grpc::internal::${driver_name_pascal}SharedLibrary::*${method_name}_fp)(${handler_helpers.create_params(parameters, driver_name_pascal)});
      ${method_name}_fp = &ni::tests::unit::hardware::grpc::internal::${driver_name_pascal}SharedLibrary::${c_function_prefix}${method_name};
      register_function("${c_function_prefix}${method_name}", reinterpret_cast<void*>(${method_name}_fp));

% endif
% endfor
  }

#pragma GCC diagnostic pop

} // namespace internal
} // namespace grpc
} // namespace hardware
} // namespace unit
} // namespace tests
} // namespace ni
