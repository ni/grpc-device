<%
import common_helpers
import handler_helpers
driver_name_pascal = common_helpers.driver_name_to_pascal(data["config"]["driver_name"])
driver_name_caps_underscore = common_helpers.driver_name_add_underscore(data["config"]["driver_name"])

driver_name_camel = common_helpers.pascal_to_camel(driver_name_pascal)
c_function_prefix = data["config"]["c_function_prefix"]

functions = data["functions"]
%>\
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Header file for mocking shared library functions for ${driver_name_camel}.
// This should only be used for writing tests.
//---------------------------------------------------------------------

#ifndef FAKE_${driver_name_caps_underscore}_LIBRARY_HEADER
#define FAKE_${driver_name_caps_underscore}_LIBRARY_HEADER

#include "fake_shared_library.h"
#include <gmock/gmock.h>

namespace ni
{
namespace tests
{
namespace unit
{
namespace hardware
{
namespace grpc
{
namespace internal
{

  class ${driver_name_pascal}SharedLibrary : public FakeSharedLibrary
  {
    public:
      ${driver_name_pascal}SharedLibrary(const char* library_name);
      virtual ~${driver_name_pascal}SharedLibrary;
% for method_name in functions:
<%
  f = functions[method_name]
  if not handler_helpers.should_gen_function_pointer(f) :
    continue
  parameters = f["parameters"]
  handler_helpers.sanitize_names(parameters)
%>\
% if not common_helpers.has_array_parameter(f) :
      MOCK_METHOD(int, ${c_function_prefix}${method_name}, (${handler_helpers.create_params(parameters, driver_name_pascal)}));
% endif
% endfor
    protected:
      void create_function_map() override;
  };

} // namespace internal
} // namespace grpc
} // namespace hardware
} // namespace unit
} // namespace tests
} // namespace ni

#ENDIF // FAKE_${driver_name_caps_underscore}_LIBRARY_HEADER
