<%
import common_helpers
import handler_helpers
functions = data['functions']

driver_name = data["config"]["driver_name"]
driver_name_pascal = common_helpers.driver_name_to_pascal(driver_name)
driver_name_caps_underscore = common_helpers.driver_name_add_underscore(data["config"]["driver_name"])

driver_full_namespace = common_helpers.get_service_namespace(driver_name_caps_underscore)
driver_namespaces = driver_full_namespace.split(".")
reversed_driver_namespaces = driver_namespaces.copy()
reversed_driver_namespaces.reverse()
define_name = driver_full_namespace + "_interface_h"
define_name = define_name.upper().replace(".", "_")
%>\
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Interface header for implementing interactions with ${driver_name}
//---------------------------------------------------------------------
## Define section
#ifndef ${define_name}
#define ${define_name}

## Include section
#include <grpcpp/grpcpp.h>

% for namespace in driver_namespaces:
namespace ${namespace} {
% endfor

class ${driver_name_pascal}Interface {
 public:
  virtual ::grpc::Status CheckIfFunctionExists(const char* functionName) = 0;
% for function in functions:
<%
  f = functions[function]
  if not common_helpers.should_gen_service_handler(f):
    continue
  parameters = f['parameters']
  handler_helpers.sanitize_names(parameters)
%>\
% if not common_helpers.has_array_parameter(f):
  virtual int ${function}(${handler_helpers.create_params(parameters, driver_name_pascal)}) = 0;
% endif
% endfor
};

% for namespace in reversed_driver_namespaces:
} // namespace ${namespace}
% endfor
#endif  // ${define_name}
