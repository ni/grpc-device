<%
import service_helpers

config = data['config']
functions = data['functions']

service_class_prefix = config["service_class_prefix"]
namespace_prefix = config["namespace_component"] + "_grpc"
include_guard_name = service_helpers.get_include_guard_name(config, "_LIBRARY_H")
c_function_prefix = config["c_function_prefix"]

class_name = f"{service_class_prefix}Library"
inherited_functions = service_helpers.filter_api_functions(functions)

set_runtime_environment_supported = 'SetRuntimeEnvironment' in service_helpers.filter_api_functions(functions, only_mockable_functions=False)
%>\
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Real implementation of LibraryInterface for ${config["driver_name"]}
//---------------------------------------------------------------------
#ifndef ${include_guard_name}
#define ${include_guard_name}

#include "${config["module_name"]}_library_interface.h"

#include <server/shared_library_interface.h>

#include <memory>

namespace ${config["namespace_component"]}_grpc {

class ${class_name} : public ${namespace_prefix}::${class_name}Interface {
 public:
  ${class_name}();
  explicit ${class_name}(std::shared_ptr<nidevice_grpc::SharedLibraryInterface> shared_library);
  virtual ~${class_name}();

  ::grpc::Status check_function_exists(std::string functionName);
% for method_name in service_helpers.filter_api_functions(functions, only_mockable_functions=False):
<%
  f = functions[method_name]
  parameters = f['parameters']
  return_type = f['returns']
  override_specifier = " override" if method_name in inherited_functions else ""
%>\
  ${return_type} ${method_name}(${service_helpers.create_params(parameters, expand_varargs=True)})${override_specifier};
% endfor
% if set_runtime_environment_supported:
  bool is_runtime_environment_set() const; // needed to test that we properly call SetRuntimeEnvironment
% endif

 private:
% for method_name in service_helpers.filter_api_functions(functions, only_mockable_functions=False):
<%
  f = functions[method_name]
  parameters = f['parameters']
  return_type = f['returns']
  c_name = service_helpers.get_cname(functions, method_name, c_function_prefix)
%>\
## "Private" methods aren't in the public header, so generate the params from the metadata.
% if service_helpers.is_private_method(f) or service_helpers.is_restricted_driver_service(config):
  using ${method_name}Ptr = ${return_type} (*)(${service_helpers.create_params(parameters, expand_varargs=False)});
% else:
  using ${method_name}Ptr = decltype(&${c_name});
% endif
% endfor

  typedef struct FunctionPointers {
% for method_name in service_helpers.filter_api_functions(functions, only_mockable_functions=False):
    ${method_name}Ptr ${method_name};
% endfor
  } FunctionLoadStatus;

  std::shared_ptr<nidevice_grpc::SharedLibraryInterface> shared_library_;
  FunctionPointers function_pointers_;
% if set_runtime_environment_supported:
  bool runtime_environment_set_; // needed to test that we properly call SetRuntimeEnvironment
% endif
};

}  // namespace ${config["namespace_component"]}_grpc

#endif  // ${include_guard_name}
