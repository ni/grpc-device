<%
import common_helpers
import service_helpers

config = data['config']
functions = data['functions']

service_class_prefix = config["service_class_prefix"]
module_name = config["module_name"]
c_function_prefix = config["c_function_prefix"]
c_dll_function_prefix = config.get("c_dll_function_prefix", c_function_prefix)
linux_library_info = config['library_info']['Linux']['64bit']
linux_library_name = linux_library_info['name']
linux_abi_version = linux_library_info.get('abi_version', None)
linux_so_version_suffix = f'.{linux_abi_version}' if linux_abi_version else ''
windows_library_info = config['library_info']['Windows']['64bit']
windows_library_name = windows_library_info['name']

class_name = f"{service_class_prefix}Library"

initialization_list = "shared_library_(shared_library)"
set_runtime_environment_supported = 'SetRuntimeEnvironment' in service_helpers.filter_api_functions(functions, only_mockable_functions=False)
if set_runtime_environment_supported:
  initialization_list += ", runtime_environment_set_(false)"
%>\
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the ${config["driver_name"]} Metadata
//---------------------------------------------------------------------
#include "${module_name}_library.h"
#include <server/shared_library.h>
% if set_runtime_environment_supported:
#include "version.h"
% endif

#include <memory>

#if defined(_MSC_VER)
static const char* kLibraryName = "${windows_library_name}";
#else
static const char* kLibraryName = "lib${linux_library_name}.so${linux_so_version_suffix}";
#endif

namespace ${config["namespace_component"]}_grpc {

${class_name}::${class_name}() : ${class_name}(std::make_shared<nidevice_grpc::SharedLibrary>()) {}

${class_name}::${class_name}(std::shared_ptr<nidevice_grpc::SharedLibraryInterface> shared_library) : ${initialization_list}
{
  shared_library_->set_library_name(kLibraryName);
  shared_library_->load();
  bool loaded = shared_library_->is_loaded();
  memset(&function_pointers_, 0, sizeof(function_pointers_));
  if (!loaded) {
    return;
  }
% for method_name in service_helpers.filter_api_functions(functions, only_mockable_functions=False):
<%
  c_name = service_helpers.get_cname(functions, method_name, c_dll_function_prefix)
%>\
  function_pointers_.${method_name} = reinterpret_cast<${method_name}Ptr>(shared_library_->get_function_pointer("${c_name}"));
% endfor
% if set_runtime_environment_supported:

  if (function_pointers_.SetRuntimeEnvironment) {
    this->SetRuntimeEnvironment(nidevice_grpc::kNiDeviceGrpcOriginalFileName, nidevice_grpc::kNiDeviceGrpcFileVersion, "", "");
    this->runtime_environment_set_ = true;
  }
% endif
}

${class_name}::~${class_name}()
{
}

::grpc::Status ${class_name}::check_function_exists(std::string functionName)
{
  return shared_library_->function_exists(functionName.c_str())
    ? ::grpc::Status::OK
    : ::grpc::Status(::grpc::NOT_FOUND, "Could not find the function " + functionName);
}

% for method_name in service_helpers.filter_api_functions(functions, only_mockable_functions=False):
<%
  f = functions[method_name]
  parameters = f['parameters']
  return_type = f['returns']
  parameter_list = service_helpers.create_params(parameters, expand_varargs=True)
  argument_list = ', '.join(p['cppName'] for p in service_helpers.expand_varargs_parameters(parameters) if not p.get("proto_only", False))
  c_name = service_helpers.get_cname(functions, method_name, c_function_prefix)
%>\
${return_type} ${class_name}::${method_name}(${parameter_list})
{
  if (!function_pointers_.${method_name}) {
    throw nidevice_grpc::LibraryLoadException("Could not find ${c_name}.");
  }
  return function_pointers_.${method_name}(${argument_list});
}

% endfor
% if set_runtime_environment_supported:
bool ${class_name}::is_runtime_environment_set() const { return this->runtime_environment_set_; }

% endif
}  // namespace ${config["namespace_component"]}_grpc
