<%
import service_helpers

config = data['config']
functions = data['functions']

service_class_prefix = config["service_class_prefix"]
namespace_prefix = config["namespace_component"] + "_grpc"
include_guard_name = service_helpers.get_include_guard_name(config, "_MOCK_LIBRARY_H")
%>\
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Mock of LibraryInterface for ${config["driver_name"]}
//---------------------------------------------------------------------
## Define section
#ifndef ${include_guard_name}
#define ${include_guard_name}

## Include section
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include "${config["module_name"]}_library_interface.h"

namespace ni {
namespace tests {
namespace unit {

class ${service_class_prefix}MockLibrary : public ${namespace_prefix}::${service_class_prefix}LibraryInterface {
 public:
% for method_name in service_helpers.filter_api_functions(functions):
<%
  f = functions[method_name]
  parameters = f['parameters']
  return_type = f['returns']
%>\
% if len(parameters) <= 15: # MOCK_METHOD shows compilation error (undefined GMOCK_PP_INTERNAL_FOR_EACH_IMPL_<type>) for params > 15
  MOCK_METHOD(${return_type}, ${method_name}, (${service_helpers.create_params(parameters)}), (override));
% else:
  ${return_type} ${method_name}(${service_helpers.create_params(parameters)}) { throw std::runtime_error("Not implemented."); }
% endif
% endfor
};

}  // namespace unit
}  // namespace tests
}  // namespace ni
#endif  // ${include_guard_name}
