<%
import common_helpers
import handler_helpers

attributes = data['attributes']
config = data['config']
enums = data['enums']
functions = data['functions']

service_class_prefix = config["service_class_prefix"]
driver_namespaces = handler_helpers.get_namespace_segments(config)
namespace_prefix = "::".join(driver_namespaces) + "::"
module_name = config["module_name"]
c_function_prefix = config["c_function_prefix"]
linux_library_name = config['library_info']['Linux']['64bit']['name']
windows_libary_name = config['library_info']['Windows']['64bit']['name']
%>\

//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the ${config["driver_name"]} Metadata
//---------------------------------------------------------------------
#include "${module_name}_service.h"

#include <${config["c_header"]}>
#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>

## Namespaces
% for namespace in driver_namespaces:
namespace ${namespace} {
% endfor

  namespace internal = ni::hardware::grpc::internal;
## Function pointers to driver library
% for function in handler_helpers.filter_api_functions(functions):
<%
    f = functions[function]
    parameters = f['parameters']
    handler_helpers.sanitize_names(parameters)
    return_type = f['returns']
%>\
% if not common_helpers.has_unsupported_parameter(f):
  using ${c_function_prefix}${function}Ptr = ${return_type} (*)(${handler_helpers.create_params(parameters)});
% endif
%endfor

  #if defined(_MSC_VER)
    static const char* driver_api_library_name = "${windows_libary_name}";
  #else
    static const char* driver_api_library_name = "./lib${linux_library_name}.so";
  #endif

## Constructors
  ${service_class_prefix}Service::${service_class_prefix}Service(internal::SharedLibrary* shared_library, internal::SessionRepository* session_repository)
      : shared_library_(shared_library), session_repository_(session_repository)
  {
    shared_library_->set_library_name(driver_api_library_name);
  }

  ${service_class_prefix}Service::~${service_class_prefix}Service()
  {
  }

% for function in common_helpers.filter_proto_rpc_functions(functions):
<%
    f = functions[function]
    c_function_name = c_function_prefix + function
    method_name = common_helpers.snake_to_camel(function)
    parameters = f['parameters']
    handler_helpers.sanitize_names(parameters)
    input_parameters = [p for p in parameters if common_helpers.is_input_parameter(p)]
    output_parameters = [p for p in parameters if common_helpers.is_output_parameter(p)]
%>\
  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status ${service_class_prefix}Service::${method_name}(::grpc::ServerContext* context, const ${method_name}Request* request, ${method_name}Response* response)
  {
% if common_helpers.has_unsupported_parameter(f):
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

<% continue %>
% endif
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto ${c_function_name}_function = reinterpret_cast<${c_function_name}Ptr>(shared_library_->get_function_pointer("${c_function_name}"));
    if (${c_function_name}_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: ${c_function_name}");
    }

%for parameter in input_parameters:
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
  paramter_name_ctype = parameter_name + "_ctype"
  parameter_type = parameter['type']
%>\
%if common_helpers.is_enum(parameter) == True:
    ## TODO: Handle non integer enums
    // TODO: The below would work with integer enums but we need to properly convert non-integer enums to their corresponding values of the correct type.
    // auto ${parameter_name} = static_cast<${parameter_type}>(${handler_helpers.get_request_value(parameter)});
    ${parameter_type} ${parameter_name};
% else:
    ${parameter_type} ${parameter_name} = ${handler_helpers.get_request_value(parameter)};
% endif
%endfor
%for parameter in output_parameters:
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
  paramter_name_ctype = parameter_name + "_ctype"
  parameter_type = parameter['type']
%>\
%if common_helpers.is_enum(parameter) == True:
    ${parameter_type} ${paramter_name_ctype};
<%
     parameter['cppName'] = paramter_name_ctype
%>\
%else:
    ${parameter_type} ${parameter_name};
%endif
%endfor
    auto status = ${c_function_name}_function(${handler_helpers.create_args(parameters)});
<%
     parameter['cppName'] = parameter_name
%>\
    response->set_status(status);
%if output_parameters:
    if (status == 0) {
%for parameter in output_parameters:
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
  paramter_name_ctype = parameter_name + "_ctype"
  parameter_type = parameter['type']
%>\
## TODO: Figure out how to format ViSession responses. Look at Cifra's example for an idea.
%if common_helpers.is_enum(parameter) == True:
      ##TODO: Handle non int types
      response->set_${parameter_name}(static_cast<${namespace_prefix}${parameter["enum"]}>(${paramter_name_ctype}));
% else:
      response->set_${parameter_name}(${parameter_name});
%endif
%endfor
    }
%endif
    return ::grpc::Status::OK;
  }

% endfor
% for namespace in reversed(driver_namespaces):
} // namespace ${namespace}
% endfor
