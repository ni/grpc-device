<%
import common_helpers
import handler_helpers

config = data['config']
enums = data['enums']
functions = data['functions']

service_class_prefix = config["service_class_prefix"]
namespace_prefix = "ni::" + config["namespace_component"] + "::grpc::"
module_name = config["module_name"]
c_function_prefix = config["c_function_prefix"]
linux_library_name = config['library_info']['Linux']['64bit']['name']
windows_libary_name = config['library_info']['Windows']['64bit']['name']
%>\

//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the ${config["driver_name"]} Metadata
//---------------------------------------------------------------------
#include "${module_name}_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>

namespace ni {
namespace ${config["namespace_component"]} {
namespace grpc {

  namespace internal = ni::hardware::grpc::internal;

  ${service_class_prefix}Service::${service_class_prefix}Service(${service_class_prefix}LibraryWrapper* library_wrapper, internal::SessionRepository* session_repository)
      : library_wrapper_(library_wrapper), session_repository_(session_repository)
  {
  }

  ${service_class_prefix}Service::~${service_class_prefix}Service()
  {
  }

% for function in common_helpers.filter_proto_rpc_functions(functions):
<%
    f = functions[function]
    method_name = common_helpers.snake_to_camel(function)
%>\
  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status ${service_class_prefix}Service::${method_name}(::grpc::ServerContext* context, const ${method_name}Request* request, ${method_name}Response* response)
  {
% if common_helpers.has_unsupported_parameter(f):
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
% elif function == config['init_function']:
${gen_init_method_body(function)}
% else:
${gen_simple_method_body(function)}
% endif
  }

% endfor

} // namespace grpc
} // namespace ${config["namespace_component"]}
} // namespace ni
\
\
\
\
<%def name="gen_init_method_body(function)">\
<%
  f = functions[function]
  parameters = f['parameters']
  handler_helpers.sanitize_names(parameters)
  output_parameters = [p for p in parameters if common_helpers.is_output_parameter(p)]
  session_output_param = next((parameter for parameter in output_parameters if parameter['type'] == 'ViSession'), None)
  session_output_var_name = session_output_param['cppName']
%>\
${check_if_function_exists(function)}

${request_input_parameters(f)}
    auto init_lambda = [&] () -> std::tuple<int, uint32_t> {
    ViSession ${session_output_var_name};
    int status = library_wrapper_->${function}(${handler_helpers.create_args(parameters)});
    return std::make_tuple(status, vi);
    };
    uint32_t session_id = 0;
    std::string session_name = request->session_name();
    auto cleanup_lambda = [&] (uint32_t id) { library_wrapper_->${config['close_function']}(id); };
    int status = session_repository_->add_session(session_name, init_lambda, cleanup_lambda, session_id);
    response->set_status(status);
    if (status == 0) {
      ni::hardware::grpc::Session session;
      session.set_id(session_id);
      response->set_allocated_${session_output_var_name}(&session);
    }
    return ::grpc::Status::OK;\
</%def>\
\
\
\
\
<%def name="gen_simple_method_body(function)">\
<%
  f = functions[function]
  parameters = f['parameters']
  handler_helpers.sanitize_names(parameters)
  output_parameters = [p for p in parameters if common_helpers.is_output_parameter(p)]
%>\
${check_if_function_exists(function)}

${request_input_parameters(f)}\
%for parameter in output_parameters:
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
%>\
    ${parameter['type']} ${parameter_name} {};
%endfor
%if function == config['close_function']:
    session_repository_->remove_session(${handler_helpers.create_args(parameters)});
%else:
    auto status = library_wrapper_->${function}(${handler_helpers.create_args(parameters)});
    response->set_status(status);
%endif
%if output_parameters:
    if (status == 0) {
${set_response_values(output_parameters=output_parameters)}\
    }
%endif
    return ::grpc::Status::OK;\
</%def>\
\
\
\
\
<%def name="check_if_function_exists(function)">\
<%
  c_function_name = c_function_prefix + function
%>\
    ::grpc::Status libraryStatus = library_wrapper_->check_function_exists("${c_function_name}");
    if (!libraryStatus.ok()) {
      return libraryStatus;
    }\
</%def>\
\
\
\
\
<%def name="request_input_parameters(function)">\
<%
    parameters = function['parameters']
    handler_helpers.sanitize_names(parameters)
    input_parameters = [p for p in parameters if common_helpers.is_input_parameter(p)]
%>\
% for parameter in input_parameters:
${initialize_input_param_snippet(parameter=parameter)}
% endfor
</%def>\
\
\
\
\
<%def name="initialize_input_param_snippet(parameter)">\
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
  field_name = common_helpers.camel_to_snake(parameter["name"])
  request_snippet = f'request->{field_name}()'
  c_type = parameter['type']
%>\
%if common_helpers.is_enum(parameter) == True and enums[parameter["enum"]].get("generate-mappings", False):
${initialize_enum_with_mapping_snippet(parameter)}
% else:
  % if c_type == 'ViConstString':
    ${c_type} ${parameter_name} = ${request_snippet}.c_str();\
  % elif c_type == 'ViString' or c_type == 'ViRsrc':
    ${c_type} ${parameter_name} = (${c_type})${request_snippet}.c_str();\
  % elif c_type == 'ViInt8[]' or c_type == 'ViChar[]':
    ${c_type} ${parameter_name} = (${c_type[:-2]}*)${request_snippet}.c_str();\
  % elif c_type == 'ViChar' or c_type == 'ViInt16' or c_type == 'ViInt8' or 'enum' in parameter:
    ${c_type} ${parameter_name} = (${c_type})${request_snippet};\
  % elif c_type == 'ViSession':
    auto session = request->${field_name}();
    ${c_type} ${parameter_name} = session_repository_->access_session(session.id(), session.name());\
  % else:
    ${c_type} ${parameter_name} = ${request_snippet};\
  % endif
% endif
</%def>\
\
\
\
\
<%def name="initialize_enum_with_mapping_snippet(parameter)">\
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
  map_name = parameter["enum"].lower() + "_input_map_"
  iterator_name = parameter_name + "_imap_it"
%>\
    auto ${iterator_name} = ${map_name}.find(request->${parameter_name}());

    if (${iterator_name} == ${map_name}.end()) {
      return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ${parameter_name} was not specified or out of range.");
    }
%if parameter['type'] == "ViConstString": 
    auto ${parameter_name} = static_cast<${parameter['type']}>((${iterator_name}->second).c_str());\
%else:
    auto ${parameter_name} = static_cast<${parameter['type']}>(${iterator_name}->second);\
%endif
</%def>\
\
\
\
\
<%def name="set_response_values(output_parameters)">\
%for parameter in output_parameters:
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
%>\
%if common_helpers.is_enum(parameter) == True:
%if enums[parameter["enum"]].get("generate-mappings", False):
<% 
  map_name = parameter["enum"].lower() + "_output_map_"
  iterator_name = parameter_name + "_imap_it"
%>\

    auto ${iterator_name} = ${map_name}.find(${parameter_name});
    if(${iterator_name} == ${map_name}.end()) {
      return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ${parameter_name} was not specified or out of range.");
    }
      response->set_${parameter_name}(static_cast<${namespace_prefix}${parameter["enum"]}>(${iterator_name}->second));
%else:
      response->set_${parameter_name}(static_cast<${namespace_prefix}${parameter["enum"]}>(${parameter_name}));
%endif
% else:
      response->set_${parameter_name}(${parameter_name});
%endif
%endfor
</%def>