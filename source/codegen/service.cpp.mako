<%
import common_helpers
import handler_helpers

config = data['config']
enums = data['enums']
functions = data['functions']
lookup = data["lookup"]

service_class_prefix = config["service_class_prefix"]
namespace_prefix = "grpc::" + config["namespace_component"] + "::"
module_name = config["module_name"]
c_function_prefix = config["c_function_prefix"]
linux_library_name = config['library_info']['Linux']['64bit']['name']
windows_libary_name = config['library_info']['Windows']['64bit']['name']
if len(config["custom_types"]) > 0:
  custom_types = config["custom_types"]
%>\

//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the ${config["driver_name"]} Metadata
//---------------------------------------------------------------------
#include "${module_name}_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>

namespace grpc {
namespace ${config["namespace_component"]} {

  ${service_class_prefix}Service::${service_class_prefix}Service(${service_class_prefix}LibraryInterface* library, grpc::nidevice::SessionRepository* session_repository)
      : library_(library), session_repository_(session_repository)
  {
  }

  ${service_class_prefix}Service::~${service_class_prefix}Service()
  {
  }

  %if 'custom_types' in locals():
  %for custom_type in custom_types:
  void ${service_class_prefix}Service::Copy(const ${custom_type["name"]}& input, ${namespace_prefix}${custom_type["grpc_name"]}* output) 
  {
%for field in custom_type["fields"]: 
    output->set_${field["grpc_name"]}(input.${field["name"]});
%endfor
  }

  void ${service_class_prefix}Service::Copy(const std::vector<${custom_type["name"]}>& input, google::protobuf::RepeatedPtrField<${namespace_prefix}${custom_type["grpc_name"]}>* output) 
  {
    for (auto item : input) {
      auto message = new ${namespace_prefix}${custom_type["grpc_name"]}();
      Copy(item, message);
      output->AddAllocated(message);
    }
  }

%endfor
%endif
% for function_name in handler_helpers.filter_proto_rpc_functions_to_generate(functions):
<%
    function_data = functions[function_name]
    method_name = common_helpers.snake_to_pascal(function_name)
    parameters = function_data['parameters']
    handler_helpers.sanitize_names(parameters)
    common_helpers.mark_non_grpc_params(parameters)
%>\
  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status ${service_class_prefix}Service::${method_name}(::grpc::ServerContext* context, const ${method_name}Request* request, ${method_name}Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
% if common_helpers.has_unsupported_parameter(function_data):
      return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
% elif common_helpers.is_init_method(function_data):
${gen_init_method_body(function_name=function_name, function_data=function_data, parameters=parameters)}
% elif common_helpers.has_ivi_dance_param(parameters):
${gen_ivi_dance_method_body(function_name=function_name, function_data=function_data, parameters=parameters)}
% else:
${gen_simple_method_body(function_name=function_name, function_data=function_data, parameters=parameters)}
% endif
    }
    catch (grpc::nidevice::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

% endfor
} // namespace ${config["namespace_component"]}
} // namespace grpc
\
\
\
\
\
<%def name="gen_init_method_body(function_name, function_data, parameters)">\
<%
  output_parameters = [p for p in parameters if common_helpers.is_output_parameter(p)]
  session_output_param = next((parameter for parameter in output_parameters if parameter['type'] == 'ViSession'), None)
  session_output_var_name = session_output_param['cppName']
%>\
${request_input_parameters(function_name, parameters)}
      auto init_lambda = [&] () -> std::tuple<int, uint32_t> {
        ViSession ${session_output_var_name};
        int status = library_->${function_name}(${handler_helpers.create_args(parameters)});
        return std::make_tuple(status, vi);
      };
      uint32_t session_id = 0;
      const std::string& session_name = request->session_name();
      auto cleanup_lambda = [&] (uint32_t id) { library_->${config['close_function']}(id); };
      int status = session_repository_->add_session(session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_${session_output_var_name}()->set_id(session_id);
      }
      return ::grpc::Status::OK;\
</%def>\
\
\
\
\
<%def name="gen_ivi_dance_method_body(function_name, function_data, parameters)">\
<%
  (size_param, array_param, non_ivi_params) = common_helpers.get_ivi_dance_params(parameters)
  output_parameters = [p for p in parameters if common_helpers.is_output_parameter(p)]
%>\
${request_input_parameters(function_name, non_ivi_params)}\

      auto status = library_->${function_name}(${handler_helpers.create_args_for_ivi_dance(parameters)});
      if (status < 0) {
        response->set_status(status);
        return ::grpc::Status::OK;
      }
      ${size_param['type']} ${common_helpers.camel_to_snake(size_param['cppName'])} = status;

${initialize_output_variables_snippet(output_parameters)}\
      status = library_->${function_name}(${handler_helpers.create_args(parameters)});
      response->set_status(status);
%if output_parameters:
      if (status == 0) {
${set_response_values(output_parameters)}\
      }
%endif
      return ::grpc::Status::OK;\
</%def>\
\
\
\
\
<%def name="gen_simple_method_body(function_name, function_data, parameters)">\
<%
  output_parameters = [p for p in parameters if common_helpers.is_output_parameter(p)]
%>\
${request_input_parameters(function_name, parameters)}\
${initialize_output_variables_snippet(output_parameters)}\
%if function_name == config['close_function']:
      session_repository_->remove_session(${handler_helpers.create_args(parameters)});
%else:
      auto status = library_->${function_name}(${handler_helpers.create_args(parameters)});
      response->set_status(status);
%endif
%if output_parameters:
      if (status == 0) {
${set_response_values(output_parameters=output_parameters)}\
      }
%endif
      return ::grpc::Status::OK;\
</%def>\
\
\
\
\
<%def name="request_input_parameters(function_name, parameters)">\
<%
    input_parameters = [p for p in parameters if common_helpers.is_input_parameter(p)]
%>\
% for parameter in input_parameters:
${initialize_input_param_snippet(function_name, parameter=parameter)}
% endfor
</%def>\
\
\
\
\
<%def name="initialize_input_param_snippet(function_name, parameter)">\
% if common_helpers.is_enum(parameter) and enums[parameter["enum"]].get("generate-mappings", False):
${initialize_enum_input_param(function_name, parameter)}\
% elif "determine_size_from" in parameter:
${initialize_len_input_param(parameter)}\
% else:
${initialize_standard_input_param(function_name, parameter)}\
% endif
</%def>\
\
\
\
\
<%def name="initialize_enum_input_param(function_name, parameter)">\
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
  pascal_parameter_name = list(parameter['cppName'])
  pascal_parameter_name[0] = pascal_parameter_name[0].upper()
  pascal_parameter_name = "".join(pascal_parameter_name)
  map_name = parameter["enum"].lower() + "_input_map_"
  iterator_name = parameter_name + "_imap_it"
  enum_type_prefix = function_name + "Request::" + pascal_parameter_name + "OneofCase::"
  param_all_caps_snake = parameter_name.upper()
%>\
      ${parameter['type']} ${parameter_name};
      switch (request->${parameter_name}_oneof_case()) {
        case ${enum_type_prefix}k${pascal_parameter_name}: {
          auto ${iterator_name} = ${map_name}.find(request->${parameter_name}());
          if (${iterator_name} == ${map_name}.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ${parameter_name} was not specified or out of range.");
          }
%if parameter['type'] == "ViConstString":
          ${parameter_name} = static_cast<${parameter['type']}>((${iterator_name}->second).c_str());
%else:
          ${parameter_name} = static_cast<${parameter['type']}>(${iterator_name}->second);
%endif
          break;
        }
        case ${enum_type_prefix}k${pascal_parameter_name}Raw: {
%if parameter['type'] == "ViConstString":
          ${parameter_name} = static_cast<${parameter['type']}>((request->${parameter_name}_raw()).c_str());
%else:
          ${parameter_name} = static_cast<${parameter['type']}>(request->${parameter_name}_raw());
%endif
          break;
        } 
        case ${enum_type_prefix}${param_all_caps_snake}_ONEOF_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ${parameter_name} was not specified or out of range");
          break;
        }
      }
</%def>\
\
\
\
\
<%def name="initialize_len_input_param(parameter)">\
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
  field_name = common_helpers.camel_to_snake(parameter["determine_size_from"])
%>\
      ${parameter['type']} ${parameter_name} = request->${field_name}().size();\
</%def>\
\
\
\
\
<%def name="initialize_standard_input_param(function_name, parameter)">\
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
  field_name = common_helpers.camel_to_snake(parameter["name"])
  PascalFieldName = common_helpers.snake_to_pascal(field_name)
  request_snippet = f'request->{field_name}()'
  c_type = parameter['type']
  c_type_pointer = c_type.replace('[]','*')
%>\
    % if c_type == 'ViConstString':
      ${c_type} ${parameter_name} = ${request_snippet}.c_str();\
    % elif c_type == 'ViString' or c_type == 'ViRsrc':
      ${c_type} ${parameter_name} = (${c_type})${request_snippet}.c_str();\
    % elif c_type == 'ViInt8[]' or c_type == 'ViChar[]':
      ${c_type_pointer} ${parameter_name} = (${c_type[:-2]}*)${request_snippet}.c_str();\
    % elif 'enum' in parameter:
      ${c_type} ${parameter_name};
      switch (request->${field_name}_oneof_case()) {
        case grpc::${config["namespace_component"]}::${function_name}Request::${PascalFieldName}OneofCase::k${PascalFieldName}:
          ${parameter_name} = (${c_type})${request_snippet};
          break;
        default:
          ${parameter_name} = (${c_type})request->${field_name}_raw();
          break;
      }
    % elif c_type == 'ViChar' or c_type == 'ViInt16' or c_type == 'ViInt8':
      ${c_type} ${parameter_name} = (${c_type})${request_snippet};\
    % elif c_type == 'ViSession':
      auto ${parameter_name}_grpc_session = ${request_snippet};
      ${c_type} ${parameter_name} = session_repository_->access_session(${parameter_name}_grpc_session.id(), ${parameter_name}_grpc_session.name());\
    % elif common_helpers.is_array(c_type):
      auto ${parameter_name} = const_cast<${c_type_pointer}>(${request_snippet}.data());\
    % else:
      ${c_type} ${parameter_name} = ${request_snippet};\
    % endif
</%def>\
\
\
\
\
<%def name="initialize_output_variables_snippet(output_parameters)">\
%for parameter in output_parameters:
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
  underlying_param_type = common_helpers.get_underlying_type_name(parameter["type"])
%>\
% if common_helpers.is_array(parameter['type']):
<%
  size = ''
  if common_helpers.get_size_mechanism(parameter) == 'fixed':
    size = parameter['size']['value']
  else:
    size = common_helpers.camel_to_snake(parameter['size']['value'])
%>\
% if common_helpers.is_struct(parameter):
      std::vector<${underlying_param_type}> ${parameter_name}(${size}, ${underlying_param_type}());
% elif handler_helpers.is_string_arg(parameter):
      std::string ${parameter_name}(${size}, '\0');
% else:
      response->mutable_${parameter_name}()->Resize(${size}, 0);
      ${underlying_param_type}* ${parameter_name} = response->mutable_${parameter_name}()->mutable_data();
% endif
% else:
      ${underlying_param_type} ${parameter_name} {};
% endif
%endfor
</%def>\
\
\
\
\
<%def name="set_response_values(output_parameters)">\
%for parameter in output_parameters:
<%
  parameter_name = common_helpers.camel_to_snake(parameter['cppName'])
%>\
%if common_helpers.is_enum(parameter) == True:
%  if enums[parameter["enum"]].get("generate-mappings", False):
<%
  map_name = parameter["enum"].lower() + "_output_map_"
  iterator_name = parameter_name + "_imap_it"
%>\
        auto ${iterator_name} = ${map_name}.find(${parameter_name});
        if(${iterator_name} == ${map_name}.end()) {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ${parameter_name} was not specified or out of range.");
        }
        response->set_${parameter_name}(static_cast<${namespace_prefix}${parameter["enum"]}>(${iterator_name}->second));
        response->set_${parameter_name}_raw(${iterator_name}->first);
%  else:
        response->set_${parameter_name}(static_cast<${namespace_prefix}${parameter["enum"]}>(${parameter_name}));
        response->set_${parameter_name}_raw(${parameter_name});
%  endif
%elif common_helpers.is_array(parameter['type']):
%  if handler_helpers.is_string_arg(parameter):
        response->set_${parameter_name}(${parameter_name});
%  elif common_helpers.is_struct(parameter):
        Copy(${parameter_name}, response->mutable_${parameter_name}());
%  endif
%elif parameter['type'] == 'ViSession':
        response->mutable_${parameter_name}()->set_id(${parameter_name});
%else :
        response->set_${parameter_name}(${parameter_name});
%endif
%endfor
</%def>
