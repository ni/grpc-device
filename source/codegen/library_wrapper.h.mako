<%
import common_helpers
import handler_helpers

config = data['config']
functions = data['functions']

service_class_prefix = config["service_class_prefix"]
driver_namespaces = handler_helpers.get_namespace_segments(config)
include_guard_name = handler_helpers.get_include_guard_name(config, "_LIBRARY_WRAPPER_H")
%>\
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Library wrapper for implementing interactions with ${config["driver_name"]}
//---------------------------------------------------------------------
## Define section
#ifndef ${include_guard_name}
#define ${include_guard_name}

## Include section
#include <grpcpp/grpcpp.h>

% for namespace in driver_namespaces:
namespace ${namespace} {
% endfor

class ${service_class_prefix}LibraryWrapper {
public:
  virtual ::grpc::Status check_function_exists(const char* functionName) = 0;
% for method_name in handler_helpers.filter_api_functions(functions):
<%
  f = functions[method_name]
  parameters = f['parameters']
  handler_helpers.sanitize_names(parameters)
  return_type = "std::uint32_t"
%>\
% if not common_helpers.has_unsupported_parameter(f):
  virtual ${return_type} ${method_name}(${handler_helpers.create_params(parameters, service_class_prefix)}) = 0;
% endif
%endfor
};

% for namespace in reversed(driver_namespaces):
}  // namespace ${namespace}
% endfor
#endif  // ${include_guard_name}
