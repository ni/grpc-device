<%
import common_helpers
import handler_helpers
functions = data['functions']

driver_name = data["config"]["driver_name"]
driver_name_pascal = common_helpers.driver_name_to_pascal(driver_name)
driver_name_caps_underscore = common_helpers.driver_name_add_underscore(data["config"]["driver_name"])

driver_full_namespace = common_helpers.get_service_namespace(driver_name_caps_underscore)
driver_namespaces = driver_full_namespace.split(".")
reversed_driver_namespaces = driver_namespaces.copy()
reversed_driver_namespaces.reverse()
define_name = driver_full_namespace + "_library_wrapper_h"
define_name = define_name.upper().replace(".", "_")
%>\
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Library wrapper for implementing interactions with ${driver_name}
//---------------------------------------------------------------------
## Define section
#ifndef ${define_name}
#define ${define_name}

## Include section
#include <grpcpp/grpcpp.h>

% for namespace in driver_namespaces:
namespace ${namespace} {
% endfor

class ${driver_name_pascal}LibraryWrapper {
 public:
  virtual ::grpc::Status check_function_exists(const char* functionName) = 0;
% for method_name in handler_helpers.filter_api_functions(functions):
<%
f = functions[method_name]
parameters = f['parameters']
handler_helpers.sanitize_names(parameters)
return_value = f['returns']
%>\
% if not common_helpers.has_array_parameter(f):
  virtual std::uint32_t ${method_name}(${handler_helpers.create_params(parameters, driver_name_pascal)}) = 0;
% endif
%endfor
};

% for namespace in reversed_driver_namespaces:
}  // namespace ${namespace}
% endfor
#endif  // ${define_name}
