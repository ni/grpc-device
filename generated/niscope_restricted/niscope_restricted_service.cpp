
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-SCOPE-RESTRICTED Metadata
//---------------------------------------------------------------------
#include "niscope_restricted_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/ivi_errors.h"
#include <server/converters.h>

namespace niscope_restricted_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  NiScopeRestrictedService::NiScopeRestrictedService(
      LibrarySharedPtr library,
      ResourceRepositorySharedPtr resource_repository,
      const NiScopeRestrictedFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiScopeRestrictedService::~NiScopeRestrictedService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeRestrictedService::GetStartTimestampInformation(::grpc::ServerContext* context, const GetStartTimestampInformationRequest* request, GetStartTimestampInformationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt32 sys_time_in_128_bits_t1 {};
      ViUInt32 sys_time_in_128_bits_t2 {};
      ViUInt32 sys_time_in_128_bits_t3 {};
      ViUInt32 sys_time_in_128_bits_t4 {};
      ViReal64 device_time_in_absolute_time_units {};
      auto status = library_->GetStartTimestampInformation(vi, &sys_time_in_128_bits_t1, &sys_time_in_128_bits_t2, &sys_time_in_128_bits_t3, &sys_time_in_128_bits_t4, &device_time_in_absolute_time_units);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_sys_time_in_128_bits_t1(sys_time_in_128_bits_t1);
      response->set_sys_time_in_128_bits_t2(sys_time_in_128_bits_t2);
      response->set_sys_time_in_128_bits_t3(sys_time_in_128_bits_t3);
      response->set_sys_time_in_128_bits_t4(sys_time_in_128_bits_t4);
      response->set_device_time_in_absolute_time_units(device_time_in_absolute_time_units);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeRestrictedService::GetStartTimestampInformationWithChannels(::grpc::ServerContext* context, const GetStartTimestampInformationWithChannelsRequest* request, GetStartTimestampInformationWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_list_mbcs = convert_from_grpc<std::string>(request->channel_list());
      auto channel_list = channel_list_mbcs.c_str();
      ViUInt32 number_of_channels = request->number_of_channels();
      response->mutable_sys_time_in_128_bits_t1_array()->Resize(number_of_channels, 0);
      ViUInt32* sys_time_in_128_bits_t1_array = reinterpret_cast<ViUInt32*>(response->mutable_sys_time_in_128_bits_t1_array()->mutable_data());
      response->mutable_sys_time_in_128_bits_t2_array()->Resize(number_of_channels, 0);
      ViUInt32* sys_time_in_128_bits_t2_array = reinterpret_cast<ViUInt32*>(response->mutable_sys_time_in_128_bits_t2_array()->mutable_data());
      response->mutable_sys_time_in_128_bits_t3_array()->Resize(number_of_channels, 0);
      ViUInt32* sys_time_in_128_bits_t3_array = reinterpret_cast<ViUInt32*>(response->mutable_sys_time_in_128_bits_t3_array()->mutable_data());
      response->mutable_sys_time_in_128_bits_t4_array()->Resize(number_of_channels, 0);
      ViUInt32* sys_time_in_128_bits_t4_array = reinterpret_cast<ViUInt32*>(response->mutable_sys_time_in_128_bits_t4_array()->mutable_data());
      response->mutable_device_time_in_absolute_time_units_array()->Resize(number_of_channels, 0);
      ViReal64* device_time_in_absolute_time_units_array = response->mutable_device_time_in_absolute_time_units_array()->mutable_data();
      auto status = library_->GetStartTimestampInformationWithChannels(vi, channel_list, number_of_channels, sys_time_in_128_bits_t1_array, sys_time_in_128_bits_t2_array, sys_time_in_128_bits_t3_array, sys_time_in_128_bits_t4_array, device_time_in_absolute_time_units_array);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeRestrictedService::ParseNumberOfChannels(::grpc::ServerContext* context, const ParseNumberOfChannelsRequest* request, ParseNumberOfChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_mbcs = convert_from_grpc<std::string>(request->channel());
      auto channel = channel_mbcs.c_str();
      ViUInt32 num_channels {};
      auto status = library_->ParseNumberOfChannels(vi, channel, &num_channels);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_num_channels(num_channels);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  NiScopeRestrictedFeatureToggles::NiScopeRestrictedFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("niscope_restricted", CodeReadiness::kRelease))
  {
  }
} // namespace niscope_restricted_grpc

