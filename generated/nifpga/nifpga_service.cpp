
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-FPGA Metadata
//---------------------------------------------------------------------
#include "nifpga_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>

namespace nifpga_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  NiFpgaService::NiFpgaService(
      LibrarySharedPtr library,
      ResourceRepositorySharedPtr resource_repository,
      const NiFpgaFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiFpgaService::~NiFpgaService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::Abort(::grpc::ServerContext* context, const AbortRequest* request, AbortResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      auto status = library_->Abort(session);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      uint32_t attribute = request->attribute();
      session_repository_->remove_session(session_grpc_session.name());
      auto status = library_->Close(session, attribute);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::CloseHostMemoryBuffer(::grpc::ServerContext* context, const CloseHostMemoryBufferRequest* request, CloseHostMemoryBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      auto memory_name_mbcs = convert_from_grpc<std::string>(request->memory_name());
      auto memory_name = memory_name_mbcs.c_str();
      auto status = library_->CloseHostMemoryBuffer(session, memory_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::CloseLowLatencyBuffer(::grpc::ServerContext* context, const CloseLowLatencyBufferRequest* request, CloseLowLatencyBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      auto memory_name_mbcs = convert_from_grpc<std::string>(request->memory_name());
      auto memory_name = memory_name_mbcs.c_str();
      auto status = library_->CloseLowLatencyBuffer(session, memory_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::CommitFifoConfiguration(::grpc::ServerContext* context, const CommitFifoConfigurationRequest* request, CommitFifoConfigurationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      uint32_t fifo = request->fifo();
      auto status = library_->CommitFifoConfiguration(session, fifo);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::Download(::grpc::ServerContext* context, const DownloadRequest* request, DownloadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      auto status = library_->Download(session);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::Finalize(::grpc::ServerContext* context, const FinalizeRequest* request, FinalizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto status = library_->Finalize();
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::Initialize(::grpc::ServerContext* context, const InitializeRequest* request, InitializeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto status = library_->Initialize();
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::Open(::grpc::ServerContext* context, const OpenRequest* request, OpenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto bitfile_mbcs = convert_from_grpc<std::string>(request->bitfile());
      auto bitfile = bitfile_mbcs.c_str();
      auto signature_mbcs = convert_from_grpc<std::string>(request->signature());
      auto signature = signature_mbcs.c_str();
      auto resource_mbcs = convert_from_grpc<std::string>(request->resource());
      auto resource = resource_mbcs.c_str();
      uint32_t attribute = request->attribute();
      auto initialization_behavior = request->initialization_behavior();

      bool new_session_initialized {};
      auto init_lambda = [&] () {
        NiFpga_Session session;
        auto status = library_->Open(bitfile, signature, resource, attribute, &session);
        return std::make_tuple(status, session);
      };
      std::string grpc_device_session_name = request->session_name();
      // Capture the library shared_ptr by value. Do not capture `this` or any references.
      LibrarySharedPtr library = library_;
      auto cleanup_lambda = [library] (NiFpga_Session id) { library->Close(id, 0); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, 0);
      }
      response->set_status(status);
      response->mutable_session()->set_name(grpc_device_session_name);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::ReleaseFifoElements(::grpc::ServerContext* context, const ReleaseFifoElementsRequest* request, ReleaseFifoElementsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      uint32_t fifo = request->fifo();
      size_t elements = request->elements();
      auto status = library_->ReleaseFifoElements(session, fifo, elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::Reset(::grpc::ServerContext* context, const ResetRequest* request, ResetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      auto status = library_->Reset(session);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::Run(::grpc::ServerContext* context, const RunRequest* request, RunResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      uint32_t attribute = request->attribute();
      auto status = library_->Run(session, attribute);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::StartFifo(::grpc::ServerContext* context, const StartFifoRequest* request, StartFifoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      uint32_t fifo = request->fifo();
      auto status = library_->StartFifo(session, fifo);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::StopFifo(::grpc::ServerContext* context, const StopFifoRequest* request, StopFifoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      uint32_t fifo = request->fifo();
      auto status = library_->StopFifo(session, fifo);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFpgaService::UnreserveFifo(::grpc::ServerContext* context, const UnreserveFifoRequest* request, UnreserveFifoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      NiFpga_Session session = session_repository_->access_session(session_grpc_session.name());
      uint32_t fifo = request->fifo();
      auto status = library_->UnreserveFifo(session, fifo);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiFpga_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  NiFpgaFeatureToggles::NiFpgaFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nifpga", CodeReadiness::kNextRelease))
  {
  }
} // namespace nifpga_grpc

