
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-XNETSOCKET Metadata
//---------------------------------------------------------------------
#include "nixnetsocket_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/xnetsocket_converters.h"
#include "custom/xnetsocket_errors.h"
#include <server/converters.h>

namespace nixnetsocket_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  NiXnetSocketService::NiXnetSocketService(
      NiXnetSocketLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      nxIpStackRef_tResourceRepositorySharedPtr nx_ip_stack_ref_t_resource_repository,
      const NiXnetSocketFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      nx_ip_stack_ref_t_resource_repository_(nx_ip_stack_ref_t_resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiXnetSocketService::~NiXnetSocketService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Accept(::grpc::ServerContext* context, const AcceptRequest* request, AcceptResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());

      auto addr = allocate_output_storage<nxsockaddr, SockAddr>();
      nxsocklen_t addrlen {};
      auto init_lambda = [&] () {
        auto socket_out = library_->Accept(socket, &addr, &addrlen);
        auto status = socket_out == -1 ? -1 : 0;
        return std::make_tuple(status, socket_out);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (nxSOCKET id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(addr, response->mutable_addr());
        response->mutable_socket()->set_id(session_id);
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::SessionException& ex) {
      return ::grpc::Status(::grpc::INVALID_ARGUMENT, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Bind(::grpc::ServerContext* context, const BindRequest* request, BindResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      auto name = convert_from_grpc<nxsockaddr>(request->name());
      auto namelen = name.size();
      auto status = library_->Bind(socket, name, namelen);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      session_repository_->remove_session(socket_grpc_session.id(), socket_grpc_session.name());
      auto status = library_->Close(socket);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Connect(::grpc::ServerContext* context, const ConnectRequest* request, ConnectResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      auto name = convert_from_grpc<nxsockaddr>(request->name());
      auto namelen = name.size();
      auto status = library_->Connect(socket, name, namelen);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::FdIsSet(::grpc::ServerContext* context, const FdIsSetRequest* request, FdIsSetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto fd_grpc_session = request->fd();
      nxSOCKET fd = session_repository_->access_session(fd_grpc_session.id(), fd_grpc_session.name());
      auto set = convert_from_grpc<nxfd_set>(request->set(), session_repository_);
      auto is_set = library_->FdIsSet(fd, set);
      auto status = 0;
      response->set_status(status);
      if (status_ok(status)) {
        response->set_is_set(is_set);
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::GetAddrInfo(::grpc::ServerContext* context, const GetAddrInfoRequest* request, GetAddrInfoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      auto node = request->node().c_str();
      auto node_api = request->node() == "" ? nullptr : node;
      auto service = request->service().c_str();
      auto service_api = request->service() == "" ? nullptr : service;
      auto hints = convert_from_grpc<nxaddrinfo>(request->hints());
      auto res = allocate_output_storage<nxaddrinfo, google::protobuf::RepeatedPtrField<AddrInfo>>(library_);
      auto status = library_->GetAddrInfo(stack_ref, node_api, service_api, hints, &res);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(res, response->mutable_res());
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::GetNameInfo(::grpc::ServerContext* context, const GetNameInfoRequest* request, GetNameInfoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      auto addr = convert_from_grpc<nxsockaddr>(request->addr());
      auto addrlen = addr.size();
      nxsocklen_t hostlen = request->hostlen();
      nxsocklen_t servlen = request->servlen();
      const auto flags = nidevice_grpc::converters::convert_bitfield_as_enum_array_input(
        request->flags_array(),
        request->flags_raw());

      std::string host;
      if (hostlen > 0) {
          host.resize(hostlen - 1);
      }
      std::string serv;
      if (servlen > 0) {
          serv.resize(servlen - 1);
      }
      auto status = library_->GetNameInfo(stack_ref, addr, addrlen, (char*)host.data(), hostlen, (char*)serv.data(), servlen, flags);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_host(host);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_host()));
        response->set_serv(serv);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_serv()));
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::GetPeerName(::grpc::ServerContext* context, const GetPeerNameRequest* request, GetPeerNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      auto addr = allocate_output_storage<nxsockaddr, SockAddr>();
      auto addrlen = static_cast<nxsocklen_t>(sizeof(addr.storage));
      auto status = library_->GetPeerName(socket, &addr, &addrlen);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(addr, response->mutable_addr());
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::GetSockName(::grpc::ServerContext* context, const GetSockNameRequest* request, GetSockNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      auto addr = allocate_output_storage<nxsockaddr, SockAddr>();
      auto addrlen = static_cast<nxsocklen_t>(sizeof(addr.storage));
      auto status = library_->GetSockName(socket, &addr, &addrlen);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(addr, response->mutable_addr());
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::GetSockOpt(::grpc::ServerContext* context, const GetSockOptRequest* request, GetSockOptResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      int32_t level;
      switch (request->level_enum_case()) {
        case nixnetsocket_grpc::GetSockOptRequest::LevelEnumCase::kLevel: {
          level = static_cast<int32_t>(request->level());
          break;
        }
        case nixnetsocket_grpc::GetSockOptRequest::LevelEnumCase::kLevelRaw: {
          level = static_cast<int32_t>(request->level_raw());
          break;
        }
        case nixnetsocket_grpc::GetSockOptRequest::LevelEnumCase::LEVEL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for level was not specified or out of range");
          break;
        }
      }

      int32_t optname;
      switch (request->optname_enum_case()) {
        case nixnetsocket_grpc::GetSockOptRequest::OptnameEnumCase::kOptname: {
          optname = static_cast<int32_t>(request->optname());
          break;
        }
        case nixnetsocket_grpc::GetSockOptRequest::OptnameEnumCase::kOptnameRaw: {
          optname = static_cast<int32_t>(request->optname_raw());
          break;
        }
        case nixnetsocket_grpc::GetSockOptRequest::OptnameEnumCase::OPTNAME_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for optname was not specified or out of range");
          break;
        }
      }

      auto optval = allocate_output_storage<void *, SockOptData>(library_, optname);
      auto optlen = optval.size(socket, level);
      auto status = library_->GetSockOpt(socket, level, optname, optval.data(), &optlen);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(optval, response->mutable_optval());
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::InetAddr(::grpc::ServerContext* context, const InetAddrRequest* request, InetAddrResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      auto cp = request->cp().c_str();
      auto addr = library_->InetAddr(stack_ref, cp);
      auto status = addr == -1 ? -1 : 0;
      response->set_status(status);
      if (status_ok(status)) {
        response->set_addr(addr);
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::InetAToN(::grpc::ServerContext* context, const InetAToNRequest* request, InetAToNResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      auto cp = request->cp().c_str();
      auto name = allocate_output_storage<nxin_addr, InAddr>();
      auto status = library_->InetAToN(stack_ref, cp, &name);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(name, response->mutable_name());
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::InetNToA(::grpc::ServerContext* context, const InetNToARequest* request, InetNToAResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      auto in_addr = convert_from_grpc<nxin_addr>(request->in_addr());
      auto address = library_->InetNToA(stack_ref, in_addr);
      auto status = address ? 0 : -1;
      response->set_status(status);
      if (status_ok(status)) {
        response->set_address(address);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_address()));
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::InetNToP(::grpc::ServerContext* context, const InetNToPRequest* request, InetNToPResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      auto af = get_address_family(request->addr().addr_case());
      auto addr = convert_from_grpc<void>(request->addr());
      auto size = nxINET6_ADDRSTRLEN;
      std::string dst(nxINET6_ADDRSTRLEN - 1, '\0');
      auto address = library_->InetNToP(stack_ref, af, addr, (char*)dst.data(), size);
      auto status = address ? 0 : -1;
      response->set_status(status);
      if (status_ok(status)) {
        response->set_address(address);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_address()));
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::InetPToN(::grpc::ServerContext* context, const InetPToNRequest* request, InetPToNResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      int32_t af;
      switch (request->af_enum_case()) {
        case nixnetsocket_grpc::InetPToNRequest::AfEnumCase::kAf: {
          af = static_cast<int32_t>(request->af());
          break;
        }
        case nixnetsocket_grpc::InetPToNRequest::AfEnumCase::kAfRaw: {
          af = static_cast<int32_t>(request->af_raw());
          break;
        }
        case nixnetsocket_grpc::InetPToNRequest::AfEnumCase::AF_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for af was not specified or out of range");
          break;
        }
      }

      auto address = request->address().c_str();
      auto addr = allocate_output_storage<void, Addr>(af);
      auto status = library_->InetPToN(stack_ref, af, address, &addr);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(addr, response->mutable_addr());
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::IpStackClear(::grpc::ServerContext* context, const IpStackClearRequest* request, IpStackClearResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      nx_ip_stack_ref_t_resource_repository_->remove_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      auto status = library_->IpStackClear(stack_ref);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::IpStackCreate(::grpc::ServerContext* context, const IpStackCreateRequest* request, IpStackCreateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      char* stack_name = (char*)request->stack_name().c_str();
      char* config = (char*)request->config().c_str();

      auto init_lambda = [&] () {
        nxIpStackRef_t stack_ref;
        auto status = library_->IpStackCreate(stack_name, config, &stack_ref);
        return std::make_tuple(status, stack_ref);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (nxIpStackRef_t id) { library_->IpStackClear(id); };
      int status = nx_ip_stack_ref_t_resource_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_stack_ref()->set_id(session_id);
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::SessionException& ex) {
      return ::grpc::Status(::grpc::INVALID_ARGUMENT, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::IpStackGetAllStacksInfoStr(::grpc::ServerContext* context, const IpStackGetAllStacksInfoStrRequest* request, IpStackGetAllStacksInfoStrResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      uint32_t format;
      switch (request->format_enum_case()) {
        case nixnetsocket_grpc::IpStackGetAllStacksInfoStrRequest::FormatEnumCase::kFormat: {
          format = static_cast<uint32_t>(request->format());
          break;
        }
        case nixnetsocket_grpc::IpStackGetAllStacksInfoStrRequest::FormatEnumCase::kFormatRaw: {
          format = static_cast<uint32_t>(request->format_raw());
          break;
        }
        case nixnetsocket_grpc::IpStackGetAllStacksInfoStrRequest::FormatEnumCase::FORMAT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for format was not specified or out of range");
          break;
        }
      }

      auto info = allocate_output_storage<nixnetsocket_grpc::IpStackInfoString, std::string>(library_);
      auto status = library_->IpStackGetAllStacksInfoStr(format, (nixnetsocket_grpc::IpStackInfoString*)info.data());
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(info, response->mutable_info());
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_info()));
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::IpStackGetInfo(::grpc::ServerContext* context, const IpStackGetInfoRequest* request, IpStackGetInfoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      auto info_id = nxIPSTACK_INFO_ID;
      auto virtual_interfaces = allocate_output_storage<nxVirtualInterface_t, google::protobuf::RepeatedPtrField<VirtualInterface>>(library_);
      auto status = library_->IpStackGetInfo(stack_ref, info_id, &virtual_interfaces);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(virtual_interfaces, response->mutable_virtual_interfaces());
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::IpStackOpen(::grpc::ServerContext* context, const IpStackOpenRequest* request, IpStackOpenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      char* stack_name = (char*)request->stack_name().c_str();

      auto init_lambda = [&] () {
        nxIpStackRef_t stack_ref;
        auto status = library_->IpStackOpen(stack_name, &stack_ref);
        return std::make_tuple(status, stack_ref);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (nxIpStackRef_t id) { library_->IpStackClear(id); };
      int status = nx_ip_stack_ref_t_resource_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_stack_ref()->set_id(session_id);
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::SessionException& ex) {
      return ::grpc::Status(::grpc::INVALID_ARGUMENT, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::IpStackWaitForInterface(::grpc::ServerContext* context, const IpStackWaitForInterfaceRequest* request, IpStackWaitForInterfaceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      auto local_interface = request->local_interface().c_str();
      int32_t timeout_ms = request->timeout_ms();
      auto status = library_->IpStackWaitForInterface(stack_ref, local_interface, timeout_ms);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Listen(::grpc::ServerContext* context, const ListenRequest* request, ListenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      int32_t backlog = request->backlog();
      auto status = library_->Listen(socket, backlog);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Recv(::grpc::ServerContext* context, const RecvRequest* request, RecvResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      int32_t size = request->size();
      const auto flags = nidevice_grpc::converters::convert_bitfield_as_enum_array_input(
        request->flags_array(),
        request->flags_raw());

      std::string data(size, '\0');
      auto status = library_->Recv(socket, (char*)data.data(), size, flags);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_data(data);
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::RecvFrom(::grpc::ServerContext* context, const RecvFromRequest* request, RecvFromResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      int32_t size = request->size();
      const auto flags = nidevice_grpc::converters::convert_bitfield_as_enum_array_input(
        request->flags_array(),
        request->flags_raw());

      std::string data(size, '\0');
      auto from_addr = allocate_output_storage<nxsockaddr, SockAddr>();
      nxsocklen_t fromlen {};
      auto status = library_->RecvFrom(socket, (char*)data.data(), size, flags, &from_addr, &fromlen);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_data(data);
        convert_to_grpc(from_addr, response->mutable_from_addr());
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Select(::grpc::ServerContext* context, const SelectRequest* request, SelectResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto nfds = 0;
      auto readfds = convert_from_grpc<nxfd_set>(request->readfds(), session_repository_);
      auto writefds = convert_from_grpc<nxfd_set>(request->writefds(), session_repository_);
      auto exceptfds = convert_from_grpc<nxfd_set>(request->exceptfds(), session_repository_);
      auto timeout = convert_from_grpc<nxtimeval>(request->timeout());
      auto status = library_->Select(nfds, readfds, writefds, exceptfds, timeout);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Send(::grpc::ServerContext* context, const SendRequest* request, SendResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      char* data = (char*)request->data().c_str();
      int32_t size = static_cast<int32_t>(request->data().size());
      int32_t flags_raw = request->flags_raw();
      auto status = library_->Send(socket, data, size, flags_raw);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::SendTo(::grpc::ServerContext* context, const SendToRequest* request, SendToResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      char* data = (char*)request->data().c_str();
      int32_t size = static_cast<int32_t>(request->data().size());
      int32_t flags_raw = request->flags_raw();
      auto to = convert_from_grpc<nxsockaddr>(request->to());
      auto tolen = to.size();
      auto status = library_->SendTo(socket, data, size, flags_raw, to, tolen);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::SetSockOpt(::grpc::ServerContext* context, const SetSockOptRequest* request, SetSockOptResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      int32_t level;
      switch (request->level_enum_case()) {
        case nixnetsocket_grpc::SetSockOptRequest::LevelEnumCase::kLevel: {
          level = static_cast<int32_t>(request->level());
          break;
        }
        case nixnetsocket_grpc::SetSockOptRequest::LevelEnumCase::kLevelRaw: {
          level = static_cast<int32_t>(request->level_raw());
          break;
        }
        case nixnetsocket_grpc::SetSockOptRequest::LevelEnumCase::LEVEL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for level was not specified or out of range");
          break;
        }
      }

      int32_t optname;
      switch (request->optname_enum_case()) {
        case nixnetsocket_grpc::SetSockOptRequest::OptnameEnumCase::kOptname: {
          optname = static_cast<int32_t>(request->optname());
          break;
        }
        case nixnetsocket_grpc::SetSockOptRequest::OptnameEnumCase::kOptnameRaw: {
          optname = static_cast<int32_t>(request->optname_raw());
          break;
        }
        case nixnetsocket_grpc::SetSockOptRequest::OptnameEnumCase::OPTNAME_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for optname was not specified or out of range");
          break;
        }
      }

      auto opt_data = convert_from_grpc<SockOptDataInputConverter>(request->opt_data());
      auto optval = opt_data.data();
      auto optlen = opt_data.size();
      auto status = library_->SetSockOpt(socket, level, optname, optval, optlen);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Shutdown(::grpc::ServerContext* context, const ShutdownRequest* request, ShutdownResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      int32_t how;
      switch (request->how_enum_case()) {
        case nixnetsocket_grpc::ShutdownRequest::HowEnumCase::kHow: {
          how = static_cast<int32_t>(request->how());
          break;
        }
        case nixnetsocket_grpc::ShutdownRequest::HowEnumCase::kHowRaw: {
          how = static_cast<int32_t>(request->how_raw());
          break;
        }
        case nixnetsocket_grpc::ShutdownRequest::HowEnumCase::HOW_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for how was not specified or out of range");
          break;
        }
      }

      auto status = library_->Shutdown(socket, how);
      response->set_status(status);
      if (status_ok(status)) {
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Socket(::grpc::ServerContext* context, const SocketRequest* request, SocketResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref_grpc_session = request->stack_ref();
      nxIpStackRef_t stack_ref = nx_ip_stack_ref_t_resource_repository_->access_session(stack_ref_grpc_session.id(), stack_ref_grpc_session.name());
      int32_t domain;
      switch (request->domain_enum_case()) {
        case nixnetsocket_grpc::SocketRequest::DomainEnumCase::kDomain: {
          domain = static_cast<int32_t>(request->domain());
          break;
        }
        case nixnetsocket_grpc::SocketRequest::DomainEnumCase::kDomainRaw: {
          domain = static_cast<int32_t>(request->domain_raw());
          break;
        }
        case nixnetsocket_grpc::SocketRequest::DomainEnumCase::DOMAIN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for domain was not specified or out of range");
          break;
        }
      }

      int32_t type;
      switch (request->type_enum_case()) {
        case nixnetsocket_grpc::SocketRequest::TypeEnumCase::kType: {
          type = static_cast<int32_t>(request->type());
          break;
        }
        case nixnetsocket_grpc::SocketRequest::TypeEnumCase::kTypeRaw: {
          type = static_cast<int32_t>(request->type_raw());
          break;
        }
        case nixnetsocket_grpc::SocketRequest::TypeEnumCase::TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for type was not specified or out of range");
          break;
        }
      }

      int32_t protocol;
      switch (request->protocol_enum_case()) {
        case nixnetsocket_grpc::SocketRequest::ProtocolEnumCase::kProtocol: {
          protocol = static_cast<int32_t>(request->protocol());
          break;
        }
        case nixnetsocket_grpc::SocketRequest::ProtocolEnumCase::kProtocolRaw: {
          protocol = static_cast<int32_t>(request->protocol_raw());
          break;
        }
        case nixnetsocket_grpc::SocketRequest::ProtocolEnumCase::PROTOCOL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for protocol was not specified or out of range");
          break;
        }
      }


      auto init_lambda = [&] () {
        auto socket = library_->Socket(stack_ref, domain, type, protocol);
        auto status = socket == -1 ? -1 : 0;
        return std::make_tuple(status, socket);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (nxSOCKET id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_socket()->set_id(session_id);
      }
      else {
        const auto error_message = get_last_error_message(library_);
        response->set_error_message(error_message);
        const auto error_num = get_last_error_num(library_);
        response->set_error_num(error_num);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::SessionException& ex) {
      return ::grpc::Status(::grpc::INVALID_ARGUMENT, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::StrErrR(::grpc::ServerContext* context, const StrErrRRequest* request, StrErrRResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      int errnum = request->errnum();
      size_t buf_len = request->buf_len();
      std::string buf;
      if (buf_len > 0) {
          buf.resize(buf_len - 1);
      }
      auto error = library_->StrErrR(errnum, (char*)buf.data(), buf_len);
      auto status = error ? 0 : -1;
      response->set_status(status);
      if (status_ok(status)) {
        response->set_error(error);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error()));
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  NiXnetSocketFeatureToggles::NiXnetSocketFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nixnetsocket", CodeReadiness::kRelease))
  {
  }
} // namespace nixnetsocket_grpc

