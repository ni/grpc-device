
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-XNETSOCKET Metadata
//---------------------------------------------------------------------
#include "nixnetsocket_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/xnetsocket_converters.h"
#include <server/converters.h>

namespace nixnetsocket_grpc {

  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  NiXnetSocketService::NiXnetSocketService(
      NiXnetSocketLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      const NiXnetSocketFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiXnetSocketService::~NiXnetSocketService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Bind(::grpc::ServerContext* context, const BindRequest* request, BindResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      auto name = convert_from_grpc<nxsockaddr>(request->name());
      auto namelen = name.size();
      auto status = library_->Bind(socket, name, namelen);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Connect(::grpc::ServerContext* context, const ConnectRequest* request, ConnectResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      auto name = convert_from_grpc<nxsockaddr>(request->name());
      auto namelen = name.size();
      auto status = library_->Connect(socket, name, namelen);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Listen(::grpc::ServerContext* context, const ListenRequest* request, ListenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      int32_t backlog = request->backlog();
      auto status = library_->Listen(socket, backlog);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::SendTo(::grpc::ServerContext* context, const SendToRequest* request, SendToResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      char* dataptr = (char*)request->dataptr().c_str();
      int32_t size = static_cast<int32_t>(request->dataptr().size());
      int32_t flags = request->flags();
      auto to = convert_from_grpc<nxsockaddr>(request->to());
      auto tolen = to.size();
      auto status = library_->SendTo(socket, dataptr, size, flags, to, tolen);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Send(::grpc::ServerContext* context, const SendRequest* request, SendResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      char* dataptr = (char*)request->dataptr().c_str();
      int32_t size = static_cast<int32_t>(request->dataptr().size());
      int32_t flags = request->flags();
      auto status = library_->Send(socket, dataptr, size, flags);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Recv(::grpc::ServerContext* context, const RecvRequest* request, RecvResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      char* mem = (char*)request->mem().c_str();
      int32_t size = static_cast<int32_t>(request->mem().size());
      int32_t flags = request->flags();
      auto status = library_->Recv(socket, mem, size, flags);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Shutdown(::grpc::ServerContext* context, const ShutdownRequest* request, ShutdownResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      int32_t how = request->how();
      auto status = library_->Shutdown(socket, how);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto socket_grpc_session = request->socket();
      nxSOCKET socket = session_repository_->access_session(socket_grpc_session.id(), socket_grpc_session.name());
      session_repository_->remove_session(socket_grpc_session.id(), socket_grpc_session.name());
      auto status = library_->Close(socket);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::GetLastErrorNum(::grpc::ServerContext* context, const GetLastErrorNumRequest* request, GetLastErrorNumResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto status = library_->GetLastErrorNum();
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::GetLastErrorStr(::grpc::ServerContext* context, const GetLastErrorStrRequest* request, GetLastErrorStrResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      size_t buf_len = request->buf_len();
      std::string buf;
      if (buf_len > 0) {
          buf.resize(buf_len - 1);
      }
      auto error = library_->GetLastErrorStr((char*)buf.data(), buf_len);
      auto status = error ? 0 : -1;
      response->set_status(status);
      if (status_ok(status)) {
        response->set_error(error);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error()));
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::IsSet(::grpc::ServerContext* context, const IsSetRequest* request, IsSetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto fd_grpc_session = request->fd();
      nxSOCKET fd = session_repository_->access_session(fd_grpc_session.id(), fd_grpc_session.name());
      auto set = convert_from_grpc<nxfd_set>(request->set(), session_repository_);
      auto is_set = library_->IsSet(fd, set);
      auto status = 0;
      response->set_status(status);
      if (status_ok(status)) {
        response->set_is_set(is_set);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Select(::grpc::ServerContext* context, const SelectRequest* request, SelectResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto nfds = 0;
      auto read_fds = convert_from_grpc<nxfd_set>(request->read_fds(), session_repository_);
      auto write_fds = convert_from_grpc<nxfd_set>(request->write_fds(), session_repository_);
      auto except_fds = convert_from_grpc<nxfd_set>(request->except_fds(), session_repository_);
      auto timeout = convert_from_grpc<nxtimeval>(request->timeout());
      auto status = library_->Select(nfds, read_fds, write_fds, except_fds, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetSocketService::Socket(::grpc::ServerContext* context, const SocketRequest* request, SocketResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto stack_ref = nullptr;
      int32_t domain = request->domain();
      int32_t type = request->type();
      int32_t prototcol = request->prototcol();

      auto init_lambda = [&] () {
        auto socket = library_->Socket(stack_ref, domain, type, prototcol);
        auto status = socket == -1 ? -1 : 0;
        return std::make_tuple(status, socket);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (nxSOCKET id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_socket()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  NiXnetSocketFeatureToggles::NiXnetSocketFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nixnetsocket", CodeReadiness::kNextRelease))
  {
  }
} // namespace nixnetsocket_grpc

