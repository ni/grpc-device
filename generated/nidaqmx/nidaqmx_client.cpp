
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// EXPERIMENTAL Client convenience wrapper for NI-DAQMX.
//---------------------------------------------------------------------
#include "nidaqmx_client.h"

#include <grpcpp/grpcpp.h>

#include <nidaqmx.grpc.pb.h>

#include <cstdint>
#include <memory>
#include <stdexcept>
#include <vector>

namespace nidaqmx_grpc::experimental::client {

AddCDAQSyncConnectionResponse
add_cdaq_sync_connection(const StubPtr& stub, const pb::string& port_list)
{
  ::grpc::ClientContext context;

  auto request = AddCDAQSyncConnectionRequest{};
  request.set_port_list(port_list);

  auto response = AddCDAQSyncConnectionResponse{};

  raise_if_error(
      stub->AddCDAQSyncConnection(&context, request, &response));

  return response;
}

AddGlobalChansToTaskResponse
add_global_chans_to_task(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel_names)
{
  ::grpc::ClientContext context;

  auto request = AddGlobalChansToTaskRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel_names(channel_names);

  auto response = AddGlobalChansToTaskResponse{};

  raise_if_error(
      stub->AddGlobalChansToTask(&context, request, &response));

  return response;
}

AddNetworkDeviceResponse
add_network_device(const StubPtr& stub, const pb::string& ip_address, const pb::string& device_name, const bool& attempt_reservation, const double& timeout, const pb::uint32& device_name_out_buffer_size)
{
  ::grpc::ClientContext context;

  auto request = AddNetworkDeviceRequest{};
  request.set_ip_address(ip_address);
  request.set_device_name(device_name);
  request.set_attempt_reservation(attempt_reservation);
  request.set_timeout(timeout);
  request.set_device_name_out_buffer_size(device_name_out_buffer_size);

  auto response = AddNetworkDeviceResponse{};

  raise_if_error(
      stub->AddNetworkDevice(&context, request, &response));

  return response;
}

AreConfiguredCDAQSyncPortsDisconnectedResponse
are_configured_cdaq_sync_ports_disconnected(const StubPtr& stub, const pb::string& chassis_devices_ports, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = AreConfiguredCDAQSyncPortsDisconnectedRequest{};
  request.set_chassis_devices_ports(chassis_devices_ports);
  request.set_timeout(timeout);

  auto response = AreConfiguredCDAQSyncPortsDisconnectedResponse{};

  raise_if_error(
      stub->AreConfiguredCDAQSyncPortsDisconnected(&context, request, &response));

  return response;
}

AutoConfigureCDAQSyncConnectionsResponse
auto_configure_cdaq_sync_connections(const StubPtr& stub, const pb::string& chassis_devices_ports, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = AutoConfigureCDAQSyncConnectionsRequest{};
  request.set_chassis_devices_ports(chassis_devices_ports);
  request.set_timeout(timeout);

  auto response = AutoConfigureCDAQSyncConnectionsResponse{};

  raise_if_error(
      stub->AutoConfigureCDAQSyncConnections(&context, request, &response));

  return response;
}

CalculateReversePolyCoeffResponse
calculate_reverse_poly_coeff(const StubPtr& stub, const std::vector<double>& forward_coeffs, const pb::uint32& num_forward_coeffs_in, const double& min_val_x, const double& max_val_x, const pb::int32& num_points_to_compute, const pb::int32& reverse_poly_order)
{
  ::grpc::ClientContext context;

  auto request = CalculateReversePolyCoeffRequest{};
  copy_array(forward_coeffs, request.mutable_forward_coeffs());
  request.set_num_forward_coeffs_in(num_forward_coeffs_in);
  request.set_min_val_x(min_val_x);
  request.set_max_val_x(max_val_x);
  request.set_num_points_to_compute(num_points_to_compute);
  request.set_reverse_poly_order(reverse_poly_order);

  auto response = CalculateReversePolyCoeffResponse{};

  raise_if_error(
      stub->CalculateReversePolyCoeff(&context, request, &response));

  return response;
}

CfgAnlgEdgeRefTrigResponse
cfg_anlg_edge_ref_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& trigger_source, const simple_variant<Slope1, pb::int32>& trigger_slope, const double& trigger_level, const pb::uint32& pretrigger_samples)
{
  ::grpc::ClientContext context;

  auto request = CfgAnlgEdgeRefTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_trigger_source(trigger_source);
  const auto trigger_slope_ptr = trigger_slope.get_if<Slope1>();
  const auto trigger_slope_raw_ptr = trigger_slope.get_if<pb::int32>();
  if (trigger_slope_ptr) {
    request.set_trigger_slope(*trigger_slope_ptr);
  }
  else if (trigger_slope_raw_ptr) {
    request.set_trigger_slope_raw(*trigger_slope_raw_ptr);
  }
  request.set_trigger_level(trigger_level);
  request.set_pretrigger_samples(pretrigger_samples);

  auto response = CfgAnlgEdgeRefTrigResponse{};

  raise_if_error(
      stub->CfgAnlgEdgeRefTrig(&context, request, &response));

  return response;
}

CfgAnlgEdgeStartTrigResponse
cfg_anlg_edge_start_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& trigger_source, const simple_variant<Slope1, pb::int32>& trigger_slope, const double& trigger_level)
{
  ::grpc::ClientContext context;

  auto request = CfgAnlgEdgeStartTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_trigger_source(trigger_source);
  const auto trigger_slope_ptr = trigger_slope.get_if<Slope1>();
  const auto trigger_slope_raw_ptr = trigger_slope.get_if<pb::int32>();
  if (trigger_slope_ptr) {
    request.set_trigger_slope(*trigger_slope_ptr);
  }
  else if (trigger_slope_raw_ptr) {
    request.set_trigger_slope_raw(*trigger_slope_raw_ptr);
  }
  request.set_trigger_level(trigger_level);

  auto response = CfgAnlgEdgeStartTrigResponse{};

  raise_if_error(
      stub->CfgAnlgEdgeStartTrig(&context, request, &response));

  return response;
}

CfgAnlgMultiEdgeRefTrigResponse
cfg_anlg_multi_edge_ref_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& trigger_sources, const std::vector<pb::int32>& trigger_slope_array, const std::vector<double>& trigger_level_array, const pb::uint32& pretrigger_samples, const pb::uint32& array_size)
{
  ::grpc::ClientContext context;

  auto request = CfgAnlgMultiEdgeRefTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_trigger_sources(trigger_sources);
  copy_array(trigger_slope_array, request.mutable_trigger_slope_array());
  copy_array(trigger_level_array, request.mutable_trigger_level_array());
  request.set_pretrigger_samples(pretrigger_samples);
  request.set_array_size(array_size);

  auto response = CfgAnlgMultiEdgeRefTrigResponse{};

  raise_if_error(
      stub->CfgAnlgMultiEdgeRefTrig(&context, request, &response));

  return response;
}

CfgAnlgMultiEdgeStartTrigResponse
cfg_anlg_multi_edge_start_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& trigger_sources, const std::vector<pb::int32>& trigger_slope_array, const std::vector<double>& trigger_level_array)
{
  ::grpc::ClientContext context;

  auto request = CfgAnlgMultiEdgeStartTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_trigger_sources(trigger_sources);
  copy_array(trigger_slope_array, request.mutable_trigger_slope_array());
  copy_array(trigger_level_array, request.mutable_trigger_level_array());

  auto response = CfgAnlgMultiEdgeStartTrigResponse{};

  raise_if_error(
      stub->CfgAnlgMultiEdgeStartTrig(&context, request, &response));

  return response;
}

CfgAnlgWindowRefTrigResponse
cfg_anlg_window_ref_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& trigger_source, const simple_variant<WindowTriggerCondition1, pb::int32>& trigger_when, const double& window_top, const double& window_bottom, const pb::uint32& pretrigger_samples)
{
  ::grpc::ClientContext context;

  auto request = CfgAnlgWindowRefTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_trigger_source(trigger_source);
  const auto trigger_when_ptr = trigger_when.get_if<WindowTriggerCondition1>();
  const auto trigger_when_raw_ptr = trigger_when.get_if<pb::int32>();
  if (trigger_when_ptr) {
    request.set_trigger_when(*trigger_when_ptr);
  }
  else if (trigger_when_raw_ptr) {
    request.set_trigger_when_raw(*trigger_when_raw_ptr);
  }
  request.set_window_top(window_top);
  request.set_window_bottom(window_bottom);
  request.set_pretrigger_samples(pretrigger_samples);

  auto response = CfgAnlgWindowRefTrigResponse{};

  raise_if_error(
      stub->CfgAnlgWindowRefTrig(&context, request, &response));

  return response;
}

CfgAnlgWindowStartTrigResponse
cfg_anlg_window_start_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& trigger_source, const simple_variant<WindowTriggerCondition1, pb::int32>& trigger_when, const double& window_top, const double& window_bottom)
{
  ::grpc::ClientContext context;

  auto request = CfgAnlgWindowStartTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_trigger_source(trigger_source);
  const auto trigger_when_ptr = trigger_when.get_if<WindowTriggerCondition1>();
  const auto trigger_when_raw_ptr = trigger_when.get_if<pb::int32>();
  if (trigger_when_ptr) {
    request.set_trigger_when(*trigger_when_ptr);
  }
  else if (trigger_when_raw_ptr) {
    request.set_trigger_when_raw(*trigger_when_raw_ptr);
  }
  request.set_window_top(window_top);
  request.set_window_bottom(window_bottom);

  auto response = CfgAnlgWindowStartTrigResponse{};

  raise_if_error(
      stub->CfgAnlgWindowStartTrig(&context, request, &response));

  return response;
}

CfgBurstHandshakingTimingExportClockResponse
cfg_burst_handshaking_timing_export_clock(const StubPtr& stub, const nidevice_grpc::Session& task, const simple_variant<AcquisitionType, pb::int32>& sample_mode, const pb::uint64& samps_per_chan, const double& sample_clk_rate, const pb::string& sample_clk_outp_term, const simple_variant<Polarity2, pb::int32>& sample_clk_pulse_polarity, const simple_variant<Level1, pb::int32>& pause_when, const simple_variant<Polarity2, pb::int32>& ready_event_active_level)
{
  ::grpc::ClientContext context;

  auto request = CfgBurstHandshakingTimingExportClockRequest{};
  request.mutable_task()->CopyFrom(task);
  const auto sample_mode_ptr = sample_mode.get_if<AcquisitionType>();
  const auto sample_mode_raw_ptr = sample_mode.get_if<pb::int32>();
  if (sample_mode_ptr) {
    request.set_sample_mode(*sample_mode_ptr);
  }
  else if (sample_mode_raw_ptr) {
    request.set_sample_mode_raw(*sample_mode_raw_ptr);
  }
  request.set_samps_per_chan(samps_per_chan);
  request.set_sample_clk_rate(sample_clk_rate);
  request.set_sample_clk_outp_term(sample_clk_outp_term);
  const auto sample_clk_pulse_polarity_ptr = sample_clk_pulse_polarity.get_if<Polarity2>();
  const auto sample_clk_pulse_polarity_raw_ptr = sample_clk_pulse_polarity.get_if<pb::int32>();
  if (sample_clk_pulse_polarity_ptr) {
    request.set_sample_clk_pulse_polarity(*sample_clk_pulse_polarity_ptr);
  }
  else if (sample_clk_pulse_polarity_raw_ptr) {
    request.set_sample_clk_pulse_polarity_raw(*sample_clk_pulse_polarity_raw_ptr);
  }
  const auto pause_when_ptr = pause_when.get_if<Level1>();
  const auto pause_when_raw_ptr = pause_when.get_if<pb::int32>();
  if (pause_when_ptr) {
    request.set_pause_when(*pause_when_ptr);
  }
  else if (pause_when_raw_ptr) {
    request.set_pause_when_raw(*pause_when_raw_ptr);
  }
  const auto ready_event_active_level_ptr = ready_event_active_level.get_if<Polarity2>();
  const auto ready_event_active_level_raw_ptr = ready_event_active_level.get_if<pb::int32>();
  if (ready_event_active_level_ptr) {
    request.set_ready_event_active_level(*ready_event_active_level_ptr);
  }
  else if (ready_event_active_level_raw_ptr) {
    request.set_ready_event_active_level_raw(*ready_event_active_level_raw_ptr);
  }

  auto response = CfgBurstHandshakingTimingExportClockResponse{};

  raise_if_error(
      stub->CfgBurstHandshakingTimingExportClock(&context, request, &response));

  return response;
}

CfgBurstHandshakingTimingImportClockResponse
cfg_burst_handshaking_timing_import_clock(const StubPtr& stub, const nidevice_grpc::Session& task, const simple_variant<AcquisitionType, pb::int32>& sample_mode, const pb::uint64& samps_per_chan, const double& sample_clk_rate, const pb::string& sample_clk_src, const simple_variant<Edge1, pb::int32>& sample_clk_active_edge, const simple_variant<Level1, pb::int32>& pause_when, const simple_variant<Polarity2, pb::int32>& ready_event_active_level)
{
  ::grpc::ClientContext context;

  auto request = CfgBurstHandshakingTimingImportClockRequest{};
  request.mutable_task()->CopyFrom(task);
  const auto sample_mode_ptr = sample_mode.get_if<AcquisitionType>();
  const auto sample_mode_raw_ptr = sample_mode.get_if<pb::int32>();
  if (sample_mode_ptr) {
    request.set_sample_mode(*sample_mode_ptr);
  }
  else if (sample_mode_raw_ptr) {
    request.set_sample_mode_raw(*sample_mode_raw_ptr);
  }
  request.set_samps_per_chan(samps_per_chan);
  request.set_sample_clk_rate(sample_clk_rate);
  request.set_sample_clk_src(sample_clk_src);
  const auto sample_clk_active_edge_ptr = sample_clk_active_edge.get_if<Edge1>();
  const auto sample_clk_active_edge_raw_ptr = sample_clk_active_edge.get_if<pb::int32>();
  if (sample_clk_active_edge_ptr) {
    request.set_sample_clk_active_edge(*sample_clk_active_edge_ptr);
  }
  else if (sample_clk_active_edge_raw_ptr) {
    request.set_sample_clk_active_edge_raw(*sample_clk_active_edge_raw_ptr);
  }
  const auto pause_when_ptr = pause_when.get_if<Level1>();
  const auto pause_when_raw_ptr = pause_when.get_if<pb::int32>();
  if (pause_when_ptr) {
    request.set_pause_when(*pause_when_ptr);
  }
  else if (pause_when_raw_ptr) {
    request.set_pause_when_raw(*pause_when_raw_ptr);
  }
  const auto ready_event_active_level_ptr = ready_event_active_level.get_if<Polarity2>();
  const auto ready_event_active_level_raw_ptr = ready_event_active_level.get_if<pb::int32>();
  if (ready_event_active_level_ptr) {
    request.set_ready_event_active_level(*ready_event_active_level_ptr);
  }
  else if (ready_event_active_level_raw_ptr) {
    request.set_ready_event_active_level_raw(*ready_event_active_level_raw_ptr);
  }

  auto response = CfgBurstHandshakingTimingImportClockResponse{};

  raise_if_error(
      stub->CfgBurstHandshakingTimingImportClock(&context, request, &response));

  return response;
}

CfgChangeDetectionTimingResponse
cfg_change_detection_timing(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& rising_edge_chan, const pb::string& falling_edge_chan, const simple_variant<AcquisitionType, pb::int32>& sample_mode, const pb::uint64& samps_per_chan)
{
  ::grpc::ClientContext context;

  auto request = CfgChangeDetectionTimingRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_rising_edge_chan(rising_edge_chan);
  request.set_falling_edge_chan(falling_edge_chan);
  const auto sample_mode_ptr = sample_mode.get_if<AcquisitionType>();
  const auto sample_mode_raw_ptr = sample_mode.get_if<pb::int32>();
  if (sample_mode_ptr) {
    request.set_sample_mode(*sample_mode_ptr);
  }
  else if (sample_mode_raw_ptr) {
    request.set_sample_mode_raw(*sample_mode_raw_ptr);
  }
  request.set_samps_per_chan(samps_per_chan);

  auto response = CfgChangeDetectionTimingResponse{};

  raise_if_error(
      stub->CfgChangeDetectionTiming(&context, request, &response));

  return response;
}

CfgDigEdgeRefTrigResponse
cfg_dig_edge_ref_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& trigger_source, const simple_variant<Edge1, pb::int32>& trigger_edge, const pb::uint32& pretrigger_samples)
{
  ::grpc::ClientContext context;

  auto request = CfgDigEdgeRefTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_trigger_source(trigger_source);
  const auto trigger_edge_ptr = trigger_edge.get_if<Edge1>();
  const auto trigger_edge_raw_ptr = trigger_edge.get_if<pb::int32>();
  if (trigger_edge_ptr) {
    request.set_trigger_edge(*trigger_edge_ptr);
  }
  else if (trigger_edge_raw_ptr) {
    request.set_trigger_edge_raw(*trigger_edge_raw_ptr);
  }
  request.set_pretrigger_samples(pretrigger_samples);

  auto response = CfgDigEdgeRefTrigResponse{};

  raise_if_error(
      stub->CfgDigEdgeRefTrig(&context, request, &response));

  return response;
}

CfgDigEdgeStartTrigResponse
cfg_dig_edge_start_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& trigger_source, const simple_variant<Edge1, pb::int32>& trigger_edge)
{
  ::grpc::ClientContext context;

  auto request = CfgDigEdgeStartTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_trigger_source(trigger_source);
  const auto trigger_edge_ptr = trigger_edge.get_if<Edge1>();
  const auto trigger_edge_raw_ptr = trigger_edge.get_if<pb::int32>();
  if (trigger_edge_ptr) {
    request.set_trigger_edge(*trigger_edge_ptr);
  }
  else if (trigger_edge_raw_ptr) {
    request.set_trigger_edge_raw(*trigger_edge_raw_ptr);
  }

  auto response = CfgDigEdgeStartTrigResponse{};

  raise_if_error(
      stub->CfgDigEdgeStartTrig(&context, request, &response));

  return response;
}

CfgDigPatternRefTrigResponse
cfg_dig_pattern_ref_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& trigger_source, const pb::string& trigger_pattern, const simple_variant<DigitalPatternCondition1, pb::int32>& trigger_when, const pb::uint32& pretrigger_samples)
{
  ::grpc::ClientContext context;

  auto request = CfgDigPatternRefTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_trigger_source(trigger_source);
  request.set_trigger_pattern(trigger_pattern);
  const auto trigger_when_ptr = trigger_when.get_if<DigitalPatternCondition1>();
  const auto trigger_when_raw_ptr = trigger_when.get_if<pb::int32>();
  if (trigger_when_ptr) {
    request.set_trigger_when(*trigger_when_ptr);
  }
  else if (trigger_when_raw_ptr) {
    request.set_trigger_when_raw(*trigger_when_raw_ptr);
  }
  request.set_pretrigger_samples(pretrigger_samples);

  auto response = CfgDigPatternRefTrigResponse{};

  raise_if_error(
      stub->CfgDigPatternRefTrig(&context, request, &response));

  return response;
}

CfgDigPatternStartTrigResponse
cfg_dig_pattern_start_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& trigger_source, const pb::string& trigger_pattern, const simple_variant<DigitalPatternCondition1, pb::int32>& trigger_when)
{
  ::grpc::ClientContext context;

  auto request = CfgDigPatternStartTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_trigger_source(trigger_source);
  request.set_trigger_pattern(trigger_pattern);
  const auto trigger_when_ptr = trigger_when.get_if<DigitalPatternCondition1>();
  const auto trigger_when_raw_ptr = trigger_when.get_if<pb::int32>();
  if (trigger_when_ptr) {
    request.set_trigger_when(*trigger_when_ptr);
  }
  else if (trigger_when_raw_ptr) {
    request.set_trigger_when_raw(*trigger_when_raw_ptr);
  }

  auto response = CfgDigPatternStartTrigResponse{};

  raise_if_error(
      stub->CfgDigPatternStartTrig(&context, request, &response));

  return response;
}

CfgHandshakingTimingResponse
cfg_handshaking_timing(const StubPtr& stub, const nidevice_grpc::Session& task, const simple_variant<AcquisitionType, pb::int32>& sample_mode, const pb::uint64& samps_per_chan)
{
  ::grpc::ClientContext context;

  auto request = CfgHandshakingTimingRequest{};
  request.mutable_task()->CopyFrom(task);
  const auto sample_mode_ptr = sample_mode.get_if<AcquisitionType>();
  const auto sample_mode_raw_ptr = sample_mode.get_if<pb::int32>();
  if (sample_mode_ptr) {
    request.set_sample_mode(*sample_mode_ptr);
  }
  else if (sample_mode_raw_ptr) {
    request.set_sample_mode_raw(*sample_mode_raw_ptr);
  }
  request.set_samps_per_chan(samps_per_chan);

  auto response = CfgHandshakingTimingResponse{};

  raise_if_error(
      stub->CfgHandshakingTiming(&context, request, &response));

  return response;
}

CfgImplicitTimingResponse
cfg_implicit_timing(const StubPtr& stub, const nidevice_grpc::Session& task, const simple_variant<AcquisitionType, pb::int32>& sample_mode, const pb::uint64& samps_per_chan)
{
  ::grpc::ClientContext context;

  auto request = CfgImplicitTimingRequest{};
  request.mutable_task()->CopyFrom(task);
  const auto sample_mode_ptr = sample_mode.get_if<AcquisitionType>();
  const auto sample_mode_raw_ptr = sample_mode.get_if<pb::int32>();
  if (sample_mode_ptr) {
    request.set_sample_mode(*sample_mode_ptr);
  }
  else if (sample_mode_raw_ptr) {
    request.set_sample_mode_raw(*sample_mode_raw_ptr);
  }
  request.set_samps_per_chan(samps_per_chan);

  auto response = CfgImplicitTimingResponse{};

  raise_if_error(
      stub->CfgImplicitTiming(&context, request, &response));

  return response;
}

CfgInputBufferResponse
cfg_input_buffer(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::uint32& num_samps_per_chan)
{
  ::grpc::ClientContext context;

  auto request = CfgInputBufferRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);

  auto response = CfgInputBufferResponse{};

  raise_if_error(
      stub->CfgInputBuffer(&context, request, &response));

  return response;
}

CfgOutputBufferResponse
cfg_output_buffer(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::uint32& num_samps_per_chan)
{
  ::grpc::ClientContext context;

  auto request = CfgOutputBufferRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);

  auto response = CfgOutputBufferResponse{};

  raise_if_error(
      stub->CfgOutputBuffer(&context, request, &response));

  return response;
}

CfgPipelinedSampClkTimingResponse
cfg_pipelined_samp_clk_timing(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& source, const double& rate, const simple_variant<Edge1, pb::int32>& active_edge, const simple_variant<AcquisitionType, pb::int32>& sample_mode, const pb::uint64& samps_per_chan)
{
  ::grpc::ClientContext context;

  auto request = CfgPipelinedSampClkTimingRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_source(source);
  request.set_rate(rate);
  const auto active_edge_ptr = active_edge.get_if<Edge1>();
  const auto active_edge_raw_ptr = active_edge.get_if<pb::int32>();
  if (active_edge_ptr) {
    request.set_active_edge(*active_edge_ptr);
  }
  else if (active_edge_raw_ptr) {
    request.set_active_edge_raw(*active_edge_raw_ptr);
  }
  const auto sample_mode_ptr = sample_mode.get_if<AcquisitionType>();
  const auto sample_mode_raw_ptr = sample_mode.get_if<pb::int32>();
  if (sample_mode_ptr) {
    request.set_sample_mode(*sample_mode_ptr);
  }
  else if (sample_mode_raw_ptr) {
    request.set_sample_mode_raw(*sample_mode_raw_ptr);
  }
  request.set_samps_per_chan(samps_per_chan);

  auto response = CfgPipelinedSampClkTimingResponse{};

  raise_if_error(
      stub->CfgPipelinedSampClkTiming(&context, request, &response));

  return response;
}

CfgSampClkTimingResponse
cfg_samp_clk_timing(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& source, const double& rate, const simple_variant<Edge1, pb::int32>& active_edge, const simple_variant<AcquisitionType, pb::int32>& sample_mode, const pb::uint64& samps_per_chan)
{
  ::grpc::ClientContext context;

  auto request = CfgSampClkTimingRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_source(source);
  request.set_rate(rate);
  const auto active_edge_ptr = active_edge.get_if<Edge1>();
  const auto active_edge_raw_ptr = active_edge.get_if<pb::int32>();
  if (active_edge_ptr) {
    request.set_active_edge(*active_edge_ptr);
  }
  else if (active_edge_raw_ptr) {
    request.set_active_edge_raw(*active_edge_raw_ptr);
  }
  const auto sample_mode_ptr = sample_mode.get_if<AcquisitionType>();
  const auto sample_mode_raw_ptr = sample_mode.get_if<pb::int32>();
  if (sample_mode_ptr) {
    request.set_sample_mode(*sample_mode_ptr);
  }
  else if (sample_mode_raw_ptr) {
    request.set_sample_mode_raw(*sample_mode_raw_ptr);
  }
  request.set_samps_per_chan(samps_per_chan);

  auto response = CfgSampClkTimingResponse{};

  raise_if_error(
      stub->CfgSampClkTiming(&context, request, &response));

  return response;
}

CfgTimeStartTrigResponse
cfg_time_start_trig(const StubPtr& stub, const nidevice_grpc::Session& task, const google::protobuf::Timestamp& when, const simple_variant<Timescale2, pb::int32>& timescale)
{
  ::grpc::ClientContext context;

  auto request = CfgTimeStartTrigRequest{};
  request.mutable_task()->CopyFrom(task);
  request.mutable_when()->CopyFrom(when);
  const auto timescale_ptr = timescale.get_if<Timescale2>();
  const auto timescale_raw_ptr = timescale.get_if<pb::int32>();
  if (timescale_ptr) {
    request.set_timescale(*timescale_ptr);
  }
  else if (timescale_raw_ptr) {
    request.set_timescale_raw(*timescale_raw_ptr);
  }

  auto response = CfgTimeStartTrigResponse{};

  raise_if_error(
      stub->CfgTimeStartTrig(&context, request, &response));

  return response;
}

CfgWatchdogAOExpirStatesResponse
cfg_watchdog_ao_expir_states(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel_names, const std::vector<double>& expir_state_array, const std::vector<pb::int32>& output_type_array, const pb::uint32& array_size)
{
  ::grpc::ClientContext context;

  auto request = CfgWatchdogAOExpirStatesRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel_names(channel_names);
  copy_array(expir_state_array, request.mutable_expir_state_array());
  copy_array(output_type_array, request.mutable_output_type_array());
  request.set_array_size(array_size);

  auto response = CfgWatchdogAOExpirStatesResponse{};

  raise_if_error(
      stub->CfgWatchdogAOExpirStates(&context, request, &response));

  return response;
}

CfgWatchdogCOExpirStatesResponse
cfg_watchdog_co_expir_states(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel_names, const std::vector<pb::int32>& expir_state_array, const pb::uint32& array_size)
{
  ::grpc::ClientContext context;

  auto request = CfgWatchdogCOExpirStatesRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel_names(channel_names);
  copy_array(expir_state_array, request.mutable_expir_state_array());
  request.set_array_size(array_size);

  auto response = CfgWatchdogCOExpirStatesResponse{};

  raise_if_error(
      stub->CfgWatchdogCOExpirStates(&context, request, &response));

  return response;
}

CfgWatchdogDOExpirStatesResponse
cfg_watchdog_do_expir_states(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel_names, const std::vector<pb::int32>& expir_state_array, const pb::uint32& array_size)
{
  ::grpc::ClientContext context;

  auto request = CfgWatchdogDOExpirStatesRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel_names(channel_names);
  copy_array(expir_state_array, request.mutable_expir_state_array());
  request.set_array_size(array_size);

  auto response = CfgWatchdogDOExpirStatesResponse{};

  raise_if_error(
      stub->CfgWatchdogDOExpirStates(&context, request, &response));

  return response;
}

ClearTEDSResponse
clear_teds(const StubPtr& stub, const pb::string& physical_channel)
{
  ::grpc::ClientContext context;

  auto request = ClearTEDSRequest{};
  request.set_physical_channel(physical_channel);

  auto response = ClearTEDSResponse{};

  raise_if_error(
      stub->ClearTEDS(&context, request, &response));

  return response;
}

ClearTaskResponse
clear_task(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = ClearTaskRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = ClearTaskResponse{};

  raise_if_error(
      stub->ClearTask(&context, request, &response));

  return response;
}

ConfigureLoggingResponse
configure_logging(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& file_path, const simple_variant<LoggingMode, pb::int32>& logging_mode, const pb::string& group_name, const simple_variant<LoggingOperation, pb::int32>& operation)
{
  ::grpc::ClientContext context;

  auto request = ConfigureLoggingRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_file_path(file_path);
  const auto logging_mode_ptr = logging_mode.get_if<LoggingMode>();
  const auto logging_mode_raw_ptr = logging_mode.get_if<pb::int32>();
  if (logging_mode_ptr) {
    request.set_logging_mode(*logging_mode_ptr);
  }
  else if (logging_mode_raw_ptr) {
    request.set_logging_mode_raw(*logging_mode_raw_ptr);
  }
  request.set_group_name(group_name);
  const auto operation_ptr = operation.get_if<LoggingOperation>();
  const auto operation_raw_ptr = operation.get_if<pb::int32>();
  if (operation_ptr) {
    request.set_operation(*operation_ptr);
  }
  else if (operation_raw_ptr) {
    request.set_operation_raw(*operation_raw_ptr);
  }

  auto response = ConfigureLoggingResponse{};

  raise_if_error(
      stub->ConfigureLogging(&context, request, &response));

  return response;
}

ConfigureTEDSResponse
configure_teds(const StubPtr& stub, const pb::string& physical_channel, const pb::string& file_path)
{
  ::grpc::ClientContext context;

  auto request = ConfigureTEDSRequest{};
  request.set_physical_channel(physical_channel);
  request.set_file_path(file_path);

  auto response = ConfigureTEDSResponse{};

  raise_if_error(
      stub->ConfigureTEDS(&context, request, &response));

  return response;
}

ConnectTermsResponse
connect_terms(const StubPtr& stub, const pb::string& source_terminal, const pb::string& destination_terminal, const simple_variant<InvertPolarity, pb::int32>& signal_modifiers)
{
  ::grpc::ClientContext context;

  auto request = ConnectTermsRequest{};
  request.set_source_terminal(source_terminal);
  request.set_destination_terminal(destination_terminal);
  const auto signal_modifiers_ptr = signal_modifiers.get_if<InvertPolarity>();
  const auto signal_modifiers_raw_ptr = signal_modifiers.get_if<pb::int32>();
  if (signal_modifiers_ptr) {
    request.set_signal_modifiers(*signal_modifiers_ptr);
  }
  else if (signal_modifiers_raw_ptr) {
    request.set_signal_modifiers_raw(*signal_modifiers_raw_ptr);
  }

  auto response = ConnectTermsResponse{};

  raise_if_error(
      stub->ConnectTerms(&context, request, &response));

  return response;
}

ControlWatchdogTaskResponse
control_watchdog_task(const StubPtr& stub, const nidevice_grpc::Session& task, const simple_variant<WatchdogControlAction, pb::int32>& action)
{
  ::grpc::ClientContext context;

  auto request = ControlWatchdogTaskRequest{};
  request.mutable_task()->CopyFrom(task);
  const auto action_ptr = action.get_if<WatchdogControlAction>();
  const auto action_raw_ptr = action.get_if<pb::int32>();
  if (action_ptr) {
    request.set_action(*action_ptr);
  }
  else if (action_raw_ptr) {
    request.set_action_raw(*action_raw_ptr);
  }

  auto response = ControlWatchdogTaskResponse{};

  raise_if_error(
      stub->ControlWatchdogTask(&context, request, &response));

  return response;
}

CreateAIAccel4WireDCVoltageChanResponse
create_ai_accel4_wire_dc_voltage_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<AccelUnits2, pb::int32>& units, const double& sensitivity, const simple_variant<AccelSensitivityUnits1, pb::int32>& sensitivity_units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const bool& use_excit_for_scaling, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIAccel4WireDCVoltageChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<AccelUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_sensitivity(sensitivity);
  const auto sensitivity_units_ptr = sensitivity_units.get_if<AccelSensitivityUnits1>();
  const auto sensitivity_units_raw_ptr = sensitivity_units.get_if<pb::int32>();
  if (sensitivity_units_ptr) {
    request.set_sensitivity_units(*sensitivity_units_ptr);
  }
  else if (sensitivity_units_raw_ptr) {
    request.set_sensitivity_units_raw(*sensitivity_units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_use_excit_for_scaling(use_excit_for_scaling);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIAccel4WireDCVoltageChanResponse{};

  raise_if_error(
      stub->CreateAIAccel4WireDCVoltageChan(&context, request, &response));

  return response;
}

CreateAIAccelChanResponse
create_ai_accel_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<AccelUnits2, pb::int32>& units, const double& sensitivity, const simple_variant<AccelSensitivityUnits1, pb::int32>& sensitivity_units, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIAccelChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<AccelUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_sensitivity(sensitivity);
  const auto sensitivity_units_ptr = sensitivity_units.get_if<AccelSensitivityUnits1>();
  const auto sensitivity_units_raw_ptr = sensitivity_units.get_if<pb::int32>();
  if (sensitivity_units_ptr) {
    request.set_sensitivity_units(*sensitivity_units_ptr);
  }
  else if (sensitivity_units_raw_ptr) {
    request.set_sensitivity_units_raw(*sensitivity_units_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIAccelChanResponse{};

  raise_if_error(
      stub->CreateAIAccelChan(&context, request, &response));

  return response;
}

CreateAIAccelChargeChanResponse
create_ai_accel_charge_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<AccelUnits2, pb::int32>& units, const double& sensitivity, const simple_variant<AccelChargeSensitivityUnits, pb::int32>& sensitivity_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIAccelChargeChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<AccelUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_sensitivity(sensitivity);
  const auto sensitivity_units_ptr = sensitivity_units.get_if<AccelChargeSensitivityUnits>();
  const auto sensitivity_units_raw_ptr = sensitivity_units.get_if<pb::int32>();
  if (sensitivity_units_ptr) {
    request.set_sensitivity_units(*sensitivity_units_ptr);
  }
  else if (sensitivity_units_raw_ptr) {
    request.set_sensitivity_units_raw(*sensitivity_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIAccelChargeChanResponse{};

  raise_if_error(
      stub->CreateAIAccelChargeChan(&context, request, &response));

  return response;
}

CreateAIBridgeChanResponse
create_ai_bridge_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<BridgeUnits, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& nominal_bridge_resistance, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIBridgeChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<BridgeUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_nominal_bridge_resistance(nominal_bridge_resistance);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIBridgeChanResponse{};

  raise_if_error(
      stub->CreateAIBridgeChan(&context, request, &response));

  return response;
}

CreateAIChargeChanResponse
create_ai_charge_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<ChargeUnits, pb::int32>& units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIChargeChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<ChargeUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIChargeChanResponse{};

  raise_if_error(
      stub->CreateAIChargeChan(&context, request, &response));

  return response;
}

CreateAICurrentChanResponse
create_ai_current_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<CurrentUnits2, pb::int32>& units, const simple_variant<CurrentShuntResistorLocationWithDefault, pb::int32>& shunt_resistor_loc, const double& ext_shunt_resistor_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAICurrentChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<CurrentUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto shunt_resistor_loc_ptr = shunt_resistor_loc.get_if<CurrentShuntResistorLocationWithDefault>();
  const auto shunt_resistor_loc_raw_ptr = shunt_resistor_loc.get_if<pb::int32>();
  if (shunt_resistor_loc_ptr) {
    request.set_shunt_resistor_loc(*shunt_resistor_loc_ptr);
  }
  else if (shunt_resistor_loc_raw_ptr) {
    request.set_shunt_resistor_loc_raw(*shunt_resistor_loc_raw_ptr);
  }
  request.set_ext_shunt_resistor_val(ext_shunt_resistor_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAICurrentChanResponse{};

  raise_if_error(
      stub->CreateAICurrentChan(&context, request, &response));

  return response;
}

CreateAICurrentRMSChanResponse
create_ai_current_rms_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<CurrentUnits2, pb::int32>& units, const simple_variant<CurrentShuntResistorLocationWithDefault, pb::int32>& shunt_resistor_loc, const double& ext_shunt_resistor_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAICurrentRMSChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<CurrentUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto shunt_resistor_loc_ptr = shunt_resistor_loc.get_if<CurrentShuntResistorLocationWithDefault>();
  const auto shunt_resistor_loc_raw_ptr = shunt_resistor_loc.get_if<pb::int32>();
  if (shunt_resistor_loc_ptr) {
    request.set_shunt_resistor_loc(*shunt_resistor_loc_ptr);
  }
  else if (shunt_resistor_loc_raw_ptr) {
    request.set_shunt_resistor_loc_raw(*shunt_resistor_loc_raw_ptr);
  }
  request.set_ext_shunt_resistor_val(ext_shunt_resistor_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAICurrentRMSChanResponse{};

  raise_if_error(
      stub->CreateAICurrentRMSChan(&context, request, &response));

  return response;
}

CreateAIForceBridgePolynomialChanResponse
create_ai_force_bridge_polynomial_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<ForceUnits, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& nominal_bridge_resistance, const std::vector<double>& forward_coeffs, const pb::uint32& num_forward_coeffs, const std::vector<double>& reverse_coeffs, const pb::uint32& num_reverse_coeffs, const simple_variant<BridgeElectricalUnits, pb::int32>& electrical_units, const simple_variant<BridgePhysicalUnits, pb::int32>& physical_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIForceBridgePolynomialChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<ForceUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_nominal_bridge_resistance(nominal_bridge_resistance);
  copy_array(forward_coeffs, request.mutable_forward_coeffs());
  request.set_num_forward_coeffs(num_forward_coeffs);
  copy_array(reverse_coeffs, request.mutable_reverse_coeffs());
  request.set_num_reverse_coeffs(num_reverse_coeffs);
  const auto electrical_units_ptr = electrical_units.get_if<BridgeElectricalUnits>();
  const auto electrical_units_raw_ptr = electrical_units.get_if<pb::int32>();
  if (electrical_units_ptr) {
    request.set_electrical_units(*electrical_units_ptr);
  }
  else if (electrical_units_raw_ptr) {
    request.set_electrical_units_raw(*electrical_units_raw_ptr);
  }
  const auto physical_units_ptr = physical_units.get_if<BridgePhysicalUnits>();
  const auto physical_units_raw_ptr = physical_units.get_if<pb::int32>();
  if (physical_units_ptr) {
    request.set_physical_units(*physical_units_ptr);
  }
  else if (physical_units_raw_ptr) {
    request.set_physical_units_raw(*physical_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIForceBridgePolynomialChanResponse{};

  raise_if_error(
      stub->CreateAIForceBridgePolynomialChan(&context, request, &response));

  return response;
}

CreateAIForceBridgeTableChanResponse
create_ai_force_bridge_table_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<ForceUnits, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& nominal_bridge_resistance, const std::vector<double>& electrical_vals, const pb::uint32& num_electrical_vals, const simple_variant<BridgeElectricalUnits, pb::int32>& electrical_units, const std::vector<double>& physical_vals, const pb::uint32& num_physical_vals, const simple_variant<BridgePhysicalUnits, pb::int32>& physical_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIForceBridgeTableChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<ForceUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_nominal_bridge_resistance(nominal_bridge_resistance);
  copy_array(electrical_vals, request.mutable_electrical_vals());
  request.set_num_electrical_vals(num_electrical_vals);
  const auto electrical_units_ptr = electrical_units.get_if<BridgeElectricalUnits>();
  const auto electrical_units_raw_ptr = electrical_units.get_if<pb::int32>();
  if (electrical_units_ptr) {
    request.set_electrical_units(*electrical_units_ptr);
  }
  else if (electrical_units_raw_ptr) {
    request.set_electrical_units_raw(*electrical_units_raw_ptr);
  }
  copy_array(physical_vals, request.mutable_physical_vals());
  request.set_num_physical_vals(num_physical_vals);
  const auto physical_units_ptr = physical_units.get_if<BridgePhysicalUnits>();
  const auto physical_units_raw_ptr = physical_units.get_if<pb::int32>();
  if (physical_units_ptr) {
    request.set_physical_units(*physical_units_ptr);
  }
  else if (physical_units_raw_ptr) {
    request.set_physical_units_raw(*physical_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIForceBridgeTableChanResponse{};

  raise_if_error(
      stub->CreateAIForceBridgeTableChan(&context, request, &response));

  return response;
}

CreateAIForceBridgeTwoPointLinChanResponse
create_ai_force_bridge_two_point_lin_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<ForceUnits, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& nominal_bridge_resistance, const double& first_electrical_val, const double& second_electrical_val, const simple_variant<BridgeElectricalUnits, pb::int32>& electrical_units, const double& first_physical_val, const double& second_physical_val, const simple_variant<BridgePhysicalUnits, pb::int32>& physical_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIForceBridgeTwoPointLinChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<ForceUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_nominal_bridge_resistance(nominal_bridge_resistance);
  request.set_first_electrical_val(first_electrical_val);
  request.set_second_electrical_val(second_electrical_val);
  const auto electrical_units_ptr = electrical_units.get_if<BridgeElectricalUnits>();
  const auto electrical_units_raw_ptr = electrical_units.get_if<pb::int32>();
  if (electrical_units_ptr) {
    request.set_electrical_units(*electrical_units_ptr);
  }
  else if (electrical_units_raw_ptr) {
    request.set_electrical_units_raw(*electrical_units_raw_ptr);
  }
  request.set_first_physical_val(first_physical_val);
  request.set_second_physical_val(second_physical_val);
  const auto physical_units_ptr = physical_units.get_if<BridgePhysicalUnits>();
  const auto physical_units_raw_ptr = physical_units.get_if<pb::int32>();
  if (physical_units_ptr) {
    request.set_physical_units(*physical_units_ptr);
  }
  else if (physical_units_raw_ptr) {
    request.set_physical_units_raw(*physical_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIForceBridgeTwoPointLinChanResponse{};

  raise_if_error(
      stub->CreateAIForceBridgeTwoPointLinChan(&context, request, &response));

  return response;
}

CreateAIForceIEPEChanResponse
create_ai_force_iepe_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<ForceIEPEUnits, pb::int32>& units, const double& sensitivity, const simple_variant<ForceIEPESensorSensitivityUnits, pb::int32>& sensitivity_units, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIForceIEPEChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<ForceIEPEUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_sensitivity(sensitivity);
  const auto sensitivity_units_ptr = sensitivity_units.get_if<ForceIEPESensorSensitivityUnits>();
  const auto sensitivity_units_raw_ptr = sensitivity_units.get_if<pb::int32>();
  if (sensitivity_units_ptr) {
    request.set_sensitivity_units(*sensitivity_units_ptr);
  }
  else if (sensitivity_units_raw_ptr) {
    request.set_sensitivity_units_raw(*sensitivity_units_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIForceIEPEChanResponse{};

  raise_if_error(
      stub->CreateAIForceIEPEChan(&context, request, &response));

  return response;
}

CreateAIFreqVoltageChanResponse
create_ai_freq_voltage_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<FrequencyUnits, pb::int32>& units, const double& threshold_level, const double& hysteresis, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIFreqVoltageChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<FrequencyUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_threshold_level(threshold_level);
  request.set_hysteresis(hysteresis);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIFreqVoltageChanResponse{};

  raise_if_error(
      stub->CreateAIFreqVoltageChan(&context, request, &response));

  return response;
}

CreateAIMicrophoneChanResponse
create_ai_microphone_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const simple_variant<SoundPressureUnits1, pb::int32>& units, const double& mic_sensitivity, const double& max_snd_press_level, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIMicrophoneChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  const auto units_ptr = units.get_if<SoundPressureUnits1>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_mic_sensitivity(mic_sensitivity);
  request.set_max_snd_press_level(max_snd_press_level);
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIMicrophoneChanResponse{};

  raise_if_error(
      stub->CreateAIMicrophoneChan(&context, request, &response));

  return response;
}

CreateAIPosEddyCurrProxProbeChanResponse
create_ai_pos_eddy_curr_prox_probe_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<LengthUnits2, pb::int32>& units, const double& sensitivity, const simple_variant<EddyCurrentProxProbeSensitivityUnits, pb::int32>& sensitivity_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIPosEddyCurrProxProbeChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<LengthUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_sensitivity(sensitivity);
  const auto sensitivity_units_ptr = sensitivity_units.get_if<EddyCurrentProxProbeSensitivityUnits>();
  const auto sensitivity_units_raw_ptr = sensitivity_units.get_if<pb::int32>();
  if (sensitivity_units_ptr) {
    request.set_sensitivity_units(*sensitivity_units_ptr);
  }
  else if (sensitivity_units_raw_ptr) {
    request.set_sensitivity_units_raw(*sensitivity_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIPosEddyCurrProxProbeChanResponse{};

  raise_if_error(
      stub->CreateAIPosEddyCurrProxProbeChan(&context, request, &response));

  return response;
}

CreateAIPosLVDTChanResponse
create_ai_pos_lvdt_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<LengthUnits2, pb::int32>& units, const double& sensitivity, const simple_variant<LVDTSensitivityUnits1, pb::int32>& sensitivity_units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& voltage_excit_freq, const simple_variant<ACExcitWireMode, pb::int32>& ac_excit_wire_mode, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIPosLVDTChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<LengthUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_sensitivity(sensitivity);
  const auto sensitivity_units_ptr = sensitivity_units.get_if<LVDTSensitivityUnits1>();
  const auto sensitivity_units_raw_ptr = sensitivity_units.get_if<pb::int32>();
  if (sensitivity_units_ptr) {
    request.set_sensitivity_units(*sensitivity_units_ptr);
  }
  else if (sensitivity_units_raw_ptr) {
    request.set_sensitivity_units_raw(*sensitivity_units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_voltage_excit_freq(voltage_excit_freq);
  const auto ac_excit_wire_mode_ptr = ac_excit_wire_mode.get_if<ACExcitWireMode>();
  const auto ac_excit_wire_mode_raw_ptr = ac_excit_wire_mode.get_if<pb::int32>();
  if (ac_excit_wire_mode_ptr) {
    request.set_ac_excit_wire_mode(*ac_excit_wire_mode_ptr);
  }
  else if (ac_excit_wire_mode_raw_ptr) {
    request.set_ac_excit_wire_mode_raw(*ac_excit_wire_mode_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIPosLVDTChanResponse{};

  raise_if_error(
      stub->CreateAIPosLVDTChan(&context, request, &response));

  return response;
}

CreateAIPosRVDTChanResponse
create_ai_pos_rvdt_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<AngleUnits1, pb::int32>& units, const double& sensitivity, const simple_variant<RVDTSensitivityUnits1, pb::int32>& sensitivity_units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& voltage_excit_freq, const simple_variant<ACExcitWireMode, pb::int32>& ac_excit_wire_mode, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIPosRVDTChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<AngleUnits1>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_sensitivity(sensitivity);
  const auto sensitivity_units_ptr = sensitivity_units.get_if<RVDTSensitivityUnits1>();
  const auto sensitivity_units_raw_ptr = sensitivity_units.get_if<pb::int32>();
  if (sensitivity_units_ptr) {
    request.set_sensitivity_units(*sensitivity_units_ptr);
  }
  else if (sensitivity_units_raw_ptr) {
    request.set_sensitivity_units_raw(*sensitivity_units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_voltage_excit_freq(voltage_excit_freq);
  const auto ac_excit_wire_mode_ptr = ac_excit_wire_mode.get_if<ACExcitWireMode>();
  const auto ac_excit_wire_mode_raw_ptr = ac_excit_wire_mode.get_if<pb::int32>();
  if (ac_excit_wire_mode_ptr) {
    request.set_ac_excit_wire_mode(*ac_excit_wire_mode_ptr);
  }
  else if (ac_excit_wire_mode_raw_ptr) {
    request.set_ac_excit_wire_mode_raw(*ac_excit_wire_mode_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIPosRVDTChanResponse{};

  raise_if_error(
      stub->CreateAIPosRVDTChan(&context, request, &response));

  return response;
}

CreateAIPressureBridgePolynomialChanResponse
create_ai_pressure_bridge_polynomial_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<PressureUnits, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& nominal_bridge_resistance, const std::vector<double>& forward_coeffs, const pb::uint32& num_forward_coeffs, const std::vector<double>& reverse_coeffs, const pb::uint32& num_reverse_coeffs, const simple_variant<BridgeElectricalUnits, pb::int32>& electrical_units, const simple_variant<BridgePhysicalUnits, pb::int32>& physical_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIPressureBridgePolynomialChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<PressureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_nominal_bridge_resistance(nominal_bridge_resistance);
  copy_array(forward_coeffs, request.mutable_forward_coeffs());
  request.set_num_forward_coeffs(num_forward_coeffs);
  copy_array(reverse_coeffs, request.mutable_reverse_coeffs());
  request.set_num_reverse_coeffs(num_reverse_coeffs);
  const auto electrical_units_ptr = electrical_units.get_if<BridgeElectricalUnits>();
  const auto electrical_units_raw_ptr = electrical_units.get_if<pb::int32>();
  if (electrical_units_ptr) {
    request.set_electrical_units(*electrical_units_ptr);
  }
  else if (electrical_units_raw_ptr) {
    request.set_electrical_units_raw(*electrical_units_raw_ptr);
  }
  const auto physical_units_ptr = physical_units.get_if<BridgePhysicalUnits>();
  const auto physical_units_raw_ptr = physical_units.get_if<pb::int32>();
  if (physical_units_ptr) {
    request.set_physical_units(*physical_units_ptr);
  }
  else if (physical_units_raw_ptr) {
    request.set_physical_units_raw(*physical_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIPressureBridgePolynomialChanResponse{};

  raise_if_error(
      stub->CreateAIPressureBridgePolynomialChan(&context, request, &response));

  return response;
}

CreateAIPressureBridgeTableChanResponse
create_ai_pressure_bridge_table_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<PressureUnits, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& nominal_bridge_resistance, const std::vector<double>& electrical_vals, const pb::uint32& num_electrical_vals, const simple_variant<BridgeElectricalUnits, pb::int32>& electrical_units, const std::vector<double>& physical_vals, const pb::uint32& num_physical_vals, const simple_variant<BridgePhysicalUnits, pb::int32>& physical_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIPressureBridgeTableChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<PressureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_nominal_bridge_resistance(nominal_bridge_resistance);
  copy_array(electrical_vals, request.mutable_electrical_vals());
  request.set_num_electrical_vals(num_electrical_vals);
  const auto electrical_units_ptr = electrical_units.get_if<BridgeElectricalUnits>();
  const auto electrical_units_raw_ptr = electrical_units.get_if<pb::int32>();
  if (electrical_units_ptr) {
    request.set_electrical_units(*electrical_units_ptr);
  }
  else if (electrical_units_raw_ptr) {
    request.set_electrical_units_raw(*electrical_units_raw_ptr);
  }
  copy_array(physical_vals, request.mutable_physical_vals());
  request.set_num_physical_vals(num_physical_vals);
  const auto physical_units_ptr = physical_units.get_if<BridgePhysicalUnits>();
  const auto physical_units_raw_ptr = physical_units.get_if<pb::int32>();
  if (physical_units_ptr) {
    request.set_physical_units(*physical_units_ptr);
  }
  else if (physical_units_raw_ptr) {
    request.set_physical_units_raw(*physical_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIPressureBridgeTableChanResponse{};

  raise_if_error(
      stub->CreateAIPressureBridgeTableChan(&context, request, &response));

  return response;
}

CreateAIPressureBridgeTwoPointLinChanResponse
create_ai_pressure_bridge_two_point_lin_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<PressureUnits, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& nominal_bridge_resistance, const double& first_electrical_val, const double& second_electrical_val, const simple_variant<BridgeElectricalUnits, pb::int32>& electrical_units, const double& first_physical_val, const double& second_physical_val, const simple_variant<BridgePhysicalUnits, pb::int32>& physical_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIPressureBridgeTwoPointLinChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<PressureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_nominal_bridge_resistance(nominal_bridge_resistance);
  request.set_first_electrical_val(first_electrical_val);
  request.set_second_electrical_val(second_electrical_val);
  const auto electrical_units_ptr = electrical_units.get_if<BridgeElectricalUnits>();
  const auto electrical_units_raw_ptr = electrical_units.get_if<pb::int32>();
  if (electrical_units_ptr) {
    request.set_electrical_units(*electrical_units_ptr);
  }
  else if (electrical_units_raw_ptr) {
    request.set_electrical_units_raw(*electrical_units_raw_ptr);
  }
  request.set_first_physical_val(first_physical_val);
  request.set_second_physical_val(second_physical_val);
  const auto physical_units_ptr = physical_units.get_if<BridgePhysicalUnits>();
  const auto physical_units_raw_ptr = physical_units.get_if<pb::int32>();
  if (physical_units_ptr) {
    request.set_physical_units(*physical_units_ptr);
  }
  else if (physical_units_raw_ptr) {
    request.set_physical_units_raw(*physical_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIPressureBridgeTwoPointLinChanResponse{};

  raise_if_error(
      stub->CreateAIPressureBridgeTwoPointLinChan(&context, request, &response));

  return response;
}

CreateAIRTDChanResponse
create_airtd_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TemperatureUnits, pb::int32>& units, const simple_variant<RTDType1, pb::int32>& rtd_type, const simple_variant<ResistanceConfiguration, pb::int32>& resistance_config, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const double& r0)
{
  ::grpc::ClientContext context;

  auto request = CreateAIRTDChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TemperatureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto rtd_type_ptr = rtd_type.get_if<RTDType1>();
  const auto rtd_type_raw_ptr = rtd_type.get_if<pb::int32>();
  if (rtd_type_ptr) {
    request.set_rtd_type(*rtd_type_ptr);
  }
  else if (rtd_type_raw_ptr) {
    request.set_rtd_type_raw(*rtd_type_raw_ptr);
  }
  const auto resistance_config_ptr = resistance_config.get_if<ResistanceConfiguration>();
  const auto resistance_config_raw_ptr = resistance_config.get_if<pb::int32>();
  if (resistance_config_ptr) {
    request.set_resistance_config(*resistance_config_ptr);
  }
  else if (resistance_config_raw_ptr) {
    request.set_resistance_config_raw(*resistance_config_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_r0(r0);

  auto response = CreateAIRTDChanResponse{};

  raise_if_error(
      stub->CreateAIRTDChan(&context, request, &response));

  return response;
}

CreateAIResistanceChanResponse
create_ai_resistance_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<ResistanceUnits2, pb::int32>& units, const simple_variant<ResistanceConfiguration, pb::int32>& resistance_config, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIResistanceChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<ResistanceUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto resistance_config_ptr = resistance_config.get_if<ResistanceConfiguration>();
  const auto resistance_config_raw_ptr = resistance_config.get_if<pb::int32>();
  if (resistance_config_ptr) {
    request.set_resistance_config(*resistance_config_ptr);
  }
  else if (resistance_config_raw_ptr) {
    request.set_resistance_config_raw(*resistance_config_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIResistanceChanResponse{};

  raise_if_error(
      stub->CreateAIResistanceChan(&context, request, &response));

  return response;
}

CreateAIRosetteStrainGageChanResponse
create_ai_rosette_strain_gage_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<StrainGageRosetteType, pb::int32>& rosette_type, const double& gage_orientation, const std::vector<pb::int32>& rosette_meas_types, const pb::uint32& num_rosette_meas_types, const simple_variant<StrainGageBridgeType1, pb::int32>& strain_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& gage_factor, const double& nominal_gage_resistance, const double& poisson_ratio, const double& lead_wire_resistance)
{
  ::grpc::ClientContext context;

  auto request = CreateAIRosetteStrainGageChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto rosette_type_ptr = rosette_type.get_if<StrainGageRosetteType>();
  const auto rosette_type_raw_ptr = rosette_type.get_if<pb::int32>();
  if (rosette_type_ptr) {
    request.set_rosette_type(*rosette_type_ptr);
  }
  else if (rosette_type_raw_ptr) {
    request.set_rosette_type_raw(*rosette_type_raw_ptr);
  }
  request.set_gage_orientation(gage_orientation);
  copy_array(rosette_meas_types, request.mutable_rosette_meas_types());
  request.set_num_rosette_meas_types(num_rosette_meas_types);
  const auto strain_config_ptr = strain_config.get_if<StrainGageBridgeType1>();
  const auto strain_config_raw_ptr = strain_config.get_if<pb::int32>();
  if (strain_config_ptr) {
    request.set_strain_config(*strain_config_ptr);
  }
  else if (strain_config_raw_ptr) {
    request.set_strain_config_raw(*strain_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_gage_factor(gage_factor);
  request.set_nominal_gage_resistance(nominal_gage_resistance);
  request.set_poisson_ratio(poisson_ratio);
  request.set_lead_wire_resistance(lead_wire_resistance);

  auto response = CreateAIRosetteStrainGageChanResponse{};

  raise_if_error(
      stub->CreateAIRosetteStrainGageChan(&context, request, &response));

  return response;
}

CreateAIStrainGageChanResponse
create_ai_strain_gage_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<StrainUnits1, pb::int32>& units, const simple_variant<StrainGageBridgeType1, pb::int32>& strain_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& gage_factor, const double& initial_bridge_voltage, const double& nominal_gage_resistance, const double& poisson_ratio, const double& lead_wire_resistance, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIStrainGageChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<StrainUnits1>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto strain_config_ptr = strain_config.get_if<StrainGageBridgeType1>();
  const auto strain_config_raw_ptr = strain_config.get_if<pb::int32>();
  if (strain_config_ptr) {
    request.set_strain_config(*strain_config_ptr);
  }
  else if (strain_config_raw_ptr) {
    request.set_strain_config_raw(*strain_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_gage_factor(gage_factor);
  request.set_initial_bridge_voltage(initial_bridge_voltage);
  request.set_nominal_gage_resistance(nominal_gage_resistance);
  request.set_poisson_ratio(poisson_ratio);
  request.set_lead_wire_resistance(lead_wire_resistance);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIStrainGageChanResponse{};

  raise_if_error(
      stub->CreateAIStrainGageChan(&context, request, &response));

  return response;
}

CreateAITempBuiltInSensorChanResponse
create_ai_temp_built_in_sensor_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<TemperatureUnits, pb::int32>& units)
{
  ::grpc::ClientContext context;

  auto request = CreateAITempBuiltInSensorChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto units_ptr = units.get_if<TemperatureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }

  auto response = CreateAITempBuiltInSensorChanResponse{};

  raise_if_error(
      stub->CreateAITempBuiltInSensorChan(&context, request, &response));

  return response;
}

CreateAIThrmcplChanResponse
create_ai_thrmcpl_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TemperatureUnits, pb::int32>& units, const simple_variant<ThermocoupleType1, pb::int32>& thermocouple_type, const simple_variant<CJCSource1, pb::int32>& cjc_source, const double& cjc_val, const pb::string& cjc_channel)
{
  ::grpc::ClientContext context;

  auto request = CreateAIThrmcplChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TemperatureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto thermocouple_type_ptr = thermocouple_type.get_if<ThermocoupleType1>();
  const auto thermocouple_type_raw_ptr = thermocouple_type.get_if<pb::int32>();
  if (thermocouple_type_ptr) {
    request.set_thermocouple_type(*thermocouple_type_ptr);
  }
  else if (thermocouple_type_raw_ptr) {
    request.set_thermocouple_type_raw(*thermocouple_type_raw_ptr);
  }
  const auto cjc_source_ptr = cjc_source.get_if<CJCSource1>();
  const auto cjc_source_raw_ptr = cjc_source.get_if<pb::int32>();
  if (cjc_source_ptr) {
    request.set_cjc_source(*cjc_source_ptr);
  }
  else if (cjc_source_raw_ptr) {
    request.set_cjc_source_raw(*cjc_source_raw_ptr);
  }
  request.set_cjc_val(cjc_val);
  request.set_cjc_channel(cjc_channel);

  auto response = CreateAIThrmcplChanResponse{};

  raise_if_error(
      stub->CreateAIThrmcplChan(&context, request, &response));

  return response;
}

CreateAIThrmstrChanIexResponse
create_ai_thrmstr_chan_iex(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TemperatureUnits, pb::int32>& units, const simple_variant<ResistanceConfiguration, pb::int32>& resistance_config, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const double& a, const double& b, const double& c)
{
  ::grpc::ClientContext context;

  auto request = CreateAIThrmstrChanIexRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TemperatureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto resistance_config_ptr = resistance_config.get_if<ResistanceConfiguration>();
  const auto resistance_config_raw_ptr = resistance_config.get_if<pb::int32>();
  if (resistance_config_ptr) {
    request.set_resistance_config(*resistance_config_ptr);
  }
  else if (resistance_config_raw_ptr) {
    request.set_resistance_config_raw(*resistance_config_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_a(a);
  request.set_b(b);
  request.set_c(c);

  auto response = CreateAIThrmstrChanIexResponse{};

  raise_if_error(
      stub->CreateAIThrmstrChanIex(&context, request, &response));

  return response;
}

CreateAIThrmstrChanVexResponse
create_ai_thrmstr_chan_vex(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TemperatureUnits, pb::int32>& units, const simple_variant<ResistanceConfiguration, pb::int32>& resistance_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& a, const double& b, const double& c, const double& r1)
{
  ::grpc::ClientContext context;

  auto request = CreateAIThrmstrChanVexRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TemperatureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto resistance_config_ptr = resistance_config.get_if<ResistanceConfiguration>();
  const auto resistance_config_raw_ptr = resistance_config.get_if<pb::int32>();
  if (resistance_config_ptr) {
    request.set_resistance_config(*resistance_config_ptr);
  }
  else if (resistance_config_raw_ptr) {
    request.set_resistance_config_raw(*resistance_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_a(a);
  request.set_b(b);
  request.set_c(c);
  request.set_r1(r1);

  auto response = CreateAIThrmstrChanVexResponse{};

  raise_if_error(
      stub->CreateAIThrmstrChanVex(&context, request, &response));

  return response;
}

CreateAITorqueBridgePolynomialChanResponse
create_ai_torque_bridge_polynomial_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TorqueUnits, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& nominal_bridge_resistance, const std::vector<double>& forward_coeffs, const pb::uint32& num_forward_coeffs, const std::vector<double>& reverse_coeffs, const pb::uint32& num_reverse_coeffs, const simple_variant<BridgeElectricalUnits, pb::int32>& electrical_units, const simple_variant<BridgePhysicalUnits, pb::int32>& physical_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAITorqueBridgePolynomialChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TorqueUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_nominal_bridge_resistance(nominal_bridge_resistance);
  copy_array(forward_coeffs, request.mutable_forward_coeffs());
  request.set_num_forward_coeffs(num_forward_coeffs);
  copy_array(reverse_coeffs, request.mutable_reverse_coeffs());
  request.set_num_reverse_coeffs(num_reverse_coeffs);
  const auto electrical_units_ptr = electrical_units.get_if<BridgeElectricalUnits>();
  const auto electrical_units_raw_ptr = electrical_units.get_if<pb::int32>();
  if (electrical_units_ptr) {
    request.set_electrical_units(*electrical_units_ptr);
  }
  else if (electrical_units_raw_ptr) {
    request.set_electrical_units_raw(*electrical_units_raw_ptr);
  }
  const auto physical_units_ptr = physical_units.get_if<BridgePhysicalUnits>();
  const auto physical_units_raw_ptr = physical_units.get_if<pb::int32>();
  if (physical_units_ptr) {
    request.set_physical_units(*physical_units_ptr);
  }
  else if (physical_units_raw_ptr) {
    request.set_physical_units_raw(*physical_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAITorqueBridgePolynomialChanResponse{};

  raise_if_error(
      stub->CreateAITorqueBridgePolynomialChan(&context, request, &response));

  return response;
}

CreateAITorqueBridgeTableChanResponse
create_ai_torque_bridge_table_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TorqueUnits, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& nominal_bridge_resistance, const std::vector<double>& electrical_vals, const pb::uint32& num_electrical_vals, const simple_variant<BridgeElectricalUnits, pb::int32>& electrical_units, const std::vector<double>& physical_vals, const pb::uint32& num_physical_vals, const simple_variant<BridgePhysicalUnits, pb::int32>& physical_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAITorqueBridgeTableChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TorqueUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_nominal_bridge_resistance(nominal_bridge_resistance);
  copy_array(electrical_vals, request.mutable_electrical_vals());
  request.set_num_electrical_vals(num_electrical_vals);
  const auto electrical_units_ptr = electrical_units.get_if<BridgeElectricalUnits>();
  const auto electrical_units_raw_ptr = electrical_units.get_if<pb::int32>();
  if (electrical_units_ptr) {
    request.set_electrical_units(*electrical_units_ptr);
  }
  else if (electrical_units_raw_ptr) {
    request.set_electrical_units_raw(*electrical_units_raw_ptr);
  }
  copy_array(physical_vals, request.mutable_physical_vals());
  request.set_num_physical_vals(num_physical_vals);
  const auto physical_units_ptr = physical_units.get_if<BridgePhysicalUnits>();
  const auto physical_units_raw_ptr = physical_units.get_if<pb::int32>();
  if (physical_units_ptr) {
    request.set_physical_units(*physical_units_ptr);
  }
  else if (physical_units_raw_ptr) {
    request.set_physical_units_raw(*physical_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAITorqueBridgeTableChanResponse{};

  raise_if_error(
      stub->CreateAITorqueBridgeTableChan(&context, request, &response));

  return response;
}

CreateAITorqueBridgeTwoPointLinChanResponse
create_ai_torque_bridge_two_point_lin_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TorqueUnits, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& nominal_bridge_resistance, const double& first_electrical_val, const double& second_electrical_val, const simple_variant<BridgeElectricalUnits, pb::int32>& electrical_units, const double& first_physical_val, const double& second_physical_val, const simple_variant<BridgePhysicalUnits, pb::int32>& physical_units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAITorqueBridgeTwoPointLinChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TorqueUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_nominal_bridge_resistance(nominal_bridge_resistance);
  request.set_first_electrical_val(first_electrical_val);
  request.set_second_electrical_val(second_electrical_val);
  const auto electrical_units_ptr = electrical_units.get_if<BridgeElectricalUnits>();
  const auto electrical_units_raw_ptr = electrical_units.get_if<pb::int32>();
  if (electrical_units_ptr) {
    request.set_electrical_units(*electrical_units_ptr);
  }
  else if (electrical_units_raw_ptr) {
    request.set_electrical_units_raw(*electrical_units_raw_ptr);
  }
  request.set_first_physical_val(first_physical_val);
  request.set_second_physical_val(second_physical_val);
  const auto physical_units_ptr = physical_units.get_if<BridgePhysicalUnits>();
  const auto physical_units_raw_ptr = physical_units.get_if<pb::int32>();
  if (physical_units_ptr) {
    request.set_physical_units(*physical_units_ptr);
  }
  else if (physical_units_raw_ptr) {
    request.set_physical_units_raw(*physical_units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAITorqueBridgeTwoPointLinChanResponse{};

  raise_if_error(
      stub->CreateAITorqueBridgeTwoPointLinChan(&context, request, &response));

  return response;
}

CreateAIVelocityIEPEChanResponse
create_ai_velocity_iepe_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<VelocityUnits, pb::int32>& units, const double& sensitivity, const simple_variant<VelocityIEPESensorSensitivityUnits, pb::int32>& sensitivity_units, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIVelocityIEPEChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<VelocityUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_sensitivity(sensitivity);
  const auto sensitivity_units_ptr = sensitivity_units.get_if<VelocityIEPESensorSensitivityUnits>();
  const auto sensitivity_units_raw_ptr = sensitivity_units.get_if<pb::int32>();
  if (sensitivity_units_ptr) {
    request.set_sensitivity_units(*sensitivity_units_ptr);
  }
  else if (sensitivity_units_raw_ptr) {
    request.set_sensitivity_units_raw(*sensitivity_units_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIVelocityIEPEChanResponse{};

  raise_if_error(
      stub->CreateAIVelocityIEPEChan(&context, request, &response));

  return response;
}

CreateAIVoltageChanResponse
create_ai_voltage_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<VoltageUnits2, pb::int32>& units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIVoltageChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<VoltageUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIVoltageChanResponse{};

  raise_if_error(
      stub->CreateAIVoltageChan(&context, request, &response));

  return response;
}

CreateAIVoltageChanWithExcitResponse
create_ai_voltage_chan_with_excit(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<VoltageUnits2, pb::int32>& units, const simple_variant<BridgeConfiguration1, pb::int32>& bridge_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const bool& use_excit_for_scaling, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIVoltageChanWithExcitRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<VoltageUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto bridge_config_ptr = bridge_config.get_if<BridgeConfiguration1>();
  const auto bridge_config_raw_ptr = bridge_config.get_if<pb::int32>();
  if (bridge_config_ptr) {
    request.set_bridge_config(*bridge_config_ptr);
  }
  else if (bridge_config_raw_ptr) {
    request.set_bridge_config_raw(*bridge_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_use_excit_for_scaling(use_excit_for_scaling);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIVoltageChanWithExcitResponse{};

  raise_if_error(
      stub->CreateAIVoltageChanWithExcit(&context, request, &response));

  return response;
}

CreateAIVoltageRMSChanResponse
create_ai_voltage_rms_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<VoltageUnits2, pb::int32>& units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAIVoltageRMSChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<VoltageUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAIVoltageRMSChanResponse{};

  raise_if_error(
      stub->CreateAIVoltageRMSChan(&context, request, &response));

  return response;
}

CreateAOCurrentChanResponse
create_ao_current_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<CurrentUnits2, pb::int32>& units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAOCurrentChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<CurrentUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAOCurrentChanResponse{};

  raise_if_error(
      stub->CreateAOCurrentChan(&context, request, &response));

  return response;
}

CreateAOFuncGenChanResponse
create_ao_func_gen_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<FuncGenType, pb::int32>& type, const double& freq, const double& amplitude, const double& offset)
{
  ::grpc::ClientContext context;

  auto request = CreateAOFuncGenChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto type_ptr = type.get_if<FuncGenType>();
  const auto type_raw_ptr = type.get_if<pb::int32>();
  if (type_ptr) {
    request.set_type(*type_ptr);
  }
  else if (type_raw_ptr) {
    request.set_type_raw(*type_raw_ptr);
  }
  request.set_freq(freq);
  request.set_amplitude(amplitude);
  request.set_offset(offset);

  auto response = CreateAOFuncGenChanResponse{};

  raise_if_error(
      stub->CreateAOFuncGenChan(&context, request, &response));

  return response;
}

CreateAOVoltageChanResponse
create_ao_voltage_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<VoltageUnits2, pb::int32>& units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateAOVoltageChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<VoltageUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateAOVoltageChanResponse{};

  raise_if_error(
      stub->CreateAOVoltageChan(&context, request, &response));

  return response;
}

CreateCIAngEncoderChanResponse
create_ci_ang_encoder_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const simple_variant<EncoderType2, pb::int32>& decoding_type, const bool& zidx_enable, const double& zidx_val, const simple_variant<EncoderZIndexPhase1, pb::int32>& zidx_phase, const simple_variant<AngleUnits2, pb::int32>& units, const pb::uint32& pulses_per_rev, const double& initial_angle, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCIAngEncoderChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto decoding_type_ptr = decoding_type.get_if<EncoderType2>();
  const auto decoding_type_raw_ptr = decoding_type.get_if<pb::int32>();
  if (decoding_type_ptr) {
    request.set_decoding_type(*decoding_type_ptr);
  }
  else if (decoding_type_raw_ptr) {
    request.set_decoding_type_raw(*decoding_type_raw_ptr);
  }
  request.set_zidx_enable(zidx_enable);
  request.set_zidx_val(zidx_val);
  const auto zidx_phase_ptr = zidx_phase.get_if<EncoderZIndexPhase1>();
  const auto zidx_phase_raw_ptr = zidx_phase.get_if<pb::int32>();
  if (zidx_phase_ptr) {
    request.set_zidx_phase(*zidx_phase_ptr);
  }
  else if (zidx_phase_raw_ptr) {
    request.set_zidx_phase_raw(*zidx_phase_raw_ptr);
  }
  const auto units_ptr = units.get_if<AngleUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_pulses_per_rev(pulses_per_rev);
  request.set_initial_angle(initial_angle);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCIAngEncoderChanResponse{};

  raise_if_error(
      stub->CreateCIAngEncoderChan(&context, request, &response));

  return response;
}

CreateCIAngVelocityChanResponse
create_ci_ang_velocity_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<EncoderType2, pb::int32>& decoding_type, const simple_variant<AngularVelocityUnits, pb::int32>& units, const pb::uint32& pulses_per_rev, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCIAngVelocityChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto decoding_type_ptr = decoding_type.get_if<EncoderType2>();
  const auto decoding_type_raw_ptr = decoding_type.get_if<pb::int32>();
  if (decoding_type_ptr) {
    request.set_decoding_type(*decoding_type_ptr);
  }
  else if (decoding_type_raw_ptr) {
    request.set_decoding_type_raw(*decoding_type_raw_ptr);
  }
  const auto units_ptr = units.get_if<AngularVelocityUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_pulses_per_rev(pulses_per_rev);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCIAngVelocityChanResponse{};

  raise_if_error(
      stub->CreateCIAngVelocityChan(&context, request, &response));

  return response;
}

CreateCICountEdgesChanResponse
create_ci_count_edges_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const simple_variant<Edge1, pb::int32>& edge, const pb::uint32& initial_count, const simple_variant<CountDirection1, pb::int32>& count_direction)
{
  ::grpc::ClientContext context;

  auto request = CreateCICountEdgesChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto edge_ptr = edge.get_if<Edge1>();
  const auto edge_raw_ptr = edge.get_if<pb::int32>();
  if (edge_ptr) {
    request.set_edge(*edge_ptr);
  }
  else if (edge_raw_ptr) {
    request.set_edge_raw(*edge_raw_ptr);
  }
  request.set_initial_count(initial_count);
  const auto count_direction_ptr = count_direction.get_if<CountDirection1>();
  const auto count_direction_raw_ptr = count_direction.get_if<pb::int32>();
  if (count_direction_ptr) {
    request.set_count_direction(*count_direction_ptr);
  }
  else if (count_direction_raw_ptr) {
    request.set_count_direction_raw(*count_direction_raw_ptr);
  }

  auto response = CreateCICountEdgesChanResponse{};

  raise_if_error(
      stub->CreateCICountEdgesChan(&context, request, &response));

  return response;
}

CreateCIDutyCycleChanResponse
create_ci_duty_cycle_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const double& min_freq, const double& max_freq, const simple_variant<Edge1, pb::int32>& edge, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCIDutyCycleChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_freq(min_freq);
  request.set_max_freq(max_freq);
  const auto edge_ptr = edge.get_if<Edge1>();
  const auto edge_raw_ptr = edge.get_if<pb::int32>();
  if (edge_ptr) {
    request.set_edge(*edge_ptr);
  }
  else if (edge_raw_ptr) {
    request.set_edge_raw(*edge_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCIDutyCycleChanResponse{};

  raise_if_error(
      stub->CreateCIDutyCycleChan(&context, request, &response));

  return response;
}

CreateCIFreqChanResponse
create_ci_freq_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<FrequencyUnits3, pb::int32>& units, const simple_variant<Edge1, pb::int32>& edge, const simple_variant<CounterFrequencyMethod, pb::int32>& meas_method, const double& meas_time, const pb::uint32& divisor, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCIFreqChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<FrequencyUnits3>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto edge_ptr = edge.get_if<Edge1>();
  const auto edge_raw_ptr = edge.get_if<pb::int32>();
  if (edge_ptr) {
    request.set_edge(*edge_ptr);
  }
  else if (edge_raw_ptr) {
    request.set_edge_raw(*edge_raw_ptr);
  }
  const auto meas_method_ptr = meas_method.get_if<CounterFrequencyMethod>();
  const auto meas_method_raw_ptr = meas_method.get_if<pb::int32>();
  if (meas_method_ptr) {
    request.set_meas_method(*meas_method_ptr);
  }
  else if (meas_method_raw_ptr) {
    request.set_meas_method_raw(*meas_method_raw_ptr);
  }
  request.set_meas_time(meas_time);
  request.set_divisor(divisor);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCIFreqChanResponse{};

  raise_if_error(
      stub->CreateCIFreqChan(&context, request, &response));

  return response;
}

CreateCIGPSTimestampChanResponse
create_cigps_timestamp_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const simple_variant<TimeUnits, pb::int32>& units, const simple_variant<GpsSignalType1, pb::int32>& sync_method, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCIGPSTimestampChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto units_ptr = units.get_if<TimeUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto sync_method_ptr = sync_method.get_if<GpsSignalType1>();
  const auto sync_method_raw_ptr = sync_method.get_if<pb::int32>();
  if (sync_method_ptr) {
    request.set_sync_method(*sync_method_ptr);
  }
  else if (sync_method_raw_ptr) {
    request.set_sync_method_raw(*sync_method_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCIGPSTimestampChanResponse{};

  raise_if_error(
      stub->CreateCIGPSTimestampChan(&context, request, &response));

  return response;
}

CreateCILinEncoderChanResponse
create_ci_lin_encoder_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const simple_variant<EncoderType2, pb::int32>& decoding_type, const bool& zidx_enable, const double& zidx_val, const simple_variant<EncoderZIndexPhase1, pb::int32>& zidx_phase, const simple_variant<LengthUnits3, pb::int32>& units, const double& dist_per_pulse, const double& initial_pos, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCILinEncoderChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto decoding_type_ptr = decoding_type.get_if<EncoderType2>();
  const auto decoding_type_raw_ptr = decoding_type.get_if<pb::int32>();
  if (decoding_type_ptr) {
    request.set_decoding_type(*decoding_type_ptr);
  }
  else if (decoding_type_raw_ptr) {
    request.set_decoding_type_raw(*decoding_type_raw_ptr);
  }
  request.set_zidx_enable(zidx_enable);
  request.set_zidx_val(zidx_val);
  const auto zidx_phase_ptr = zidx_phase.get_if<EncoderZIndexPhase1>();
  const auto zidx_phase_raw_ptr = zidx_phase.get_if<pb::int32>();
  if (zidx_phase_ptr) {
    request.set_zidx_phase(*zidx_phase_ptr);
  }
  else if (zidx_phase_raw_ptr) {
    request.set_zidx_phase_raw(*zidx_phase_raw_ptr);
  }
  const auto units_ptr = units.get_if<LengthUnits3>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_dist_per_pulse(dist_per_pulse);
  request.set_initial_pos(initial_pos);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCILinEncoderChanResponse{};

  raise_if_error(
      stub->CreateCILinEncoderChan(&context, request, &response));

  return response;
}

CreateCILinVelocityChanResponse
create_ci_lin_velocity_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<EncoderType2, pb::int32>& decoding_type, const simple_variant<VelocityUnits, pb::int32>& units, const double& dist_per_pulse, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCILinVelocityChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto decoding_type_ptr = decoding_type.get_if<EncoderType2>();
  const auto decoding_type_raw_ptr = decoding_type.get_if<pb::int32>();
  if (decoding_type_ptr) {
    request.set_decoding_type(*decoding_type_ptr);
  }
  else if (decoding_type_raw_ptr) {
    request.set_decoding_type_raw(*decoding_type_raw_ptr);
  }
  const auto units_ptr = units.get_if<VelocityUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_dist_per_pulse(dist_per_pulse);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCILinVelocityChanResponse{};

  raise_if_error(
      stub->CreateCILinVelocityChan(&context, request, &response));

  return response;
}

CreateCIPeriodChanResponse
create_ci_period_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TimeUnits3, pb::int32>& units, const simple_variant<Edge1, pb::int32>& edge, const simple_variant<CounterFrequencyMethod, pb::int32>& meas_method, const double& meas_time, const pb::uint32& divisor, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCIPeriodChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TimeUnits3>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto edge_ptr = edge.get_if<Edge1>();
  const auto edge_raw_ptr = edge.get_if<pb::int32>();
  if (edge_ptr) {
    request.set_edge(*edge_ptr);
  }
  else if (edge_raw_ptr) {
    request.set_edge_raw(*edge_raw_ptr);
  }
  const auto meas_method_ptr = meas_method.get_if<CounterFrequencyMethod>();
  const auto meas_method_raw_ptr = meas_method.get_if<pb::int32>();
  if (meas_method_ptr) {
    request.set_meas_method(*meas_method_ptr);
  }
  else if (meas_method_raw_ptr) {
    request.set_meas_method_raw(*meas_method_raw_ptr);
  }
  request.set_meas_time(meas_time);
  request.set_divisor(divisor);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCIPeriodChanResponse{};

  raise_if_error(
      stub->CreateCIPeriodChan(&context, request, &response));

  return response;
}

CreateCIPulseChanFreqResponse
create_ci_pulse_chan_freq(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<FrequencyUnits2, pb::int32>& units)
{
  ::grpc::ClientContext context;

  auto request = CreateCIPulseChanFreqRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<FrequencyUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }

  auto response = CreateCIPulseChanFreqResponse{};

  raise_if_error(
      stub->CreateCIPulseChanFreq(&context, request, &response));

  return response;
}

CreateCIPulseChanTicksResponse
create_ci_pulse_chan_ticks(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const pb::string& source_terminal, const double& min_val, const double& max_val)
{
  ::grpc::ClientContext context;

  auto request = CreateCIPulseChanTicksRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_source_terminal(source_terminal);
  request.set_min_val(min_val);
  request.set_max_val(max_val);

  auto response = CreateCIPulseChanTicksResponse{};

  raise_if_error(
      stub->CreateCIPulseChanTicks(&context, request, &response));

  return response;
}

CreateCIPulseChanTimeResponse
create_ci_pulse_chan_time(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<DigitalWidthUnits3, pb::int32>& units)
{
  ::grpc::ClientContext context;

  auto request = CreateCIPulseChanTimeRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<DigitalWidthUnits3>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }

  auto response = CreateCIPulseChanTimeResponse{};

  raise_if_error(
      stub->CreateCIPulseChanTime(&context, request, &response));

  return response;
}

CreateCIPulseWidthChanResponse
create_ci_pulse_width_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TimeUnits3, pb::int32>& units, const simple_variant<Edge1, pb::int32>& starting_edge, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCIPulseWidthChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TimeUnits3>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto starting_edge_ptr = starting_edge.get_if<Edge1>();
  const auto starting_edge_raw_ptr = starting_edge.get_if<pb::int32>();
  if (starting_edge_ptr) {
    request.set_starting_edge(*starting_edge_ptr);
  }
  else if (starting_edge_raw_ptr) {
    request.set_starting_edge_raw(*starting_edge_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCIPulseWidthChanResponse{};

  raise_if_error(
      stub->CreateCIPulseWidthChan(&context, request, &response));

  return response;
}

CreateCISemiPeriodChanResponse
create_ci_semi_period_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TimeUnits3, pb::int32>& units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCISemiPeriodChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TimeUnits3>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCISemiPeriodChanResponse{};

  raise_if_error(
      stub->CreateCISemiPeriodChan(&context, request, &response));

  return response;
}

CreateCITwoEdgeSepChanResponse
create_ci_two_edge_sep_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TimeUnits3, pb::int32>& units, const simple_variant<Edge1, pb::int32>& first_edge, const simple_variant<Edge1, pb::int32>& second_edge, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateCITwoEdgeSepChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TimeUnits3>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto first_edge_ptr = first_edge.get_if<Edge1>();
  const auto first_edge_raw_ptr = first_edge.get_if<pb::int32>();
  if (first_edge_ptr) {
    request.set_first_edge(*first_edge_ptr);
  }
  else if (first_edge_raw_ptr) {
    request.set_first_edge_raw(*first_edge_raw_ptr);
  }
  const auto second_edge_ptr = second_edge.get_if<Edge1>();
  const auto second_edge_raw_ptr = second_edge.get_if<pb::int32>();
  if (second_edge_ptr) {
    request.set_second_edge(*second_edge_ptr);
  }
  else if (second_edge_raw_ptr) {
    request.set_second_edge_raw(*second_edge_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateCITwoEdgeSepChanResponse{};

  raise_if_error(
      stub->CreateCITwoEdgeSepChan(&context, request, &response));

  return response;
}

CreateCOPulseChanFreqResponse
create_co_pulse_chan_freq(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const simple_variant<FrequencyUnits2, pb::int32>& units, const simple_variant<Level1, pb::int32>& idle_state, const double& initial_delay, const double& freq, const double& duty_cycle)
{
  ::grpc::ClientContext context;

  auto request = CreateCOPulseChanFreqRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto units_ptr = units.get_if<FrequencyUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto idle_state_ptr = idle_state.get_if<Level1>();
  const auto idle_state_raw_ptr = idle_state.get_if<pb::int32>();
  if (idle_state_ptr) {
    request.set_idle_state(*idle_state_ptr);
  }
  else if (idle_state_raw_ptr) {
    request.set_idle_state_raw(*idle_state_raw_ptr);
  }
  request.set_initial_delay(initial_delay);
  request.set_freq(freq);
  request.set_duty_cycle(duty_cycle);

  auto response = CreateCOPulseChanFreqResponse{};

  raise_if_error(
      stub->CreateCOPulseChanFreq(&context, request, &response));

  return response;
}

CreateCOPulseChanTicksResponse
create_co_pulse_chan_ticks(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const pb::string& source_terminal, const simple_variant<Level1, pb::int32>& idle_state, const pb::int32& initial_delay, const pb::int32& low_ticks, const pb::int32& high_ticks)
{
  ::grpc::ClientContext context;

  auto request = CreateCOPulseChanTicksRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_source_terminal(source_terminal);
  const auto idle_state_ptr = idle_state.get_if<Level1>();
  const auto idle_state_raw_ptr = idle_state.get_if<pb::int32>();
  if (idle_state_ptr) {
    request.set_idle_state(*idle_state_ptr);
  }
  else if (idle_state_raw_ptr) {
    request.set_idle_state_raw(*idle_state_raw_ptr);
  }
  request.set_initial_delay(initial_delay);
  request.set_low_ticks(low_ticks);
  request.set_high_ticks(high_ticks);

  auto response = CreateCOPulseChanTicksResponse{};

  raise_if_error(
      stub->CreateCOPulseChanTicks(&context, request, &response));

  return response;
}

CreateCOPulseChanTimeResponse
create_co_pulse_chan_time(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& counter, const pb::string& name_to_assign_to_channel, const simple_variant<DigitalWidthUnits3, pb::int32>& units, const simple_variant<Level1, pb::int32>& idle_state, const double& initial_delay, const double& low_time, const double& high_time)
{
  ::grpc::ClientContext context;

  auto request = CreateCOPulseChanTimeRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_counter(counter);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto units_ptr = units.get_if<DigitalWidthUnits3>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto idle_state_ptr = idle_state.get_if<Level1>();
  const auto idle_state_raw_ptr = idle_state.get_if<pb::int32>();
  if (idle_state_ptr) {
    request.set_idle_state(*idle_state_ptr);
  }
  else if (idle_state_raw_ptr) {
    request.set_idle_state_raw(*idle_state_raw_ptr);
  }
  request.set_initial_delay(initial_delay);
  request.set_low_time(low_time);
  request.set_high_time(high_time);

  auto response = CreateCOPulseChanTimeResponse{};

  raise_if_error(
      stub->CreateCOPulseChanTime(&context, request, &response));

  return response;
}

CreateDIChanResponse
create_di_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& lines, const pb::string& name_to_assign_to_lines, const simple_variant<LineGrouping, pb::int32>& line_grouping)
{
  ::grpc::ClientContext context;

  auto request = CreateDIChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_lines(lines);
  request.set_name_to_assign_to_lines(name_to_assign_to_lines);
  const auto line_grouping_ptr = line_grouping.get_if<LineGrouping>();
  const auto line_grouping_raw_ptr = line_grouping.get_if<pb::int32>();
  if (line_grouping_ptr) {
    request.set_line_grouping(*line_grouping_ptr);
  }
  else if (line_grouping_raw_ptr) {
    request.set_line_grouping_raw(*line_grouping_raw_ptr);
  }

  auto response = CreateDIChanResponse{};

  raise_if_error(
      stub->CreateDIChan(&context, request, &response));

  return response;
}

CreateDOChanResponse
create_do_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& lines, const pb::string& name_to_assign_to_lines, const simple_variant<LineGrouping, pb::int32>& line_grouping)
{
  ::grpc::ClientContext context;

  auto request = CreateDOChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_lines(lines);
  request.set_name_to_assign_to_lines(name_to_assign_to_lines);
  const auto line_grouping_ptr = line_grouping.get_if<LineGrouping>();
  const auto line_grouping_raw_ptr = line_grouping.get_if<pb::int32>();
  if (line_grouping_ptr) {
    request.set_line_grouping(*line_grouping_ptr);
  }
  else if (line_grouping_raw_ptr) {
    request.set_line_grouping_raw(*line_grouping_raw_ptr);
  }

  auto response = CreateDOChanResponse{};

  raise_if_error(
      stub->CreateDOChan(&context, request, &response));

  return response;
}

CreateLinScaleResponse
create_lin_scale(const StubPtr& stub, const pb::string& name, const double& slope, const double& y_intercept, const simple_variant<UnitsPreScaled, pb::int32>& pre_scaled_units, const pb::string& scaled_units)
{
  ::grpc::ClientContext context;

  auto request = CreateLinScaleRequest{};
  request.set_name(name);
  request.set_slope(slope);
  request.set_y_intercept(y_intercept);
  const auto pre_scaled_units_ptr = pre_scaled_units.get_if<UnitsPreScaled>();
  const auto pre_scaled_units_raw_ptr = pre_scaled_units.get_if<pb::int32>();
  if (pre_scaled_units_ptr) {
    request.set_pre_scaled_units(*pre_scaled_units_ptr);
  }
  else if (pre_scaled_units_raw_ptr) {
    request.set_pre_scaled_units_raw(*pre_scaled_units_raw_ptr);
  }
  request.set_scaled_units(scaled_units);

  auto response = CreateLinScaleResponse{};

  raise_if_error(
      stub->CreateLinScale(&context, request, &response));

  return response;
}

CreateMapScaleResponse
create_map_scale(const StubPtr& stub, const pb::string& name, const double& prescaled_min, const double& prescaled_max, const double& scaled_min, const double& scaled_max, const simple_variant<UnitsPreScaled, pb::int32>& pre_scaled_units, const pb::string& scaled_units)
{
  ::grpc::ClientContext context;

  auto request = CreateMapScaleRequest{};
  request.set_name(name);
  request.set_prescaled_min(prescaled_min);
  request.set_prescaled_max(prescaled_max);
  request.set_scaled_min(scaled_min);
  request.set_scaled_max(scaled_max);
  const auto pre_scaled_units_ptr = pre_scaled_units.get_if<UnitsPreScaled>();
  const auto pre_scaled_units_raw_ptr = pre_scaled_units.get_if<pb::int32>();
  if (pre_scaled_units_ptr) {
    request.set_pre_scaled_units(*pre_scaled_units_ptr);
  }
  else if (pre_scaled_units_raw_ptr) {
    request.set_pre_scaled_units_raw(*pre_scaled_units_raw_ptr);
  }
  request.set_scaled_units(scaled_units);

  auto response = CreateMapScaleResponse{};

  raise_if_error(
      stub->CreateMapScale(&context, request, &response));

  return response;
}

CreatePolynomialScaleResponse
create_polynomial_scale(const StubPtr& stub, const pb::string& name, const std::vector<double>& forward_coeffs, const pb::uint32& num_forward_coeffs_in, const std::vector<double>& reverse_coeffs, const pb::uint32& num_reverse_coeffs_in, const simple_variant<UnitsPreScaled, pb::int32>& pre_scaled_units, const pb::string& scaled_units)
{
  ::grpc::ClientContext context;

  auto request = CreatePolynomialScaleRequest{};
  request.set_name(name);
  copy_array(forward_coeffs, request.mutable_forward_coeffs());
  request.set_num_forward_coeffs_in(num_forward_coeffs_in);
  copy_array(reverse_coeffs, request.mutable_reverse_coeffs());
  request.set_num_reverse_coeffs_in(num_reverse_coeffs_in);
  const auto pre_scaled_units_ptr = pre_scaled_units.get_if<UnitsPreScaled>();
  const auto pre_scaled_units_raw_ptr = pre_scaled_units.get_if<pb::int32>();
  if (pre_scaled_units_ptr) {
    request.set_pre_scaled_units(*pre_scaled_units_ptr);
  }
  else if (pre_scaled_units_raw_ptr) {
    request.set_pre_scaled_units_raw(*pre_scaled_units_raw_ptr);
  }
  request.set_scaled_units(scaled_units);

  auto response = CreatePolynomialScaleResponse{};

  raise_if_error(
      stub->CreatePolynomialScale(&context, request, &response));

  return response;
}

CreateTEDSAIAccelChanResponse
create_tedsai_accel_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<AccelUnits2, pb::int32>& units, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIAccelChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<AccelUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIAccelChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIAccelChan(&context, request, &response));

  return response;
}

CreateTEDSAIBridgeChanResponse
create_tedsai_bridge_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TEDSUnits, pb::int32>& units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIBridgeChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TEDSUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIBridgeChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIBridgeChan(&context, request, &response));

  return response;
}

CreateTEDSAICurrentChanResponse
create_tedsai_current_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<TEDSUnits, pb::int32>& units, const simple_variant<CurrentShuntResistorLocationWithDefault, pb::int32>& shunt_resistor_loc, const double& ext_shunt_resistor_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAICurrentChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TEDSUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto shunt_resistor_loc_ptr = shunt_resistor_loc.get_if<CurrentShuntResistorLocationWithDefault>();
  const auto shunt_resistor_loc_raw_ptr = shunt_resistor_loc.get_if<pb::int32>();
  if (shunt_resistor_loc_ptr) {
    request.set_shunt_resistor_loc(*shunt_resistor_loc_ptr);
  }
  else if (shunt_resistor_loc_raw_ptr) {
    request.set_shunt_resistor_loc_raw(*shunt_resistor_loc_raw_ptr);
  }
  request.set_ext_shunt_resistor_val(ext_shunt_resistor_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAICurrentChanResponse{};

  raise_if_error(
      stub->CreateTEDSAICurrentChan(&context, request, &response));

  return response;
}

CreateTEDSAIForceBridgeChanResponse
create_tedsai_force_bridge_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<ForceUnits, pb::int32>& units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIForceBridgeChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<ForceUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIForceBridgeChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIForceBridgeChan(&context, request, &response));

  return response;
}

CreateTEDSAIForceIEPEChanResponse
create_tedsai_force_iepe_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<ForceIEPEUnits, pb::int32>& units, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIForceIEPEChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<ForceIEPEUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIForceIEPEChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIForceIEPEChan(&context, request, &response));

  return response;
}

CreateTEDSAIMicrophoneChanResponse
create_tedsai_microphone_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const simple_variant<SoundPressureUnits1, pb::int32>& units, const double& max_snd_press_level, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIMicrophoneChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  const auto units_ptr = units.get_if<SoundPressureUnits1>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_max_snd_press_level(max_snd_press_level);
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIMicrophoneChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIMicrophoneChan(&context, request, &response));

  return response;
}

CreateTEDSAIPosLVDTChanResponse
create_tedsai_pos_lvdt_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<LengthUnits2, pb::int32>& units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& voltage_excit_freq, const simple_variant<ACExcitWireMode, pb::int32>& ac_excit_wire_mode, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIPosLVDTChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<LengthUnits2>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_voltage_excit_freq(voltage_excit_freq);
  const auto ac_excit_wire_mode_ptr = ac_excit_wire_mode.get_if<ACExcitWireMode>();
  const auto ac_excit_wire_mode_raw_ptr = ac_excit_wire_mode.get_if<pb::int32>();
  if (ac_excit_wire_mode_ptr) {
    request.set_ac_excit_wire_mode(*ac_excit_wire_mode_ptr);
  }
  else if (ac_excit_wire_mode_raw_ptr) {
    request.set_ac_excit_wire_mode_raw(*ac_excit_wire_mode_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIPosLVDTChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIPosLVDTChan(&context, request, &response));

  return response;
}

CreateTEDSAIPosRVDTChanResponse
create_tedsai_pos_rvdt_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<AngleUnits1, pb::int32>& units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& voltage_excit_freq, const simple_variant<ACExcitWireMode, pb::int32>& ac_excit_wire_mode, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIPosRVDTChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<AngleUnits1>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_voltage_excit_freq(voltage_excit_freq);
  const auto ac_excit_wire_mode_ptr = ac_excit_wire_mode.get_if<ACExcitWireMode>();
  const auto ac_excit_wire_mode_raw_ptr = ac_excit_wire_mode.get_if<pb::int32>();
  if (ac_excit_wire_mode_ptr) {
    request.set_ac_excit_wire_mode(*ac_excit_wire_mode_ptr);
  }
  else if (ac_excit_wire_mode_raw_ptr) {
    request.set_ac_excit_wire_mode_raw(*ac_excit_wire_mode_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIPosRVDTChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIPosRVDTChan(&context, request, &response));

  return response;
}

CreateTEDSAIPressureBridgeChanResponse
create_tedsai_pressure_bridge_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<PressureUnits, pb::int32>& units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIPressureBridgeChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<PressureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIPressureBridgeChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIPressureBridgeChan(&context, request, &response));

  return response;
}

CreateTEDSAIRTDChanResponse
create_tedsairtd_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TemperatureUnits, pb::int32>& units, const simple_variant<ResistanceConfiguration, pb::int32>& resistance_config, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIRTDChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TemperatureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto resistance_config_ptr = resistance_config.get_if<ResistanceConfiguration>();
  const auto resistance_config_raw_ptr = resistance_config.get_if<pb::int32>();
  if (resistance_config_ptr) {
    request.set_resistance_config(*resistance_config_ptr);
  }
  else if (resistance_config_raw_ptr) {
    request.set_resistance_config_raw(*resistance_config_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);

  auto response = CreateTEDSAIRTDChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIRTDChan(&context, request, &response));

  return response;
}

CreateTEDSAIResistanceChanResponse
create_tedsai_resistance_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TEDSUnits, pb::int32>& units, const simple_variant<ResistanceConfiguration, pb::int32>& resistance_config, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIResistanceChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TEDSUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto resistance_config_ptr = resistance_config.get_if<ResistanceConfiguration>();
  const auto resistance_config_raw_ptr = resistance_config.get_if<pb::int32>();
  if (resistance_config_ptr) {
    request.set_resistance_config(*resistance_config_ptr);
  }
  else if (resistance_config_raw_ptr) {
    request.set_resistance_config_raw(*resistance_config_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIResistanceChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIResistanceChan(&context, request, &response));

  return response;
}

CreateTEDSAIStrainGageChanResponse
create_tedsai_strain_gage_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<StrainUnits1, pb::int32>& units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& initial_bridge_voltage, const double& lead_wire_resistance, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIStrainGageChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<StrainUnits1>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_initial_bridge_voltage(initial_bridge_voltage);
  request.set_lead_wire_resistance(lead_wire_resistance);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIStrainGageChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIStrainGageChan(&context, request, &response));

  return response;
}

CreateTEDSAIThrmcplChanResponse
create_tedsai_thrmcpl_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TemperatureUnits, pb::int32>& units, const simple_variant<CJCSource1, pb::int32>& cjc_source, const double& cjc_val, const pb::string& cjc_channel)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIThrmcplChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TemperatureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto cjc_source_ptr = cjc_source.get_if<CJCSource1>();
  const auto cjc_source_raw_ptr = cjc_source.get_if<pb::int32>();
  if (cjc_source_ptr) {
    request.set_cjc_source(*cjc_source_ptr);
  }
  else if (cjc_source_raw_ptr) {
    request.set_cjc_source_raw(*cjc_source_raw_ptr);
  }
  request.set_cjc_val(cjc_val);
  request.set_cjc_channel(cjc_channel);

  auto response = CreateTEDSAIThrmcplChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIThrmcplChan(&context, request, &response));

  return response;
}

CreateTEDSAIThrmstrChanIexResponse
create_tedsai_thrmstr_chan_iex(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TemperatureUnits, pb::int32>& units, const simple_variant<ResistanceConfiguration, pb::int32>& resistance_config, const simple_variant<ExcitationSource, pb::int32>& current_excit_source, const double& current_excit_val)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIThrmstrChanIexRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TemperatureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto resistance_config_ptr = resistance_config.get_if<ResistanceConfiguration>();
  const auto resistance_config_raw_ptr = resistance_config.get_if<pb::int32>();
  if (resistance_config_ptr) {
    request.set_resistance_config(*resistance_config_ptr);
  }
  else if (resistance_config_raw_ptr) {
    request.set_resistance_config_raw(*resistance_config_raw_ptr);
  }
  const auto current_excit_source_ptr = current_excit_source.get_if<ExcitationSource>();
  const auto current_excit_source_raw_ptr = current_excit_source.get_if<pb::int32>();
  if (current_excit_source_ptr) {
    request.set_current_excit_source(*current_excit_source_ptr);
  }
  else if (current_excit_source_raw_ptr) {
    request.set_current_excit_source_raw(*current_excit_source_raw_ptr);
  }
  request.set_current_excit_val(current_excit_val);

  auto response = CreateTEDSAIThrmstrChanIexResponse{};

  raise_if_error(
      stub->CreateTEDSAIThrmstrChanIex(&context, request, &response));

  return response;
}

CreateTEDSAIThrmstrChanVexResponse
create_tedsai_thrmstr_chan_vex(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TemperatureUnits, pb::int32>& units, const simple_variant<ResistanceConfiguration, pb::int32>& resistance_config, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const double& r1)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIThrmstrChanVexRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TemperatureUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto resistance_config_ptr = resistance_config.get_if<ResistanceConfiguration>();
  const auto resistance_config_raw_ptr = resistance_config.get_if<pb::int32>();
  if (resistance_config_ptr) {
    request.set_resistance_config(*resistance_config_ptr);
  }
  else if (resistance_config_raw_ptr) {
    request.set_resistance_config_raw(*resistance_config_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_r1(r1);

  auto response = CreateTEDSAIThrmstrChanVexResponse{};

  raise_if_error(
      stub->CreateTEDSAIThrmstrChanVex(&context, request, &response));

  return response;
}

CreateTEDSAITorqueBridgeChanResponse
create_tedsai_torque_bridge_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const double& min_val, const double& max_val, const simple_variant<TorqueUnits, pb::int32>& units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAITorqueBridgeChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TorqueUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAITorqueBridgeChanResponse{};

  raise_if_error(
      stub->CreateTEDSAITorqueBridgeChan(&context, request, &response));

  return response;
}

CreateTEDSAIVoltageChanResponse
create_tedsai_voltage_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<TEDSUnits, pb::int32>& units, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIVoltageChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TEDSUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIVoltageChanResponse{};

  raise_if_error(
      stub->CreateTEDSAIVoltageChan(&context, request, &response));

  return response;
}

CreateTEDSAIVoltageChanWithExcitResponse
create_tedsai_voltage_chan_with_excit(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& physical_channel, const pb::string& name_to_assign_to_channel, const simple_variant<InputTermCfgWithDefault, pb::int32>& terminal_config, const double& min_val, const double& max_val, const simple_variant<TEDSUnits, pb::int32>& units, const simple_variant<ExcitationSource, pb::int32>& voltage_excit_source, const double& voltage_excit_val, const pb::string& custom_scale_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTEDSAIVoltageChanWithExcitRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_physical_channel(physical_channel);
  request.set_name_to_assign_to_channel(name_to_assign_to_channel);
  const auto terminal_config_ptr = terminal_config.get_if<InputTermCfgWithDefault>();
  const auto terminal_config_raw_ptr = terminal_config.get_if<pb::int32>();
  if (terminal_config_ptr) {
    request.set_terminal_config(*terminal_config_ptr);
  }
  else if (terminal_config_raw_ptr) {
    request.set_terminal_config_raw(*terminal_config_raw_ptr);
  }
  request.set_min_val(min_val);
  request.set_max_val(max_val);
  const auto units_ptr = units.get_if<TEDSUnits>();
  const auto units_raw_ptr = units.get_if<pb::int32>();
  if (units_ptr) {
    request.set_units(*units_ptr);
  }
  else if (units_raw_ptr) {
    request.set_units_raw(*units_raw_ptr);
  }
  const auto voltage_excit_source_ptr = voltage_excit_source.get_if<ExcitationSource>();
  const auto voltage_excit_source_raw_ptr = voltage_excit_source.get_if<pb::int32>();
  if (voltage_excit_source_ptr) {
    request.set_voltage_excit_source(*voltage_excit_source_ptr);
  }
  else if (voltage_excit_source_raw_ptr) {
    request.set_voltage_excit_source_raw(*voltage_excit_source_raw_ptr);
  }
  request.set_voltage_excit_val(voltage_excit_val);
  request.set_custom_scale_name(custom_scale_name);

  auto response = CreateTEDSAIVoltageChanWithExcitResponse{};

  raise_if_error(
      stub->CreateTEDSAIVoltageChanWithExcit(&context, request, &response));

  return response;
}

CreateTableScaleResponse
create_table_scale(const StubPtr& stub, const pb::string& name, const std::vector<double>& prescaled_vals, const pb::uint32& num_prescaled_vals_in, const std::vector<double>& scaled_vals, const pb::uint32& num_scaled_vals_in, const simple_variant<UnitsPreScaled, pb::int32>& pre_scaled_units, const pb::string& scaled_units)
{
  ::grpc::ClientContext context;

  auto request = CreateTableScaleRequest{};
  request.set_name(name);
  copy_array(prescaled_vals, request.mutable_prescaled_vals());
  request.set_num_prescaled_vals_in(num_prescaled_vals_in);
  copy_array(scaled_vals, request.mutable_scaled_vals());
  request.set_num_scaled_vals_in(num_scaled_vals_in);
  const auto pre_scaled_units_ptr = pre_scaled_units.get_if<UnitsPreScaled>();
  const auto pre_scaled_units_raw_ptr = pre_scaled_units.get_if<pb::int32>();
  if (pre_scaled_units_ptr) {
    request.set_pre_scaled_units(*pre_scaled_units_ptr);
  }
  else if (pre_scaled_units_raw_ptr) {
    request.set_pre_scaled_units_raw(*pre_scaled_units_raw_ptr);
  }
  request.set_scaled_units(scaled_units);

  auto response = CreateTableScaleResponse{};

  raise_if_error(
      stub->CreateTableScale(&context, request, &response));

  return response;
}

CreateTaskResponse
create_task(const StubPtr& stub, const pb::string& session_name)
{
  ::grpc::ClientContext context;

  auto request = CreateTaskRequest{};
  request.set_session_name(session_name);

  auto response = CreateTaskResponse{};

  raise_if_error(
      stub->CreateTask(&context, request, &response));

  return response;
}

CreateWatchdogTimerTaskResponse
create_watchdog_timer_task(const StubPtr& stub, const pb::string& device_name, const pb::string& session_name, const double& timeout, const std::vector<WatchdogExpChannelsAndState>& exp_states)
{
  ::grpc::ClientContext context;

  auto request = CreateWatchdogTimerTaskRequest{};
  request.set_device_name(device_name);
  request.set_session_name(session_name);
  request.set_timeout(timeout);
  copy_array(exp_states, request.mutable_exp_states());

  auto response = CreateWatchdogTimerTaskResponse{};

  raise_if_error(
      stub->CreateWatchdogTimerTask(&context, request, &response));

  return response;
}

CreateWatchdogTimerTaskExResponse
create_watchdog_timer_task_ex(const StubPtr& stub, const pb::string& device_name, const pb::string& session_name, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = CreateWatchdogTimerTaskExRequest{};
  request.set_device_name(device_name);
  request.set_session_name(session_name);
  request.set_timeout(timeout);

  auto response = CreateWatchdogTimerTaskExResponse{};

  raise_if_error(
      stub->CreateWatchdogTimerTaskEx(&context, request, &response));

  return response;
}

DeleteNetworkDeviceResponse
delete_network_device(const StubPtr& stub, const pb::string& device_name)
{
  ::grpc::ClientContext context;

  auto request = DeleteNetworkDeviceRequest{};
  request.set_device_name(device_name);

  auto response = DeleteNetworkDeviceResponse{};

  raise_if_error(
      stub->DeleteNetworkDevice(&context, request, &response));

  return response;
}

DeleteSavedGlobalChanResponse
delete_saved_global_chan(const StubPtr& stub, const pb::string& channel_name)
{
  ::grpc::ClientContext context;

  auto request = DeleteSavedGlobalChanRequest{};
  request.set_channel_name(channel_name);

  auto response = DeleteSavedGlobalChanResponse{};

  raise_if_error(
      stub->DeleteSavedGlobalChan(&context, request, &response));

  return response;
}

DeleteSavedScaleResponse
delete_saved_scale(const StubPtr& stub, const pb::string& scale_name)
{
  ::grpc::ClientContext context;

  auto request = DeleteSavedScaleRequest{};
  request.set_scale_name(scale_name);

  auto response = DeleteSavedScaleResponse{};

  raise_if_error(
      stub->DeleteSavedScale(&context, request, &response));

  return response;
}

DeleteSavedTaskResponse
delete_saved_task(const StubPtr& stub, const pb::string& task_name)
{
  ::grpc::ClientContext context;

  auto request = DeleteSavedTaskRequest{};
  request.set_task_name(task_name);

  auto response = DeleteSavedTaskResponse{};

  raise_if_error(
      stub->DeleteSavedTask(&context, request, &response));

  return response;
}

DeviceSupportsCalResponse
device_supports_cal(const StubPtr& stub, const pb::string& device_name)
{
  ::grpc::ClientContext context;

  auto request = DeviceSupportsCalRequest{};
  request.set_device_name(device_name);

  auto response = DeviceSupportsCalResponse{};

  raise_if_error(
      stub->DeviceSupportsCal(&context, request, &response));

  return response;
}

DisableRefTrigResponse
disable_ref_trig(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = DisableRefTrigRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = DisableRefTrigResponse{};

  raise_if_error(
      stub->DisableRefTrig(&context, request, &response));

  return response;
}

DisableStartTrigResponse
disable_start_trig(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = DisableStartTrigRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = DisableStartTrigResponse{};

  raise_if_error(
      stub->DisableStartTrig(&context, request, &response));

  return response;
}

DisconnectTermsResponse
disconnect_terms(const StubPtr& stub, const pb::string& source_terminal, const pb::string& destination_terminal)
{
  ::grpc::ClientContext context;

  auto request = DisconnectTermsRequest{};
  request.set_source_terminal(source_terminal);
  request.set_destination_terminal(destination_terminal);

  auto response = DisconnectTermsResponse{};

  raise_if_error(
      stub->DisconnectTerms(&context, request, &response));

  return response;
}

ExportSignalResponse
export_signal(const StubPtr& stub, const nidevice_grpc::Session& task, const simple_variant<Signal, pb::int32>& signal_id, const pb::string& output_terminal)
{
  ::grpc::ClientContext context;

  auto request = ExportSignalRequest{};
  request.mutable_task()->CopyFrom(task);
  const auto signal_id_ptr = signal_id.get_if<Signal>();
  const auto signal_id_raw_ptr = signal_id.get_if<pb::int32>();
  if (signal_id_ptr) {
    request.set_signal_id(*signal_id_ptr);
  }
  else if (signal_id_raw_ptr) {
    request.set_signal_id_raw(*signal_id_raw_ptr);
  }
  request.set_output_terminal(output_terminal);

  auto response = ExportSignalResponse{};

  raise_if_error(
      stub->ExportSignal(&context, request, &response));

  return response;
}

GetAIChanCalCalDateResponse
get_ai_chan_cal_cal_date(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel_name)
{
  ::grpc::ClientContext context;

  auto request = GetAIChanCalCalDateRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel_name(channel_name);

  auto response = GetAIChanCalCalDateResponse{};

  raise_if_error(
      stub->GetAIChanCalCalDate(&context, request, &response));

  return response;
}

GetAIChanCalExpDateResponse
get_ai_chan_cal_exp_date(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel_name)
{
  ::grpc::ClientContext context;

  auto request = GetAIChanCalExpDateRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel_name(channel_name);

  auto response = GetAIChanCalExpDateResponse{};

  raise_if_error(
      stub->GetAIChanCalExpDate(&context, request, &response));

  return response;
}

GetAnalogPowerUpStatesResponse
get_analog_power_up_states(const StubPtr& stub, const pb::string& device_name, const std::vector<AnalogPowerUpChannelAndType>& channels)
{
  ::grpc::ClientContext context;

  auto request = GetAnalogPowerUpStatesRequest{};
  request.set_device_name(device_name);
  copy_array(channels, request.mutable_channels());

  auto response = GetAnalogPowerUpStatesResponse{};

  raise_if_error(
      stub->GetAnalogPowerUpStates(&context, request, &response));

  return response;
}

GetArmStartTrigTimestampValResponse
get_arm_start_trig_timestamp_val(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = GetArmStartTrigTimestampValRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = GetArmStartTrigTimestampValResponse{};

  raise_if_error(
      stub->GetArmStartTrigTimestampVal(&context, request, &response));

  return response;
}

GetArmStartTrigTrigWhenResponse
get_arm_start_trig_trig_when(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = GetArmStartTrigTrigWhenRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = GetArmStartTrigTrigWhenResponse{};

  raise_if_error(
      stub->GetArmStartTrigTrigWhen(&context, request, &response));

  return response;
}

GetAutoConfiguredCDAQSyncConnectionsResponse
get_auto_configured_cdaq_sync_connections(const StubPtr& stub, const pb::uint32& port_list_size)
{
  ::grpc::ClientContext context;

  auto request = GetAutoConfiguredCDAQSyncConnectionsRequest{};
  request.set_port_list_size(port_list_size);

  auto response = GetAutoConfiguredCDAQSyncConnectionsResponse{};

  raise_if_error(
      stub->GetAutoConfiguredCDAQSyncConnections(&context, request, &response));

  return response;
}

GetBufferAttributeUInt32Response
get_buffer_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const BufferUInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetBufferAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetBufferAttributeUInt32Response{};

  raise_if_error(
      stub->GetBufferAttributeUInt32(&context, request, &response));

  return response;
}

GetChanAttributeBoolResponse
get_chan_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelBoolAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetChanAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);

  auto response = GetChanAttributeBoolResponse{};

  raise_if_error(
      stub->GetChanAttributeBool(&context, request, &response));

  return response;
}

GetChanAttributeDoubleResponse
get_chan_attribute_double(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelDoubleAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetChanAttributeDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);

  auto response = GetChanAttributeDoubleResponse{};

  raise_if_error(
      stub->GetChanAttributeDouble(&context, request, &response));

  return response;
}

GetChanAttributeDoubleArrayResponse
get_chan_attribute_double_array(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelDoubleArrayAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetChanAttributeDoubleArrayRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetChanAttributeDoubleArrayResponse{};

  raise_if_error(
      stub->GetChanAttributeDoubleArray(&context, request, &response));

  return response;
}

GetChanAttributeInt32Response
get_chan_attribute_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetChanAttributeInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);

  auto response = GetChanAttributeInt32Response{};

  raise_if_error(
      stub->GetChanAttributeInt32(&context, request, &response));

  return response;
}

GetChanAttributeStringResponse
get_chan_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelStringAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetChanAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetChanAttributeStringResponse{};

  raise_if_error(
      stub->GetChanAttributeString(&context, request, &response));

  return response;
}

GetChanAttributeUInt32Response
get_chan_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelUInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetChanAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);

  auto response = GetChanAttributeUInt32Response{};

  raise_if_error(
      stub->GetChanAttributeUInt32(&context, request, &response));

  return response;
}

GetDeviceAttributeBoolResponse
get_device_attribute_bool(const StubPtr& stub, const pb::string& device_name, const DeviceBoolAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetDeviceAttributeBoolRequest{};
  request.set_device_name(device_name);
  request.set_attribute(attribute);

  auto response = GetDeviceAttributeBoolResponse{};

  raise_if_error(
      stub->GetDeviceAttributeBool(&context, request, &response));

  return response;
}

GetDeviceAttributeDoubleResponse
get_device_attribute_double(const StubPtr& stub, const pb::string& device_name, const DeviceDoubleAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetDeviceAttributeDoubleRequest{};
  request.set_device_name(device_name);
  request.set_attribute(attribute);

  auto response = GetDeviceAttributeDoubleResponse{};

  raise_if_error(
      stub->GetDeviceAttributeDouble(&context, request, &response));

  return response;
}

GetDeviceAttributeDoubleArrayResponse
get_device_attribute_double_array(const StubPtr& stub, const pb::string& device_name, const DeviceDoubleArrayAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetDeviceAttributeDoubleArrayRequest{};
  request.set_device_name(device_name);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetDeviceAttributeDoubleArrayResponse{};

  raise_if_error(
      stub->GetDeviceAttributeDoubleArray(&context, request, &response));

  return response;
}

GetDeviceAttributeInt32Response
get_device_attribute_int32(const StubPtr& stub, const pb::string& device_name, const DeviceInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetDeviceAttributeInt32Request{};
  request.set_device_name(device_name);
  request.set_attribute(attribute);

  auto response = GetDeviceAttributeInt32Response{};

  raise_if_error(
      stub->GetDeviceAttributeInt32(&context, request, &response));

  return response;
}

GetDeviceAttributeInt32ArrayResponse
get_device_attribute_int32_array(const StubPtr& stub, const pb::string& device_name, const DeviceInt32ArrayAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetDeviceAttributeInt32ArrayRequest{};
  request.set_device_name(device_name);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetDeviceAttributeInt32ArrayResponse{};

  raise_if_error(
      stub->GetDeviceAttributeInt32Array(&context, request, &response));

  return response;
}

GetDeviceAttributeStringResponse
get_device_attribute_string(const StubPtr& stub, const pb::string& device_name, const DeviceStringAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetDeviceAttributeStringRequest{};
  request.set_device_name(device_name);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetDeviceAttributeStringResponse{};

  raise_if_error(
      stub->GetDeviceAttributeString(&context, request, &response));

  return response;
}

GetDeviceAttributeUInt32Response
get_device_attribute_uint32(const StubPtr& stub, const pb::string& device_name, const DeviceUInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetDeviceAttributeUInt32Request{};
  request.set_device_name(device_name);
  request.set_attribute(attribute);

  auto response = GetDeviceAttributeUInt32Response{};

  raise_if_error(
      stub->GetDeviceAttributeUInt32(&context, request, &response));

  return response;
}

GetDeviceAttributeUInt32ArrayResponse
get_device_attribute_uint32_array(const StubPtr& stub, const pb::string& device_name, const DeviceUInt32ArrayAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetDeviceAttributeUInt32ArrayRequest{};
  request.set_device_name(device_name);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetDeviceAttributeUInt32ArrayResponse{};

  raise_if_error(
      stub->GetDeviceAttributeUInt32Array(&context, request, &response));

  return response;
}

GetDigitalLogicFamilyPowerUpStateResponse
get_digital_logic_family_power_up_state(const StubPtr& stub, const pb::string& device_name)
{
  ::grpc::ClientContext context;

  auto request = GetDigitalLogicFamilyPowerUpStateRequest{};
  request.set_device_name(device_name);

  auto response = GetDigitalLogicFamilyPowerUpStateResponse{};

  raise_if_error(
      stub->GetDigitalLogicFamilyPowerUpState(&context, request, &response));

  return response;
}

GetDigitalPowerUpStatesResponse
get_digital_power_up_states(const StubPtr& stub, const pb::string& device_name, const std::vector<pb::string>& channel_name)
{
  ::grpc::ClientContext context;

  auto request = GetDigitalPowerUpStatesRequest{};
  request.set_device_name(device_name);
  copy_array(channel_name, request.mutable_channel_name());

  auto response = GetDigitalPowerUpStatesResponse{};

  raise_if_error(
      stub->GetDigitalPowerUpStates(&context, request, &response));

  return response;
}

GetDigitalPullUpPullDownStatesResponse
get_digital_pull_up_pull_down_states(const StubPtr& stub, const pb::string& device_name, const std::vector<pb::string>& channel_name)
{
  ::grpc::ClientContext context;

  auto request = GetDigitalPullUpPullDownStatesRequest{};
  request.set_device_name(device_name);
  copy_array(channel_name, request.mutable_channel_name());

  auto response = GetDigitalPullUpPullDownStatesResponse{};

  raise_if_error(
      stub->GetDigitalPullUpPullDownStates(&context, request, &response));

  return response;
}

GetDisconnectedCDAQSyncPortsResponse
get_disconnected_cdaq_sync_ports(const StubPtr& stub, const pb::uint32& port_list_size)
{
  ::grpc::ClientContext context;

  auto request = GetDisconnectedCDAQSyncPortsRequest{};
  request.set_port_list_size(port_list_size);

  auto response = GetDisconnectedCDAQSyncPortsResponse{};

  raise_if_error(
      stub->GetDisconnectedCDAQSyncPorts(&context, request, &response));

  return response;
}

GetErrorStringResponse
get_error_string(const StubPtr& stub, const pb::int32& error_code)
{
  ::grpc::ClientContext context;

  auto request = GetErrorStringRequest{};
  request.set_error_code(error_code);

  auto response = GetErrorStringResponse{};

  raise_if_error(
      stub->GetErrorString(&context, request, &response));

  return response;
}

GetExtendedErrorInfoResponse
get_extended_error_info(const StubPtr& stub)
{
  ::grpc::ClientContext context;

  auto request = GetExtendedErrorInfoRequest{};

  auto response = GetExtendedErrorInfoResponse{};

  raise_if_error(
      stub->GetExtendedErrorInfo(&context, request, &response));

  return response;
}

GetFirstSampClkWhenResponse
get_first_samp_clk_when(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = GetFirstSampClkWhenRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = GetFirstSampClkWhenResponse{};

  raise_if_error(
      stub->GetFirstSampClkWhen(&context, request, &response));

  return response;
}

GetFirstSampTimestampValResponse
get_first_samp_timestamp_val(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = GetFirstSampTimestampValRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = GetFirstSampTimestampValResponse{};

  raise_if_error(
      stub->GetFirstSampTimestampVal(&context, request, &response));

  return response;
}

GetNthTaskChannelResponse
get_nth_task_channel(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::uint32& index, const pb::int32& buffer_size)
{
  ::grpc::ClientContext context;

  auto request = GetNthTaskChannelRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_index(index);
  request.set_buffer_size(buffer_size);

  auto response = GetNthTaskChannelResponse{};

  raise_if_error(
      stub->GetNthTaskChannel(&context, request, &response));

  return response;
}

GetNthTaskDeviceResponse
get_nth_task_device(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::uint32& index, const pb::int32& buffer_size)
{
  ::grpc::ClientContext context;

  auto request = GetNthTaskDeviceRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_index(index);
  request.set_buffer_size(buffer_size);

  auto response = GetNthTaskDeviceResponse{};

  raise_if_error(
      stub->GetNthTaskDevice(&context, request, &response));

  return response;
}

GetNthTaskReadChannelResponse
get_nth_task_read_channel(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::uint32& index, const pb::int32& buffer_size)
{
  ::grpc::ClientContext context;

  auto request = GetNthTaskReadChannelRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_index(index);
  request.set_buffer_size(buffer_size);

  auto response = GetNthTaskReadChannelResponse{};

  raise_if_error(
      stub->GetNthTaskReadChannel(&context, request, &response));

  return response;
}

GetReadAttributeBoolResponse
get_read_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadBoolAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetReadAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetReadAttributeBoolResponse{};

  raise_if_error(
      stub->GetReadAttributeBool(&context, request, &response));

  return response;
}

GetReadAttributeDoubleResponse
get_read_attribute_double(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadDoubleAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetReadAttributeDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetReadAttributeDoubleResponse{};

  raise_if_error(
      stub->GetReadAttributeDouble(&context, request, &response));

  return response;
}

GetReadAttributeInt32Response
get_read_attribute_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetReadAttributeInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetReadAttributeInt32Response{};

  raise_if_error(
      stub->GetReadAttributeInt32(&context, request, &response));

  return response;
}

GetReadAttributeStringResponse
get_read_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadStringAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetReadAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetReadAttributeStringResponse{};

  raise_if_error(
      stub->GetReadAttributeString(&context, request, &response));

  return response;
}

GetReadAttributeUInt32Response
get_read_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadUInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetReadAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetReadAttributeUInt32Response{};

  raise_if_error(
      stub->GetReadAttributeUInt32(&context, request, &response));

  return response;
}

GetReadAttributeUInt64Response
get_read_attribute_uint64(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadUInt64Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetReadAttributeUInt64Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetReadAttributeUInt64Response{};

  raise_if_error(
      stub->GetReadAttributeUInt64(&context, request, &response));

  return response;
}

GetRefTrigTimestampValResponse
get_ref_trig_timestamp_val(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = GetRefTrigTimestampValRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = GetRefTrigTimestampValResponse{};

  raise_if_error(
      stub->GetRefTrigTimestampVal(&context, request, &response));

  return response;
}

GetScaleAttributeDoubleResponse
get_scale_attribute_double(const StubPtr& stub, const pb::string& scale_name, const ScaleDoubleAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetScaleAttributeDoubleRequest{};
  request.set_scale_name(scale_name);
  request.set_attribute(attribute);

  auto response = GetScaleAttributeDoubleResponse{};

  raise_if_error(
      stub->GetScaleAttributeDouble(&context, request, &response));

  return response;
}

GetScaleAttributeDoubleArrayResponse
get_scale_attribute_double_array(const StubPtr& stub, const pb::string& scale_name, const ScaleDoubleArrayAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetScaleAttributeDoubleArrayRequest{};
  request.set_scale_name(scale_name);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetScaleAttributeDoubleArrayResponse{};

  raise_if_error(
      stub->GetScaleAttributeDoubleArray(&context, request, &response));

  return response;
}

GetScaleAttributeInt32Response
get_scale_attribute_int32(const StubPtr& stub, const pb::string& scale_name, const ScaleInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetScaleAttributeInt32Request{};
  request.set_scale_name(scale_name);
  request.set_attribute(attribute);

  auto response = GetScaleAttributeInt32Response{};

  raise_if_error(
      stub->GetScaleAttributeInt32(&context, request, &response));

  return response;
}

GetScaleAttributeStringResponse
get_scale_attribute_string(const StubPtr& stub, const pb::string& scale_name, const ScaleStringAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetScaleAttributeStringRequest{};
  request.set_scale_name(scale_name);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetScaleAttributeStringResponse{};

  raise_if_error(
      stub->GetScaleAttributeString(&context, request, &response));

  return response;
}

GetSelfCalLastDateAndTimeResponse
get_self_cal_last_date_and_time(const StubPtr& stub, const pb::string& device_name)
{
  ::grpc::ClientContext context;

  auto request = GetSelfCalLastDateAndTimeRequest{};
  request.set_device_name(device_name);

  auto response = GetSelfCalLastDateAndTimeResponse{};

  raise_if_error(
      stub->GetSelfCalLastDateAndTime(&context, request, &response));

  return response;
}

GetStartTrigTimestampValResponse
get_start_trig_timestamp_val(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = GetStartTrigTimestampValRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = GetStartTrigTimestampValResponse{};

  raise_if_error(
      stub->GetStartTrigTimestampVal(&context, request, &response));

  return response;
}

GetStartTrigTrigWhenResponse
get_start_trig_trig_when(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = GetStartTrigTrigWhenRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = GetStartTrigTrigWhenResponse{};

  raise_if_error(
      stub->GetStartTrigTrigWhen(&context, request, &response));

  return response;
}

GetSyncPulseTimeWhenResponse
get_sync_pulse_time_when(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = GetSyncPulseTimeWhenRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = GetSyncPulseTimeWhenResponse{};

  raise_if_error(
      stub->GetSyncPulseTimeWhen(&context, request, &response));

  return response;
}

GetTaskAttributeBoolResponse
get_task_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const TaskBoolAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTaskAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTaskAttributeBoolResponse{};

  raise_if_error(
      stub->GetTaskAttributeBool(&context, request, &response));

  return response;
}

GetTaskAttributeStringResponse
get_task_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const TaskStringAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetTaskAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetTaskAttributeStringResponse{};

  raise_if_error(
      stub->GetTaskAttributeString(&context, request, &response));

  return response;
}

GetTaskAttributeUInt32Response
get_task_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const TaskUInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTaskAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTaskAttributeUInt32Response{};

  raise_if_error(
      stub->GetTaskAttributeUInt32(&context, request, &response));

  return response;
}

GetTimingAttributeBoolResponse
get_timing_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingBoolAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTimingAttributeBoolResponse{};

  raise_if_error(
      stub->GetTimingAttributeBool(&context, request, &response));

  return response;
}

GetTimingAttributeDoubleResponse
get_timing_attribute_double(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingDoubleAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTimingAttributeDoubleResponse{};

  raise_if_error(
      stub->GetTimingAttributeDouble(&context, request, &response));

  return response;
}

GetTimingAttributeExBoolResponse
get_timing_attribute_ex_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingBoolAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeExBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);

  auto response = GetTimingAttributeExBoolResponse{};

  raise_if_error(
      stub->GetTimingAttributeExBool(&context, request, &response));

  return response;
}

GetTimingAttributeExDoubleResponse
get_timing_attribute_ex_double(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingDoubleAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeExDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);

  auto response = GetTimingAttributeExDoubleResponse{};

  raise_if_error(
      stub->GetTimingAttributeExDouble(&context, request, &response));

  return response;
}

GetTimingAttributeExInt32Response
get_timing_attribute_ex_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeExInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);

  auto response = GetTimingAttributeExInt32Response{};

  raise_if_error(
      stub->GetTimingAttributeExInt32(&context, request, &response));

  return response;
}

GetTimingAttributeExStringResponse
get_timing_attribute_ex_string(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingStringAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeExStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetTimingAttributeExStringResponse{};

  raise_if_error(
      stub->GetTimingAttributeExString(&context, request, &response));

  return response;
}

GetTimingAttributeExTimestampResponse
get_timing_attribute_ex_timestamp(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingTimestampAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeExTimestampRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);

  auto response = GetTimingAttributeExTimestampResponse{};

  raise_if_error(
      stub->GetTimingAttributeExTimestamp(&context, request, &response));

  return response;
}

GetTimingAttributeExUInt32Response
get_timing_attribute_ex_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingUInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeExUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);

  auto response = GetTimingAttributeExUInt32Response{};

  raise_if_error(
      stub->GetTimingAttributeExUInt32(&context, request, &response));

  return response;
}

GetTimingAttributeInt32Response
get_timing_attribute_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTimingAttributeInt32Response{};

  raise_if_error(
      stub->GetTimingAttributeInt32(&context, request, &response));

  return response;
}

GetTimingAttributeStringResponse
get_timing_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingStringAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetTimingAttributeStringResponse{};

  raise_if_error(
      stub->GetTimingAttributeString(&context, request, &response));

  return response;
}

GetTimingAttributeTimestampResponse
get_timing_attribute_timestamp(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingTimestampAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeTimestampRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTimingAttributeTimestampResponse{};

  raise_if_error(
      stub->GetTimingAttributeTimestamp(&context, request, &response));

  return response;
}

GetTimingAttributeUInt32Response
get_timing_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingUInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTimingAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTimingAttributeUInt32Response{};

  raise_if_error(
      stub->GetTimingAttributeUInt32(&context, request, &response));

  return response;
}

GetTrigAttributeBoolResponse
get_trig_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerBoolAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTrigAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTrigAttributeBoolResponse{};

  raise_if_error(
      stub->GetTrigAttributeBool(&context, request, &response));

  return response;
}

GetTrigAttributeDoubleResponse
get_trig_attribute_double(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerDoubleAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTrigAttributeDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTrigAttributeDoubleResponse{};

  raise_if_error(
      stub->GetTrigAttributeDouble(&context, request, &response));

  return response;
}

GetTrigAttributeDoubleArrayResponse
get_trig_attribute_double_array(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerDoubleArrayAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetTrigAttributeDoubleArrayRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetTrigAttributeDoubleArrayResponse{};

  raise_if_error(
      stub->GetTrigAttributeDoubleArray(&context, request, &response));

  return response;
}

GetTrigAttributeInt32Response
get_trig_attribute_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTrigAttributeInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTrigAttributeInt32Response{};

  raise_if_error(
      stub->GetTrigAttributeInt32(&context, request, &response));

  return response;
}

GetTrigAttributeInt32ArrayResponse
get_trig_attribute_int32_array(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerInt32ArrayAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetTrigAttributeInt32ArrayRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetTrigAttributeInt32ArrayResponse{};

  raise_if_error(
      stub->GetTrigAttributeInt32Array(&context, request, &response));

  return response;
}

GetTrigAttributeStringResponse
get_trig_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerStringAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetTrigAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetTrigAttributeStringResponse{};

  raise_if_error(
      stub->GetTrigAttributeString(&context, request, &response));

  return response;
}

GetTrigAttributeTimestampResponse
get_trig_attribute_timestamp(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerTimestampAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTrigAttributeTimestampRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTrigAttributeTimestampResponse{};

  raise_if_error(
      stub->GetTrigAttributeTimestamp(&context, request, &response));

  return response;
}

GetTrigAttributeUInt32Response
get_trig_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerUInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetTrigAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetTrigAttributeUInt32Response{};

  raise_if_error(
      stub->GetTrigAttributeUInt32(&context, request, &response));

  return response;
}

GetWriteAttributeBoolResponse
get_write_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteBoolAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetWriteAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetWriteAttributeBoolResponse{};

  raise_if_error(
      stub->GetWriteAttributeBool(&context, request, &response));

  return response;
}

GetWriteAttributeDoubleResponse
get_write_attribute_double(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteDoubleAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetWriteAttributeDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetWriteAttributeDoubleResponse{};

  raise_if_error(
      stub->GetWriteAttributeDouble(&context, request, &response));

  return response;
}

GetWriteAttributeInt32Response
get_write_attribute_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetWriteAttributeInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetWriteAttributeInt32Response{};

  raise_if_error(
      stub->GetWriteAttributeInt32(&context, request, &response));

  return response;
}

GetWriteAttributeStringResponse
get_write_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteStringAttributes& attribute, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = GetWriteAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_size(size);

  auto response = GetWriteAttributeStringResponse{};

  raise_if_error(
      stub->GetWriteAttributeString(&context, request, &response));

  return response;
}

GetWriteAttributeUInt32Response
get_write_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteUInt32Attributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = GetWriteAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = GetWriteAttributeUInt32Response{};

  raise_if_error(
      stub->GetWriteAttributeUInt32(&context, request, &response));

  return response;
}

IsTaskDoneResponse
is_task_done(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = IsTaskDoneRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = IsTaskDoneResponse{};

  raise_if_error(
      stub->IsTaskDone(&context, request, &response));

  return response;
}

LoadTaskResponse
load_task(const StubPtr& stub, const pb::string& session_name)
{
  ::grpc::ClientContext context;

  auto request = LoadTaskRequest{};
  request.set_session_name(session_name);

  auto response = LoadTaskResponse{};

  raise_if_error(
      stub->LoadTask(&context, request, &response));

  return response;
}

ReadAnalogF64Response
read_analog_f64(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadAnalogF64Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadAnalogF64Response{};

  raise_if_error(
      stub->ReadAnalogF64(&context, request, &response));

  return response;
}

ReadAnalogScalarF64Response
read_analog_scalar_f64(const StubPtr& stub, const nidevice_grpc::Session& task, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ReadAnalogScalarF64Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_timeout(timeout);

  auto response = ReadAnalogScalarF64Response{};

  raise_if_error(
      stub->ReadAnalogScalarF64(&context, request, &response));

  return response;
}

ReadBinaryI16Response
read_binary_i16(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadBinaryI16Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadBinaryI16Response{};

  raise_if_error(
      stub->ReadBinaryI16(&context, request, &response));

  return response;
}

ReadBinaryI32Response
read_binary_i32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadBinaryI32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadBinaryI32Response{};

  raise_if_error(
      stub->ReadBinaryI32(&context, request, &response));

  return response;
}

ReadBinaryU16Response
read_binary_u16(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadBinaryU16Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadBinaryU16Response{};

  raise_if_error(
      stub->ReadBinaryU16(&context, request, &response));

  return response;
}

ReadBinaryU32Response
read_binary_u32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadBinaryU32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadBinaryU32Response{};

  raise_if_error(
      stub->ReadBinaryU32(&context, request, &response));

  return response;
}

ReadCounterF64Response
read_counter_f64(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadCounterF64Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadCounterF64Response{};

  raise_if_error(
      stub->ReadCounterF64(&context, request, &response));

  return response;
}

ReadCounterF64ExResponse
read_counter_f64_ex(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadCounterF64ExRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadCounterF64ExResponse{};

  raise_if_error(
      stub->ReadCounterF64Ex(&context, request, &response));

  return response;
}

ReadCounterScalarF64Response
read_counter_scalar_f64(const StubPtr& stub, const nidevice_grpc::Session& task, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ReadCounterScalarF64Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_timeout(timeout);

  auto response = ReadCounterScalarF64Response{};

  raise_if_error(
      stub->ReadCounterScalarF64(&context, request, &response));

  return response;
}

ReadCounterScalarU32Response
read_counter_scalar_u32(const StubPtr& stub, const nidevice_grpc::Session& task, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ReadCounterScalarU32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_timeout(timeout);

  auto response = ReadCounterScalarU32Response{};

  raise_if_error(
      stub->ReadCounterScalarU32(&context, request, &response));

  return response;
}

ReadCounterU32Response
read_counter_u32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadCounterU32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadCounterU32Response{};

  raise_if_error(
      stub->ReadCounterU32(&context, request, &response));

  return response;
}

ReadCounterU32ExResponse
read_counter_u32_ex(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadCounterU32ExRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadCounterU32ExResponse{};

  raise_if_error(
      stub->ReadCounterU32Ex(&context, request, &response));

  return response;
}

ReadCtrFreqResponse
read_ctr_freq(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& interleaved, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadCtrFreqRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto interleaved_ptr = interleaved.get_if<GroupBy>();
  const auto interleaved_raw_ptr = interleaved.get_if<pb::int32>();
  if (interleaved_ptr) {
    request.set_interleaved(*interleaved_ptr);
  }
  else if (interleaved_raw_ptr) {
    request.set_interleaved_raw(*interleaved_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadCtrFreqResponse{};

  raise_if_error(
      stub->ReadCtrFreq(&context, request, &response));

  return response;
}

ReadCtrFreqScalarResponse
read_ctr_freq_scalar(const StubPtr& stub, const nidevice_grpc::Session& task, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ReadCtrFreqScalarRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_timeout(timeout);

  auto response = ReadCtrFreqScalarResponse{};

  raise_if_error(
      stub->ReadCtrFreqScalar(&context, request, &response));

  return response;
}

ReadCtrTicksResponse
read_ctr_ticks(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& interleaved, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadCtrTicksRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto interleaved_ptr = interleaved.get_if<GroupBy>();
  const auto interleaved_raw_ptr = interleaved.get_if<pb::int32>();
  if (interleaved_ptr) {
    request.set_interleaved(*interleaved_ptr);
  }
  else if (interleaved_raw_ptr) {
    request.set_interleaved_raw(*interleaved_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadCtrTicksResponse{};

  raise_if_error(
      stub->ReadCtrTicks(&context, request, &response));

  return response;
}

ReadCtrTicksScalarResponse
read_ctr_ticks_scalar(const StubPtr& stub, const nidevice_grpc::Session& task, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ReadCtrTicksScalarRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_timeout(timeout);

  auto response = ReadCtrTicksScalarResponse{};

  raise_if_error(
      stub->ReadCtrTicksScalar(&context, request, &response));

  return response;
}

ReadCtrTimeResponse
read_ctr_time(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& interleaved, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadCtrTimeRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto interleaved_ptr = interleaved.get_if<GroupBy>();
  const auto interleaved_raw_ptr = interleaved.get_if<pb::int32>();
  if (interleaved_ptr) {
    request.set_interleaved(*interleaved_ptr);
  }
  else if (interleaved_raw_ptr) {
    request.set_interleaved_raw(*interleaved_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadCtrTimeResponse{};

  raise_if_error(
      stub->ReadCtrTime(&context, request, &response));

  return response;
}

ReadCtrTimeScalarResponse
read_ctr_time_scalar(const StubPtr& stub, const nidevice_grpc::Session& task, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ReadCtrTimeScalarRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_timeout(timeout);

  auto response = ReadCtrTimeScalarResponse{};

  raise_if_error(
      stub->ReadCtrTimeScalar(&context, request, &response));

  return response;
}

ReadDigitalLinesResponse
read_digital_lines(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_bytes)
{
  ::grpc::ClientContext context;

  auto request = ReadDigitalLinesRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_bytes(array_size_in_bytes);

  auto response = ReadDigitalLinesResponse{};

  raise_if_error(
      stub->ReadDigitalLines(&context, request, &response));

  return response;
}

ReadDigitalScalarU32Response
read_digital_scalar_u32(const StubPtr& stub, const nidevice_grpc::Session& task, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ReadDigitalScalarU32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_timeout(timeout);

  auto response = ReadDigitalScalarU32Response{};

  raise_if_error(
      stub->ReadDigitalScalarU32(&context, request, &response));

  return response;
}

ReadDigitalU16Response
read_digital_u16(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadDigitalU16Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadDigitalU16Response{};

  raise_if_error(
      stub->ReadDigitalU16(&context, request, &response));

  return response;
}

ReadDigitalU32Response
read_digital_u32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadDigitalU32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadDigitalU32Response{};

  raise_if_error(
      stub->ReadDigitalU32(&context, request, &response));

  return response;
}

ReadDigitalU8Response
read_digital_u8(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const simple_variant<GroupBy, pb::int32>& fill_mode, const pb::uint32& array_size_in_samps)
{
  ::grpc::ClientContext context;

  auto request = ReadDigitalU8Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  const auto fill_mode_ptr = fill_mode.get_if<GroupBy>();
  const auto fill_mode_raw_ptr = fill_mode.get_if<pb::int32>();
  if (fill_mode_ptr) {
    request.set_fill_mode(*fill_mode_ptr);
  }
  else if (fill_mode_raw_ptr) {
    request.set_fill_mode_raw(*fill_mode_raw_ptr);
  }
  request.set_array_size_in_samps(array_size_in_samps);

  auto response = ReadDigitalU8Response{};

  raise_if_error(
      stub->ReadDigitalU8(&context, request, &response));

  return response;
}

ReadRawResponse
read_raw(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const double& timeout, const pb::uint32& array_size_in_bytes)
{
  ::grpc::ClientContext context;

  auto request = ReadRawRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_timeout(timeout);
  request.set_array_size_in_bytes(array_size_in_bytes);

  auto response = ReadRawResponse{};

  raise_if_error(
      stub->ReadRaw(&context, request, &response));

  return response;
}

std::unique_ptr<grpc::ClientReader<RegisterDoneEventResponse>>
register_done_event(const StubPtr& stub, ::grpc::ClientContext& context, const nidevice_grpc::Session& task)
{
  auto request = RegisterDoneEventRequest{};
  request.mutable_task()->CopyFrom(task);

  return stub->RegisterDoneEvent(&context, request);
}

std::unique_ptr<grpc::ClientReader<RegisterEveryNSamplesEventResponse>>
register_every_n_samples_event(const StubPtr& stub, ::grpc::ClientContext& context, const nidevice_grpc::Session& task, const simple_variant<EveryNSamplesEventType, pb::int32>& every_n_samples_event_type, const pb::uint32& n_samples)
{
  auto request = RegisterEveryNSamplesEventRequest{};
  request.mutable_task()->CopyFrom(task);
  const auto every_n_samples_event_type_ptr = every_n_samples_event_type.get_if<EveryNSamplesEventType>();
  const auto every_n_samples_event_type_raw_ptr = every_n_samples_event_type.get_if<pb::int32>();
  if (every_n_samples_event_type_ptr) {
    request.set_every_n_samples_event_type(*every_n_samples_event_type_ptr);
  }
  else if (every_n_samples_event_type_raw_ptr) {
    request.set_every_n_samples_event_type_raw(*every_n_samples_event_type_raw_ptr);
  }
  request.set_n_samples(n_samples);

  return stub->RegisterEveryNSamplesEvent(&context, request);
}

std::unique_ptr<grpc::ClientReader<RegisterSignalEventResponse>>
register_signal_event(const StubPtr& stub, ::grpc::ClientContext& context, const nidevice_grpc::Session& task, const simple_variant<Signal2, pb::int32>& signal_id)
{
  auto request = RegisterSignalEventRequest{};
  request.mutable_task()->CopyFrom(task);
  const auto signal_id_ptr = signal_id.get_if<Signal2>();
  const auto signal_id_raw_ptr = signal_id.get_if<pb::int32>();
  if (signal_id_ptr) {
    request.set_signal_id(*signal_id_ptr);
  }
  else if (signal_id_raw_ptr) {
    request.set_signal_id_raw(*signal_id_raw_ptr);
  }

  return stub->RegisterSignalEvent(&context, request);
}

RemoveCDAQSyncConnectionResponse
remove_cdaq_sync_connection(const StubPtr& stub, const pb::string& port_list)
{
  ::grpc::ClientContext context;

  auto request = RemoveCDAQSyncConnectionRequest{};
  request.set_port_list(port_list);

  auto response = RemoveCDAQSyncConnectionResponse{};

  raise_if_error(
      stub->RemoveCDAQSyncConnection(&context, request, &response));

  return response;
}

ReserveNetworkDeviceResponse
reserve_network_device(const StubPtr& stub, const pb::string& device_name, const bool& override_reservation)
{
  ::grpc::ClientContext context;

  auto request = ReserveNetworkDeviceRequest{};
  request.set_device_name(device_name);
  request.set_override_reservation(override_reservation);

  auto response = ReserveNetworkDeviceResponse{};

  raise_if_error(
      stub->ReserveNetworkDevice(&context, request, &response));

  return response;
}

ResetBufferAttributeResponse
reset_buffer_attribute(const StubPtr& stub, const nidevice_grpc::Session& task, const BufferResetAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = ResetBufferAttributeRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = ResetBufferAttributeResponse{};

  raise_if_error(
      stub->ResetBufferAttribute(&context, request, &response));

  return response;
}

ResetChanAttributeResponse
reset_chan_attribute(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelResetAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = ResetChanAttributeRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);

  auto response = ResetChanAttributeResponse{};

  raise_if_error(
      stub->ResetChanAttribute(&context, request, &response));

  return response;
}

ResetDeviceResponse
reset_device(const StubPtr& stub, const pb::string& device_name)
{
  ::grpc::ClientContext context;

  auto request = ResetDeviceRequest{};
  request.set_device_name(device_name);

  auto response = ResetDeviceResponse{};

  raise_if_error(
      stub->ResetDevice(&context, request, &response));

  return response;
}

ResetReadAttributeResponse
reset_read_attribute(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadResetAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = ResetReadAttributeRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = ResetReadAttributeResponse{};

  raise_if_error(
      stub->ResetReadAttribute(&context, request, &response));

  return response;
}

ResetTimingAttributeResponse
reset_timing_attribute(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingResetAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = ResetTimingAttributeRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = ResetTimingAttributeResponse{};

  raise_if_error(
      stub->ResetTimingAttribute(&context, request, &response));

  return response;
}

ResetTimingAttributeExResponse
reset_timing_attribute_ex(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingResetAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = ResetTimingAttributeExRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);

  auto response = ResetTimingAttributeExResponse{};

  raise_if_error(
      stub->ResetTimingAttributeEx(&context, request, &response));

  return response;
}

ResetTrigAttributeResponse
reset_trig_attribute(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerResetAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = ResetTrigAttributeRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = ResetTrigAttributeResponse{};

  raise_if_error(
      stub->ResetTrigAttribute(&context, request, &response));

  return response;
}

ResetWriteAttributeResponse
reset_write_attribute(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteResetAttributes& attribute)
{
  ::grpc::ClientContext context;

  auto request = ResetWriteAttributeRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);

  auto response = ResetWriteAttributeResponse{};

  raise_if_error(
      stub->ResetWriteAttribute(&context, request, &response));

  return response;
}

SaveGlobalChanResponse
save_global_chan(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel_name, const pb::string& save_as, const pb::string& author, const simple_variant<SaveOptions, pb::uint32>& options)
{
  ::grpc::ClientContext context;

  auto request = SaveGlobalChanRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel_name(channel_name);
  request.set_save_as(save_as);
  request.set_author(author);
  const auto options_ptr = options.get_if<SaveOptions>();
  const auto options_raw_ptr = options.get_if<pb::uint32>();
  if (options_ptr) {
    request.set_options(*options_ptr);
  }
  else if (options_raw_ptr) {
    request.set_options_raw(*options_raw_ptr);
  }

  auto response = SaveGlobalChanResponse{};

  raise_if_error(
      stub->SaveGlobalChan(&context, request, &response));

  return response;
}

SaveScaleResponse
save_scale(const StubPtr& stub, const pb::string& scale_name, const pb::string& save_as, const pb::string& author, const simple_variant<SaveOptions, pb::uint32>& options)
{
  ::grpc::ClientContext context;

  auto request = SaveScaleRequest{};
  request.set_scale_name(scale_name);
  request.set_save_as(save_as);
  request.set_author(author);
  const auto options_ptr = options.get_if<SaveOptions>();
  const auto options_raw_ptr = options.get_if<pb::uint32>();
  if (options_ptr) {
    request.set_options(*options_ptr);
  }
  else if (options_raw_ptr) {
    request.set_options_raw(*options_raw_ptr);
  }

  auto response = SaveScaleResponse{};

  raise_if_error(
      stub->SaveScale(&context, request, &response));

  return response;
}

SaveTaskResponse
save_task(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& save_as, const pb::string& author, const simple_variant<SaveOptions, pb::uint32>& options)
{
  ::grpc::ClientContext context;

  auto request = SaveTaskRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_save_as(save_as);
  request.set_author(author);
  const auto options_ptr = options.get_if<SaveOptions>();
  const auto options_raw_ptr = options.get_if<pb::uint32>();
  if (options_ptr) {
    request.set_options(*options_ptr);
  }
  else if (options_raw_ptr) {
    request.set_options_raw(*options_raw_ptr);
  }

  auto response = SaveTaskResponse{};

  raise_if_error(
      stub->SaveTask(&context, request, &response));

  return response;
}

SelfCalResponse
self_cal(const StubPtr& stub, const pb::string& device_name)
{
  ::grpc::ClientContext context;

  auto request = SelfCalRequest{};
  request.set_device_name(device_name);

  auto response = SelfCalResponse{};

  raise_if_error(
      stub->SelfCal(&context, request, &response));

  return response;
}

SelfTestDeviceResponse
self_test_device(const StubPtr& stub, const pb::string& device_name)
{
  ::grpc::ClientContext context;

  auto request = SelfTestDeviceRequest{};
  request.set_device_name(device_name);

  auto response = SelfTestDeviceResponse{};

  raise_if_error(
      stub->SelfTestDevice(&context, request, &response));

  return response;
}

SetAIChanCalCalDateResponse
set_ai_chan_cal_cal_date(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel_name, const pb::uint32& year, const pb::uint32& month, const pb::uint32& day, const pb::uint32& hour, const pb::uint32& minute)
{
  ::grpc::ClientContext context;

  auto request = SetAIChanCalCalDateRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel_name(channel_name);
  request.set_year(year);
  request.set_month(month);
  request.set_day(day);
  request.set_hour(hour);
  request.set_minute(minute);

  auto response = SetAIChanCalCalDateResponse{};

  raise_if_error(
      stub->SetAIChanCalCalDate(&context, request, &response));

  return response;
}

SetAIChanCalExpDateResponse
set_ai_chan_cal_exp_date(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel_name, const pb::uint32& year, const pb::uint32& month, const pb::uint32& day, const pb::uint32& hour, const pb::uint32& minute)
{
  ::grpc::ClientContext context;

  auto request = SetAIChanCalExpDateRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel_name(channel_name);
  request.set_year(year);
  request.set_month(month);
  request.set_day(day);
  request.set_hour(hour);
  request.set_minute(minute);

  auto response = SetAIChanCalExpDateResponse{};

  raise_if_error(
      stub->SetAIChanCalExpDate(&context, request, &response));

  return response;
}

SetAnalogPowerUpStatesResponse
set_analog_power_up_states(const StubPtr& stub, const pb::string& device_name, const std::vector<AnalogPowerUpChannelsAndState>& power_up_states)
{
  ::grpc::ClientContext context;

  auto request = SetAnalogPowerUpStatesRequest{};
  request.set_device_name(device_name);
  copy_array(power_up_states, request.mutable_power_up_states());

  auto response = SetAnalogPowerUpStatesResponse{};

  raise_if_error(
      stub->SetAnalogPowerUpStates(&context, request, &response));

  return response;
}

SetArmStartTrigTrigWhenResponse
set_arm_start_trig_trig_when(const StubPtr& stub, const nidevice_grpc::Session& task, const google::protobuf::Timestamp& data)
{
  ::grpc::ClientContext context;

  auto request = SetArmStartTrigTrigWhenRequest{};
  request.mutable_task()->CopyFrom(task);
  request.mutable_data()->CopyFrom(data);

  auto response = SetArmStartTrigTrigWhenResponse{};

  raise_if_error(
      stub->SetArmStartTrigTrigWhen(&context, request, &response));

  return response;
}

SetBufferAttributeUInt32Response
set_buffer_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const BufferUInt32Attributes& attribute, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = SetBufferAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetBufferAttributeUInt32Response{};

  raise_if_error(
      stub->SetBufferAttributeUInt32(&context, request, &response));

  return response;
}

SetChanAttributeBoolResponse
set_chan_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelBoolAttributes& attribute, const bool& value)
{
  ::grpc::ClientContext context;

  auto request = SetChanAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetChanAttributeBoolResponse{};

  raise_if_error(
      stub->SetChanAttributeBool(&context, request, &response));

  return response;
}

SetChanAttributeDoubleResponse
set_chan_attribute_double(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelDoubleAttributes& attribute, const double& value)
{
  ::grpc::ClientContext context;

  auto request = SetChanAttributeDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetChanAttributeDoubleResponse{};

  raise_if_error(
      stub->SetChanAttributeDouble(&context, request, &response));

  return response;
}

SetChanAttributeDoubleArrayResponse
set_chan_attribute_double_array(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelDoubleArrayAttributes& attribute, const std::vector<double>& value, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = SetChanAttributeDoubleArrayRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);
  copy_array(value, request.mutable_value());
  request.set_size(size);

  auto response = SetChanAttributeDoubleArrayResponse{};

  raise_if_error(
      stub->SetChanAttributeDoubleArray(&context, request, &response));

  return response;
}

SetChanAttributeInt32Response
set_chan_attribute_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelInt32Attributes& attribute, const simple_variant<ChannelInt32AttributeValues, pb::int32>& value)
{
  ::grpc::ClientContext context;

  auto request = SetChanAttributeInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);
  const auto value_ptr = value.get_if<ChannelInt32AttributeValues>();
  const auto value_raw_ptr = value.get_if<pb::int32>();
  if (value_ptr) {
    request.set_value(*value_ptr);
  }
  else if (value_raw_ptr) {
    request.set_value_raw(*value_raw_ptr);
  }

  auto response = SetChanAttributeInt32Response{};

  raise_if_error(
      stub->SetChanAttributeInt32(&context, request, &response));

  return response;
}

SetChanAttributeStringResponse
set_chan_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelStringAttributes& attribute, const pb::string& value)
{
  ::grpc::ClientContext context;

  auto request = SetChanAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetChanAttributeStringResponse{};

  raise_if_error(
      stub->SetChanAttributeString(&context, request, &response));

  return response;
}

SetChanAttributeUInt32Response
set_chan_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& channel, const ChannelUInt32Attributes& attribute, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = SetChanAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_channel(channel);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetChanAttributeUInt32Response{};

  raise_if_error(
      stub->SetChanAttributeUInt32(&context, request, &response));

  return response;
}

SetDigitalLogicFamilyPowerUpStateResponse
set_digital_logic_family_power_up_state(const StubPtr& stub, const pb::string& device_name, const simple_variant<LogicFamily, pb::int32>& logic_family)
{
  ::grpc::ClientContext context;

  auto request = SetDigitalLogicFamilyPowerUpStateRequest{};
  request.set_device_name(device_name);
  const auto logic_family_ptr = logic_family.get_if<LogicFamily>();
  const auto logic_family_raw_ptr = logic_family.get_if<pb::int32>();
  if (logic_family_ptr) {
    request.set_logic_family(*logic_family_ptr);
  }
  else if (logic_family_raw_ptr) {
    request.set_logic_family_raw(*logic_family_raw_ptr);
  }

  auto response = SetDigitalLogicFamilyPowerUpStateResponse{};

  raise_if_error(
      stub->SetDigitalLogicFamilyPowerUpState(&context, request, &response));

  return response;
}

SetDigitalPowerUpStatesResponse
set_digital_power_up_states(const StubPtr& stub, const pb::string& device_name, const std::vector<DigitalPowerUpChannelsAndState>& power_up_states)
{
  ::grpc::ClientContext context;

  auto request = SetDigitalPowerUpStatesRequest{};
  request.set_device_name(device_name);
  copy_array(power_up_states, request.mutable_power_up_states());

  auto response = SetDigitalPowerUpStatesResponse{};

  raise_if_error(
      stub->SetDigitalPowerUpStates(&context, request, &response));

  return response;
}

SetDigitalPullUpPullDownStatesResponse
set_digital_pull_up_pull_down_states(const StubPtr& stub, const pb::string& device_name, const std::vector<DigitalPullUpPullDownChannelsAndState>& pull_up_pull_down_states)
{
  ::grpc::ClientContext context;

  auto request = SetDigitalPullUpPullDownStatesRequest{};
  request.set_device_name(device_name);
  copy_array(pull_up_pull_down_states, request.mutable_pull_up_pull_down_states());

  auto response = SetDigitalPullUpPullDownStatesResponse{};

  raise_if_error(
      stub->SetDigitalPullUpPullDownStates(&context, request, &response));

  return response;
}

SetFirstSampClkWhenResponse
set_first_samp_clk_when(const StubPtr& stub, const nidevice_grpc::Session& task, const google::protobuf::Timestamp& data)
{
  ::grpc::ClientContext context;

  auto request = SetFirstSampClkWhenRequest{};
  request.mutable_task()->CopyFrom(task);
  request.mutable_data()->CopyFrom(data);

  auto response = SetFirstSampClkWhenResponse{};

  raise_if_error(
      stub->SetFirstSampClkWhen(&context, request, &response));

  return response;
}

SetReadAttributeBoolResponse
set_read_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadBoolAttributes& attribute, const bool& value)
{
  ::grpc::ClientContext context;

  auto request = SetReadAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetReadAttributeBoolResponse{};

  raise_if_error(
      stub->SetReadAttributeBool(&context, request, &response));

  return response;
}

SetReadAttributeDoubleResponse
set_read_attribute_double(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadDoubleAttributes& attribute, const double& value)
{
  ::grpc::ClientContext context;

  auto request = SetReadAttributeDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetReadAttributeDoubleResponse{};

  raise_if_error(
      stub->SetReadAttributeDouble(&context, request, &response));

  return response;
}

SetReadAttributeInt32Response
set_read_attribute_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadInt32Attributes& attribute, const simple_variant<ReadInt32AttributeValues, pb::int32>& value)
{
  ::grpc::ClientContext context;

  auto request = SetReadAttributeInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  const auto value_ptr = value.get_if<ReadInt32AttributeValues>();
  const auto value_raw_ptr = value.get_if<pb::int32>();
  if (value_ptr) {
    request.set_value(*value_ptr);
  }
  else if (value_raw_ptr) {
    request.set_value_raw(*value_raw_ptr);
  }

  auto response = SetReadAttributeInt32Response{};

  raise_if_error(
      stub->SetReadAttributeInt32(&context, request, &response));

  return response;
}

SetReadAttributeStringResponse
set_read_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadStringAttributes& attribute, const pb::string& value)
{
  ::grpc::ClientContext context;

  auto request = SetReadAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetReadAttributeStringResponse{};

  raise_if_error(
      stub->SetReadAttributeString(&context, request, &response));

  return response;
}

SetReadAttributeUInt32Response
set_read_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadUInt32Attributes& attribute, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = SetReadAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetReadAttributeUInt32Response{};

  raise_if_error(
      stub->SetReadAttributeUInt32(&context, request, &response));

  return response;
}

SetReadAttributeUInt64Response
set_read_attribute_uint64(const StubPtr& stub, const nidevice_grpc::Session& task, const ReadUInt64Attributes& attribute, const pb::uint64& value)
{
  ::grpc::ClientContext context;

  auto request = SetReadAttributeUInt64Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetReadAttributeUInt64Response{};

  raise_if_error(
      stub->SetReadAttributeUInt64(&context, request, &response));

  return response;
}

SetScaleAttributeDoubleResponse
set_scale_attribute_double(const StubPtr& stub, const pb::string& scale_name, const ScaleDoubleAttributes& attribute, const double& value)
{
  ::grpc::ClientContext context;

  auto request = SetScaleAttributeDoubleRequest{};
  request.set_scale_name(scale_name);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetScaleAttributeDoubleResponse{};

  raise_if_error(
      stub->SetScaleAttributeDouble(&context, request, &response));

  return response;
}

SetScaleAttributeDoubleArrayResponse
set_scale_attribute_double_array(const StubPtr& stub, const pb::string& scale_name, const ScaleDoubleArrayAttributes& attribute, const std::vector<double>& value, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = SetScaleAttributeDoubleArrayRequest{};
  request.set_scale_name(scale_name);
  request.set_attribute(attribute);
  copy_array(value, request.mutable_value());
  request.set_size(size);

  auto response = SetScaleAttributeDoubleArrayResponse{};

  raise_if_error(
      stub->SetScaleAttributeDoubleArray(&context, request, &response));

  return response;
}

SetScaleAttributeInt32Response
set_scale_attribute_int32(const StubPtr& stub, const pb::string& scale_name, const ScaleInt32Attributes& attribute, const simple_variant<ScaleInt32AttributeValues, pb::int32>& value)
{
  ::grpc::ClientContext context;

  auto request = SetScaleAttributeInt32Request{};
  request.set_scale_name(scale_name);
  request.set_attribute(attribute);
  const auto value_ptr = value.get_if<ScaleInt32AttributeValues>();
  const auto value_raw_ptr = value.get_if<pb::int32>();
  if (value_ptr) {
    request.set_value(*value_ptr);
  }
  else if (value_raw_ptr) {
    request.set_value_raw(*value_raw_ptr);
  }

  auto response = SetScaleAttributeInt32Response{};

  raise_if_error(
      stub->SetScaleAttributeInt32(&context, request, &response));

  return response;
}

SetScaleAttributeStringResponse
set_scale_attribute_string(const StubPtr& stub, const pb::string& scale_name, const ScaleStringAttributes& attribute, const pb::string& value)
{
  ::grpc::ClientContext context;

  auto request = SetScaleAttributeStringRequest{};
  request.set_scale_name(scale_name);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetScaleAttributeStringResponse{};

  raise_if_error(
      stub->SetScaleAttributeString(&context, request, &response));

  return response;
}

SetStartTrigTrigWhenResponse
set_start_trig_trig_when(const StubPtr& stub, const nidevice_grpc::Session& task, const google::protobuf::Timestamp& data)
{
  ::grpc::ClientContext context;

  auto request = SetStartTrigTrigWhenRequest{};
  request.mutable_task()->CopyFrom(task);
  request.mutable_data()->CopyFrom(data);

  auto response = SetStartTrigTrigWhenResponse{};

  raise_if_error(
      stub->SetStartTrigTrigWhen(&context, request, &response));

  return response;
}

SetSyncPulseTimeWhenResponse
set_sync_pulse_time_when(const StubPtr& stub, const nidevice_grpc::Session& task, const google::protobuf::Timestamp& data)
{
  ::grpc::ClientContext context;

  auto request = SetSyncPulseTimeWhenRequest{};
  request.mutable_task()->CopyFrom(task);
  request.mutable_data()->CopyFrom(data);

  auto response = SetSyncPulseTimeWhenResponse{};

  raise_if_error(
      stub->SetSyncPulseTimeWhen(&context, request, &response));

  return response;
}

SetTimingAttributeBoolResponse
set_timing_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingBoolAttributes& attribute, const bool& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTimingAttributeBoolResponse{};

  raise_if_error(
      stub->SetTimingAttributeBool(&context, request, &response));

  return response;
}

SetTimingAttributeDoubleResponse
set_timing_attribute_double(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingDoubleAttributes& attribute, const double& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTimingAttributeDoubleResponse{};

  raise_if_error(
      stub->SetTimingAttributeDouble(&context, request, &response));

  return response;
}

SetTimingAttributeExBoolResponse
set_timing_attribute_ex_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingBoolAttributes& attribute, const bool& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeExBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTimingAttributeExBoolResponse{};

  raise_if_error(
      stub->SetTimingAttributeExBool(&context, request, &response));

  return response;
}

SetTimingAttributeExDoubleResponse
set_timing_attribute_ex_double(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingDoubleAttributes& attribute, const double& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeExDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTimingAttributeExDoubleResponse{};

  raise_if_error(
      stub->SetTimingAttributeExDouble(&context, request, &response));

  return response;
}

SetTimingAttributeExInt32Response
set_timing_attribute_ex_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingInt32Attributes& attribute, const simple_variant<TimingInt32AttributeValues, pb::int32>& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeExInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);
  const auto value_ptr = value.get_if<TimingInt32AttributeValues>();
  const auto value_raw_ptr = value.get_if<pb::int32>();
  if (value_ptr) {
    request.set_value(*value_ptr);
  }
  else if (value_raw_ptr) {
    request.set_value_raw(*value_raw_ptr);
  }

  auto response = SetTimingAttributeExInt32Response{};

  raise_if_error(
      stub->SetTimingAttributeExInt32(&context, request, &response));

  return response;
}

SetTimingAttributeExStringResponse
set_timing_attribute_ex_string(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingStringAttributes& attribute, const pb::string& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeExStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTimingAttributeExStringResponse{};

  raise_if_error(
      stub->SetTimingAttributeExString(&context, request, &response));

  return response;
}

SetTimingAttributeExTimestampResponse
set_timing_attribute_ex_timestamp(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingTimestampAttributes& attribute, const google::protobuf::Timestamp& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeExTimestampRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);
  request.mutable_value()->CopyFrom(value);

  auto response = SetTimingAttributeExTimestampResponse{};

  raise_if_error(
      stub->SetTimingAttributeExTimestamp(&context, request, &response));

  return response;
}

SetTimingAttributeExUInt32Response
set_timing_attribute_ex_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& device_names, const TimingUInt32Attributes& attribute, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeExUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_device_names(device_names);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTimingAttributeExUInt32Response{};

  raise_if_error(
      stub->SetTimingAttributeExUInt32(&context, request, &response));

  return response;
}

SetTimingAttributeInt32Response
set_timing_attribute_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingInt32Attributes& attribute, const simple_variant<TimingInt32AttributeValues, pb::int32>& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  const auto value_ptr = value.get_if<TimingInt32AttributeValues>();
  const auto value_raw_ptr = value.get_if<pb::int32>();
  if (value_ptr) {
    request.set_value(*value_ptr);
  }
  else if (value_raw_ptr) {
    request.set_value_raw(*value_raw_ptr);
  }

  auto response = SetTimingAttributeInt32Response{};

  raise_if_error(
      stub->SetTimingAttributeInt32(&context, request, &response));

  return response;
}

SetTimingAttributeStringResponse
set_timing_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingStringAttributes& attribute, const pb::string& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTimingAttributeStringResponse{};

  raise_if_error(
      stub->SetTimingAttributeString(&context, request, &response));

  return response;
}

SetTimingAttributeTimestampResponse
set_timing_attribute_timestamp(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingTimestampAttributes& attribute, const google::protobuf::Timestamp& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeTimestampRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.mutable_value()->CopyFrom(value);

  auto response = SetTimingAttributeTimestampResponse{};

  raise_if_error(
      stub->SetTimingAttributeTimestamp(&context, request, &response));

  return response;
}

SetTimingAttributeUInt32Response
set_timing_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const TimingUInt32Attributes& attribute, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = SetTimingAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTimingAttributeUInt32Response{};

  raise_if_error(
      stub->SetTimingAttributeUInt32(&context, request, &response));

  return response;
}

SetTrigAttributeBoolResponse
set_trig_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerBoolAttributes& attribute, const bool& value)
{
  ::grpc::ClientContext context;

  auto request = SetTrigAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTrigAttributeBoolResponse{};

  raise_if_error(
      stub->SetTrigAttributeBool(&context, request, &response));

  return response;
}

SetTrigAttributeDoubleResponse
set_trig_attribute_double(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerDoubleAttributes& attribute, const double& value)
{
  ::grpc::ClientContext context;

  auto request = SetTrigAttributeDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTrigAttributeDoubleResponse{};

  raise_if_error(
      stub->SetTrigAttributeDouble(&context, request, &response));

  return response;
}

SetTrigAttributeDoubleArrayResponse
set_trig_attribute_double_array(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerDoubleArrayAttributes& attribute, const std::vector<double>& value, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = SetTrigAttributeDoubleArrayRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  copy_array(value, request.mutable_value());
  request.set_size(size);

  auto response = SetTrigAttributeDoubleArrayResponse{};

  raise_if_error(
      stub->SetTrigAttributeDoubleArray(&context, request, &response));

  return response;
}

SetTrigAttributeInt32Response
set_trig_attribute_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerInt32Attributes& attribute, const simple_variant<TriggerInt32AttributeValues, pb::int32>& value)
{
  ::grpc::ClientContext context;

  auto request = SetTrigAttributeInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  const auto value_ptr = value.get_if<TriggerInt32AttributeValues>();
  const auto value_raw_ptr = value.get_if<pb::int32>();
  if (value_ptr) {
    request.set_value(*value_ptr);
  }
  else if (value_raw_ptr) {
    request.set_value_raw(*value_raw_ptr);
  }

  auto response = SetTrigAttributeInt32Response{};

  raise_if_error(
      stub->SetTrigAttributeInt32(&context, request, &response));

  return response;
}

SetTrigAttributeInt32ArrayResponse
set_trig_attribute_int32_array(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerInt32ArrayAttributes& attribute, const std::vector<pb::int32>& value, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = SetTrigAttributeInt32ArrayRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  copy_array(value, request.mutable_value());
  request.set_size(size);

  auto response = SetTrigAttributeInt32ArrayResponse{};

  raise_if_error(
      stub->SetTrigAttributeInt32Array(&context, request, &response));

  return response;
}

SetTrigAttributeStringResponse
set_trig_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerStringAttributes& attribute, const pb::string& value)
{
  ::grpc::ClientContext context;

  auto request = SetTrigAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTrigAttributeStringResponse{};

  raise_if_error(
      stub->SetTrigAttributeString(&context, request, &response));

  return response;
}

SetTrigAttributeTimestampResponse
set_trig_attribute_timestamp(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerTimestampAttributes& attribute, const google::protobuf::Timestamp& value)
{
  ::grpc::ClientContext context;

  auto request = SetTrigAttributeTimestampRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.mutable_value()->CopyFrom(value);

  auto response = SetTrigAttributeTimestampResponse{};

  raise_if_error(
      stub->SetTrigAttributeTimestamp(&context, request, &response));

  return response;
}

SetTrigAttributeUInt32Response
set_trig_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const TriggerUInt32Attributes& attribute, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = SetTrigAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetTrigAttributeUInt32Response{};

  raise_if_error(
      stub->SetTrigAttributeUInt32(&context, request, &response));

  return response;
}

SetWriteAttributeBoolResponse
set_write_attribute_bool(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteBoolAttributes& attribute, const bool& value)
{
  ::grpc::ClientContext context;

  auto request = SetWriteAttributeBoolRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetWriteAttributeBoolResponse{};

  raise_if_error(
      stub->SetWriteAttributeBool(&context, request, &response));

  return response;
}

SetWriteAttributeDoubleResponse
set_write_attribute_double(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteDoubleAttributes& attribute, const double& value)
{
  ::grpc::ClientContext context;

  auto request = SetWriteAttributeDoubleRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetWriteAttributeDoubleResponse{};

  raise_if_error(
      stub->SetWriteAttributeDouble(&context, request, &response));

  return response;
}

SetWriteAttributeInt32Response
set_write_attribute_int32(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteInt32Attributes& attribute, const simple_variant<WriteInt32AttributeValues, pb::int32>& value)
{
  ::grpc::ClientContext context;

  auto request = SetWriteAttributeInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  const auto value_ptr = value.get_if<WriteInt32AttributeValues>();
  const auto value_raw_ptr = value.get_if<pb::int32>();
  if (value_ptr) {
    request.set_value(*value_ptr);
  }
  else if (value_raw_ptr) {
    request.set_value_raw(*value_raw_ptr);
  }

  auto response = SetWriteAttributeInt32Response{};

  raise_if_error(
      stub->SetWriteAttributeInt32(&context, request, &response));

  return response;
}

SetWriteAttributeStringResponse
set_write_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteStringAttributes& attribute, const pb::string& value)
{
  ::grpc::ClientContext context;

  auto request = SetWriteAttributeStringRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetWriteAttributeStringResponse{};

  raise_if_error(
      stub->SetWriteAttributeString(&context, request, &response));

  return response;
}

SetWriteAttributeUInt32Response
set_write_attribute_uint32(const StubPtr& stub, const nidevice_grpc::Session& task, const WriteUInt32Attributes& attribute, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = SetWriteAttributeUInt32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_attribute(attribute);
  request.set_value(value);

  auto response = SetWriteAttributeUInt32Response{};

  raise_if_error(
      stub->SetWriteAttributeUInt32(&context, request, &response));

  return response;
}

StartNewFileResponse
start_new_file(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::string& file_path)
{
  ::grpc::ClientContext context;

  auto request = StartNewFileRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_file_path(file_path);

  auto response = StartNewFileResponse{};

  raise_if_error(
      stub->StartNewFile(&context, request, &response));

  return response;
}

StartTaskResponse
start_task(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = StartTaskRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = StartTaskResponse{};

  raise_if_error(
      stub->StartTask(&context, request, &response));

  return response;
}

StopTaskResponse
stop_task(const StubPtr& stub, const nidevice_grpc::Session& task)
{
  ::grpc::ClientContext context;

  auto request = StopTaskRequest{};
  request.mutable_task()->CopyFrom(task);

  auto response = StopTaskResponse{};

  raise_if_error(
      stub->StopTask(&context, request, &response));

  return response;
}

TaskControlResponse
task_control(const StubPtr& stub, const nidevice_grpc::Session& task, const simple_variant<TaskControlAction, pb::int32>& action)
{
  ::grpc::ClientContext context;

  auto request = TaskControlRequest{};
  request.mutable_task()->CopyFrom(task);
  const auto action_ptr = action.get_if<TaskControlAction>();
  const auto action_raw_ptr = action.get_if<pb::int32>();
  if (action_ptr) {
    request.set_action(*action_ptr);
  }
  else if (action_raw_ptr) {
    request.set_action_raw(*action_raw_ptr);
  }

  auto response = TaskControlResponse{};

  raise_if_error(
      stub->TaskControl(&context, request, &response));

  return response;
}

TristateOutputTermResponse
tristate_output_term(const StubPtr& stub, const pb::string& output_terminal)
{
  ::grpc::ClientContext context;

  auto request = TristateOutputTermRequest{};
  request.set_output_terminal(output_terminal);

  auto response = TristateOutputTermResponse{};

  raise_if_error(
      stub->TristateOutputTerm(&context, request, &response));

  return response;
}

UnreserveNetworkDeviceResponse
unreserve_network_device(const StubPtr& stub, const pb::string& device_name)
{
  ::grpc::ClientContext context;

  auto request = UnreserveNetworkDeviceRequest{};
  request.set_device_name(device_name);

  auto response = UnreserveNetworkDeviceResponse{};

  raise_if_error(
      stub->UnreserveNetworkDevice(&context, request, &response));

  return response;
}

WaitForNextSampleClockResponse
wait_for_next_sample_clock(const StubPtr& stub, const nidevice_grpc::Session& task, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = WaitForNextSampleClockRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_timeout(timeout);

  auto response = WaitForNextSampleClockResponse{};

  raise_if_error(
      stub->WaitForNextSampleClock(&context, request, &response));

  return response;
}

WaitForValidTimestampResponse
wait_for_valid_timestamp(const StubPtr& stub, const nidevice_grpc::Session& task, const simple_variant<TimestampEvent, pb::int32>& timestamp_event, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = WaitForValidTimestampRequest{};
  request.mutable_task()->CopyFrom(task);
  const auto timestamp_event_ptr = timestamp_event.get_if<TimestampEvent>();
  const auto timestamp_event_raw_ptr = timestamp_event.get_if<pb::int32>();
  if (timestamp_event_ptr) {
    request.set_timestamp_event(*timestamp_event_ptr);
  }
  else if (timestamp_event_raw_ptr) {
    request.set_timestamp_event_raw(*timestamp_event_raw_ptr);
  }
  request.set_timeout(timeout);

  auto response = WaitForValidTimestampResponse{};

  raise_if_error(
      stub->WaitForValidTimestamp(&context, request, &response));

  return response;
}

WaitUntilTaskDoneResponse
wait_until_task_done(const StubPtr& stub, const nidevice_grpc::Session& task, const double& time_to_wait)
{
  ::grpc::ClientContext context;

  auto request = WaitUntilTaskDoneRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_time_to_wait(time_to_wait);

  auto response = WaitUntilTaskDoneResponse{};

  raise_if_error(
      stub->WaitUntilTaskDone(&context, request, &response));

  return response;
}

WriteAnalogF64Response
write_analog_f64(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const std::vector<double>& write_array)
{
  ::grpc::ClientContext context;

  auto request = WriteAnalogF64Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  copy_array(write_array, request.mutable_write_array());

  auto response = WriteAnalogF64Response{};

  raise_if_error(
      stub->WriteAnalogF64(&context, request, &response));

  return response;
}

WriteAnalogScalarF64Response
write_analog_scalar_f64(const StubPtr& stub, const nidevice_grpc::Session& task, const bool& auto_start, const double& timeout, const double& value)
{
  ::grpc::ClientContext context;

  auto request = WriteAnalogScalarF64Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  request.set_value(value);

  auto response = WriteAnalogScalarF64Response{};

  raise_if_error(
      stub->WriteAnalogScalarF64(&context, request, &response));

  return response;
}

WriteBinaryI16Response
write_binary_i16(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const std::vector<pb::int32>& write_array)
{
  ::grpc::ClientContext context;

  auto request = WriteBinaryI16Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  copy_array(write_array, request.mutable_write_array());

  auto response = WriteBinaryI16Response{};

  raise_if_error(
      stub->WriteBinaryI16(&context, request, &response));

  return response;
}

WriteBinaryI32Response
write_binary_i32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const std::vector<pb::int32>& write_array)
{
  ::grpc::ClientContext context;

  auto request = WriteBinaryI32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  copy_array(write_array, request.mutable_write_array());

  auto response = WriteBinaryI32Response{};

  raise_if_error(
      stub->WriteBinaryI32(&context, request, &response));

  return response;
}

WriteBinaryU16Response
write_binary_u16(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const std::vector<pb::uint32>& write_array)
{
  ::grpc::ClientContext context;

  auto request = WriteBinaryU16Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  copy_array(write_array, request.mutable_write_array());

  auto response = WriteBinaryU16Response{};

  raise_if_error(
      stub->WriteBinaryU16(&context, request, &response));

  return response;
}

WriteBinaryU32Response
write_binary_u32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const std::vector<pb::uint32>& write_array)
{
  ::grpc::ClientContext context;

  auto request = WriteBinaryU32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  copy_array(write_array, request.mutable_write_array());

  auto response = WriteBinaryU32Response{};

  raise_if_error(
      stub->WriteBinaryU32(&context, request, &response));

  return response;
}

WriteCtrFreqResponse
write_ctr_freq(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const std::vector<double>& frequency, const std::vector<double>& duty_cycle)
{
  ::grpc::ClientContext context;

  auto request = WriteCtrFreqRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  copy_array(frequency, request.mutable_frequency());
  copy_array(duty_cycle, request.mutable_duty_cycle());

  auto response = WriteCtrFreqResponse{};

  raise_if_error(
      stub->WriteCtrFreq(&context, request, &response));

  return response;
}

WriteCtrFreqScalarResponse
write_ctr_freq_scalar(const StubPtr& stub, const nidevice_grpc::Session& task, const bool& auto_start, const double& timeout, const double& frequency, const double& duty_cycle)
{
  ::grpc::ClientContext context;

  auto request = WriteCtrFreqScalarRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  request.set_frequency(frequency);
  request.set_duty_cycle(duty_cycle);

  auto response = WriteCtrFreqScalarResponse{};

  raise_if_error(
      stub->WriteCtrFreqScalar(&context, request, &response));

  return response;
}

WriteCtrTicksResponse
write_ctr_ticks(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const std::vector<pb::uint32>& high_ticks, const std::vector<pb::uint32>& low_ticks)
{
  ::grpc::ClientContext context;

  auto request = WriteCtrTicksRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  copy_array(high_ticks, request.mutable_high_ticks());
  copy_array(low_ticks, request.mutable_low_ticks());

  auto response = WriteCtrTicksResponse{};

  raise_if_error(
      stub->WriteCtrTicks(&context, request, &response));

  return response;
}

WriteCtrTicksScalarResponse
write_ctr_ticks_scalar(const StubPtr& stub, const nidevice_grpc::Session& task, const bool& auto_start, const double& timeout, const pb::uint32& high_ticks, const pb::uint32& low_ticks)
{
  ::grpc::ClientContext context;

  auto request = WriteCtrTicksScalarRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  request.set_high_ticks(high_ticks);
  request.set_low_ticks(low_ticks);

  auto response = WriteCtrTicksScalarResponse{};

  raise_if_error(
      stub->WriteCtrTicksScalar(&context, request, &response));

  return response;
}

WriteCtrTimeResponse
write_ctr_time(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const std::vector<double>& high_time, const std::vector<double>& low_time)
{
  ::grpc::ClientContext context;

  auto request = WriteCtrTimeRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  copy_array(high_time, request.mutable_high_time());
  copy_array(low_time, request.mutable_low_time());

  auto response = WriteCtrTimeResponse{};

  raise_if_error(
      stub->WriteCtrTime(&context, request, &response));

  return response;
}

WriteCtrTimeScalarResponse
write_ctr_time_scalar(const StubPtr& stub, const nidevice_grpc::Session& task, const bool& auto_start, const double& timeout, const double& high_time, const double& low_time)
{
  ::grpc::ClientContext context;

  auto request = WriteCtrTimeScalarRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  request.set_high_time(high_time);
  request.set_low_time(low_time);

  auto response = WriteCtrTimeScalarResponse{};

  raise_if_error(
      stub->WriteCtrTimeScalar(&context, request, &response));

  return response;
}

WriteDigitalLinesResponse
write_digital_lines(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const pb::string& write_array)
{
  ::grpc::ClientContext context;

  auto request = WriteDigitalLinesRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  request.set_write_array(write_array);

  auto response = WriteDigitalLinesResponse{};

  raise_if_error(
      stub->WriteDigitalLines(&context, request, &response));

  return response;
}

WriteDigitalScalarU32Response
write_digital_scalar_u32(const StubPtr& stub, const nidevice_grpc::Session& task, const bool& auto_start, const double& timeout, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = WriteDigitalScalarU32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  request.set_value(value);

  auto response = WriteDigitalScalarU32Response{};

  raise_if_error(
      stub->WriteDigitalScalarU32(&context, request, &response));

  return response;
}

WriteDigitalU16Response
write_digital_u16(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const std::vector<pb::uint32>& write_array)
{
  ::grpc::ClientContext context;

  auto request = WriteDigitalU16Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  copy_array(write_array, request.mutable_write_array());

  auto response = WriteDigitalU16Response{};

  raise_if_error(
      stub->WriteDigitalU16(&context, request, &response));

  return response;
}

WriteDigitalU32Response
write_digital_u32(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const std::vector<pb::uint32>& write_array)
{
  ::grpc::ClientContext context;

  auto request = WriteDigitalU32Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  copy_array(write_array, request.mutable_write_array());

  auto response = WriteDigitalU32Response{};

  raise_if_error(
      stub->WriteDigitalU32(&context, request, &response));

  return response;
}

WriteDigitalU8Response
write_digital_u8(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps_per_chan, const bool& auto_start, const double& timeout, const simple_variant<GroupBy, pb::int32>& data_layout, const pb::string& write_array)
{
  ::grpc::ClientContext context;

  auto request = WriteDigitalU8Request{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps_per_chan(num_samps_per_chan);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  const auto data_layout_ptr = data_layout.get_if<GroupBy>();
  const auto data_layout_raw_ptr = data_layout.get_if<pb::int32>();
  if (data_layout_ptr) {
    request.set_data_layout(*data_layout_ptr);
  }
  else if (data_layout_raw_ptr) {
    request.set_data_layout_raw(*data_layout_raw_ptr);
  }
  request.set_write_array(write_array);

  auto response = WriteDigitalU8Response{};

  raise_if_error(
      stub->WriteDigitalU8(&context, request, &response));

  return response;
}

WriteRawResponse
write_raw(const StubPtr& stub, const nidevice_grpc::Session& task, const pb::int32& num_samps, const bool& auto_start, const double& timeout, const pb::string& write_array)
{
  ::grpc::ClientContext context;

  auto request = WriteRawRequest{};
  request.mutable_task()->CopyFrom(task);
  request.set_num_samps(num_samps);
  request.set_auto_start(auto_start);
  request.set_timeout(timeout);
  request.set_write_array(write_array);

  auto response = WriteRawResponse{};

  raise_if_error(
      stub->WriteRaw(&context, request, &response));

  return response;
}

WriteToTEDSFromArrayResponse
write_to_teds_from_array(const StubPtr& stub, const pb::string& physical_channel, const pb::string& bit_stream, const pb::uint32& array_size, const simple_variant<WriteBasicTEDSOptions, pb::int32>& basic_teds_options)
{
  ::grpc::ClientContext context;

  auto request = WriteToTEDSFromArrayRequest{};
  request.set_physical_channel(physical_channel);
  request.set_bit_stream(bit_stream);
  request.set_array_size(array_size);
  const auto basic_teds_options_ptr = basic_teds_options.get_if<WriteBasicTEDSOptions>();
  const auto basic_teds_options_raw_ptr = basic_teds_options.get_if<pb::int32>();
  if (basic_teds_options_ptr) {
    request.set_basic_teds_options(*basic_teds_options_ptr);
  }
  else if (basic_teds_options_raw_ptr) {
    request.set_basic_teds_options_raw(*basic_teds_options_raw_ptr);
  }

  auto response = WriteToTEDSFromArrayResponse{};

  raise_if_error(
      stub->WriteToTEDSFromArray(&context, request, &response));

  return response;
}

WriteToTEDSFromFileResponse
write_to_teds_from_file(const StubPtr& stub, const pb::string& physical_channel, const pb::string& file_path, const simple_variant<WriteBasicTEDSOptions, pb::int32>& basic_teds_options)
{
  ::grpc::ClientContext context;

  auto request = WriteToTEDSFromFileRequest{};
  request.set_physical_channel(physical_channel);
  request.set_file_path(file_path);
  const auto basic_teds_options_ptr = basic_teds_options.get_if<WriteBasicTEDSOptions>();
  const auto basic_teds_options_raw_ptr = basic_teds_options.get_if<pb::int32>();
  if (basic_teds_options_ptr) {
    request.set_basic_teds_options(*basic_teds_options_ptr);
  }
  else if (basic_teds_options_raw_ptr) {
    request.set_basic_teds_options_raw(*basic_teds_options_raw_ptr);
  }

  auto response = WriteToTEDSFromFileResponse{};

  raise_if_error(
      stub->WriteToTEDSFromFile(&context, request, &response));

  return response;
}


} // namespace nidaqmx_grpc::experimental::client
