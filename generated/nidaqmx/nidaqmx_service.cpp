
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-DAQMX Metadata
//---------------------------------------------------------------------
#include "nidaqmx_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/nidaqmx_conversions.h"
#include <server/callback_router.h>
#include <server/server_reactor.h>

namespace nidaqmx_grpc {

  NiDAQmxService::NiDAQmxService(NiDAQmxLibraryInterface* library, ResourceRepositorySharedPtr session_repository)
      : library_(library), session_repository_(session_repository)
  {
  }

  NiDAQmxService::~NiDAQmxService()
  {
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AddCDAQSyncConnection(::grpc::ServerContext* context, const AddCDAQSyncConnectionRequest* request, AddCDAQSyncConnectionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto port_list = request->port_list().c_str();
      auto status = library_->AddCDAQSyncConnection(port_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AddGlobalChansToTask(::grpc::ServerContext* context, const AddGlobalChansToTaskRequest* request, AddGlobalChansToTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto status = library_->AddGlobalChansToTask(task, channel_names);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AddNetworkDevice(::grpc::ServerContext* context, const AddNetworkDeviceRequest* request, AddNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto ip_address = request->ip_address().c_str();
      auto device_name = request->device_name().c_str();
      bool32 attempt_reservation = request->attempt_reservation();
      float64 timeout = request->timeout();
      uInt32 device_name_out_buffer_size = request->device_name_out_buffer_size();
      std::string device_name_out;
      if (device_name_out_buffer_size > 0) {
          device_name_out.resize(device_name_out_buffer_size-1);
      }
      auto status = library_->AddNetworkDevice(ip_address, device_name, attempt_reservation, timeout, (char*)device_name_out.data(), device_name_out_buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_device_name_out(device_name_out);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AreConfiguredCDAQSyncPortsDisconnected(::grpc::ServerContext* context, const AreConfiguredCDAQSyncPortsDisconnectedRequest* request, AreConfiguredCDAQSyncPortsDisconnectedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto chassis_devices_ports = request->chassis_devices_ports().c_str();
      float64 timeout = request->timeout();
      bool32 disconnected_ports_exist {};
      auto status = library_->AreConfiguredCDAQSyncPortsDisconnected(chassis_devices_ports, timeout, &disconnected_ports_exist);
      response->set_status(status);
      if (status == 0) {
        response->set_disconnected_ports_exist(disconnected_ports_exist);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AutoConfigureCDAQSyncConnections(::grpc::ServerContext* context, const AutoConfigureCDAQSyncConnectionsRequest* request, AutoConfigureCDAQSyncConnectionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto chassis_devices_ports = request->chassis_devices_ports().c_str();
      float64 timeout = request->timeout();
      auto status = library_->AutoConfigureCDAQSyncConnections(chassis_devices_ports, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CalculateReversePolyCoeff(::grpc::ServerContext* context, const CalculateReversePolyCoeffRequest* request, CalculateReversePolyCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs_in = request->num_forward_coeffs_in();
      float64 min_val_x = request->min_val_x();
      float64 max_val_x = request->max_val_x();
      int32 num_points_to_compute = request->num_points_to_compute();
      int32 reverse_poly_order = request->reverse_poly_order();
      response->mutable_reverse_coeffs()->Resize((reverse_poly_order < 0) ? num_forward_coeffs_in : reverse_poly_order + 1, 0);
      float64* reverse_coeffs = response->mutable_reverse_coeffs()->mutable_data();
      auto status = library_->CalculateReversePolyCoeff(forward_coeffs, num_forward_coeffs_in, min_val_x, max_val_x, num_points_to_compute, reverse_poly_order, reverse_coeffs);
      response->set_status(status);
      if (status == 0) {
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgEdgeRefTrig(::grpc::ServerContext* context, const CfgAnlgEdgeRefTrigRequest* request, CfgAnlgEdgeRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_slope;
      switch (request->trigger_slope_enum_case()) {
        case nidaqmx_grpc::CfgAnlgEdgeRefTrigRequest::TriggerSlopeEnumCase::kTriggerSlope: {
          trigger_slope = static_cast<int32>(request->trigger_slope());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeRefTrigRequest::TriggerSlopeEnumCase::kTriggerSlopeRaw: {
          trigger_slope = static_cast<int32>(request->trigger_slope_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeRefTrigRequest::TriggerSlopeEnumCase::TRIGGER_SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_slope was not specified or out of range");
          break;
        }
      }

      float64 trigger_level = request->trigger_level();
      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgAnlgEdgeRefTrig(task, trigger_source, trigger_slope, trigger_level, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgEdgeStartTrig(::grpc::ServerContext* context, const CfgAnlgEdgeStartTrigRequest* request, CfgAnlgEdgeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_slope;
      switch (request->trigger_slope_enum_case()) {
        case nidaqmx_grpc::CfgAnlgEdgeStartTrigRequest::TriggerSlopeEnumCase::kTriggerSlope: {
          trigger_slope = static_cast<int32>(request->trigger_slope());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeStartTrigRequest::TriggerSlopeEnumCase::kTriggerSlopeRaw: {
          trigger_slope = static_cast<int32>(request->trigger_slope_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeStartTrigRequest::TriggerSlopeEnumCase::TRIGGER_SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_slope was not specified or out of range");
          break;
        }
      }

      float64 trigger_level = request->trigger_level();
      auto status = library_->CfgAnlgEdgeStartTrig(task, trigger_source, trigger_slope, trigger_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgMultiEdgeRefTrig(::grpc::ServerContext* context, const CfgAnlgMultiEdgeRefTrigRequest* request, CfgAnlgMultiEdgeRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_sources = request->trigger_sources().c_str();
      auto trigger_slope_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->trigger_slope_array().data()));
      auto trigger_level_array = const_cast<const float64*>(request->trigger_level_array().data());
      uInt32 pretrigger_samples = request->pretrigger_samples();
      uInt32 array_size = request->array_size();
      auto status = library_->CfgAnlgMultiEdgeRefTrig(task, trigger_sources, trigger_slope_array, trigger_level_array, pretrigger_samples, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgMultiEdgeStartTrig(::grpc::ServerContext* context, const CfgAnlgMultiEdgeStartTrigRequest* request, CfgAnlgMultiEdgeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_sources = request->trigger_sources().c_str();
      auto trigger_slope_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->trigger_slope_array().data()));
      auto trigger_level_array = const_cast<const float64*>(request->trigger_level_array().data());
      uInt32 array_size = request->array_size();
      auto status = library_->CfgAnlgMultiEdgeStartTrig(task, trigger_sources, trigger_slope_array, trigger_level_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgWindowRefTrig(::grpc::ServerContext* context, const CfgAnlgWindowRefTrigRequest* request, CfgAnlgWindowRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgAnlgWindowRefTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowRefTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowRefTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      float64 window_top = request->window_top();
      float64 window_bottom = request->window_bottom();
      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgAnlgWindowRefTrig(task, trigger_source, trigger_when, window_top, window_bottom, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgWindowStartTrig(::grpc::ServerContext* context, const CfgAnlgWindowStartTrigRequest* request, CfgAnlgWindowStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgAnlgWindowStartTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowStartTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowStartTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      float64 window_top = request->window_top();
      float64 window_bottom = request->window_bottom();
      auto status = library_->CfgAnlgWindowStartTrig(task, trigger_source, trigger_when, window_top, window_bottom);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgBurstHandshakingTimingExportClock(::grpc::ServerContext* context, const CfgBurstHandshakingTimingExportClockRequest* request, CfgBurstHandshakingTimingExportClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      float64 sample_clk_rate = request->sample_clk_rate();
      auto sample_clk_outp_term = request->sample_clk_outp_term().c_str();
      int32 sample_clk_pulse_polarity;
      switch (request->sample_clk_pulse_polarity_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleClkPulsePolarityEnumCase::kSampleClkPulsePolarity: {
          sample_clk_pulse_polarity = static_cast<int32>(request->sample_clk_pulse_polarity());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleClkPulsePolarityEnumCase::kSampleClkPulsePolarityRaw: {
          sample_clk_pulse_polarity = static_cast<int32>(request->sample_clk_pulse_polarity_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleClkPulsePolarityEnumCase::SAMPLE_CLK_PULSE_POLARITY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_clk_pulse_polarity was not specified or out of range");
          break;
        }
      }

      int32 pause_when;
      switch (request->pause_when_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::PauseWhenEnumCase::kPauseWhen: {
          pause_when = static_cast<int32>(request->pause_when());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::PauseWhenEnumCase::kPauseWhenRaw: {
          pause_when = static_cast<int32>(request->pause_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::PauseWhenEnumCase::PAUSE_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pause_when was not specified or out of range");
          break;
        }
      }

      int32 ready_event_active_level;
      switch (request->ready_event_active_level_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevel: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevelRaw: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::ReadyEventActiveLevelEnumCase::READY_EVENT_ACTIVE_LEVEL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ready_event_active_level was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgBurstHandshakingTimingExportClock(task, sample_mode, samps_per_chan, sample_clk_rate, sample_clk_outp_term, sample_clk_pulse_polarity, pause_when, ready_event_active_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgBurstHandshakingTimingImportClock(::grpc::ServerContext* context, const CfgBurstHandshakingTimingImportClockRequest* request, CfgBurstHandshakingTimingImportClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      float64 sample_clk_rate = request->sample_clk_rate();
      auto sample_clk_src = request->sample_clk_src().c_str();
      int32 sample_clk_active_edge;
      switch (request->sample_clk_active_edge_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleClkActiveEdgeEnumCase::kSampleClkActiveEdge: {
          sample_clk_active_edge = static_cast<int32>(request->sample_clk_active_edge());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleClkActiveEdgeEnumCase::kSampleClkActiveEdgeRaw: {
          sample_clk_active_edge = static_cast<int32>(request->sample_clk_active_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleClkActiveEdgeEnumCase::SAMPLE_CLK_ACTIVE_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_clk_active_edge was not specified or out of range");
          break;
        }
      }

      int32 pause_when;
      switch (request->pause_when_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::PauseWhenEnumCase::kPauseWhen: {
          pause_when = static_cast<int32>(request->pause_when());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::PauseWhenEnumCase::kPauseWhenRaw: {
          pause_when = static_cast<int32>(request->pause_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::PauseWhenEnumCase::PAUSE_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pause_when was not specified or out of range");
          break;
        }
      }

      int32 ready_event_active_level;
      switch (request->ready_event_active_level_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevel: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevelRaw: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::ReadyEventActiveLevelEnumCase::READY_EVENT_ACTIVE_LEVEL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ready_event_active_level was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgBurstHandshakingTimingImportClock(task, sample_mode, samps_per_chan, sample_clk_rate, sample_clk_src, sample_clk_active_edge, pause_when, ready_event_active_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgChangeDetectionTiming(::grpc::ServerContext* context, const CfgChangeDetectionTimingRequest* request, CfgChangeDetectionTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto rising_edge_chan = request->rising_edge_chan().c_str();
      auto falling_edge_chan = request->falling_edge_chan().c_str();
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgChangeDetectionTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgChangeDetectionTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgChangeDetectionTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgChangeDetectionTiming(task, rising_edge_chan, falling_edge_chan, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigEdgeRefTrig(::grpc::ServerContext* context, const CfgDigEdgeRefTrigRequest* request, CfgDigEdgeRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_edge;
      switch (request->trigger_edge_enum_case()) {
        case nidaqmx_grpc::CfgDigEdgeRefTrigRequest::TriggerEdgeEnumCase::kTriggerEdge: {
          trigger_edge = static_cast<int32>(request->trigger_edge());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeRefTrigRequest::TriggerEdgeEnumCase::kTriggerEdgeRaw: {
          trigger_edge = static_cast<int32>(request->trigger_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeRefTrigRequest::TriggerEdgeEnumCase::TRIGGER_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_edge was not specified or out of range");
          break;
        }
      }

      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgDigEdgeRefTrig(task, trigger_source, trigger_edge, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigEdgeStartTrig(::grpc::ServerContext* context, const CfgDigEdgeStartTrigRequest* request, CfgDigEdgeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_edge;
      switch (request->trigger_edge_enum_case()) {
        case nidaqmx_grpc::CfgDigEdgeStartTrigRequest::TriggerEdgeEnumCase::kTriggerEdge: {
          trigger_edge = static_cast<int32>(request->trigger_edge());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeStartTrigRequest::TriggerEdgeEnumCase::kTriggerEdgeRaw: {
          trigger_edge = static_cast<int32>(request->trigger_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeStartTrigRequest::TriggerEdgeEnumCase::TRIGGER_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgDigEdgeStartTrig(task, trigger_source, trigger_edge);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigPatternRefTrig(::grpc::ServerContext* context, const CfgDigPatternRefTrigRequest* request, CfgDigPatternRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      auto trigger_pattern = request->trigger_pattern().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgDigPatternRefTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternRefTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternRefTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgDigPatternRefTrig(task, trigger_source, trigger_pattern, trigger_when, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigPatternStartTrig(::grpc::ServerContext* context, const CfgDigPatternStartTrigRequest* request, CfgDigPatternStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      auto trigger_pattern = request->trigger_pattern().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgDigPatternStartTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternStartTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternStartTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgDigPatternStartTrig(task, trigger_source, trigger_pattern, trigger_when);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgHandshakingTiming(::grpc::ServerContext* context, const CfgHandshakingTimingRequest* request, CfgHandshakingTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgHandshakingTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgHandshakingTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgHandshakingTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgHandshakingTiming(task, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgImplicitTiming(::grpc::ServerContext* context, const CfgImplicitTimingRequest* request, CfgImplicitTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgImplicitTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgImplicitTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgImplicitTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgImplicitTiming(task, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgInputBuffer(::grpc::ServerContext* context, const CfgInputBufferRequest* request, CfgInputBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 num_samps_per_chan = request->num_samps_per_chan();
      auto status = library_->CfgInputBuffer(task, num_samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgOutputBuffer(::grpc::ServerContext* context, const CfgOutputBufferRequest* request, CfgOutputBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 num_samps_per_chan = request->num_samps_per_chan();
      auto status = library_->CfgOutputBuffer(task, num_samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgPipelinedSampClkTiming(::grpc::ServerContext* context, const CfgPipelinedSampClkTimingRequest* request, CfgPipelinedSampClkTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto source = request->source().c_str();
      float64 rate = request->rate();
      int32 active_edge;
      switch (request->active_edge_enum_case()) {
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdge: {
          active_edge = static_cast<int32>(request->active_edge());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdgeRaw: {
          active_edge = static_cast<int32>(request->active_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::ActiveEdgeEnumCase::ACTIVE_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for active_edge was not specified or out of range");
          break;
        }
      }

      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgPipelinedSampClkTiming(task, source, rate, active_edge, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgSampClkTiming(::grpc::ServerContext* context, const CfgSampClkTimingRequest* request, CfgSampClkTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto source = request->source().c_str();
      float64 rate = request->rate();
      int32 active_edge;
      switch (request->active_edge_enum_case()) {
        case nidaqmx_grpc::CfgSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdge: {
          active_edge = static_cast<int32>(request->active_edge());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdgeRaw: {
          active_edge = static_cast<int32>(request->active_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::ActiveEdgeEnumCase::ACTIVE_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for active_edge was not specified or out of range");
          break;
        }
      }

      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgSampClkTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgSampClkTiming(task, source, rate, active_edge, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgTimeStartTrig(::grpc::ServerContext* context, const CfgTimeStartTrigRequest* request, CfgTimeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime when = convert_from_grpc<CVIAbsoluteTime>(request->when());
      int32 timescale;
      switch (request->timescale_enum_case()) {
        case nidaqmx_grpc::CfgTimeStartTrigRequest::TimescaleEnumCase::kTimescale: {
          timescale = static_cast<int32>(request->timescale());
          break;
        }
        case nidaqmx_grpc::CfgTimeStartTrigRequest::TimescaleEnumCase::kTimescaleRaw: {
          timescale = static_cast<int32>(request->timescale_raw());
          break;
        }
        case nidaqmx_grpc::CfgTimeStartTrigRequest::TimescaleEnumCase::TIMESCALE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timescale was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgTimeStartTrig(task, when, timescale);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgWatchdogAOExpirStates(::grpc::ServerContext* context, const CfgWatchdogAOExpirStatesRequest* request, CfgWatchdogAOExpirStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto expir_state_array = const_cast<const float64*>(request->expir_state_array().data());
      auto output_type_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->output_type_array().data()));
      uInt32 array_size = request->array_size();
      auto status = library_->CfgWatchdogAOExpirStates(task, channel_names, expir_state_array, output_type_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgWatchdogCOExpirStates(::grpc::ServerContext* context, const CfgWatchdogCOExpirStatesRequest* request, CfgWatchdogCOExpirStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto expir_state_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->expir_state_array().data()));
      uInt32 array_size = request->array_size();
      auto status = library_->CfgWatchdogCOExpirStates(task, channel_names, expir_state_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgWatchdogDOExpirStates(::grpc::ServerContext* context, const CfgWatchdogDOExpirStatesRequest* request, CfgWatchdogDOExpirStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto expir_state_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->expir_state_array().data()));
      uInt32 array_size = request->array_size();
      auto status = library_->CfgWatchdogDOExpirStates(task, channel_names, expir_state_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ClearTEDS(::grpc::ServerContext* context, const ClearTEDSRequest* request, ClearTEDSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      auto status = library_->ClearTEDS(physical_channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ClearTask(::grpc::ServerContext* context, const ClearTaskRequest* request, ClearTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      session_repository_->remove_session(task);
      auto status = library_->ClearTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ConfigureLogging(::grpc::ServerContext* context, const ConfigureLoggingRequest* request, ConfigureLoggingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto file_path = request->file_path().c_str();
      int32 logging_mode;
      switch (request->logging_mode_enum_case()) {
        case nidaqmx_grpc::ConfigureLoggingRequest::LoggingModeEnumCase::kLoggingMode: {
          logging_mode = static_cast<int32>(request->logging_mode());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::LoggingModeEnumCase::kLoggingModeRaw: {
          logging_mode = static_cast<int32>(request->logging_mode_raw());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::LoggingModeEnumCase::LOGGING_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for logging_mode was not specified or out of range");
          break;
        }
      }

      auto group_name = request->group_name().c_str();
      int32 operation;
      switch (request->operation_enum_case()) {
        case nidaqmx_grpc::ConfigureLoggingRequest::OperationEnumCase::kOperation: {
          operation = static_cast<int32>(request->operation());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::OperationEnumCase::kOperationRaw: {
          operation = static_cast<int32>(request->operation_raw());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::OperationEnumCase::OPERATION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for operation was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureLogging(task, file_path, logging_mode, group_name, operation);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ConfigureTEDS(::grpc::ServerContext* context, const ConfigureTEDSRequest* request, ConfigureTEDSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      auto file_path = request->file_path().c_str();
      auto status = library_->ConfigureTEDS(physical_channel, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ConnectTerms(::grpc::ServerContext* context, const ConnectTermsRequest* request, ConnectTermsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto source_terminal = request->source_terminal().c_str();
      auto destination_terminal = request->destination_terminal().c_str();
      int32 signal_modifiers;
      switch (request->signal_modifiers_enum_case()) {
        case nidaqmx_grpc::ConnectTermsRequest::SignalModifiersEnumCase::kSignalModifiers: {
          signal_modifiers = static_cast<int32>(request->signal_modifiers());
          break;
        }
        case nidaqmx_grpc::ConnectTermsRequest::SignalModifiersEnumCase::kSignalModifiersRaw: {
          signal_modifiers = static_cast<int32>(request->signal_modifiers_raw());
          break;
        }
        case nidaqmx_grpc::ConnectTermsRequest::SignalModifiersEnumCase::SIGNAL_MODIFIERS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_modifiers was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConnectTerms(source_terminal, destination_terminal, signal_modifiers);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ControlWatchdogTask(::grpc::ServerContext* context, const ControlWatchdogTaskRequest* request, ControlWatchdogTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 action;
      switch (request->action_enum_case()) {
        case nidaqmx_grpc::ControlWatchdogTaskRequest::ActionEnumCase::kAction: {
          action = static_cast<int32>(request->action());
          break;
        }
        case nidaqmx_grpc::ControlWatchdogTaskRequest::ActionEnumCase::kActionRaw: {
          action = static_cast<int32>(request->action_raw());
          break;
        }
        case nidaqmx_grpc::ControlWatchdogTaskRequest::ActionEnumCase::ACTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for action was not specified or out of range");
          break;
        }
      }

      auto status = library_->ControlWatchdogTask(task, action);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccel4WireDCVoltageChan(::grpc::ServerContext* context, const CreateAIAccel4WireDCVoltageChanRequest* request, CreateAIAccel4WireDCVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      bool32 use_excit_for_scaling = request->use_excit_for_scaling();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccel4WireDCVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, use_excit_for_scaling, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccelChan(::grpc::ServerContext* context, const CreateAIAccelChanRequest* request, CreateAIAccelChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccelChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccelChargeChan(::grpc::ServerContext* context, const CreateAIAccelChargeChanRequest* request, CreateAIAccelChargeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccelChargeChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIBridgeChan(::grpc::ServerContext* context, const CreateAIBridgeChanRequest* request, CreateAIBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIChargeChan(::grpc::ServerContext* context, const CreateAIChargeChanRequest* request, CreateAIChargeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIChargeChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAICurrentChan(::grpc::ServerContext* context, const CreateAICurrentChanRequest* request, CreateAICurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAICurrentChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAICurrentRMSChan(::grpc::ServerContext* context, const CreateAICurrentRMSChanRequest* request, CreateAICurrentRMSChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAICurrentRMSChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceBridgePolynomialChan(::grpc::ServerContext* context, const CreateAIForceBridgePolynomialChanRequest* request, CreateAIForceBridgePolynomialChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs = request->num_forward_coeffs();
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs = request->num_reverse_coeffs();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceBridgePolynomialChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, num_forward_coeffs, reverse_coeffs, num_reverse_coeffs, electrical_units, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceBridgeTableChan(::grpc::ServerContext* context, const CreateAIForceBridgeTableChanRequest* request, CreateAIForceBridgeTableChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto electrical_vals = const_cast<const float64*>(request->electrical_vals().data());
      uInt32 num_electrical_vals = request->num_electrical_vals();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      auto physical_vals = const_cast<const float64*>(request->physical_vals().data());
      uInt32 num_physical_vals = request->num_physical_vals();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceBridgeTableChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, num_electrical_vals, electrical_units, physical_vals, num_physical_vals, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceBridgeTwoPointLinChan(::grpc::ServerContext* context, const CreateAIForceBridgeTwoPointLinChanRequest* request, CreateAIForceBridgeTwoPointLinChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      float64 first_electrical_val = request->first_electrical_val();
      float64 second_electrical_val = request->second_electrical_val();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      float64 first_physical_val = request->first_physical_val();
      float64 second_physical_val = request->second_physical_val();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceBridgeTwoPointLinChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceIEPEChan(::grpc::ServerContext* context, const CreateAIForceIEPEChanRequest* request, CreateAIForceIEPEChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceIEPEChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIFreqVoltageChan(::grpc::ServerContext* context, const CreateAIFreqVoltageChanRequest* request, CreateAIFreqVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 threshold_level = request->threshold_level();
      float64 hysteresis = request->hysteresis();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIFreqVoltageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, threshold_level, hysteresis, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIMicrophoneChan(::grpc::ServerContext* context, const CreateAIMicrophoneChanRequest* request, CreateAIMicrophoneChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 mic_sensitivity = request->mic_sensitivity();
      float64 max_snd_press_level = request->max_snd_press_level();
      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIMicrophoneChan(task, physical_channel, name_to_assign_to_channel, terminal_config, units, mic_sensitivity, max_snd_press_level, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosEddyCurrProxProbeChan(::grpc::ServerContext* context, const CreateAIPosEddyCurrProxProbeChanRequest* request, CreateAIPosEddyCurrProxProbeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosEddyCurrProxProbeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosLVDTChan(::grpc::ServerContext* context, const CreateAIPosLVDTChanRequest* request, CreateAIPosLVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosLVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosRVDTChan(::grpc::ServerContext* context, const CreateAIPosRVDTChanRequest* request, CreateAIPosRVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosRVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPressureBridgePolynomialChan(::grpc::ServerContext* context, const CreateAIPressureBridgePolynomialChanRequest* request, CreateAIPressureBridgePolynomialChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs = request->num_forward_coeffs();
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs = request->num_reverse_coeffs();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPressureBridgePolynomialChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, num_forward_coeffs, reverse_coeffs, num_reverse_coeffs, electrical_units, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPressureBridgeTableChan(::grpc::ServerContext* context, const CreateAIPressureBridgeTableChanRequest* request, CreateAIPressureBridgeTableChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto electrical_vals = const_cast<const float64*>(request->electrical_vals().data());
      uInt32 num_electrical_vals = request->num_electrical_vals();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      auto physical_vals = const_cast<const float64*>(request->physical_vals().data());
      uInt32 num_physical_vals = request->num_physical_vals();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPressureBridgeTableChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, num_electrical_vals, electrical_units, physical_vals, num_physical_vals, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPressureBridgeTwoPointLinChan(::grpc::ServerContext* context, const CreateAIPressureBridgeTwoPointLinChanRequest* request, CreateAIPressureBridgeTwoPointLinChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      float64 first_electrical_val = request->first_electrical_val();
      float64 second_electrical_val = request->second_electrical_val();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      float64 first_physical_val = request->first_physical_val();
      float64 second_physical_val = request->second_physical_val();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPressureBridgeTwoPointLinChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIRTDChan(::grpc::ServerContext* context, const CreateAIRTDChanRequest* request, CreateAIRTDChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 rtd_type;
      switch (request->rtd_type_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::RtdTypeEnumCase::kRtdType: {
          rtd_type = static_cast<int32>(request->rtd_type());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::RtdTypeEnumCase::kRtdTypeRaw: {
          rtd_type = static_cast<int32>(request->rtd_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::RtdTypeEnumCase::RTD_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rtd_type was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      float64 r0 = request->r0();
      auto status = library_->CreateAIRTDChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, rtd_type, resistance_config, current_excit_source, current_excit_val, r0);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIResistanceChan(::grpc::ServerContext* context, const CreateAIResistanceChanRequest* request, CreateAIResistanceChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIResistanceChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIRosetteStrainGageChan(::grpc::ServerContext* context, const CreateAIRosetteStrainGageChanRequest* request, CreateAIRosetteStrainGageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 rosette_type;
      switch (request->rosette_type_enum_case()) {
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::RosetteTypeEnumCase::kRosetteType: {
          rosette_type = static_cast<int32>(request->rosette_type());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::RosetteTypeEnumCase::kRosetteTypeRaw: {
          rosette_type = static_cast<int32>(request->rosette_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::RosetteTypeEnumCase::ROSETTE_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rosette_type was not specified or out of range");
          break;
        }
      }

      float64 gage_orientation = request->gage_orientation();
      auto rosette_meas_types = const_cast<int32*>(reinterpret_cast<const int32*>(request->rosette_meas_types().data()));
      uInt32 num_rosette_meas_types = request->num_rosette_meas_types();
      int32 strain_config;
      switch (request->strain_config_enum_case()) {
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::StrainConfigEnumCase::kStrainConfig: {
          strain_config = static_cast<int32>(request->strain_config());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::StrainConfigEnumCase::kStrainConfigRaw: {
          strain_config = static_cast<int32>(request->strain_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::StrainConfigEnumCase::STRAIN_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for strain_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 gage_factor = request->gage_factor();
      float64 nominal_gage_resistance = request->nominal_gage_resistance();
      float64 poisson_ratio = request->poisson_ratio();
      float64 lead_wire_resistance = request->lead_wire_resistance();
      auto status = library_->CreateAIRosetteStrainGageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, rosette_type, gage_orientation, rosette_meas_types, num_rosette_meas_types, strain_config, voltage_excit_source, voltage_excit_val, gage_factor, nominal_gage_resistance, poisson_ratio, lead_wire_resistance);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIStrainGageChan(::grpc::ServerContext* context, const CreateAIStrainGageChanRequest* request, CreateAIStrainGageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 strain_config;
      switch (request->strain_config_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::kStrainConfig: {
          strain_config = static_cast<int32>(request->strain_config());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::kStrainConfigRaw: {
          strain_config = static_cast<int32>(request->strain_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::STRAIN_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for strain_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 gage_factor = request->gage_factor();
      float64 initial_bridge_voltage = request->initial_bridge_voltage();
      float64 nominal_gage_resistance = request->nominal_gage_resistance();
      float64 poisson_ratio = request->poisson_ratio();
      float64 lead_wire_resistance = request->lead_wire_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIStrainGageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, strain_config, voltage_excit_source, voltage_excit_val, gage_factor, initial_bridge_voltage, nominal_gage_resistance, poisson_ratio, lead_wire_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITempBuiltInSensorChan(::grpc::ServerContext* context, const CreateAITempBuiltInSensorChanRequest* request, CreateAITempBuiltInSensorChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITempBuiltInSensorChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITempBuiltInSensorChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITempBuiltInSensorChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateAITempBuiltInSensorChan(task, physical_channel, name_to_assign_to_channel, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIThrmcplChan(::grpc::ServerContext* context, const CreateAIThrmcplChanRequest* request, CreateAIThrmcplChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 thermocouple_type;
      switch (request->thermocouple_type_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::ThermocoupleTypeEnumCase::kThermocoupleType: {
          thermocouple_type = static_cast<int32>(request->thermocouple_type());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::ThermocoupleTypeEnumCase::kThermocoupleTypeRaw: {
          thermocouple_type = static_cast<int32>(request->thermocouple_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::ThermocoupleTypeEnumCase::THERMOCOUPLE_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for thermocouple_type was not specified or out of range");
          break;
        }
      }

      int32 cjc_source;
      switch (request->cjc_source_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSource: {
          cjc_source = static_cast<int32>(request->cjc_source());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSourceRaw: {
          cjc_source = static_cast<int32>(request->cjc_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::CjcSourceEnumCase::CJC_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for cjc_source was not specified or out of range");
          break;
        }
      }

      float64 cjc_val = request->cjc_val();
      auto cjc_channel = request->cjc_channel().c_str();
      auto status = library_->CreateAIThrmcplChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, thermocouple_type, cjc_source, cjc_val, cjc_channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIThrmstrChanIex(::grpc::ServerContext* context, const CreateAIThrmstrChanIexRequest* request, CreateAIThrmstrChanIexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      float64 a = request->a();
      float64 b = request->b();
      float64 c = request->c();
      auto status = library_->CreateAIThrmstrChanIex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, a, b, c);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIThrmstrChanVex(::grpc::ServerContext* context, const CreateAIThrmstrChanVexRequest* request, CreateAIThrmstrChanVexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 a = request->a();
      float64 b = request->b();
      float64 c = request->c();
      float64 r1 = request->r1();
      auto status = library_->CreateAIThrmstrChanVex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, voltage_excit_source, voltage_excit_val, a, b, c, r1);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITorqueBridgePolynomialChan(::grpc::ServerContext* context, const CreateAITorqueBridgePolynomialChanRequest* request, CreateAITorqueBridgePolynomialChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs = request->num_forward_coeffs();
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs = request->num_reverse_coeffs();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAITorqueBridgePolynomialChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, num_forward_coeffs, reverse_coeffs, num_reverse_coeffs, electrical_units, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITorqueBridgeTableChan(::grpc::ServerContext* context, const CreateAITorqueBridgeTableChanRequest* request, CreateAITorqueBridgeTableChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto electrical_vals = const_cast<const float64*>(request->electrical_vals().data());
      uInt32 num_electrical_vals = request->num_electrical_vals();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      auto physical_vals = const_cast<const float64*>(request->physical_vals().data());
      uInt32 num_physical_vals = request->num_physical_vals();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAITorqueBridgeTableChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, num_electrical_vals, electrical_units, physical_vals, num_physical_vals, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITorqueBridgeTwoPointLinChan(::grpc::ServerContext* context, const CreateAITorqueBridgeTwoPointLinChanRequest* request, CreateAITorqueBridgeTwoPointLinChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      float64 first_electrical_val = request->first_electrical_val();
      float64 second_electrical_val = request->second_electrical_val();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      float64 first_physical_val = request->first_physical_val();
      float64 second_physical_val = request->second_physical_val();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAITorqueBridgeTwoPointLinChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVelocityIEPEChan(::grpc::ServerContext* context, const CreateAIVelocityIEPEChanRequest* request, CreateAIVelocityIEPEChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVelocityIEPEChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageChan(::grpc::ServerContext* context, const CreateAIVoltageChanRequest* request, CreateAIVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageChanWithExcit(::grpc::ServerContext* context, const CreateAIVoltageChanWithExcitRequest* request, CreateAIVoltageChanWithExcitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      bool32 use_excit_for_scaling = request->use_excit_for_scaling();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageChanWithExcit(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, use_excit_for_scaling, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageRMSChan(::grpc::ServerContext* context, const CreateAIVoltageRMSChanRequest* request, CreateAIVoltageRMSChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageRMSChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOCurrentChan(::grpc::ServerContext* context, const CreateAOCurrentChanRequest* request, CreateAOCurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAOCurrentChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOFuncGenChan(::grpc::ServerContext* context, const CreateAOFuncGenChanRequest* request, CreateAOFuncGenChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 type;
      switch (request->type_enum_case()) {
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::kType: {
          type = static_cast<int32>(request->type());
          break;
        }
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::kTypeRaw: {
          type = static_cast<int32>(request->type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for type was not specified or out of range");
          break;
        }
      }

      float64 freq = request->freq();
      float64 amplitude = request->amplitude();
      float64 offset = request->offset();
      auto status = library_->CreateAOFuncGenChan(task, physical_channel, name_to_assign_to_channel, type, freq, amplitude, offset);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOVoltageChan(::grpc::ServerContext* context, const CreateAOVoltageChanRequest* request, CreateAOVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAOVoltageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIAngEncoderChan(::grpc::ServerContext* context, const CreateCIAngEncoderChanRequest* request, CreateCIAngEncoderChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      bool32 zidx_enable = request->zidx_enable();
      float64 zidx_val = request->zidx_val();
      int32 zidx_phase;
      switch (request->zidx_phase_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhase: {
          zidx_phase = static_cast<int32>(request->zidx_phase());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhaseRaw: {
          zidx_phase = static_cast<int32>(request->zidx_phase_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::ZIDX_PHASE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for zidx_phase was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      uInt32 pulses_per_rev = request->pulses_per_rev();
      float64 initial_angle = request->initial_angle();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIAngEncoderChan(task, counter, name_to_assign_to_channel, decoding_type, zidx_enable, zidx_val, zidx_phase, units, pulses_per_rev, initial_angle, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIAngVelocityChan(::grpc::ServerContext* context, const CreateCIAngVelocityChanRequest* request, CreateCIAngVelocityChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      uInt32 pulses_per_rev = request->pulses_per_rev();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIAngVelocityChan(task, counter, name_to_assign_to_channel, min_val, max_val, decoding_type, units, pulses_per_rev, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCICountEdgesChan(::grpc::ServerContext* context, const CreateCICountEdgesChanRequest* request, CreateCICountEdgesChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      uInt32 initial_count = request->initial_count();
      int32 count_direction;
      switch (request->count_direction_enum_case()) {
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::kCountDirection: {
          count_direction = static_cast<int32>(request->count_direction());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::kCountDirectionRaw: {
          count_direction = static_cast<int32>(request->count_direction_raw());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::COUNT_DIRECTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for count_direction was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCICountEdgesChan(task, counter, name_to_assign_to_channel, edge, initial_count, count_direction);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIDutyCycleChan(::grpc::ServerContext* context, const CreateCIDutyCycleChanRequest* request, CreateCIDutyCycleChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_freq = request->min_freq();
      float64 max_freq = request->max_freq();
      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIDutyCycleChan(task, counter, name_to_assign_to_channel, min_freq, max_freq, edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIFreqChan(::grpc::ServerContext* context, const CreateCIFreqChanRequest* request, CreateCIFreqChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      int32 meas_method;
      switch (request->meas_method_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::kMeasMethod: {
          meas_method = static_cast<int32>(request->meas_method());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::kMeasMethodRaw: {
          meas_method = static_cast<int32>(request->meas_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::MEAS_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for meas_method was not specified or out of range");
          break;
        }
      }

      float64 meas_time = request->meas_time();
      uInt32 divisor = request->divisor();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIFreqChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, edge, meas_method, meas_time, divisor, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIGPSTimestampChan(::grpc::ServerContext* context, const CreateCIGPSTimestampChanRequest* request, CreateCIGPSTimestampChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 sync_method;
      switch (request->sync_method_enum_case()) {
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::kSyncMethod: {
          sync_method = static_cast<int32>(request->sync_method());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::kSyncMethodRaw: {
          sync_method = static_cast<int32>(request->sync_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::SYNC_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sync_method was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIGPSTimestampChan(task, counter, name_to_assign_to_channel, units, sync_method, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCILinEncoderChan(::grpc::ServerContext* context, const CreateCILinEncoderChanRequest* request, CreateCILinEncoderChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      bool32 zidx_enable = request->zidx_enable();
      float64 zidx_val = request->zidx_val();
      int32 zidx_phase;
      switch (request->zidx_phase_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhase: {
          zidx_phase = static_cast<int32>(request->zidx_phase());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhaseRaw: {
          zidx_phase = static_cast<int32>(request->zidx_phase_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::ZIDX_PHASE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for zidx_phase was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 dist_per_pulse = request->dist_per_pulse();
      float64 initial_pos = request->initial_pos();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCILinEncoderChan(task, counter, name_to_assign_to_channel, decoding_type, zidx_enable, zidx_val, zidx_phase, units, dist_per_pulse, initial_pos, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCILinVelocityChan(::grpc::ServerContext* context, const CreateCILinVelocityChanRequest* request, CreateCILinVelocityChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 dist_per_pulse = request->dist_per_pulse();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCILinVelocityChan(task, counter, name_to_assign_to_channel, min_val, max_val, decoding_type, units, dist_per_pulse, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPeriodChan(::grpc::ServerContext* context, const CreateCIPeriodChanRequest* request, CreateCIPeriodChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      int32 meas_method;
      switch (request->meas_method_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::kMeasMethod: {
          meas_method = static_cast<int32>(request->meas_method());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::kMeasMethodRaw: {
          meas_method = static_cast<int32>(request->meas_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::MEAS_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for meas_method was not specified or out of range");
          break;
        }
      }

      float64 meas_time = request->meas_time();
      uInt32 divisor = request->divisor();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIPeriodChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, edge, meas_method, meas_time, divisor, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanFreq(::grpc::ServerContext* context, const CreateCIPulseChanFreqRequest* request, CreateCIPulseChanFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCIPulseChanFreq(task, counter, name_to_assign_to_channel, min_val, max_val, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanTicks(::grpc::ServerContext* context, const CreateCIPulseChanTicksRequest* request, CreateCIPulseChanTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      auto source_terminal = request->source_terminal().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      auto status = library_->CreateCIPulseChanTicks(task, counter, name_to_assign_to_channel, source_terminal, min_val, max_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanTime(::grpc::ServerContext* context, const CreateCIPulseChanTimeRequest* request, CreateCIPulseChanTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCIPulseChanTime(task, counter, name_to_assign_to_channel, min_val, max_val, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseWidthChan(::grpc::ServerContext* context, const CreateCIPulseWidthChanRequest* request, CreateCIPulseWidthChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 starting_edge;
      switch (request->starting_edge_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::kStartingEdge: {
          starting_edge = static_cast<int32>(request->starting_edge());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::kStartingEdgeRaw: {
          starting_edge = static_cast<int32>(request->starting_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::STARTING_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for starting_edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIPulseWidthChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, starting_edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCISemiPeriodChan(::grpc::ServerContext* context, const CreateCISemiPeriodChanRequest* request, CreateCISemiPeriodChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCISemiPeriodChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCITwoEdgeSepChan(::grpc::ServerContext* context, const CreateCITwoEdgeSepChanRequest* request, CreateCITwoEdgeSepChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 first_edge;
      switch (request->first_edge_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::kFirstEdge: {
          first_edge = static_cast<int32>(request->first_edge());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::kFirstEdgeRaw: {
          first_edge = static_cast<int32>(request->first_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::FIRST_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for first_edge was not specified or out of range");
          break;
        }
      }

      int32 second_edge;
      switch (request->second_edge_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::kSecondEdge: {
          second_edge = static_cast<int32>(request->second_edge());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::kSecondEdgeRaw: {
          second_edge = static_cast<int32>(request->second_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::SECOND_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for second_edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCITwoEdgeSepChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, first_edge, second_edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanFreq(::grpc::ServerContext* context, const CreateCOPulseChanFreqRequest* request, CreateCOPulseChanFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      float64 initial_delay = request->initial_delay();
      float64 freq = request->freq();
      float64 duty_cycle = request->duty_cycle();
      auto status = library_->CreateCOPulseChanFreq(task, counter, name_to_assign_to_channel, units, idle_state, initial_delay, freq, duty_cycle);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanTicks(::grpc::ServerContext* context, const CreateCOPulseChanTicksRequest* request, CreateCOPulseChanTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      auto source_terminal = request->source_terminal().c_str();
      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      int32 initial_delay = request->initial_delay();
      int32 low_ticks = request->low_ticks();
      int32 high_ticks = request->high_ticks();
      auto status = library_->CreateCOPulseChanTicks(task, counter, name_to_assign_to_channel, source_terminal, idle_state, initial_delay, low_ticks, high_ticks);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanTime(::grpc::ServerContext* context, const CreateCOPulseChanTimeRequest* request, CreateCOPulseChanTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      float64 initial_delay = request->initial_delay();
      float64 low_time = request->low_time();
      float64 high_time = request->high_time();
      auto status = library_->CreateCOPulseChanTime(task, counter, name_to_assign_to_channel, units, idle_state, initial_delay, low_time, high_time);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateDIChan(::grpc::ServerContext* context, const CreateDIChanRequest* request, CreateDIChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      auto name_to_assign_to_lines = request->name_to_assign_to_lines().c_str();
      int32 line_grouping;
      switch (request->line_grouping_enum_case()) {
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::kLineGrouping: {
          line_grouping = static_cast<int32>(request->line_grouping());
          break;
        }
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::kLineGroupingRaw: {
          line_grouping = static_cast<int32>(request->line_grouping_raw());
          break;
        }
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::LINE_GROUPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for line_grouping was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateDIChan(task, lines, name_to_assign_to_lines, line_grouping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateDOChan(::grpc::ServerContext* context, const CreateDOChanRequest* request, CreateDOChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      auto name_to_assign_to_lines = request->name_to_assign_to_lines().c_str();
      int32 line_grouping;
      switch (request->line_grouping_enum_case()) {
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::kLineGrouping: {
          line_grouping = static_cast<int32>(request->line_grouping());
          break;
        }
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::kLineGroupingRaw: {
          line_grouping = static_cast<int32>(request->line_grouping_raw());
          break;
        }
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::LINE_GROUPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for line_grouping was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateDOChan(task, lines, name_to_assign_to_lines, line_grouping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateLinScale(::grpc::ServerContext* context, const CreateLinScaleRequest* request, CreateLinScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      float64 slope = request->slope();
      float64 y_intercept = request->y_intercept();
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreateLinScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreateLinScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateLinScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreateLinScale(name, slope, y_intercept, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateMapScale(::grpc::ServerContext* context, const CreateMapScaleRequest* request, CreateMapScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      float64 prescaled_min = request->prescaled_min();
      float64 prescaled_max = request->prescaled_max();
      float64 scaled_min = request->scaled_min();
      float64 scaled_max = request->scaled_max();
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreateMapScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreateMapScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateMapScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreateMapScale(name, prescaled_min, prescaled_max, scaled_min, scaled_max, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreatePolynomialScale(::grpc::ServerContext* context, const CreatePolynomialScaleRequest* request, CreatePolynomialScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs_in = request->num_forward_coeffs_in();
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs_in = request->num_reverse_coeffs_in();
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreatePolynomialScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreatePolynomialScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreatePolynomialScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreatePolynomialScale(name, forward_coeffs, num_forward_coeffs_in, reverse_coeffs, num_reverse_coeffs_in, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIAccelChan(::grpc::ServerContext* context, const CreateTEDSAIAccelChanRequest* request, CreateTEDSAIAccelChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIAccelChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIBridgeChan(::grpc::ServerContext* context, const CreateTEDSAIBridgeChanRequest* request, CreateTEDSAIBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAICurrentChan(::grpc::ServerContext* context, const CreateTEDSAICurrentChanRequest* request, CreateTEDSAICurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAICurrentChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIForceBridgeChan(::grpc::ServerContext* context, const CreateTEDSAIForceBridgeChanRequest* request, CreateTEDSAIForceBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIForceBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIForceIEPEChan(::grpc::ServerContext* context, const CreateTEDSAIForceIEPEChanRequest* request, CreateTEDSAIForceIEPEChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIForceIEPEChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIMicrophoneChan(::grpc::ServerContext* context, const CreateTEDSAIMicrophoneChanRequest* request, CreateTEDSAIMicrophoneChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 max_snd_press_level = request->max_snd_press_level();
      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIMicrophoneChan(task, physical_channel, name_to_assign_to_channel, terminal_config, units, max_snd_press_level, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPosLVDTChan(::grpc::ServerContext* context, const CreateTEDSAIPosLVDTChanRequest* request, CreateTEDSAIPosLVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPosLVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPosRVDTChan(::grpc::ServerContext* context, const CreateTEDSAIPosRVDTChanRequest* request, CreateTEDSAIPosRVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPosRVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPressureBridgeChan(::grpc::ServerContext* context, const CreateTEDSAIPressureBridgeChanRequest* request, CreateTEDSAIPressureBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPressureBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIRTDChan(::grpc::ServerContext* context, const CreateTEDSAIRTDChanRequest* request, CreateTEDSAIRTDChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto status = library_->CreateTEDSAIRTDChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIResistanceChan(::grpc::ServerContext* context, const CreateTEDSAIResistanceChanRequest* request, CreateTEDSAIResistanceChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIResistanceChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIStrainGageChan(::grpc::ServerContext* context, const CreateTEDSAIStrainGageChanRequest* request, CreateTEDSAIStrainGageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 initial_bridge_voltage = request->initial_bridge_voltage();
      float64 lead_wire_resistance = request->lead_wire_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIStrainGageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, initial_bridge_voltage, lead_wire_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIThrmcplChan(::grpc::ServerContext* context, const CreateTEDSAIThrmcplChanRequest* request, CreateTEDSAIThrmcplChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 cjc_source;
      switch (request->cjc_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSource: {
          cjc_source = static_cast<int32>(request->cjc_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSourceRaw: {
          cjc_source = static_cast<int32>(request->cjc_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::CjcSourceEnumCase::CJC_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for cjc_source was not specified or out of range");
          break;
        }
      }

      float64 cjc_val = request->cjc_val();
      auto cjc_channel = request->cjc_channel().c_str();
      auto status = library_->CreateTEDSAIThrmcplChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, cjc_source, cjc_val, cjc_channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIThrmstrChanIex(::grpc::ServerContext* context, const CreateTEDSAIThrmstrChanIexRequest* request, CreateTEDSAIThrmstrChanIexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto status = library_->CreateTEDSAIThrmstrChanIex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIThrmstrChanVex(::grpc::ServerContext* context, const CreateTEDSAIThrmstrChanVexRequest* request, CreateTEDSAIThrmstrChanVexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 r1 = request->r1();
      auto status = library_->CreateTEDSAIThrmstrChanVex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, voltage_excit_source, voltage_excit_val, r1);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAITorqueBridgeChan(::grpc::ServerContext* context, const CreateTEDSAITorqueBridgeChanRequest* request, CreateTEDSAITorqueBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAITorqueBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIVoltageChan(::grpc::ServerContext* context, const CreateTEDSAIVoltageChanRequest* request, CreateTEDSAIVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIVoltageChanWithExcit(::grpc::ServerContext* context, const CreateTEDSAIVoltageChanWithExcitRequest* request, CreateTEDSAIVoltageChanWithExcitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIVoltageChanWithExcit(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTableScale(::grpc::ServerContext* context, const CreateTableScaleRequest* request, CreateTableScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      auto prescaled_vals = const_cast<const float64*>(request->prescaled_vals().data());
      uInt32 num_prescaled_vals_in = request->num_prescaled_vals_in();
      auto scaled_vals = const_cast<const float64*>(request->scaled_vals().data());
      uInt32 num_scaled_vals_in = request->num_scaled_vals_in();
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreateTableScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreateTableScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTableScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreateTableScale(name, prescaled_vals, num_prescaled_vals_in, scaled_vals, num_scaled_vals_in, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTask(::grpc::ServerContext* context, const CreateTaskRequest* request, CreateTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_name = request->session_name().c_str();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->CreateTask(session_name, &task);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateWatchdogTimerTask(::grpc::ServerContext* context, const CreateWatchdogTimerTaskRequest* request, CreateWatchdogTimerTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto session_name = request->session_name().c_str();
      float64 timeout = request->timeout();
      auto lines = request->lines().c_str();
      int32 exp_state;
      switch (request->exp_state_enum_case()) {
        case nidaqmx_grpc::CreateWatchdogTimerTaskRequest::ExpStateEnumCase::kExpState: {
          exp_state = static_cast<int32>(request->exp_state());
          break;
        }
        case nidaqmx_grpc::CreateWatchdogTimerTaskRequest::ExpStateEnumCase::kExpStateRaw: {
          exp_state = static_cast<int32>(request->exp_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateWatchdogTimerTaskRequest::ExpStateEnumCase::EXP_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for exp_state was not specified or out of range");
          break;
        }
      }


      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->CreateWatchdogTimerTask(device_name, session_name, &task, timeout, lines, exp_state);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateWatchdogTimerTaskEx(::grpc::ServerContext* context, const CreateWatchdogTimerTaskExRequest* request, CreateWatchdogTimerTaskExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto session_name = request->session_name().c_str();
      float64 timeout = request->timeout();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->CreateWatchdogTimerTaskEx(device_name, session_name, &task, timeout);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteNetworkDevice(::grpc::ServerContext* context, const DeleteNetworkDeviceRequest* request, DeleteNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->DeleteNetworkDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteSavedGlobalChan(::grpc::ServerContext* context, const DeleteSavedGlobalChanRequest* request, DeleteSavedGlobalChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto channel_name = request->channel_name().c_str();
      auto status = library_->DeleteSavedGlobalChan(channel_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteSavedScale(::grpc::ServerContext* context, const DeleteSavedScaleRequest* request, DeleteSavedScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      auto status = library_->DeleteSavedScale(scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteSavedTask(::grpc::ServerContext* context, const DeleteSavedTaskRequest* request, DeleteSavedTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_name = request->task_name().c_str();
      auto status = library_->DeleteSavedTask(task_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeviceSupportsCal(::grpc::ServerContext* context, const DeviceSupportsCalRequest* request, DeviceSupportsCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      bool32 cal_supported {};
      auto status = library_->DeviceSupportsCal(device_name, &cal_supported);
      response->set_status(status);
      if (status == 0) {
        response->set_cal_supported(cal_supported);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DisableRefTrig(::grpc::ServerContext* context, const DisableRefTrigRequest* request, DisableRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->DisableRefTrig(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DisableStartTrig(::grpc::ServerContext* context, const DisableStartTrigRequest* request, DisableStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->DisableStartTrig(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DisconnectTerms(::grpc::ServerContext* context, const DisconnectTermsRequest* request, DisconnectTermsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto source_terminal = request->source_terminal().c_str();
      auto destination_terminal = request->destination_terminal().c_str();
      auto status = library_->DisconnectTerms(source_terminal, destination_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ExportSignal(::grpc::ServerContext* context, const ExportSignalRequest* request, ExportSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 signal_id;
      switch (request->signal_id_enum_case()) {
        case nidaqmx_grpc::ExportSignalRequest::SignalIdEnumCase::kSignalId: {
          signal_id = static_cast<int32>(request->signal_id());
          break;
        }
        case nidaqmx_grpc::ExportSignalRequest::SignalIdEnumCase::kSignalIdRaw: {
          signal_id = static_cast<int32>(request->signal_id_raw());
          break;
        }
        case nidaqmx_grpc::ExportSignalRequest::SignalIdEnumCase::SIGNAL_ID_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_id was not specified or out of range");
          break;
        }
      }

      auto output_terminal = request->output_terminal().c_str();
      auto status = library_->ExportSignal(task, signal_id, output_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIACExcitFreq(::grpc::ServerContext* context, const GetAIACExcitFreqRequest* request, GetAIACExcitFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIACExcitFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIACExcitSyncEnable(::grpc::ServerContext* context, const GetAIACExcitSyncEnableRequest* request, GetAIACExcitSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIACExcitSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIACExcitWireMode(::grpc::ServerContext* context, const GetAIACExcitWireModeRequest* request, GetAIACExcitWireModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIACExcitWireMode(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ACExcitWireMode>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIADCCustomTimingMode(::grpc::ServerContext* context, const GetAIADCCustomTimingModeRequest* request, GetAIADCCustomTimingModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAIADCCustomTimingMode(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIADCTimingMode(::grpc::ServerContext* context, const GetAIADCTimingModeRequest* request, GetAIADCTimingModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIADCTimingMode(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ADCTimingMode>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAccel4WireDCVoltageSensitivity(::grpc::ServerContext* context, const GetAIAccel4WireDCVoltageSensitivityRequest* request, GetAIAccel4WireDCVoltageSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIAccel4WireDCVoltageSensitivity(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAccel4WireDCVoltageSensitivityUnits(::grpc::ServerContext* context, const GetAIAccel4WireDCVoltageSensitivityUnitsRequest* request, GetAIAccel4WireDCVoltageSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIAccel4WireDCVoltageSensitivityUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AccelSensitivityUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAccelChargeSensitivity(::grpc::ServerContext* context, const GetAIAccelChargeSensitivityRequest* request, GetAIAccelChargeSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIAccelChargeSensitivity(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAccelChargeSensitivityUnits(::grpc::ServerContext* context, const GetAIAccelChargeSensitivityUnitsRequest* request, GetAIAccelChargeSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIAccelChargeSensitivityUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AccelChargeSensitivityUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAccelSensitivity(::grpc::ServerContext* context, const GetAIAccelSensitivityRequest* request, GetAIAccelSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIAccelSensitivity(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAccelSensitivityUnits(::grpc::ServerContext* context, const GetAIAccelSensitivityUnitsRequest* request, GetAIAccelSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIAccelSensitivityUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AccelSensitivityUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAccelUnits(::grpc::ServerContext* context, const GetAIAccelUnitsRequest* request, GetAIAccelUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIAccelUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AccelUnits2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAcceldBRef(::grpc::ServerContext* context, const GetAIAcceldBRefRequest* request, GetAIAcceldBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIAcceldBRef(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAtten(::grpc::ServerContext* context, const GetAIAttenRequest* request, GetAIAttenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIAtten(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAutoZeroMode(::grpc::ServerContext* context, const GetAIAutoZeroModeRequest* request, GetAIAutoZeroModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIAutoZeroMode(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AutoZeroType1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIAveragingWinSize(::grpc::ServerContext* context, const GetAIAveragingWinSizeRequest* request, GetAIAveragingWinSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAIAveragingWinSize(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeBalanceCoarsePot(::grpc::ServerContext* context, const GetAIBridgeBalanceCoarsePotRequest* request, GetAIBridgeBalanceCoarsePotResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIBridgeBalanceCoarsePot(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeBalanceFinePot(::grpc::ServerContext* context, const GetAIBridgeBalanceFinePotRequest* request, GetAIBridgeBalanceFinePotResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIBridgeBalanceFinePot(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeCfg(::grpc::ServerContext* context, const GetAIBridgeCfgRequest* request, GetAIBridgeCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIBridgeCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::BridgeConfiguration1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeElectricalUnits(::grpc::ServerContext* context, const GetAIBridgeElectricalUnitsRequest* request, GetAIBridgeElectricalUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIBridgeElectricalUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::BridgeElectricalUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeInitialRatio(::grpc::ServerContext* context, const GetAIBridgeInitialRatioRequest* request, GetAIBridgeInitialRatioResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeInitialRatio(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeInitialVoltage(::grpc::ServerContext* context, const GetAIBridgeInitialVoltageRequest* request, GetAIBridgeInitialVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeInitialVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeNomResistance(::grpc::ServerContext* context, const GetAIBridgeNomResistanceRequest* request, GetAIBridgeNomResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeNomResistance(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgePhysicalUnits(::grpc::ServerContext* context, const GetAIBridgePhysicalUnitsRequest* request, GetAIBridgePhysicalUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIBridgePhysicalUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::BridgePhysicalUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgePolyForwardCoeff(::grpc::ServerContext* context, const GetAIBridgePolyForwardCoeffRequest* request, GetAIBridgePolyForwardCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIBridgePolyForwardCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgePolyReverseCoeff(::grpc::ServerContext* context, const GetAIBridgePolyReverseCoeffRequest* request, GetAIBridgePolyReverseCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIBridgePolyReverseCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeScaleType(::grpc::ServerContext* context, const GetAIBridgeScaleTypeRequest* request, GetAIBridgeScaleTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIBridgeScaleType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ScaleType4>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeShuntCalEnable(::grpc::ServerContext* context, const GetAIBridgeShuntCalEnableRequest* request, GetAIBridgeShuntCalEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIBridgeShuntCalEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeShuntCalGainAdjust(::grpc::ServerContext* context, const GetAIBridgeShuntCalGainAdjustRequest* request, GetAIBridgeShuntCalGainAdjustResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeShuntCalGainAdjust(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeShuntCalSelect(::grpc::ServerContext* context, const GetAIBridgeShuntCalSelectRequest* request, GetAIBridgeShuntCalSelectResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIBridgeShuntCalSelect(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ShuntCalSelect>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeShuntCalShuntCalAActualResistance(::grpc::ServerContext* context, const GetAIBridgeShuntCalShuntCalAActualResistanceRequest* request, GetAIBridgeShuntCalShuntCalAActualResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeShuntCalShuntCalAActualResistance(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeShuntCalShuntCalAResistance(::grpc::ServerContext* context, const GetAIBridgeShuntCalShuntCalAResistanceRequest* request, GetAIBridgeShuntCalShuntCalAResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeShuntCalShuntCalAResistance(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeShuntCalShuntCalASrc(::grpc::ServerContext* context, const GetAIBridgeShuntCalShuntCalASrcRequest* request, GetAIBridgeShuntCalShuntCalASrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIBridgeShuntCalShuntCalASrc(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::BridgeShuntCalSource>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeShuntCalShuntCalBActualResistance(::grpc::ServerContext* context, const GetAIBridgeShuntCalShuntCalBActualResistanceRequest* request, GetAIBridgeShuntCalShuntCalBActualResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeShuntCalShuntCalBActualResistance(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeShuntCalShuntCalBResistance(::grpc::ServerContext* context, const GetAIBridgeShuntCalShuntCalBResistanceRequest* request, GetAIBridgeShuntCalShuntCalBResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeShuntCalShuntCalBResistance(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeTableElectricalVals(::grpc::ServerContext* context, const GetAIBridgeTableElectricalValsRequest* request, GetAIBridgeTableElectricalValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIBridgeTableElectricalVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeTablePhysicalVals(::grpc::ServerContext* context, const GetAIBridgeTablePhysicalValsRequest* request, GetAIBridgeTablePhysicalValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIBridgeTablePhysicalVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeTwoPointLinFirstElectricalVal(::grpc::ServerContext* context, const GetAIBridgeTwoPointLinFirstElectricalValRequest* request, GetAIBridgeTwoPointLinFirstElectricalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeTwoPointLinFirstElectricalVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeTwoPointLinFirstPhysicalVal(::grpc::ServerContext* context, const GetAIBridgeTwoPointLinFirstPhysicalValRequest* request, GetAIBridgeTwoPointLinFirstPhysicalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeTwoPointLinFirstPhysicalVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeTwoPointLinSecondElectricalVal(::grpc::ServerContext* context, const GetAIBridgeTwoPointLinSecondElectricalValRequest* request, GetAIBridgeTwoPointLinSecondElectricalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeTwoPointLinSecondElectricalVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeTwoPointLinSecondPhysicalVal(::grpc::ServerContext* context, const GetAIBridgeTwoPointLinSecondPhysicalValRequest* request, GetAIBridgeTwoPointLinSecondPhysicalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIBridgeTwoPointLinSecondPhysicalVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIBridgeUnits(::grpc::ServerContext* context, const GetAIBridgeUnitsRequest* request, GetAIBridgeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIBridgeUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::BridgeUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalApplyCalIfExp(::grpc::ServerContext* context, const GetAIChanCalApplyCalIfExpRequest* request, GetAIChanCalApplyCalIfExpResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIChanCalApplyCalIfExp(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalCalDate(::grpc::ServerContext* context, const GetAIChanCalCalDateRequest* request, GetAIChanCalCalDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetAIChanCalCalDate(task, channel_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status == 0) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalDesc(::grpc::ServerContext* context, const GetAIChanCalDescRequest* request, GetAIChanCalDescResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetAIChanCalDesc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalEnableCal(::grpc::ServerContext* context, const GetAIChanCalEnableCalRequest* request, GetAIChanCalEnableCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIChanCalEnableCal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalExpDate(::grpc::ServerContext* context, const GetAIChanCalExpDateRequest* request, GetAIChanCalExpDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetAIChanCalExpDate(task, channel_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status == 0) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalHasValidCalInfo(::grpc::ServerContext* context, const GetAIChanCalHasValidCalInfoRequest* request, GetAIChanCalHasValidCalInfoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIChanCalHasValidCalInfo(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalOperatorName(::grpc::ServerContext* context, const GetAIChanCalOperatorNameRequest* request, GetAIChanCalOperatorNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetAIChanCalOperatorName(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalPolyForwardCoeff(::grpc::ServerContext* context, const GetAIChanCalPolyForwardCoeffRequest* request, GetAIChanCalPolyForwardCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIChanCalPolyForwardCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalPolyReverseCoeff(::grpc::ServerContext* context, const GetAIChanCalPolyReverseCoeffRequest* request, GetAIChanCalPolyReverseCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIChanCalPolyReverseCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalScaleType(::grpc::ServerContext* context, const GetAIChanCalScaleTypeRequest* request, GetAIChanCalScaleTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIChanCalScaleType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ScaleType3>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalTablePreScaledVals(::grpc::ServerContext* context, const GetAIChanCalTablePreScaledValsRequest* request, GetAIChanCalTablePreScaledValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIChanCalTablePreScaledVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalTableScaledVals(::grpc::ServerContext* context, const GetAIChanCalTableScaledValsRequest* request, GetAIChanCalTableScaledValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIChanCalTableScaledVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalVerifAcqVals(::grpc::ServerContext* context, const GetAIChanCalVerifAcqValsRequest* request, GetAIChanCalVerifAcqValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIChanCalVerifAcqVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalVerifRefVals(::grpc::ServerContext* context, const GetAIChanCalVerifRefValsRequest* request, GetAIChanCalVerifRefValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIChanCalVerifRefVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChargeUnits(::grpc::ServerContext* context, const GetAIChargeUnitsRequest* request, GetAIChargeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIChargeUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ChargeUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChopEnable(::grpc::ServerContext* context, const GetAIChopEnableRequest* request, GetAIChopEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIChopEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAICoupling(::grpc::ServerContext* context, const GetAICouplingRequest* request, GetAICouplingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAICoupling(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Coupling1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAICurrentACRMSUnits(::grpc::ServerContext* context, const GetAICurrentACRMSUnitsRequest* request, GetAICurrentACRMSUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAICurrentACRMSUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::CurrentUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAICurrentShuntLoc(::grpc::ServerContext* context, const GetAICurrentShuntLocRequest* request, GetAICurrentShuntLocResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAICurrentShuntLoc(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::CurrentShuntResistorLocation1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAICurrentShuntResistance(::grpc::ServerContext* context, const GetAICurrentShuntResistanceRequest* request, GetAICurrentShuntResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAICurrentShuntResistance(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAICurrentUnits(::grpc::ServerContext* context, const GetAICurrentUnitsRequest* request, GetAICurrentUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAICurrentUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::CurrentUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAICustomScaleName(::grpc::ServerContext* context, const GetAICustomScaleNameRequest* request, GetAICustomScaleNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetAICustomScaleName(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDCOffset(::grpc::ServerContext* context, const GetAIDCOffsetRequest* request, GetAIDCOffsetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIDCOffset(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDataXferCustomThreshold(::grpc::ServerContext* context, const GetAIDataXferCustomThresholdRequest* request, GetAIDataXferCustomThresholdResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAIDataXferCustomThreshold(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDataXferMaxRate(::grpc::ServerContext* context, const GetAIDataXferMaxRateRequest* request, GetAIDataXferMaxRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIDataXferMaxRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDataXferMech(::grpc::ServerContext* context, const GetAIDataXferMechRequest* request, GetAIDataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIDataXferMech(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DataTransferMechanism>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDataXferReqCond(::grpc::ServerContext* context, const GetAIDataXferReqCondRequest* request, GetAIDataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIDataXferReqCond(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputDataTransferCondition>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDevScalingCoeff(::grpc::ServerContext* context, const GetAIDevScalingCoeffRequest* request, GetAIDevScalingCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIDevScalingCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrBandpassCenterFreq(::grpc::ServerContext* context, const GetAIDigFltrBandpassCenterFreqRequest* request, GetAIDigFltrBandpassCenterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIDigFltrBandpassCenterFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrBandpassWidth(::grpc::ServerContext* context, const GetAIDigFltrBandpassWidthRequest* request, GetAIDigFltrBandpassWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIDigFltrBandpassWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrCoeff(::grpc::ServerContext* context, const GetAIDigFltrCoeffRequest* request, GetAIDigFltrCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAIDigFltrCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrEnable(::grpc::ServerContext* context, const GetAIDigFltrEnableRequest* request, GetAIDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrHighpassCutoffFreq(::grpc::ServerContext* context, const GetAIDigFltrHighpassCutoffFreqRequest* request, GetAIDigFltrHighpassCutoffFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIDigFltrHighpassCutoffFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrLowpassCutoffFreq(::grpc::ServerContext* context, const GetAIDigFltrLowpassCutoffFreqRequest* request, GetAIDigFltrLowpassCutoffFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIDigFltrLowpassCutoffFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrNotchCenterFreq(::grpc::ServerContext* context, const GetAIDigFltrNotchCenterFreqRequest* request, GetAIDigFltrNotchCenterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIDigFltrNotchCenterFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrNotchWidth(::grpc::ServerContext* context, const GetAIDigFltrNotchWidthRequest* request, GetAIDigFltrNotchWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIDigFltrNotchWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrOrder(::grpc::ServerContext* context, const GetAIDigFltrOrderRequest* request, GetAIDigFltrOrderResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAIDigFltrOrder(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrResponse(::grpc::ServerContext* context, const GetAIDigFltrResponseRequest* request, GetAIDigFltrResponseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIDigFltrResponse(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::FilterResponse>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDigFltrType(::grpc::ServerContext* context, const GetAIDigFltrTypeRequest* request, GetAIDigFltrTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIDigFltrType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::FilterType2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIDitherEnable(::grpc::ServerContext* context, const GetAIDitherEnableRequest* request, GetAIDitherEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIDitherEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIEddyCurrentProxProbeSensitivity(::grpc::ServerContext* context, const GetAIEddyCurrentProxProbeSensitivityRequest* request, GetAIEddyCurrentProxProbeSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIEddyCurrentProxProbeSensitivity(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIEddyCurrentProxProbeSensitivityUnits(::grpc::ServerContext* context, const GetAIEddyCurrentProxProbeSensitivityUnitsRequest* request, GetAIEddyCurrentProxProbeSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIEddyCurrentProxProbeSensitivityUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::EddyCurrentProxProbeSensitivityUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIEddyCurrentProxProbeUnits(::grpc::ServerContext* context, const GetAIEddyCurrentProxProbeUnitsRequest* request, GetAIEddyCurrentProxProbeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIEddyCurrentProxProbeUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LengthUnits2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIEnhancedAliasRejectionEnable(::grpc::ServerContext* context, const GetAIEnhancedAliasRejectionEnableRequest* request, GetAIEnhancedAliasRejectionEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIEnhancedAliasRejectionEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIExcitActualVal(::grpc::ServerContext* context, const GetAIExcitActualValRequest* request, GetAIExcitActualValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIExcitActualVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIExcitDCorAC(::grpc::ServerContext* context, const GetAIExcitDCorACRequest* request, GetAIExcitDCorACResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIExcitDCorAC(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ExcitationDCorAC>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIExcitIdleOutputBehavior(::grpc::ServerContext* context, const GetAIExcitIdleOutputBehaviorRequest* request, GetAIExcitIdleOutputBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIExcitIdleOutputBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ExcitationIdleOutputBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIExcitSense(::grpc::ServerContext* context, const GetAIExcitSenseRequest* request, GetAIExcitSenseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIExcitSense(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Sense>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIExcitSrc(::grpc::ServerContext* context, const GetAIExcitSrcRequest* request, GetAIExcitSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIExcitSrc(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ExcitationSource>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIExcitUseForScaling(::grpc::ServerContext* context, const GetAIExcitUseForScalingRequest* request, GetAIExcitUseForScalingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIExcitUseForScaling(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIExcitUseMultiplexed(::grpc::ServerContext* context, const GetAIExcitUseMultiplexedRequest* request, GetAIExcitUseMultiplexedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIExcitUseMultiplexed(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIExcitVal(::grpc::ServerContext* context, const GetAIExcitValRequest* request, GetAIExcitValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIExcitVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIExcitVoltageOrCurrent(::grpc::ServerContext* context, const GetAIExcitVoltageOrCurrentRequest* request, GetAIExcitVoltageOrCurrentResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIExcitVoltageOrCurrent(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ExcitationVoltageOrCurrent>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIFilterDelay(::grpc::ServerContext* context, const GetAIFilterDelayRequest* request, GetAIFilterDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIFilterDelay(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIFilterDelayAdjustment(::grpc::ServerContext* context, const GetAIFilterDelayAdjustmentRequest* request, GetAIFilterDelayAdjustmentResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIFilterDelayAdjustment(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIFilterDelayUnits(::grpc::ServerContext* context, const GetAIFilterDelayUnitsRequest* request, GetAIFilterDelayUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIFilterDelayUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DigitalWidthUnits4>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIFilterEnable(::grpc::ServerContext* context, const GetAIFilterEnableRequest* request, GetAIFilterEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIFilterEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIFilterFreq(::grpc::ServerContext* context, const GetAIFilterFreqRequest* request, GetAIFilterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIFilterFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIFilterOrder(::grpc::ServerContext* context, const GetAIFilterOrderRequest* request, GetAIFilterOrderResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAIFilterOrder(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIFilterResponse(::grpc::ServerContext* context, const GetAIFilterResponseRequest* request, GetAIFilterResponseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIFilterResponse(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::FilterResponse1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIForceIEPESensorSensitivity(::grpc::ServerContext* context, const GetAIForceIEPESensorSensitivityRequest* request, GetAIForceIEPESensorSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIForceIEPESensorSensitivity(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIForceIEPESensorSensitivityUnits(::grpc::ServerContext* context, const GetAIForceIEPESensorSensitivityUnitsRequest* request, GetAIForceIEPESensorSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIForceIEPESensorSensitivityUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ForceIEPESensorSensitivityUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIForceReadFromChan(::grpc::ServerContext* context, const GetAIForceReadFromChanRequest* request, GetAIForceReadFromChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIForceReadFromChan(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIForceUnits(::grpc::ServerContext* context, const GetAIForceUnitsRequest* request, GetAIForceUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIForceUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ForceUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIFreqHyst(::grpc::ServerContext* context, const GetAIFreqHystRequest* request, GetAIFreqHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIFreqHyst(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIFreqThreshVoltage(::grpc::ServerContext* context, const GetAIFreqThreshVoltageRequest* request, GetAIFreqThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIFreqThreshVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIFreqUnits(::grpc::ServerContext* context, const GetAIFreqUnitsRequest* request, GetAIFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIFreqUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::FrequencyUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIGain(::grpc::ServerContext* context, const GetAIGainRequest* request, GetAIGainResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIGain(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIInputLimitsFaultDetectEnable(::grpc::ServerContext* context, const GetAIInputLimitsFaultDetectEnableRequest* request, GetAIInputLimitsFaultDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIInputLimitsFaultDetectEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIInputLimitsFaultDetectLowerLimit(::grpc::ServerContext* context, const GetAIInputLimitsFaultDetectLowerLimitRequest* request, GetAIInputLimitsFaultDetectLowerLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIInputLimitsFaultDetectLowerLimit(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIInputLimitsFaultDetectUpperLimit(::grpc::ServerContext* context, const GetAIInputLimitsFaultDetectUpperLimitRequest* request, GetAIInputLimitsFaultDetectUpperLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIInputLimitsFaultDetectUpperLimit(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIInputSrc(::grpc::ServerContext* context, const GetAIInputSrcRequest* request, GetAIInputSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetAIInputSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIIsTEDS(::grpc::ServerContext* context, const GetAIIsTEDSRequest* request, GetAIIsTEDSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIIsTEDS(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILVDTSensitivity(::grpc::ServerContext* context, const GetAILVDTSensitivityRequest* request, GetAILVDTSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAILVDTSensitivity(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILVDTSensitivityUnits(::grpc::ServerContext* context, const GetAILVDTSensitivityUnitsRequest* request, GetAILVDTSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAILVDTSensitivityUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LVDTSensitivityUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILVDTUnits(::grpc::ServerContext* context, const GetAILVDTUnitsRequest* request, GetAILVDTUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAILVDTUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LengthUnits2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILeadWireResistance(::grpc::ServerContext* context, const GetAILeadWireResistanceRequest* request, GetAILeadWireResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAILeadWireResistance(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILossyLSBRemovalCompressedSampSize(::grpc::ServerContext* context, const GetAILossyLSBRemovalCompressedSampSizeRequest* request, GetAILossyLSBRemovalCompressedSampSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAILossyLSBRemovalCompressedSampSize(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILowpassCutoffFreq(::grpc::ServerContext* context, const GetAILowpassCutoffFreqRequest* request, GetAILowpassCutoffFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAILowpassCutoffFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILowpassEnable(::grpc::ServerContext* context, const GetAILowpassEnableRequest* request, GetAILowpassEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAILowpassEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILowpassSwitchCapClkSrc(::grpc::ServerContext* context, const GetAILowpassSwitchCapClkSrcRequest* request, GetAILowpassSwitchCapClkSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAILowpassSwitchCapClkSrc(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::SourceSelection>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILowpassSwitchCapExtClkDiv(::grpc::ServerContext* context, const GetAILowpassSwitchCapExtClkDivRequest* request, GetAILowpassSwitchCapExtClkDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAILowpassSwitchCapExtClkDiv(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILowpassSwitchCapExtClkFreq(::grpc::ServerContext* context, const GetAILowpassSwitchCapExtClkFreqRequest* request, GetAILowpassSwitchCapExtClkFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAILowpassSwitchCapExtClkFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAILowpassSwitchCapOutClkDiv(::grpc::ServerContext* context, const GetAILowpassSwitchCapOutClkDivRequest* request, GetAILowpassSwitchCapOutClkDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAILowpassSwitchCapOutClkDiv(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIMax(::grpc::ServerContext* context, const GetAIMaxRequest* request, GetAIMaxResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIMax(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIMeasType(::grpc::ServerContext* context, const GetAIMeasTypeRequest* request, GetAIMeasTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIMeasType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AIMeasurementType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIMemMapEnable(::grpc::ServerContext* context, const GetAIMemMapEnableRequest* request, GetAIMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIMemMapEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIMicrophoneSensitivity(::grpc::ServerContext* context, const GetAIMicrophoneSensitivityRequest* request, GetAIMicrophoneSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIMicrophoneSensitivity(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIMin(::grpc::ServerContext* context, const GetAIMinRequest* request, GetAIMinResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIMin(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIOpenChanDetectEnable(::grpc::ServerContext* context, const GetAIOpenChanDetectEnableRequest* request, GetAIOpenChanDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIOpenChanDetectEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIOpenThrmcplDetectEnable(::grpc::ServerContext* context, const GetAIOpenThrmcplDetectEnableRequest* request, GetAIOpenThrmcplDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIOpenThrmcplDetectEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIOvercurrentDetectEnable(::grpc::ServerContext* context, const GetAIOvercurrentDetectEnableRequest* request, GetAIOvercurrentDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIOvercurrentDetectEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIPowerSupplyFaultDetectEnable(::grpc::ServerContext* context, const GetAIPowerSupplyFaultDetectEnableRequest* request, GetAIPowerSupplyFaultDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIPowerSupplyFaultDetectEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIPressureUnits(::grpc::ServerContext* context, const GetAIPressureUnitsRequest* request, GetAIPressureUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIPressureUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::PressureUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIProbeAtten(::grpc::ServerContext* context, const GetAIProbeAttenRequest* request, GetAIProbeAttenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIProbeAtten(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRTDA(::grpc::ServerContext* context, const GetAIRTDARequest* request, GetAIRTDAResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIRTDA(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRTDB(::grpc::ServerContext* context, const GetAIRTDBRequest* request, GetAIRTDBResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIRTDB(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRTDC(::grpc::ServerContext* context, const GetAIRTDCRequest* request, GetAIRTDCResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIRTDC(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRTDR0(::grpc::ServerContext* context, const GetAIRTDR0Request* request, GetAIRTDR0Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIRTDR0(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRTDType(::grpc::ServerContext* context, const GetAIRTDTypeRequest* request, GetAIRTDTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIRTDType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::RTDType1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRVDTSensitivity(::grpc::ServerContext* context, const GetAIRVDTSensitivityRequest* request, GetAIRVDTSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIRVDTSensitivity(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRVDTSensitivityUnits(::grpc::ServerContext* context, const GetAIRVDTSensitivityUnitsRequest* request, GetAIRVDTSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIRVDTSensitivityUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::RVDTSensitivityUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRVDTUnits(::grpc::ServerContext* context, const GetAIRVDTUnitsRequest* request, GetAIRVDTUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIRVDTUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AngleUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRawDataCompressionType(::grpc::ServerContext* context, const GetAIRawDataCompressionTypeRequest* request, GetAIRawDataCompressionTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIRawDataCompressionType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::RawDataCompressionType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRawSampJustification(::grpc::ServerContext* context, const GetAIRawSampJustificationRequest* request, GetAIRawSampJustificationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIRawSampJustification(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DataJustification1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRawSampSize(::grpc::ServerContext* context, const GetAIRawSampSizeRequest* request, GetAIRawSampSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAIRawSampSize(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRemoveFilterDelay(::grpc::ServerContext* context, const GetAIRemoveFilterDelayRequest* request, GetAIRemoveFilterDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIRemoveFilterDelay(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIResistanceCfg(::grpc::ServerContext* context, const GetAIResistanceCfgRequest* request, GetAIResistanceCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIResistanceCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ResistanceConfiguration>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIResistanceUnits(::grpc::ServerContext* context, const GetAIResistanceUnitsRequest* request, GetAIResistanceUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIResistanceUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ResistanceUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIResolution(::grpc::ServerContext* context, const GetAIResolutionRequest* request, GetAIResolutionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIResolution(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIResolutionUnits(::grpc::ServerContext* context, const GetAIResolutionUnitsRequest* request, GetAIResolutionUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIResolutionUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ResolutionType1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRngHigh(::grpc::ServerContext* context, const GetAIRngHighRequest* request, GetAIRngHighResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIRngHigh(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRngLow(::grpc::ServerContext* context, const GetAIRngLowRequest* request, GetAIRngLowResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIRngLow(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRosetteStrainGageOrientation(::grpc::ServerContext* context, const GetAIRosetteStrainGageOrientationRequest* request, GetAIRosetteStrainGageOrientationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIRosetteStrainGageOrientation(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRosetteStrainGageRosetteMeasType(::grpc::ServerContext* context, const GetAIRosetteStrainGageRosetteMeasTypeRequest* request, GetAIRosetteStrainGageRosetteMeasTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIRosetteStrainGageRosetteMeasType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::StrainGageRosetteMeasurementType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRosetteStrainGageRosetteType(::grpc::ServerContext* context, const GetAIRosetteStrainGageRosetteTypeRequest* request, GetAIRosetteStrainGageRosetteTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIRosetteStrainGageRosetteType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::StrainGageRosetteType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIRosetteStrainGageStrainChans(::grpc::ServerContext* context, const GetAIRosetteStrainGageStrainChansRequest* request, GetAIRosetteStrainGageStrainChansResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetAIRosetteStrainGageStrainChans(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAISampAndHoldEnable(::grpc::ServerContext* context, const GetAISampAndHoldEnableRequest* request, GetAISampAndHoldEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAISampAndHoldEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAISensorPowerCfg(::grpc::ServerContext* context, const GetAISensorPowerCfgRequest* request, GetAISensorPowerCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAISensorPowerCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::SensorPowerCfg>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAISensorPowerType(::grpc::ServerContext* context, const GetAISensorPowerTypeRequest* request, GetAISensorPowerTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAISensorPowerType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::SensorPowerType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAISensorPowerVoltage(::grpc::ServerContext* context, const GetAISensorPowerVoltageRequest* request, GetAISensorPowerVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAISensorPowerVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAISoundPressureMaxSoundPressureLvl(::grpc::ServerContext* context, const GetAISoundPressureMaxSoundPressureLvlRequest* request, GetAISoundPressureMaxSoundPressureLvlResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAISoundPressureMaxSoundPressureLvl(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAISoundPressureUnits(::grpc::ServerContext* context, const GetAISoundPressureUnitsRequest* request, GetAISoundPressureUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAISoundPressureUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::SoundPressureUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAISoundPressuredBRef(::grpc::ServerContext* context, const GetAISoundPressuredBRefRequest* request, GetAISoundPressuredBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAISoundPressuredBRef(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIStrainGageCfg(::grpc::ServerContext* context, const GetAIStrainGageCfgRequest* request, GetAIStrainGageCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIStrainGageCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::StrainGageBridgeType1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIStrainGageForceReadFromChan(::grpc::ServerContext* context, const GetAIStrainGageForceReadFromChanRequest* request, GetAIStrainGageForceReadFromChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAIStrainGageForceReadFromChan(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIStrainGageGageFactor(::grpc::ServerContext* context, const GetAIStrainGageGageFactorRequest* request, GetAIStrainGageGageFactorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIStrainGageGageFactor(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIStrainGagePoissonRatio(::grpc::ServerContext* context, const GetAIStrainGagePoissonRatioRequest* request, GetAIStrainGagePoissonRatioResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIStrainGagePoissonRatio(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIStrainUnits(::grpc::ServerContext* context, const GetAIStrainUnitsRequest* request, GetAIStrainUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIStrainUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::StrainUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAITEDSUnits(::grpc::ServerContext* context, const GetAITEDSUnitsRequest* request, GetAITEDSUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetAITEDSUnits(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAITempUnits(::grpc::ServerContext* context, const GetAITempUnitsRequest* request, GetAITempUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAITempUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::TemperatureUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAITermCfg(::grpc::ServerContext* context, const GetAITermCfgRequest* request, GetAITermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAITermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIThrmcplCJCChan(::grpc::ServerContext* context, const GetAIThrmcplCJCChanRequest* request, GetAIThrmcplCJCChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetAIThrmcplCJCChan(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIThrmcplCJCSrc(::grpc::ServerContext* context, const GetAIThrmcplCJCSrcRequest* request, GetAIThrmcplCJCSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIThrmcplCJCSrc(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::CJCSource1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIThrmcplCJCVal(::grpc::ServerContext* context, const GetAIThrmcplCJCValRequest* request, GetAIThrmcplCJCValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIThrmcplCJCVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIThrmcplLeadOffsetVoltage(::grpc::ServerContext* context, const GetAIThrmcplLeadOffsetVoltageRequest* request, GetAIThrmcplLeadOffsetVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIThrmcplLeadOffsetVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIThrmcplScaleType(::grpc::ServerContext* context, const GetAIThrmcplScaleTypeRequest* request, GetAIThrmcplScaleTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIThrmcplScaleType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ScaleType2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIThrmcplType(::grpc::ServerContext* context, const GetAIThrmcplTypeRequest* request, GetAIThrmcplTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIThrmcplType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ThermocoupleType1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIThrmstrA(::grpc::ServerContext* context, const GetAIThrmstrARequest* request, GetAIThrmstrAResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIThrmstrA(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIThrmstrB(::grpc::ServerContext* context, const GetAIThrmstrBRequest* request, GetAIThrmstrBResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIThrmstrB(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIThrmstrC(::grpc::ServerContext* context, const GetAIThrmstrCRequest* request, GetAIThrmstrCResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIThrmstrC(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIThrmstrR1(::grpc::ServerContext* context, const GetAIThrmstrR1Request* request, GetAIThrmstrR1Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIThrmstrR1(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAITorqueUnits(::grpc::ServerContext* context, const GetAITorqueUnitsRequest* request, GetAITorqueUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAITorqueUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::TorqueUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIUsbXferReqCount(::grpc::ServerContext* context, const GetAIUsbXferReqCountRequest* request, GetAIUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAIUsbXferReqCount(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIUsbXferReqSize(::grpc::ServerContext* context, const GetAIUsbXferReqSizeRequest* request, GetAIUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAIUsbXferReqSize(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIVelocityIEPESensorSensitivity(::grpc::ServerContext* context, const GetAIVelocityIEPESensorSensitivityRequest* request, GetAIVelocityIEPESensorSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIVelocityIEPESensorSensitivity(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIVelocityIEPESensorSensitivityUnits(::grpc::ServerContext* context, const GetAIVelocityIEPESensorSensitivityUnitsRequest* request, GetAIVelocityIEPESensorSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIVelocityIEPESensorSensitivityUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::VelocityIEPESensorSensitivityUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIVelocityIEPESensordBRef(::grpc::ServerContext* context, const GetAIVelocityIEPESensordBRefRequest* request, GetAIVelocityIEPESensordBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIVelocityIEPESensordBRef(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIVelocityUnits(::grpc::ServerContext* context, const GetAIVelocityUnitsRequest* request, GetAIVelocityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIVelocityUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::VelocityUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIVoltageACRMSUnits(::grpc::ServerContext* context, const GetAIVoltageACRMSUnitsRequest* request, GetAIVoltageACRMSUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIVoltageACRMSUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::VoltageUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIVoltageUnits(::grpc::ServerContext* context, const GetAIVoltageUnitsRequest* request, GetAIVoltageUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAIVoltageUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::VoltageUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIVoltagedBRef(::grpc::ServerContext* context, const GetAIVoltagedBRefRequest* request, GetAIVoltagedBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAIVoltagedBRef(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOCurrentUnits(::grpc::ServerContext* context, const GetAOCurrentUnitsRequest* request, GetAOCurrentUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAOCurrentUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::CurrentUnits1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOCustomScaleName(::grpc::ServerContext* context, const GetAOCustomScaleNameRequest* request, GetAOCustomScaleNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetAOCustomScaleName(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODACOffsetExtSrc(::grpc::ServerContext* context, const GetAODACOffsetExtSrcRequest* request, GetAODACOffsetExtSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetAODACOffsetExtSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODACOffsetSrc(::grpc::ServerContext* context, const GetAODACOffsetSrcRequest* request, GetAODACOffsetSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAODACOffsetSrc(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::SourceSelection>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODACOffsetVal(::grpc::ServerContext* context, const GetAODACOffsetValRequest* request, GetAODACOffsetValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAODACOffsetVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODACRefAllowConnToGnd(::grpc::ServerContext* context, const GetAODACRefAllowConnToGndRequest* request, GetAODACRefAllowConnToGndResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAODACRefAllowConnToGnd(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODACRefConnToGnd(::grpc::ServerContext* context, const GetAODACRefConnToGndRequest* request, GetAODACRefConnToGndResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAODACRefConnToGnd(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODACRefExtSrc(::grpc::ServerContext* context, const GetAODACRefExtSrcRequest* request, GetAODACRefExtSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetAODACRefExtSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODACRefSrc(::grpc::ServerContext* context, const GetAODACRefSrcRequest* request, GetAODACRefSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAODACRefSrc(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::SourceSelection>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODACRefVal(::grpc::ServerContext* context, const GetAODACRefValRequest* request, GetAODACRefValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAODACRefVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODACRngHigh(::grpc::ServerContext* context, const GetAODACRngHighRequest* request, GetAODACRngHighResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAODACRngHigh(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODACRngLow(::grpc::ServerContext* context, const GetAODACRngLowRequest* request, GetAODACRngLowResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAODACRngLow(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODataXferMech(::grpc::ServerContext* context, const GetAODataXferMechRequest* request, GetAODataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAODataXferMech(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DataTransferMechanism>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODataXferReqCond(::grpc::ServerContext* context, const GetAODataXferReqCondRequest* request, GetAODataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAODataXferReqCond(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::OutputDataTransferCondition>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAODevScalingCoeff(::grpc::ServerContext* context, const GetAODevScalingCoeffRequest* request, GetAODevScalingCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->GetAODevScalingCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOEnhancedImageRejectionEnable(::grpc::ServerContext* context, const GetAOEnhancedImageRejectionEnableRequest* request, GetAOEnhancedImageRejectionEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAOEnhancedImageRejectionEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOFilterDelay(::grpc::ServerContext* context, const GetAOFilterDelayRequest* request, GetAOFilterDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOFilterDelay(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOFilterDelayAdjustment(::grpc::ServerContext* context, const GetAOFilterDelayAdjustmentRequest* request, GetAOFilterDelayAdjustmentResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOFilterDelayAdjustment(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOFilterDelayUnits(::grpc::ServerContext* context, const GetAOFilterDelayUnitsRequest* request, GetAOFilterDelayUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAOFilterDelayUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DigitalWidthUnits4>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOFuncGenAmplitude(::grpc::ServerContext* context, const GetAOFuncGenAmplitudeRequest* request, GetAOFuncGenAmplitudeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOFuncGenAmplitude(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOFuncGenFMDeviation(::grpc::ServerContext* context, const GetAOFuncGenFMDeviationRequest* request, GetAOFuncGenFMDeviationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOFuncGenFMDeviation(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOFuncGenFreq(::grpc::ServerContext* context, const GetAOFuncGenFreqRequest* request, GetAOFuncGenFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOFuncGenFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOFuncGenModulationType(::grpc::ServerContext* context, const GetAOFuncGenModulationTypeRequest* request, GetAOFuncGenModulationTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAOFuncGenModulationType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ModulationType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOFuncGenOffset(::grpc::ServerContext* context, const GetAOFuncGenOffsetRequest* request, GetAOFuncGenOffsetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOFuncGenOffset(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOFuncGenSquareDutyCycle(::grpc::ServerContext* context, const GetAOFuncGenSquareDutyCycleRequest* request, GetAOFuncGenSquareDutyCycleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOFuncGenSquareDutyCycle(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOFuncGenType(::grpc::ServerContext* context, const GetAOFuncGenTypeRequest* request, GetAOFuncGenTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAOFuncGenType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::FuncGenType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOGain(::grpc::ServerContext* context, const GetAOGainRequest* request, GetAOGainResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOGain(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOIdleOutputBehavior(::grpc::ServerContext* context, const GetAOIdleOutputBehaviorRequest* request, GetAOIdleOutputBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAOIdleOutputBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AOIdleOutputBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOLoadImpedance(::grpc::ServerContext* context, const GetAOLoadImpedanceRequest* request, GetAOLoadImpedanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOLoadImpedance(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOMax(::grpc::ServerContext* context, const GetAOMaxRequest* request, GetAOMaxResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOMax(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOMemMapEnable(::grpc::ServerContext* context, const GetAOMemMapEnableRequest* request, GetAOMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAOMemMapEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOMin(::grpc::ServerContext* context, const GetAOMinRequest* request, GetAOMinResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOMin(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOOutputImpedance(::grpc::ServerContext* context, const GetAOOutputImpedanceRequest* request, GetAOOutputImpedanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOOutputImpedance(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOOutputType(::grpc::ServerContext* context, const GetAOOutputTypeRequest* request, GetAOOutputTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAOOutputType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AOOutputChannelType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOReglitchEnable(::grpc::ServerContext* context, const GetAOReglitchEnableRequest* request, GetAOReglitchEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAOReglitchEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOResolution(::grpc::ServerContext* context, const GetAOResolutionRequest* request, GetAOResolutionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOResolution(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOResolutionUnits(::grpc::ServerContext* context, const GetAOResolutionUnitsRequest* request, GetAOResolutionUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAOResolutionUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ResolutionType1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOTermCfg(::grpc::ServerContext* context, const GetAOTermCfgRequest* request, GetAOTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAOTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::OutputTermCfg>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOUsbXferReqCount(::grpc::ServerContext* context, const GetAOUsbXferReqCountRequest* request, GetAOUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAOUsbXferReqCount(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOUsbXferReqSize(::grpc::ServerContext* context, const GetAOUsbXferReqSizeRequest* request, GetAOUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetAOUsbXferReqSize(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOUseOnlyOnBrdMem(::grpc::ServerContext* context, const GetAOUseOnlyOnBrdMemRequest* request, GetAOUseOnlyOnBrdMemResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetAOUseOnlyOnBrdMem(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOVoltageCurrentLimit(::grpc::ServerContext* context, const GetAOVoltageCurrentLimitRequest* request, GetAOVoltageCurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetAOVoltageCurrentLimit(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAOVoltageUnits(::grpc::ServerContext* context, const GetAOVoltageUnitsRequest* request, GetAOVoltageUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetAOVoltageUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::VoltageUnits2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetArmStartTrigTimestampVal(::grpc::ServerContext* context, const GetArmStartTrigTimestampValRequest* request, GetArmStartTrigTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetArmStartTrigTimestampVal(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetArmStartTrigTrigWhen(::grpc::ServerContext* context, const GetArmStartTrigTrigWhenRequest* request, GetArmStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetArmStartTrigTrigWhen(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAutoConfiguredCDAQSyncConnections(::grpc::ServerContext* context, const GetAutoConfiguredCDAQSyncConnectionsRequest* request, GetAutoConfiguredCDAQSyncConnectionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      uInt32 port_list_size = request->port_list_size();
      std::string port_list;
      if (port_list_size > 0) {
          port_list.resize(port_list_size-1);
      }
      auto status = library_->GetAutoConfiguredCDAQSyncConnections((char*)port_list.data(), port_list_size);
      response->set_status(status);
      if (status == 0) {
        response->set_port_list(port_list);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetBufInputBufSize(::grpc::ServerContext* context, const GetBufInputBufSizeRequest* request, GetBufInputBufSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 data {};
      auto status = library_->GetBufInputBufSize(task, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetBufInputOnbrdBufSize(::grpc::ServerContext* context, const GetBufInputOnbrdBufSizeRequest* request, GetBufInputOnbrdBufSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 data {};
      auto status = library_->GetBufInputOnbrdBufSize(task, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetBufOutputBufSize(::grpc::ServerContext* context, const GetBufOutputBufSizeRequest* request, GetBufOutputBufSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 data {};
      auto status = library_->GetBufOutputBufSize(task, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetBufOutputOnbrdBufSize(::grpc::ServerContext* context, const GetBufOutputOnbrdBufSizeRequest* request, GetBufOutputOnbrdBufSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 data {};
      auto status = library_->GetBufOutputOnbrdBufSize(task, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIAngEncoderInitialAngle(::grpc::ServerContext* context, const GetCIAngEncoderInitialAngleRequest* request, GetCIAngEncoderInitialAngleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIAngEncoderInitialAngle(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIAngEncoderPulsesPerRev(::grpc::ServerContext* context, const GetCIAngEncoderPulsesPerRevRequest* request, GetCIAngEncoderPulsesPerRevResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCIAngEncoderPulsesPerRev(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIAngEncoderUnits(::grpc::ServerContext* context, const GetCIAngEncoderUnitsRequest* request, GetCIAngEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIAngEncoderUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AngleUnits2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICount(::grpc::ServerContext* context, const GetCICountRequest* request, GetCICountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCICount(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesActiveEdge(::grpc::ServerContext* context, const GetCICountEdgesActiveEdgeRequest* request, GetCICountEdgesActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesActiveEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountDirDigFltrEnable(::grpc::ServerContext* context, const GetCICountEdgesCountDirDigFltrEnableRequest* request, GetCICountEdgesCountDirDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICountEdgesCountDirDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountDirDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCICountEdgesCountDirDigFltrMinPulseWidthRequest* request, GetCICountEdgesCountDirDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesCountDirDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountDirDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCICountEdgesCountDirDigFltrTimebaseRateRequest* request, GetCICountEdgesCountDirDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesCountDirDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountDirDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCICountEdgesCountDirDigFltrTimebaseSrcRequest* request, GetCICountEdgesCountDirDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICountEdgesCountDirDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountDirDigSyncEnable(::grpc::ServerContext* context, const GetCICountEdgesCountDirDigSyncEnableRequest* request, GetCICountEdgesCountDirDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICountEdgesCountDirDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountDirHyst(::grpc::ServerContext* context, const GetCICountEdgesCountDirHystRequest* request, GetCICountEdgesCountDirHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesCountDirHyst(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountDirLogicLvlBehavior(::grpc::ServerContext* context, const GetCICountEdgesCountDirLogicLvlBehaviorRequest* request, GetCICountEdgesCountDirLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesCountDirLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountDirTermCfg(::grpc::ServerContext* context, const GetCICountEdgesCountDirTermCfgRequest* request, GetCICountEdgesCountDirTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesCountDirTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountDirThreshVoltage(::grpc::ServerContext* context, const GetCICountEdgesCountDirThreshVoltageRequest* request, GetCICountEdgesCountDirThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesCountDirThreshVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetActiveEdge(::grpc::ServerContext* context, const GetCICountEdgesCountResetActiveEdgeRequest* request, GetCICountEdgesCountResetActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesCountResetActiveEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetDigFltrEnable(::grpc::ServerContext* context, const GetCICountEdgesCountResetDigFltrEnableRequest* request, GetCICountEdgesCountResetDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICountEdgesCountResetDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCICountEdgesCountResetDigFltrMinPulseWidthRequest* request, GetCICountEdgesCountResetDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesCountResetDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCICountEdgesCountResetDigFltrTimebaseRateRequest* request, GetCICountEdgesCountResetDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesCountResetDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCICountEdgesCountResetDigFltrTimebaseSrcRequest* request, GetCICountEdgesCountResetDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICountEdgesCountResetDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetDigSyncEnable(::grpc::ServerContext* context, const GetCICountEdgesCountResetDigSyncEnableRequest* request, GetCICountEdgesCountResetDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICountEdgesCountResetDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetEnable(::grpc::ServerContext* context, const GetCICountEdgesCountResetEnableRequest* request, GetCICountEdgesCountResetEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICountEdgesCountResetEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetHyst(::grpc::ServerContext* context, const GetCICountEdgesCountResetHystRequest* request, GetCICountEdgesCountResetHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesCountResetHyst(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetLogicLvlBehavior(::grpc::ServerContext* context, const GetCICountEdgesCountResetLogicLvlBehaviorRequest* request, GetCICountEdgesCountResetLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesCountResetLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetResetCount(::grpc::ServerContext* context, const GetCICountEdgesCountResetResetCountRequest* request, GetCICountEdgesCountResetResetCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCICountEdgesCountResetResetCount(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetTerm(::grpc::ServerContext* context, const GetCICountEdgesCountResetTermRequest* request, GetCICountEdgesCountResetTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICountEdgesCountResetTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetTermCfg(::grpc::ServerContext* context, const GetCICountEdgesCountResetTermCfgRequest* request, GetCICountEdgesCountResetTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesCountResetTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesCountResetThreshVoltage(::grpc::ServerContext* context, const GetCICountEdgesCountResetThreshVoltageRequest* request, GetCICountEdgesCountResetThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesCountResetThreshVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesDigFltrEnable(::grpc::ServerContext* context, const GetCICountEdgesDigFltrEnableRequest* request, GetCICountEdgesDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICountEdgesDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCICountEdgesDigFltrMinPulseWidthRequest* request, GetCICountEdgesDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCICountEdgesDigFltrTimebaseRateRequest* request, GetCICountEdgesDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCICountEdgesDigFltrTimebaseSrcRequest* request, GetCICountEdgesDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICountEdgesDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesDigSyncEnable(::grpc::ServerContext* context, const GetCICountEdgesDigSyncEnableRequest* request, GetCICountEdgesDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICountEdgesDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesDir(::grpc::ServerContext* context, const GetCICountEdgesDirRequest* request, GetCICountEdgesDirResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesDir(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::CountDirection1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesDirTerm(::grpc::ServerContext* context, const GetCICountEdgesDirTermRequest* request, GetCICountEdgesDirTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICountEdgesDirTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateDigFltrEnable(::grpc::ServerContext* context, const GetCICountEdgesGateDigFltrEnableRequest* request, GetCICountEdgesGateDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICountEdgesGateDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCICountEdgesGateDigFltrMinPulseWidthRequest* request, GetCICountEdgesGateDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesGateDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCICountEdgesGateDigFltrTimebaseRateRequest* request, GetCICountEdgesGateDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesGateDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCICountEdgesGateDigFltrTimebaseSrcRequest* request, GetCICountEdgesGateDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICountEdgesGateDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateEnable(::grpc::ServerContext* context, const GetCICountEdgesGateEnableRequest* request, GetCICountEdgesGateEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICountEdgesGateEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateHyst(::grpc::ServerContext* context, const GetCICountEdgesGateHystRequest* request, GetCICountEdgesGateHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesGateHyst(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateLogicLvlBehavior(::grpc::ServerContext* context, const GetCICountEdgesGateLogicLvlBehaviorRequest* request, GetCICountEdgesGateLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesGateLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateTerm(::grpc::ServerContext* context, const GetCICountEdgesGateTermRequest* request, GetCICountEdgesGateTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICountEdgesGateTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateTermCfg(::grpc::ServerContext* context, const GetCICountEdgesGateTermCfgRequest* request, GetCICountEdgesGateTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesGateTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateThreshVoltage(::grpc::ServerContext* context, const GetCICountEdgesGateThreshVoltageRequest* request, GetCICountEdgesGateThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesGateThreshVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesGateWhen(::grpc::ServerContext* context, const GetCICountEdgesGateWhenRequest* request, GetCICountEdgesGateWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesGateWhen(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Level1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesHyst(::grpc::ServerContext* context, const GetCICountEdgesHystRequest* request, GetCICountEdgesHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesHyst(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesInitialCnt(::grpc::ServerContext* context, const GetCICountEdgesInitialCntRequest* request, GetCICountEdgesInitialCntResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCICountEdgesInitialCnt(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesLogicLvlBehavior(::grpc::ServerContext* context, const GetCICountEdgesLogicLvlBehaviorRequest* request, GetCICountEdgesLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesTerm(::grpc::ServerContext* context, const GetCICountEdgesTermRequest* request, GetCICountEdgesTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICountEdgesTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesTermCfg(::grpc::ServerContext* context, const GetCICountEdgesTermCfgRequest* request, GetCICountEdgesTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICountEdgesTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICountEdgesThreshVoltage(::grpc::ServerContext* context, const GetCICountEdgesThreshVoltageRequest* request, GetCICountEdgesThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICountEdgesThreshVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICtrTimebaseActiveEdge(::grpc::ServerContext* context, const GetCICtrTimebaseActiveEdgeRequest* request, GetCICtrTimebaseActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCICtrTimebaseActiveEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICtrTimebaseDigFltrEnable(::grpc::ServerContext* context, const GetCICtrTimebaseDigFltrEnableRequest* request, GetCICtrTimebaseDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICtrTimebaseDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICtrTimebaseDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCICtrTimebaseDigFltrMinPulseWidthRequest* request, GetCICtrTimebaseDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICtrTimebaseDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICtrTimebaseDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCICtrTimebaseDigFltrTimebaseRateRequest* request, GetCICtrTimebaseDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICtrTimebaseDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICtrTimebaseDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCICtrTimebaseDigFltrTimebaseSrcRequest* request, GetCICtrTimebaseDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICtrTimebaseDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICtrTimebaseDigSyncEnable(::grpc::ServerContext* context, const GetCICtrTimebaseDigSyncEnableRequest* request, GetCICtrTimebaseDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCICtrTimebaseDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICtrTimebaseMasterTimebaseDiv(::grpc::ServerContext* context, const GetCICtrTimebaseMasterTimebaseDivRequest* request, GetCICtrTimebaseMasterTimebaseDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCICtrTimebaseMasterTimebaseDiv(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICtrTimebaseRate(::grpc::ServerContext* context, const GetCICtrTimebaseRateRequest* request, GetCICtrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCICtrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICtrTimebaseSrc(::grpc::ServerContext* context, const GetCICtrTimebaseSrcRequest* request, GetCICtrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICtrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCICustomScaleName(::grpc::ServerContext* context, const GetCICustomScaleNameRequest* request, GetCICustomScaleNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCICustomScaleName(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDataXferMech(::grpc::ServerContext* context, const GetCIDataXferMechRequest* request, GetCIDataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIDataXferMech(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DataTransferMechanism>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDataXferReqCond(::grpc::ServerContext* context, const GetCIDataXferReqCondRequest* request, GetCIDataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIDataXferReqCond(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputDataTransferCondition>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDupCountPrevent(::grpc::ServerContext* context, const GetCIDupCountPreventRequest* request, GetCIDupCountPreventResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIDupCountPrevent(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDutyCycleDigFltrEnable(::grpc::ServerContext* context, const GetCIDutyCycleDigFltrEnableRequest* request, GetCIDutyCycleDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIDutyCycleDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDutyCycleDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIDutyCycleDigFltrMinPulseWidthRequest* request, GetCIDutyCycleDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIDutyCycleDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDutyCycleDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIDutyCycleDigFltrTimebaseRateRequest* request, GetCIDutyCycleDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIDutyCycleDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDutyCycleDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIDutyCycleDigFltrTimebaseSrcRequest* request, GetCIDutyCycleDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIDutyCycleDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDutyCycleLogicLvlBehavior(::grpc::ServerContext* context, const GetCIDutyCycleLogicLvlBehaviorRequest* request, GetCIDutyCycleLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIDutyCycleLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDutyCycleStartingEdge(::grpc::ServerContext* context, const GetCIDutyCycleStartingEdgeRequest* request, GetCIDutyCycleStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIDutyCycleStartingEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDutyCycleTerm(::grpc::ServerContext* context, const GetCIDutyCycleTermRequest* request, GetCIDutyCycleTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIDutyCycleTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIDutyCycleTermCfg(::grpc::ServerContext* context, const GetCIDutyCycleTermCfgRequest* request, GetCIDutyCycleTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIDutyCycleTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderAInputDigFltrEnable(::grpc::ServerContext* context, const GetCIEncoderAInputDigFltrEnableRequest* request, GetCIEncoderAInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIEncoderAInputDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderAInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIEncoderAInputDigFltrMinPulseWidthRequest* request, GetCIEncoderAInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIEncoderAInputDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderAInputDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIEncoderAInputDigFltrTimebaseRateRequest* request, GetCIEncoderAInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIEncoderAInputDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderAInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIEncoderAInputDigFltrTimebaseSrcRequest* request, GetCIEncoderAInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIEncoderAInputDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderAInputDigSyncEnable(::grpc::ServerContext* context, const GetCIEncoderAInputDigSyncEnableRequest* request, GetCIEncoderAInputDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIEncoderAInputDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderAInputLogicLvlBehavior(::grpc::ServerContext* context, const GetCIEncoderAInputLogicLvlBehaviorRequest* request, GetCIEncoderAInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIEncoderAInputLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderAInputTerm(::grpc::ServerContext* context, const GetCIEncoderAInputTermRequest* request, GetCIEncoderAInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIEncoderAInputTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderAInputTermCfg(::grpc::ServerContext* context, const GetCIEncoderAInputTermCfgRequest* request, GetCIEncoderAInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIEncoderAInputTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderBInputDigFltrEnable(::grpc::ServerContext* context, const GetCIEncoderBInputDigFltrEnableRequest* request, GetCIEncoderBInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIEncoderBInputDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderBInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIEncoderBInputDigFltrMinPulseWidthRequest* request, GetCIEncoderBInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIEncoderBInputDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderBInputDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIEncoderBInputDigFltrTimebaseRateRequest* request, GetCIEncoderBInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIEncoderBInputDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderBInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIEncoderBInputDigFltrTimebaseSrcRequest* request, GetCIEncoderBInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIEncoderBInputDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderBInputDigSyncEnable(::grpc::ServerContext* context, const GetCIEncoderBInputDigSyncEnableRequest* request, GetCIEncoderBInputDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIEncoderBInputDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderBInputLogicLvlBehavior(::grpc::ServerContext* context, const GetCIEncoderBInputLogicLvlBehaviorRequest* request, GetCIEncoderBInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIEncoderBInputLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderBInputTerm(::grpc::ServerContext* context, const GetCIEncoderBInputTermRequest* request, GetCIEncoderBInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIEncoderBInputTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderBInputTermCfg(::grpc::ServerContext* context, const GetCIEncoderBInputTermCfgRequest* request, GetCIEncoderBInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIEncoderBInputTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderDecodingType(::grpc::ServerContext* context, const GetCIEncoderDecodingTypeRequest* request, GetCIEncoderDecodingTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIEncoderDecodingType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::EncoderType2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZIndexEnable(::grpc::ServerContext* context, const GetCIEncoderZIndexEnableRequest* request, GetCIEncoderZIndexEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIEncoderZIndexEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZIndexPhase(::grpc::ServerContext* context, const GetCIEncoderZIndexPhaseRequest* request, GetCIEncoderZIndexPhaseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIEncoderZIndexPhase(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::EncoderZIndexPhase1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZIndexVal(::grpc::ServerContext* context, const GetCIEncoderZIndexValRequest* request, GetCIEncoderZIndexValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIEncoderZIndexVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZInputDigFltrEnable(::grpc::ServerContext* context, const GetCIEncoderZInputDigFltrEnableRequest* request, GetCIEncoderZInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIEncoderZInputDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIEncoderZInputDigFltrMinPulseWidthRequest* request, GetCIEncoderZInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIEncoderZInputDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZInputDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIEncoderZInputDigFltrTimebaseRateRequest* request, GetCIEncoderZInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIEncoderZInputDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIEncoderZInputDigFltrTimebaseSrcRequest* request, GetCIEncoderZInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIEncoderZInputDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZInputDigSyncEnable(::grpc::ServerContext* context, const GetCIEncoderZInputDigSyncEnableRequest* request, GetCIEncoderZInputDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIEncoderZInputDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZInputLogicLvlBehavior(::grpc::ServerContext* context, const GetCIEncoderZInputLogicLvlBehaviorRequest* request, GetCIEncoderZInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIEncoderZInputLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZInputTerm(::grpc::ServerContext* context, const GetCIEncoderZInputTermRequest* request, GetCIEncoderZInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIEncoderZInputTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIEncoderZInputTermCfg(::grpc::ServerContext* context, const GetCIEncoderZInputTermCfgRequest* request, GetCIEncoderZInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIEncoderZInputTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFilterDelay(::grpc::ServerContext* context, const GetCIFilterDelayRequest* request, GetCIFilterDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIFilterDelay(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFilterDelayUnits(::grpc::ServerContext* context, const GetCIFilterDelayUnitsRequest* request, GetCIFilterDelayUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIFilterDelayUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DigitalWidthUnits4>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFilterEnable(::grpc::ServerContext* context, const GetCIFilterEnableRequest* request, GetCIFilterEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIFilterEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFilterFreq(::grpc::ServerContext* context, const GetCIFilterFreqRequest* request, GetCIFilterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIFilterFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFilterOrder(::grpc::ServerContext* context, const GetCIFilterOrderRequest* request, GetCIFilterOrderResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCIFilterOrder(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFilterResponse(::grpc::ServerContext* context, const GetCIFilterResponseRequest* request, GetCIFilterResponseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIFilterResponse(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::FilterResponse1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqDigFltrEnable(::grpc::ServerContext* context, const GetCIFreqDigFltrEnableRequest* request, GetCIFreqDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIFreqDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIFreqDigFltrMinPulseWidthRequest* request, GetCIFreqDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIFreqDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIFreqDigFltrTimebaseRateRequest* request, GetCIFreqDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIFreqDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIFreqDigFltrTimebaseSrcRequest* request, GetCIFreqDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIFreqDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqDigSyncEnable(::grpc::ServerContext* context, const GetCIFreqDigSyncEnableRequest* request, GetCIFreqDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIFreqDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqDiv(::grpc::ServerContext* context, const GetCIFreqDivRequest* request, GetCIFreqDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCIFreqDiv(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqEnableAveraging(::grpc::ServerContext* context, const GetCIFreqEnableAveragingRequest* request, GetCIFreqEnableAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIFreqEnableAveraging(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqHyst(::grpc::ServerContext* context, const GetCIFreqHystRequest* request, GetCIFreqHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIFreqHyst(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqLogicLvlBehavior(::grpc::ServerContext* context, const GetCIFreqLogicLvlBehaviorRequest* request, GetCIFreqLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIFreqLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqMeasMeth(::grpc::ServerContext* context, const GetCIFreqMeasMethRequest* request, GetCIFreqMeasMethResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIFreqMeasMeth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::CounterFrequencyMethod>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqMeasTime(::grpc::ServerContext* context, const GetCIFreqMeasTimeRequest* request, GetCIFreqMeasTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIFreqMeasTime(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqStartingEdge(::grpc::ServerContext* context, const GetCIFreqStartingEdgeRequest* request, GetCIFreqStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIFreqStartingEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqTerm(::grpc::ServerContext* context, const GetCIFreqTermRequest* request, GetCIFreqTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIFreqTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqTermCfg(::grpc::ServerContext* context, const GetCIFreqTermCfgRequest* request, GetCIFreqTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIFreqTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqThreshVoltage(::grpc::ServerContext* context, const GetCIFreqThreshVoltageRequest* request, GetCIFreqThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIFreqThreshVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIFreqUnits(::grpc::ServerContext* context, const GetCIFreqUnitsRequest* request, GetCIFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIFreqUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::FrequencyUnits3>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIGPSSyncMethod(::grpc::ServerContext* context, const GetCIGPSSyncMethodRequest* request, GetCIGPSSyncMethodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIGPSSyncMethod(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::GpsSignalType1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIGPSSyncSrc(::grpc::ServerContext* context, const GetCIGPSSyncSrcRequest* request, GetCIGPSSyncSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIGPSSyncSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCILinEncoderDistPerPulse(::grpc::ServerContext* context, const GetCILinEncoderDistPerPulseRequest* request, GetCILinEncoderDistPerPulseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCILinEncoderDistPerPulse(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCILinEncoderInitialPos(::grpc::ServerContext* context, const GetCILinEncoderInitialPosRequest* request, GetCILinEncoderInitialPosResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCILinEncoderInitialPos(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCILinEncoderUnits(::grpc::ServerContext* context, const GetCILinEncoderUnitsRequest* request, GetCILinEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCILinEncoderUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LengthUnits3>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIMax(::grpc::ServerContext* context, const GetCIMaxRequest* request, GetCIMaxResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIMax(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIMaxMeasPeriod(::grpc::ServerContext* context, const GetCIMaxMeasPeriodRequest* request, GetCIMaxMeasPeriodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIMaxMeasPeriod(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIMeasType(::grpc::ServerContext* context, const GetCIMeasTypeRequest* request, GetCIMeasTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIMeasType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::CIMeasurementType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIMemMapEnable(::grpc::ServerContext* context, const GetCIMemMapEnableRequest* request, GetCIMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIMemMapEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIMin(::grpc::ServerContext* context, const GetCIMinRequest* request, GetCIMinResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIMin(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCINumPossiblyInvalidSamps(::grpc::ServerContext* context, const GetCINumPossiblyInvalidSampsRequest* request, GetCINumPossiblyInvalidSampsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCINumPossiblyInvalidSamps(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIOutputState(::grpc::ServerContext* context, const GetCIOutputStateRequest* request, GetCIOutputStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIOutputState(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Level1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodDigFltrEnable(::grpc::ServerContext* context, const GetCIPeriodDigFltrEnableRequest* request, GetCIPeriodDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPeriodDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIPeriodDigFltrMinPulseWidthRequest* request, GetCIPeriodDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPeriodDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIPeriodDigFltrTimebaseRateRequest* request, GetCIPeriodDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPeriodDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIPeriodDigFltrTimebaseSrcRequest* request, GetCIPeriodDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIPeriodDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodDigSyncEnable(::grpc::ServerContext* context, const GetCIPeriodDigSyncEnableRequest* request, GetCIPeriodDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPeriodDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodDiv(::grpc::ServerContext* context, const GetCIPeriodDivRequest* request, GetCIPeriodDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCIPeriodDiv(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodEnableAveraging(::grpc::ServerContext* context, const GetCIPeriodEnableAveragingRequest* request, GetCIPeriodEnableAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPeriodEnableAveraging(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodHyst(::grpc::ServerContext* context, const GetCIPeriodHystRequest* request, GetCIPeriodHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPeriodHyst(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodLogicLvlBehavior(::grpc::ServerContext* context, const GetCIPeriodLogicLvlBehaviorRequest* request, GetCIPeriodLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPeriodLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodMeasMeth(::grpc::ServerContext* context, const GetCIPeriodMeasMethRequest* request, GetCIPeriodMeasMethResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPeriodMeasMeth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::CounterFrequencyMethod>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodMeasTime(::grpc::ServerContext* context, const GetCIPeriodMeasTimeRequest* request, GetCIPeriodMeasTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPeriodMeasTime(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodStartingEdge(::grpc::ServerContext* context, const GetCIPeriodStartingEdgeRequest* request, GetCIPeriodStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPeriodStartingEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodTerm(::grpc::ServerContext* context, const GetCIPeriodTermRequest* request, GetCIPeriodTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIPeriodTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodTermCfg(::grpc::ServerContext* context, const GetCIPeriodTermCfgRequest* request, GetCIPeriodTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPeriodTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodThreshVoltage(::grpc::ServerContext* context, const GetCIPeriodThreshVoltageRequest* request, GetCIPeriodThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPeriodThreshVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPeriodUnits(::grpc::ServerContext* context, const GetCIPeriodUnitsRequest* request, GetCIPeriodUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPeriodUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::TimeUnits3>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPrescaler(::grpc::ServerContext* context, const GetCIPrescalerRequest* request, GetCIPrescalerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCIPrescaler(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseFreqDigFltrEnable(::grpc::ServerContext* context, const GetCIPulseFreqDigFltrEnableRequest* request, GetCIPulseFreqDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPulseFreqDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseFreqDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIPulseFreqDigFltrMinPulseWidthRequest* request, GetCIPulseFreqDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPulseFreqDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseFreqDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIPulseFreqDigFltrTimebaseRateRequest* request, GetCIPulseFreqDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPulseFreqDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseFreqDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIPulseFreqDigFltrTimebaseSrcRequest* request, GetCIPulseFreqDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIPulseFreqDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseFreqDigSyncEnable(::grpc::ServerContext* context, const GetCIPulseFreqDigSyncEnableRequest* request, GetCIPulseFreqDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPulseFreqDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseFreqLogicLvlBehavior(::grpc::ServerContext* context, const GetCIPulseFreqLogicLvlBehaviorRequest* request, GetCIPulseFreqLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseFreqLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseFreqStartEdge(::grpc::ServerContext* context, const GetCIPulseFreqStartEdgeRequest* request, GetCIPulseFreqStartEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseFreqStartEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseFreqTerm(::grpc::ServerContext* context, const GetCIPulseFreqTermRequest* request, GetCIPulseFreqTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIPulseFreqTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseFreqTermCfg(::grpc::ServerContext* context, const GetCIPulseFreqTermCfgRequest* request, GetCIPulseFreqTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseFreqTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseFreqUnits(::grpc::ServerContext* context, const GetCIPulseFreqUnitsRequest* request, GetCIPulseFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseFreqUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::FrequencyUnits2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTicksDigFltrEnable(::grpc::ServerContext* context, const GetCIPulseTicksDigFltrEnableRequest* request, GetCIPulseTicksDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPulseTicksDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTicksDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIPulseTicksDigFltrMinPulseWidthRequest* request, GetCIPulseTicksDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPulseTicksDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTicksDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIPulseTicksDigFltrTimebaseRateRequest* request, GetCIPulseTicksDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPulseTicksDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTicksDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIPulseTicksDigFltrTimebaseSrcRequest* request, GetCIPulseTicksDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIPulseTicksDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTicksDigSyncEnable(::grpc::ServerContext* context, const GetCIPulseTicksDigSyncEnableRequest* request, GetCIPulseTicksDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPulseTicksDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTicksLogicLvlBehavior(::grpc::ServerContext* context, const GetCIPulseTicksLogicLvlBehaviorRequest* request, GetCIPulseTicksLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseTicksLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTicksStartEdge(::grpc::ServerContext* context, const GetCIPulseTicksStartEdgeRequest* request, GetCIPulseTicksStartEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseTicksStartEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTicksTerm(::grpc::ServerContext* context, const GetCIPulseTicksTermRequest* request, GetCIPulseTicksTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIPulseTicksTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTicksTermCfg(::grpc::ServerContext* context, const GetCIPulseTicksTermCfgRequest* request, GetCIPulseTicksTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseTicksTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTimeDigFltrEnable(::grpc::ServerContext* context, const GetCIPulseTimeDigFltrEnableRequest* request, GetCIPulseTimeDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPulseTimeDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTimeDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIPulseTimeDigFltrMinPulseWidthRequest* request, GetCIPulseTimeDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPulseTimeDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTimeDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIPulseTimeDigFltrTimebaseRateRequest* request, GetCIPulseTimeDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPulseTimeDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTimeDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIPulseTimeDigFltrTimebaseSrcRequest* request, GetCIPulseTimeDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIPulseTimeDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTimeDigSyncEnable(::grpc::ServerContext* context, const GetCIPulseTimeDigSyncEnableRequest* request, GetCIPulseTimeDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPulseTimeDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTimeLogicLvlBehavior(::grpc::ServerContext* context, const GetCIPulseTimeLogicLvlBehaviorRequest* request, GetCIPulseTimeLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseTimeLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTimeStartEdge(::grpc::ServerContext* context, const GetCIPulseTimeStartEdgeRequest* request, GetCIPulseTimeStartEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseTimeStartEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTimeTerm(::grpc::ServerContext* context, const GetCIPulseTimeTermRequest* request, GetCIPulseTimeTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIPulseTimeTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTimeTermCfg(::grpc::ServerContext* context, const GetCIPulseTimeTermCfgRequest* request, GetCIPulseTimeTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseTimeTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseTimeUnits(::grpc::ServerContext* context, const GetCIPulseTimeUnitsRequest* request, GetCIPulseTimeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseTimeUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::TimeUnits2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseWidthDigFltrEnable(::grpc::ServerContext* context, const GetCIPulseWidthDigFltrEnableRequest* request, GetCIPulseWidthDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPulseWidthDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseWidthDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIPulseWidthDigFltrMinPulseWidthRequest* request, GetCIPulseWidthDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPulseWidthDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseWidthDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIPulseWidthDigFltrTimebaseRateRequest* request, GetCIPulseWidthDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIPulseWidthDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseWidthDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIPulseWidthDigFltrTimebaseSrcRequest* request, GetCIPulseWidthDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIPulseWidthDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseWidthDigSyncEnable(::grpc::ServerContext* context, const GetCIPulseWidthDigSyncEnableRequest* request, GetCIPulseWidthDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIPulseWidthDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseWidthLogicLvlBehavior(::grpc::ServerContext* context, const GetCIPulseWidthLogicLvlBehaviorRequest* request, GetCIPulseWidthLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseWidthLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseWidthStartingEdge(::grpc::ServerContext* context, const GetCIPulseWidthStartingEdgeRequest* request, GetCIPulseWidthStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseWidthStartingEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseWidthTerm(::grpc::ServerContext* context, const GetCIPulseWidthTermRequest* request, GetCIPulseWidthTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIPulseWidthTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseWidthTermCfg(::grpc::ServerContext* context, const GetCIPulseWidthTermCfgRequest* request, GetCIPulseWidthTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseWidthTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIPulseWidthUnits(::grpc::ServerContext* context, const GetCIPulseWidthUnitsRequest* request, GetCIPulseWidthUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIPulseWidthUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::TimeUnits3>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISampClkOverrunBehavior(::grpc::ServerContext* context, const GetCISampClkOverrunBehaviorRequest* request, GetCISampClkOverrunBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCISampClkOverrunBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::SampClkOverrunBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISampClkOverrunSentinelVal(::grpc::ServerContext* context, const GetCISampClkOverrunSentinelValRequest* request, GetCISampClkOverrunSentinelValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCISampClkOverrunSentinelVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISemiPeriodDigFltrEnable(::grpc::ServerContext* context, const GetCISemiPeriodDigFltrEnableRequest* request, GetCISemiPeriodDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCISemiPeriodDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISemiPeriodDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCISemiPeriodDigFltrMinPulseWidthRequest* request, GetCISemiPeriodDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCISemiPeriodDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISemiPeriodDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCISemiPeriodDigFltrTimebaseRateRequest* request, GetCISemiPeriodDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCISemiPeriodDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISemiPeriodDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCISemiPeriodDigFltrTimebaseSrcRequest* request, GetCISemiPeriodDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCISemiPeriodDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISemiPeriodDigSyncEnable(::grpc::ServerContext* context, const GetCISemiPeriodDigSyncEnableRequest* request, GetCISemiPeriodDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCISemiPeriodDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISemiPeriodLogicLvlBehavior(::grpc::ServerContext* context, const GetCISemiPeriodLogicLvlBehaviorRequest* request, GetCISemiPeriodLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCISemiPeriodLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISemiPeriodStartingEdge(::grpc::ServerContext* context, const GetCISemiPeriodStartingEdgeRequest* request, GetCISemiPeriodStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCISemiPeriodStartingEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISemiPeriodTerm(::grpc::ServerContext* context, const GetCISemiPeriodTermRequest* request, GetCISemiPeriodTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCISemiPeriodTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISemiPeriodTermCfg(::grpc::ServerContext* context, const GetCISemiPeriodTermCfgRequest* request, GetCISemiPeriodTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCISemiPeriodTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCISemiPeriodUnits(::grpc::ServerContext* context, const GetCISemiPeriodUnitsRequest* request, GetCISemiPeriodUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCISemiPeriodUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::TimeUnits3>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITCReached(::grpc::ServerContext* context, const GetCITCReachedRequest* request, GetCITCReachedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCITCReached(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIThreshVoltage(::grpc::ServerContext* context, const GetCIThreshVoltageRequest* request, GetCIThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIThreshVoltage(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITimestampInitialSeconds(::grpc::ServerContext* context, const GetCITimestampInitialSecondsRequest* request, GetCITimestampInitialSecondsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCITimestampInitialSeconds(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITimestampUnits(::grpc::ServerContext* context, const GetCITimestampUnitsRequest* request, GetCITimestampUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCITimestampUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::TimeUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepFirstDigFltrEnable(::grpc::ServerContext* context, const GetCITwoEdgeSepFirstDigFltrEnableRequest* request, GetCITwoEdgeSepFirstDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCITwoEdgeSepFirstDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepFirstDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCITwoEdgeSepFirstDigFltrMinPulseWidthRequest* request, GetCITwoEdgeSepFirstDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCITwoEdgeSepFirstDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepFirstDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCITwoEdgeSepFirstDigFltrTimebaseRateRequest* request, GetCITwoEdgeSepFirstDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCITwoEdgeSepFirstDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepFirstDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCITwoEdgeSepFirstDigFltrTimebaseSrcRequest* request, GetCITwoEdgeSepFirstDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCITwoEdgeSepFirstDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepFirstDigSyncEnable(::grpc::ServerContext* context, const GetCITwoEdgeSepFirstDigSyncEnableRequest* request, GetCITwoEdgeSepFirstDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCITwoEdgeSepFirstDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepFirstEdge(::grpc::ServerContext* context, const GetCITwoEdgeSepFirstEdgeRequest* request, GetCITwoEdgeSepFirstEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCITwoEdgeSepFirstEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepFirstLogicLvlBehavior(::grpc::ServerContext* context, const GetCITwoEdgeSepFirstLogicLvlBehaviorRequest* request, GetCITwoEdgeSepFirstLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCITwoEdgeSepFirstLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepFirstTerm(::grpc::ServerContext* context, const GetCITwoEdgeSepFirstTermRequest* request, GetCITwoEdgeSepFirstTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCITwoEdgeSepFirstTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepFirstTermCfg(::grpc::ServerContext* context, const GetCITwoEdgeSepFirstTermCfgRequest* request, GetCITwoEdgeSepFirstTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCITwoEdgeSepFirstTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepSecondDigFltrEnable(::grpc::ServerContext* context, const GetCITwoEdgeSepSecondDigFltrEnableRequest* request, GetCITwoEdgeSepSecondDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCITwoEdgeSepSecondDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepSecondDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCITwoEdgeSepSecondDigFltrMinPulseWidthRequest* request, GetCITwoEdgeSepSecondDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCITwoEdgeSepSecondDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepSecondDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCITwoEdgeSepSecondDigFltrTimebaseRateRequest* request, GetCITwoEdgeSepSecondDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCITwoEdgeSepSecondDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepSecondDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCITwoEdgeSepSecondDigFltrTimebaseSrcRequest* request, GetCITwoEdgeSepSecondDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCITwoEdgeSepSecondDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepSecondDigSyncEnable(::grpc::ServerContext* context, const GetCITwoEdgeSepSecondDigSyncEnableRequest* request, GetCITwoEdgeSepSecondDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCITwoEdgeSepSecondDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepSecondEdge(::grpc::ServerContext* context, const GetCITwoEdgeSepSecondEdgeRequest* request, GetCITwoEdgeSepSecondEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCITwoEdgeSepSecondEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepSecondLogicLvlBehavior(::grpc::ServerContext* context, const GetCITwoEdgeSepSecondLogicLvlBehaviorRequest* request, GetCITwoEdgeSepSecondLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCITwoEdgeSepSecondLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepSecondTerm(::grpc::ServerContext* context, const GetCITwoEdgeSepSecondTermRequest* request, GetCITwoEdgeSepSecondTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCITwoEdgeSepSecondTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepSecondTermCfg(::grpc::ServerContext* context, const GetCITwoEdgeSepSecondTermCfgRequest* request, GetCITwoEdgeSepSecondTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCITwoEdgeSepSecondTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCITwoEdgeSepUnits(::grpc::ServerContext* context, const GetCITwoEdgeSepUnitsRequest* request, GetCITwoEdgeSepUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCITwoEdgeSepUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::TimeUnits3>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIUsbXferReqCount(::grpc::ServerContext* context, const GetCIUsbXferReqCountRequest* request, GetCIUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCIUsbXferReqCount(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIUsbXferReqSize(::grpc::ServerContext* context, const GetCIUsbXferReqSizeRequest* request, GetCIUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCIUsbXferReqSize(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityAngEncoderPulsesPerRev(::grpc::ServerContext* context, const GetCIVelocityAngEncoderPulsesPerRevRequest* request, GetCIVelocityAngEncoderPulsesPerRevResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCIVelocityAngEncoderPulsesPerRev(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityAngEncoderUnits(::grpc::ServerContext* context, const GetCIVelocityAngEncoderUnitsRequest* request, GetCIVelocityAngEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIVelocityAngEncoderUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::AngularVelocityUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityDiv(::grpc::ServerContext* context, const GetCIVelocityDivRequest* request, GetCIVelocityDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCIVelocityDiv(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderAInputDigFltrEnable(::grpc::ServerContext* context, const GetCIVelocityEncoderAInputDigFltrEnableRequest* request, GetCIVelocityEncoderAInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIVelocityEncoderAInputDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderAInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIVelocityEncoderAInputDigFltrMinPulseWidthRequest* request, GetCIVelocityEncoderAInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIVelocityEncoderAInputDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderAInputDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIVelocityEncoderAInputDigFltrTimebaseRateRequest* request, GetCIVelocityEncoderAInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIVelocityEncoderAInputDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderAInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIVelocityEncoderAInputDigFltrTimebaseSrcRequest* request, GetCIVelocityEncoderAInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIVelocityEncoderAInputDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderAInputLogicLvlBehavior(::grpc::ServerContext* context, const GetCIVelocityEncoderAInputLogicLvlBehaviorRequest* request, GetCIVelocityEncoderAInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIVelocityEncoderAInputLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderAInputTerm(::grpc::ServerContext* context, const GetCIVelocityEncoderAInputTermRequest* request, GetCIVelocityEncoderAInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIVelocityEncoderAInputTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderAInputTermCfg(::grpc::ServerContext* context, const GetCIVelocityEncoderAInputTermCfgRequest* request, GetCIVelocityEncoderAInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIVelocityEncoderAInputTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderBInputDigFltrEnable(::grpc::ServerContext* context, const GetCIVelocityEncoderBInputDigFltrEnableRequest* request, GetCIVelocityEncoderBInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCIVelocityEncoderBInputDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderBInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCIVelocityEncoderBInputDigFltrMinPulseWidthRequest* request, GetCIVelocityEncoderBInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIVelocityEncoderBInputDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderBInputDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCIVelocityEncoderBInputDigFltrTimebaseRateRequest* request, GetCIVelocityEncoderBInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIVelocityEncoderBInputDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderBInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCIVelocityEncoderBInputDigFltrTimebaseSrcRequest* request, GetCIVelocityEncoderBInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIVelocityEncoderBInputDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderBInputLogicLvlBehavior(::grpc::ServerContext* context, const GetCIVelocityEncoderBInputLogicLvlBehaviorRequest* request, GetCIVelocityEncoderBInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIVelocityEncoderBInputLogicLvlBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicLvlBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderBInputTerm(::grpc::ServerContext* context, const GetCIVelocityEncoderBInputTermRequest* request, GetCIVelocityEncoderBInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCIVelocityEncoderBInputTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderBInputTermCfg(::grpc::ServerContext* context, const GetCIVelocityEncoderBInputTermCfgRequest* request, GetCIVelocityEncoderBInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIVelocityEncoderBInputTermCfg(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputTermCfg2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityEncoderDecodingType(::grpc::ServerContext* context, const GetCIVelocityEncoderDecodingTypeRequest* request, GetCIVelocityEncoderDecodingTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIVelocityEncoderDecodingType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::EncoderType2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityLinEncoderDistPerPulse(::grpc::ServerContext* context, const GetCIVelocityLinEncoderDistPerPulseRequest* request, GetCIVelocityLinEncoderDistPerPulseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIVelocityLinEncoderDistPerPulse(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityLinEncoderUnits(::grpc::ServerContext* context, const GetCIVelocityLinEncoderUnitsRequest* request, GetCIVelocityLinEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCIVelocityLinEncoderUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::VelocityUnits>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCIVelocityMeasTime(::grpc::ServerContext* context, const GetCIVelocityMeasTimeRequest* request, GetCIVelocityMeasTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCIVelocityMeasTime(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOAutoIncrCnt(::grpc::ServerContext* context, const GetCOAutoIncrCntRequest* request, GetCOAutoIncrCntResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCOAutoIncrCnt(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOConstrainedGenMode(::grpc::ServerContext* context, const GetCOConstrainedGenModeRequest* request, GetCOConstrainedGenModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCOConstrainedGenMode(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ConstrainedGenMode>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOCount(::grpc::ServerContext* context, const GetCOCountRequest* request, GetCOCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCOCount(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOCtrTimebaseActiveEdge(::grpc::ServerContext* context, const GetCOCtrTimebaseActiveEdgeRequest* request, GetCOCtrTimebaseActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCOCtrTimebaseActiveEdge(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Edge1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOCtrTimebaseDigFltrEnable(::grpc::ServerContext* context, const GetCOCtrTimebaseDigFltrEnableRequest* request, GetCOCtrTimebaseDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCOCtrTimebaseDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOCtrTimebaseDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetCOCtrTimebaseDigFltrMinPulseWidthRequest* request, GetCOCtrTimebaseDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCOCtrTimebaseDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOCtrTimebaseDigFltrTimebaseRate(::grpc::ServerContext* context, const GetCOCtrTimebaseDigFltrTimebaseRateRequest* request, GetCOCtrTimebaseDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCOCtrTimebaseDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOCtrTimebaseDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetCOCtrTimebaseDigFltrTimebaseSrcRequest* request, GetCOCtrTimebaseDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCOCtrTimebaseDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOCtrTimebaseDigSyncEnable(::grpc::ServerContext* context, const GetCOCtrTimebaseDigSyncEnableRequest* request, GetCOCtrTimebaseDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCOCtrTimebaseDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOCtrTimebaseMasterTimebaseDiv(::grpc::ServerContext* context, const GetCOCtrTimebaseMasterTimebaseDivRequest* request, GetCOCtrTimebaseMasterTimebaseDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCOCtrTimebaseMasterTimebaseDiv(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOCtrTimebaseRate(::grpc::ServerContext* context, const GetCOCtrTimebaseRateRequest* request, GetCOCtrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCOCtrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOCtrTimebaseSrc(::grpc::ServerContext* context, const GetCOCtrTimebaseSrcRequest* request, GetCOCtrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCOCtrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCODataXferMech(::grpc::ServerContext* context, const GetCODataXferMechRequest* request, GetCODataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCODataXferMech(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DataTransferMechanism>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCODataXferReqCond(::grpc::ServerContext* context, const GetCODataXferReqCondRequest* request, GetCODataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCODataXferReqCond(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::OutputDataTransferCondition>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOEnableInitialDelayOnRetrigger(::grpc::ServerContext* context, const GetCOEnableInitialDelayOnRetriggerRequest* request, GetCOEnableInitialDelayOnRetriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCOEnableInitialDelayOnRetrigger(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOMemMapEnable(::grpc::ServerContext* context, const GetCOMemMapEnableRequest* request, GetCOMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCOMemMapEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOOutputState(::grpc::ServerContext* context, const GetCOOutputStateRequest* request, GetCOOutputStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCOOutputState(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Level1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOOutputType(::grpc::ServerContext* context, const GetCOOutputTypeRequest* request, GetCOOutputTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCOOutputType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::COOutputType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPrescaler(::grpc::ServerContext* context, const GetCOPrescalerRequest* request, GetCOPrescalerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCOPrescaler(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseDone(::grpc::ServerContext* context, const GetCOPulseDoneRequest* request, GetCOPulseDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCOPulseDone(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseDutyCyc(::grpc::ServerContext* context, const GetCOPulseDutyCycRequest* request, GetCOPulseDutyCycResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCOPulseDutyCyc(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseFreq(::grpc::ServerContext* context, const GetCOPulseFreqRequest* request, GetCOPulseFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCOPulseFreq(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseFreqInitialDelay(::grpc::ServerContext* context, const GetCOPulseFreqInitialDelayRequest* request, GetCOPulseFreqInitialDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCOPulseFreqInitialDelay(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseFreqUnits(::grpc::ServerContext* context, const GetCOPulseFreqUnitsRequest* request, GetCOPulseFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCOPulseFreqUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::FrequencyUnits2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseHighTicks(::grpc::ServerContext* context, const GetCOPulseHighTicksRequest* request, GetCOPulseHighTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCOPulseHighTicks(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseHighTime(::grpc::ServerContext* context, const GetCOPulseHighTimeRequest* request, GetCOPulseHighTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCOPulseHighTime(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseIdleState(::grpc::ServerContext* context, const GetCOPulseIdleStateRequest* request, GetCOPulseIdleStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCOPulseIdleState(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::Level1>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseLowTicks(::grpc::ServerContext* context, const GetCOPulseLowTicksRequest* request, GetCOPulseLowTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCOPulseLowTicks(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseLowTime(::grpc::ServerContext* context, const GetCOPulseLowTimeRequest* request, GetCOPulseLowTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCOPulseLowTime(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseTerm(::grpc::ServerContext* context, const GetCOPulseTermRequest* request, GetCOPulseTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCOPulseTerm(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseTicksInitialDelay(::grpc::ServerContext* context, const GetCOPulseTicksInitialDelayRequest* request, GetCOPulseTicksInitialDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCOPulseTicksInitialDelay(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseTimeInitialDelay(::grpc::ServerContext* context, const GetCOPulseTimeInitialDelayRequest* request, GetCOPulseTimeInitialDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetCOPulseTimeInitialDelay(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOPulseTimeUnits(::grpc::ServerContext* context, const GetCOPulseTimeUnitsRequest* request, GetCOPulseTimeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetCOPulseTimeUnits(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::TimeUnits2>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCORdyForNewVal(::grpc::ServerContext* context, const GetCORdyForNewValRequest* request, GetCORdyForNewValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCORdyForNewVal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOUsbXferReqCount(::grpc::ServerContext* context, const GetCOUsbXferReqCountRequest* request, GetCOUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCOUsbXferReqCount(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOUsbXferReqSize(::grpc::ServerContext* context, const GetCOUsbXferReqSizeRequest* request, GetCOUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetCOUsbXferReqSize(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCOUseOnlyOnBrdMem(::grpc::ServerContext* context, const GetCOUseOnlyOnBrdMemRequest* request, GetCOUseOnlyOnBrdMemResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetCOUseOnlyOnBrdMem(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCalAccConnectionCount(::grpc::ServerContext* context, const GetCalAccConnectionCountRequest* request, GetCalAccConnectionCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      uInt32 data {};
      auto status = library_->GetCalAccConnectionCount(device_name, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCalDevTemp(::grpc::ServerContext* context, const GetCalDevTempRequest* request, GetCalDevTempResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      float64 data {};
      auto status = library_->GetCalDevTemp(device_name, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCalRecommendedAccConnectionCountLimit(::grpc::ServerContext* context, const GetCalRecommendedAccConnectionCountLimitRequest* request, GetCalRecommendedAccConnectionCountLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      uInt32 data {};
      auto status = library_->GetCalRecommendedAccConnectionCountLimit(device_name, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCalUserDefinedInfo(::grpc::ServerContext* context, const GetCalUserDefinedInfoRequest* request, GetCalUserDefinedInfoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetCalUserDefinedInfo(device_name, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCalUserDefinedInfoMaxSize(::grpc::ServerContext* context, const GetCalUserDefinedInfoMaxSizeRequest* request, GetCalUserDefinedInfoMaxSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      uInt32 data {};
      auto status = library_->GetCalUserDefinedInfoMaxSize(device_name, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanDescr(::grpc::ServerContext* context, const GetChanDescrRequest* request, GetChanDescrResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetChanDescr(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanIsGlobal(::grpc::ServerContext* context, const GetChanIsGlobalRequest* request, GetChanIsGlobalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetChanIsGlobal(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanSyncUnlockBehavior(::grpc::ServerContext* context, const GetChanSyncUnlockBehaviorRequest* request, GetChanSyncUnlockBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetChanSyncUnlockBehavior(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::SyncUnlockBehavior>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanType(::grpc::ServerContext* context, const GetChanTypeRequest* request, GetChanTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetChanType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::ChannelType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIAcquireOn(::grpc::ServerContext* context, const GetDIAcquireOnRequest* request, GetDIAcquireOnResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDIAcquireOn(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::SampleClockActiveOrInactiveEdgeSelection>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIDataXferMech(::grpc::ServerContext* context, const GetDIDataXferMechRequest* request, GetDIDataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDIDataXferMech(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DataTransferMechanism>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIDataXferReqCond(::grpc::ServerContext* context, const GetDIDataXferReqCondRequest* request, GetDIDataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDIDataXferReqCond(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::InputDataTransferCondition>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIDigFltrEnable(::grpc::ServerContext* context, const GetDIDigFltrEnableRequest* request, GetDIDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDIDigFltrEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIDigFltrEnableBusMode(::grpc::ServerContext* context, const GetDIDigFltrEnableBusModeRequest* request, GetDIDigFltrEnableBusModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDIDigFltrEnableBusMode(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIDigFltrMinPulseWidth(::grpc::ServerContext* context, const GetDIDigFltrMinPulseWidthRequest* request, GetDIDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetDIDigFltrMinPulseWidth(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIDigFltrTimebaseRate(::grpc::ServerContext* context, const GetDIDigFltrTimebaseRateRequest* request, GetDIDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetDIDigFltrTimebaseRate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIDigFltrTimebaseSrc(::grpc::ServerContext* context, const GetDIDigFltrTimebaseSrcRequest* request, GetDIDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetDIDigFltrTimebaseSrc(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIDigSyncEnable(::grpc::ServerContext* context, const GetDIDigSyncEnableRequest* request, GetDIDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDIDigSyncEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIInvertLines(::grpc::ServerContext* context, const GetDIInvertLinesRequest* request, GetDIInvertLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDIInvertLines(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDILogicFamily(::grpc::ServerContext* context, const GetDILogicFamilyRequest* request, GetDILogicFamilyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDILogicFamily(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicFamily>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIMemMapEnable(::grpc::ServerContext* context, const GetDIMemMapEnableRequest* request, GetDIMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDIMemMapEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDINumLines(::grpc::ServerContext* context, const GetDINumLinesRequest* request, GetDINumLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetDINumLines(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDITristate(::grpc::ServerContext* context, const GetDITristateRequest* request, GetDITristateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDITristate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIUsbXferReqCount(::grpc::ServerContext* context, const GetDIUsbXferReqCountRequest* request, GetDIUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetDIUsbXferReqCount(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDIUsbXferReqSize(::grpc::ServerContext* context, const GetDIUsbXferReqSizeRequest* request, GetDIUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetDIUsbXferReqSize(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDODataXferMech(::grpc::ServerContext* context, const GetDODataXferMechRequest* request, GetDODataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDODataXferMech(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DataTransferMechanism>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDODataXferReqCond(::grpc::ServerContext* context, const GetDODataXferReqCondRequest* request, GetDODataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDODataXferReqCond(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::OutputDataTransferCondition>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOGenerateOn(::grpc::ServerContext* context, const GetDOGenerateOnRequest* request, GetDOGenerateOnResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDOGenerateOn(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::SampleClockActiveOrInactiveEdgeSelection>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOInvertLines(::grpc::ServerContext* context, const GetDOInvertLinesRequest* request, GetDOInvertLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDOInvertLines(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOLineStatesDoneState(::grpc::ServerContext* context, const GetDOLineStatesDoneStateRequest* request, GetDOLineStatesDoneStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDOLineStatesDoneState(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DigitalLineState>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOLineStatesPausedState(::grpc::ServerContext* context, const GetDOLineStatesPausedStateRequest* request, GetDOLineStatesPausedStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDOLineStatesPausedState(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DigitalLineState>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOLineStatesStartState(::grpc::ServerContext* context, const GetDOLineStatesStartStateRequest* request, GetDOLineStatesStartStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDOLineStatesStartState(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DigitalLineState>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOLogicFamily(::grpc::ServerContext* context, const GetDOLogicFamilyRequest* request, GetDOLogicFamilyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDOLogicFamily(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::LogicFamily>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOMemMapEnable(::grpc::ServerContext* context, const GetDOMemMapEnableRequest* request, GetDOMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDOMemMapEnable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDONumLines(::grpc::ServerContext* context, const GetDONumLinesRequest* request, GetDONumLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetDONumLines(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOOutputDriveType(::grpc::ServerContext* context, const GetDOOutputDriveTypeRequest* request, GetDOOutputDriveTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data {};
      auto status = library_->GetDOOutputDriveType(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(static_cast<nidaqmx_grpc::DigitalDriveType>(data));
        response->set_data_raw(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOOvercurrentAutoReenable(::grpc::ServerContext* context, const GetDOOvercurrentAutoReenableRequest* request, GetDOOvercurrentAutoReenableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDOOvercurrentAutoReenable(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOOvercurrentLimit(::grpc::ServerContext* context, const GetDOOvercurrentLimitRequest* request, GetDOOvercurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetDOOvercurrentLimit(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOOvercurrentReenablePeriod(::grpc::ServerContext* context, const GetDOOvercurrentReenablePeriodRequest* request, GetDOOvercurrentReenablePeriodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data {};
      auto status = library_->GetDOOvercurrentReenablePeriod(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOTristate(::grpc::ServerContext* context, const GetDOTristateRequest* request, GetDOTristateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDOTristate(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOUsbXferReqCount(::grpc::ServerContext* context, const GetDOUsbXferReqCountRequest* request, GetDOUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetDOUsbXferReqCount(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOUsbXferReqSize(::grpc::ServerContext* context, const GetDOUsbXferReqSizeRequest* request, GetDOUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data {};
      auto status = library_->GetDOUsbXferReqSize(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDOUseOnlyOnBrdMem(::grpc::ServerContext* context, const GetDOUseOnlyOnBrdMemRequest* request, GetDOUseOnlyOnBrdMemResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data {};
      auto status = library_->GetDOUseOnlyOnBrdMem(task, channel, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDigitalLogicFamilyPowerUpState(::grpc::ServerContext* context, const GetDigitalLogicFamilyPowerUpStateRequest* request, GetDigitalLogicFamilyPowerUpStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 logic_family {};
      auto status = library_->GetDigitalLogicFamilyPowerUpState(device_name, &logic_family);
      response->set_status(status);
      if (status == 0) {
        response->set_logic_family(logic_family);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDisconnectedCDAQSyncPorts(::grpc::ServerContext* context, const GetDisconnectedCDAQSyncPortsRequest* request, GetDisconnectedCDAQSyncPortsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      uInt32 port_list_size = request->port_list_size();
      std::string port_list;
      if (port_list_size > 0) {
          port_list.resize(port_list_size-1);
      }
      auto status = library_->GetDisconnectedCDAQSyncPorts((char*)port_list.data(), port_list_size);
      response->set_status(status);
      if (status == 0) {
        response->set_port_list(port_list);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetErrorString(::grpc::ServerContext* context, const GetErrorStringRequest* request, GetErrorStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      int32 error_code = request->error_code();
      uInt32 buffer_size = request->buffer_size();
      std::string error_string;
      if (buffer_size > 0) {
          error_string.resize(buffer_size-1);
      }
      auto status = library_->GetErrorString(error_code, (char*)error_string.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_error_string(error_string);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExtCalLastTemp(::grpc::ServerContext* context, const GetExtCalLastTempRequest* request, GetExtCalLastTempResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      float64 data {};
      auto status = library_->GetExtCalLastTemp(device_name, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExtCalRecommendedInterval(::grpc::ServerContext* context, const GetExtCalRecommendedIntervalRequest* request, GetExtCalRecommendedIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      uInt32 data {};
      auto status = library_->GetExtCalRecommendedInterval(device_name, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExtendedErrorInfo(::grpc::ServerContext* context, const GetExtendedErrorInfoRequest* request, GetExtendedErrorInfoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      uInt32 buffer_size = request->buffer_size();
      std::string error_string;
      if (buffer_size > 0) {
          error_string.resize(buffer_size-1);
      }
      auto status = library_->GetExtendedErrorInfo((char*)error_string.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_error_string(error_string);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetFirstSampClkWhen(::grpc::ServerContext* context, const GetFirstSampClkWhenRequest* request, GetFirstSampClkWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetFirstSampClkWhen(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetFirstSampTimestampVal(::grpc::ServerContext* context, const GetFirstSampTimestampValRequest* request, GetFirstSampTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetFirstSampTimestampVal(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskChannel(::grpc::ServerContext* context, const GetNthTaskChannelRequest* request, GetNthTaskChannelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();
      int32 buffer_size = request->buffer_size();
      std::string buffer;
      if (buffer_size > 0) {
          buffer.resize(buffer_size-1);
      }
      auto status = library_->GetNthTaskChannel(task, index, (char*)buffer.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_buffer(buffer);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskDevice(::grpc::ServerContext* context, const GetNthTaskDeviceRequest* request, GetNthTaskDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();
      int32 buffer_size = request->buffer_size();
      std::string buffer;
      if (buffer_size > 0) {
          buffer.resize(buffer_size-1);
      }
      auto status = library_->GetNthTaskDevice(task, index, (char*)buffer.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_buffer(buffer);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskReadChannel(::grpc::ServerContext* context, const GetNthTaskReadChannelRequest* request, GetNthTaskReadChannelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();
      int32 buffer_size = request->buffer_size();
      std::string buffer;
      if (buffer_size > 0) {
          buffer.resize(buffer_size-1);
      }
      auto status = library_->GetNthTaskReadChannel(task, index, (char*)buffer.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_buffer(buffer);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPhysicalChanName(::grpc::ServerContext* context, const GetPhysicalChanNameRequest* request, GetPhysicalChanNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 buffer_size = request->buffer_size();
      std::string data;
      if (buffer_size > 0) {
          data.resize(buffer_size-1);
      }
      auto status = library_->GetPhysicalChanName(task, channel, (char*)data.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetRefTrigTimestampVal(::grpc::ServerContext* context, const GetRefTrigTimestampValRequest* request, GetRefTrigTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetRefTrigTimestampVal(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetSelfCalLastDateAndTime(::grpc::ServerContext* context, const GetSelfCalLastDateAndTimeRequest* request, GetSelfCalLastDateAndTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetSelfCalLastDateAndTime(device_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status == 0) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetSelfCalLastTemp(::grpc::ServerContext* context, const GetSelfCalLastTempRequest* request, GetSelfCalLastTempResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      float64 data {};
      auto status = library_->GetSelfCalLastTemp(device_name, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetSelfCalSupported(::grpc::ServerContext* context, const GetSelfCalSupportedRequest* request, GetSelfCalSupportedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      bool32 data {};
      auto status = library_->GetSelfCalSupported(device_name, &data);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetStartTrigTimestampVal(::grpc::ServerContext* context, const GetStartTrigTimestampValRequest* request, GetStartTrigTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetStartTrigTimestampVal(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetStartTrigTrigWhen(::grpc::ServerContext* context, const GetStartTrigTrigWhenRequest* request, GetStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetStartTrigTrigWhen(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetSyncPulseTimeWhen(::grpc::ServerContext* context, const GetSyncPulseTimeWhenRequest* request, GetSyncPulseTimeWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetSyncPulseTimeWhen(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::IsTaskDone(::grpc::ServerContext* context, const IsTaskDoneRequest* request, IsTaskDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 is_task_done {};
      auto status = library_->IsTaskDone(task, &is_task_done);
      response->set_status(status);
      if (status == 0) {
        response->set_is_task_done(is_task_done);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::LoadTask(::grpc::ServerContext* context, const LoadTaskRequest* request, LoadTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_name = request->session_name().c_str();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->LoadTask(session_name, &task);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadAnalogF64(::grpc::ServerContext* context, const ReadAnalogF64Request* request, ReadAnalogF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadAnalogF64(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadAnalogScalarF64(::grpc::ServerContext* context, const ReadAnalogScalarF64Request* request, ReadAnalogScalarF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 value {};
      auto status = library_->ReadAnalogScalarF64(task, timeout, &value, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryI16(::grpc::ServerContext* context, const ReadBinaryI16Request* request, ReadBinaryI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryI16Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI16Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI16Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::vector<int16> read_array(array_size_in_samps);
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryI16(task, num_samps_per_chan, timeout, fill_mode, read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->mutable_read_array()->Clear();
        response->mutable_read_array()->Reserve(array_size_in_samps);
        std::transform(
          read_array.begin(),
          read_array.end(),
          google::protobuf::RepeatedFieldBackInserter(response->mutable_read_array()),
          [](auto x) { 
              return x;
          });
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryI32(::grpc::ServerContext* context, const ReadBinaryI32Request* request, ReadBinaryI32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryI32Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI32Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI32Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      int32* read_array = reinterpret_cast<int32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryI32(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryU16(::grpc::ServerContext* context, const ReadBinaryU16Request* request, ReadBinaryU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryU16Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU16Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU16Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::vector<uInt16> read_array(array_size_in_samps);
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryU16(task, num_samps_per_chan, timeout, fill_mode, read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->mutable_read_array()->Clear();
        response->mutable_read_array()->Reserve(array_size_in_samps);
        std::transform(
          read_array.begin(),
          read_array.end(),
          google::protobuf::RepeatedFieldBackInserter(response->mutable_read_array()),
          [](auto x) { 
              return x;
          });
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryU32(::grpc::ServerContext* context, const ReadBinaryU32Request* request, ReadBinaryU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryU32Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU32Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU32Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryU32(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterF64(::grpc::ServerContext* context, const ReadCounterF64Request* request, ReadCounterF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterF64(task, num_samps_per_chan, timeout, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterF64Ex(::grpc::ServerContext* context, const ReadCounterF64ExRequest* request, ReadCounterF64ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadCounterF64ExRequest::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadCounterF64ExRequest::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadCounterF64ExRequest::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterF64Ex(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterScalarF64(::grpc::ServerContext* context, const ReadCounterScalarF64Request* request, ReadCounterScalarF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 value {};
      auto status = library_->ReadCounterScalarF64(task, timeout, &value, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterScalarU32(::grpc::ServerContext* context, const ReadCounterScalarU32Request* request, ReadCounterScalarU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      uInt32 value {};
      auto status = library_->ReadCounterScalarU32(task, timeout, &value, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterU32(::grpc::ServerContext* context, const ReadCounterU32Request* request, ReadCounterU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterU32(task, num_samps_per_chan, timeout, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterU32Ex(::grpc::ServerContext* context, const ReadCounterU32ExRequest* request, ReadCounterU32ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadCounterU32ExRequest::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadCounterU32ExRequest::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadCounterU32ExRequest::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterU32Ex(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrFreq(::grpc::ServerContext* context, const ReadCtrFreqRequest* request, ReadCtrFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 interleaved;
      switch (request->interleaved_enum_case()) {
        case nidaqmx_grpc::ReadCtrFreqRequest::InterleavedEnumCase::kInterleaved: {
          interleaved = static_cast<int32>(request->interleaved());
          break;
        }
        case nidaqmx_grpc::ReadCtrFreqRequest::InterleavedEnumCase::kInterleavedRaw: {
          interleaved = static_cast<int32>(request->interleaved_raw());
          break;
        }
        case nidaqmx_grpc::ReadCtrFreqRequest::InterleavedEnumCase::INTERLEAVED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for interleaved was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array_frequency()->Resize(array_size_in_samps, 0);
      float64* read_array_frequency = response->mutable_read_array_frequency()->mutable_data();
      response->mutable_read_array_duty_cycle()->Resize(array_size_in_samps, 0);
      float64* read_array_duty_cycle = response->mutable_read_array_duty_cycle()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCtrFreq(task, num_samps_per_chan, timeout, interleaved, read_array_frequency, read_array_duty_cycle, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrFreqScalar(::grpc::ServerContext* context, const ReadCtrFreqScalarRequest* request, ReadCtrFreqScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 frequency {};
      float64 duty_cycle {};
      auto status = library_->ReadCtrFreqScalar(task, timeout, &frequency, &duty_cycle, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_frequency(frequency);
        response->set_duty_cycle(duty_cycle);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTicks(::grpc::ServerContext* context, const ReadCtrTicksRequest* request, ReadCtrTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 interleaved;
      switch (request->interleaved_enum_case()) {
        case nidaqmx_grpc::ReadCtrTicksRequest::InterleavedEnumCase::kInterleaved: {
          interleaved = static_cast<int32>(request->interleaved());
          break;
        }
        case nidaqmx_grpc::ReadCtrTicksRequest::InterleavedEnumCase::kInterleavedRaw: {
          interleaved = static_cast<int32>(request->interleaved_raw());
          break;
        }
        case nidaqmx_grpc::ReadCtrTicksRequest::InterleavedEnumCase::INTERLEAVED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for interleaved was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array_high_ticks()->Resize(array_size_in_samps, 0);
      uInt32* read_array_high_ticks = reinterpret_cast<uInt32*>(response->mutable_read_array_high_ticks()->mutable_data());
      response->mutable_read_array_low_ticks()->Resize(array_size_in_samps, 0);
      uInt32* read_array_low_ticks = reinterpret_cast<uInt32*>(response->mutable_read_array_low_ticks()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadCtrTicks(task, num_samps_per_chan, timeout, interleaved, read_array_high_ticks, read_array_low_ticks, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTicksScalar(::grpc::ServerContext* context, const ReadCtrTicksScalarRequest* request, ReadCtrTicksScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      uInt32 high_ticks {};
      uInt32 low_ticks {};
      auto status = library_->ReadCtrTicksScalar(task, timeout, &high_ticks, &low_ticks, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_high_ticks(high_ticks);
        response->set_low_ticks(low_ticks);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTime(::grpc::ServerContext* context, const ReadCtrTimeRequest* request, ReadCtrTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 interleaved;
      switch (request->interleaved_enum_case()) {
        case nidaqmx_grpc::ReadCtrTimeRequest::InterleavedEnumCase::kInterleaved: {
          interleaved = static_cast<int32>(request->interleaved());
          break;
        }
        case nidaqmx_grpc::ReadCtrTimeRequest::InterleavedEnumCase::kInterleavedRaw: {
          interleaved = static_cast<int32>(request->interleaved_raw());
          break;
        }
        case nidaqmx_grpc::ReadCtrTimeRequest::InterleavedEnumCase::INTERLEAVED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for interleaved was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array_high_time()->Resize(array_size_in_samps, 0);
      float64* read_array_high_time = response->mutable_read_array_high_time()->mutable_data();
      response->mutable_read_array_low_time()->Resize(array_size_in_samps, 0);
      float64* read_array_low_time = response->mutable_read_array_low_time()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCtrTime(task, num_samps_per_chan, timeout, interleaved, read_array_high_time, read_array_low_time, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTimeScalar(::grpc::ServerContext* context, const ReadCtrTimeScalarRequest* request, ReadCtrTimeScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 high_time {};
      float64 low_time {};
      auto status = library_->ReadCtrTimeScalar(task, timeout, &high_time, &low_time, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_high_time(high_time);
        response->set_low_time(low_time);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalLines(::grpc::ServerContext* context, const ReadDigitalLinesRequest* request, ReadDigitalLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalLinesRequest::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalLinesRequest::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalLinesRequest::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_bytes = request->array_size_in_bytes();
      auto reserved = nullptr;
      std::string read_array(array_size_in_bytes, '\0');
      int32 samps_per_chan_read {};
      int32 num_bytes_per_samp {};
      auto status = library_->ReadDigitalLines(task, num_samps_per_chan, timeout, fill_mode, (uInt8*)read_array.data(), array_size_in_bytes, &samps_per_chan_read, &num_bytes_per_samp, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_read_array(read_array);
        response->set_samps_per_chan_read(samps_per_chan_read);
        response->set_num_bytes_per_samp(num_bytes_per_samp);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalScalarU32(::grpc::ServerContext* context, const ReadDigitalScalarU32Request* request, ReadDigitalScalarU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      uInt32 value {};
      auto status = library_->ReadDigitalScalarU32(task, timeout, &value, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU16(::grpc::ServerContext* context, const ReadDigitalU16Request* request, ReadDigitalU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::vector<uInt16> read_array(array_size_in_samps);
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU16(task, num_samps_per_chan, timeout, fill_mode, read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->mutable_read_array()->Clear();
        response->mutable_read_array()->Reserve(array_size_in_samps);
        std::transform(
          read_array.begin(),
          read_array.end(),
          google::protobuf::RepeatedFieldBackInserter(response->mutable_read_array()),
          [](auto x) { 
              return x;
          });
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU32(::grpc::ServerContext* context, const ReadDigitalU32Request* request, ReadDigitalU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU32Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU32Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU32Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU32(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU8(::grpc::ServerContext* context, const ReadDigitalU8Request* request, ReadDigitalU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::string read_array(array_size_in_samps, '\0');
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU8(task, num_samps_per_chan, timeout, fill_mode, (uInt8*)read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_read_array(read_array);
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadRaw(::grpc::ServerContext* context, const ReadRawRequest* request, ReadRawResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      uInt32 array_size_in_bytes = request->array_size_in_bytes();
      auto reserved = nullptr;
      std::string read_array(array_size_in_bytes, '\0');
      int32 samps_read {};
      int32 num_bytes_per_samp {};
      auto status = library_->ReadRaw(task, num_samps_per_chan, timeout, (uInt8*)read_array.data(), array_size_in_bytes, &samps_read, &num_bytes_per_samp, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_read_array(read_array);
        response->set_samps_read(samps_read);
        response->set_num_bytes_per_samp(num_bytes_per_samp);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  ::grpc::ServerWriteReactor<RegisterDoneEventResponse>*
  NiDAQmxService::RegisterDoneEvent(::grpc::CallbackServerContext* context, const RegisterDoneEventRequest* request)
  {
    using CallbackRouter = nidevice_grpc::CallbackRouter<int32, TaskHandle, int32>;
    class RegisterDoneEventReactor : public nidevice_grpc::ServerWriterReactor<RegisterDoneEventResponse, nidevice_grpc::CallbackRegistration> {
    public:
    RegisterDoneEventReactor(const RegisterDoneEventRequest& request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository)
    {
      auto status = start(&request, library, session_repository);
      if (!status.ok()) {
        this->Finish(status);
      }
    }

    ::grpc::Status start(const RegisterDoneEventRequest* request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository_)
    {
      try {
        auto handler = CallbackRouter::register_handler(
          [this](TaskHandle task, int32 status) {
            RegisterDoneEventResponse callback_response;
            auto response = &callback_response;
            response->set_status(status);
            queue_write(callback_response);
            return 0;
        });

        auto task_grpc_session = request->task();
        TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
        uInt32 options = request->options();

        auto status = library->RegisterDoneEvent(task, options, CallbackRouter::handle_callback, handler->token());

        // SendInitialMetadata after the driver call so that WaitForInitialMetadata can be used to ensure that calls are serialized.
        StartSendInitialMetadata();

        if (status) {
          RegisterDoneEventResponse failed_to_register_response;
          failed_to_register_response.set_status(status);
          queue_write(failed_to_register_response);
        }

        this->set_producer(std::move(handler));
      }
      catch (nidevice_grpc::LibraryLoadException& ex) {
         return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
      }

      return ::grpc::Status::OK;
    }
    };

    return new RegisterDoneEventReactor(*request, library_, session_repository_);
  }
  ::grpc::ServerWriteReactor<RegisterEveryNSamplesEventResponse>*
  NiDAQmxService::RegisterEveryNSamplesEvent(::grpc::CallbackServerContext* context, const RegisterEveryNSamplesEventRequest* request)
  {
    using CallbackRouter = nidevice_grpc::CallbackRouter<int32, TaskHandle, int32, uInt32>;
    class RegisterEveryNSamplesEventReactor : public nidevice_grpc::ServerWriterReactor<RegisterEveryNSamplesEventResponse, nidevice_grpc::CallbackRegistration> {
    public:
    RegisterEveryNSamplesEventReactor(const RegisterEveryNSamplesEventRequest& request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository)
    {
      auto status = start(&request, library, session_repository);
      if (!status.ok()) {
        this->Finish(status);
      }
    }

    ::grpc::Status start(const RegisterEveryNSamplesEventRequest* request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository_)
    {
      try {
        auto handler = CallbackRouter::register_handler(
          [this](TaskHandle task, int32 every_n_samples_event_type, uInt32 n_samples) {
            RegisterEveryNSamplesEventResponse callback_response;
            auto response = &callback_response;
            response->set_every_n_samples_event_type(static_cast<nidaqmx_grpc::EveryNSamplesEventType>(every_n_samples_event_type));
            response->set_every_n_samples_event_type_raw(every_n_samples_event_type);
            response->set_n_samples(n_samples);
            queue_write(callback_response);
            return 0;
        });

        auto task_grpc_session = request->task();
        TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
        int32 every_n_samples_event_type;
        switch (request->every_n_samples_event_type_enum_case()) {
          case nidaqmx_grpc::RegisterEveryNSamplesEventRequest::EveryNSamplesEventTypeEnumCase::kEveryNSamplesEventType: {
            every_n_samples_event_type = static_cast<int32>(request->every_n_samples_event_type());
            break;
          }
          case nidaqmx_grpc::RegisterEveryNSamplesEventRequest::EveryNSamplesEventTypeEnumCase::kEveryNSamplesEventTypeRaw: {
            every_n_samples_event_type = static_cast<int32>(request->every_n_samples_event_type_raw());
            break;
          }
          case nidaqmx_grpc::RegisterEveryNSamplesEventRequest::EveryNSamplesEventTypeEnumCase::EVERY_N_SAMPLES_EVENT_TYPE_ENUM_NOT_SET: {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for every_n_samples_event_type was not specified or out of range");
            break;
          }
        }
  
        uInt32 n_samples = request->n_samples();
        uInt32 options = request->options();

        auto status = library->RegisterEveryNSamplesEvent(task, every_n_samples_event_type, n_samples, options, CallbackRouter::handle_callback, handler->token());

        // SendInitialMetadata after the driver call so that WaitForInitialMetadata can be used to ensure that calls are serialized.
        StartSendInitialMetadata();

        if (status) {
          RegisterEveryNSamplesEventResponse failed_to_register_response;
          failed_to_register_response.set_status(status);
          queue_write(failed_to_register_response);
        }

        this->set_producer(std::move(handler));
      }
      catch (nidevice_grpc::LibraryLoadException& ex) {
         return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
      }

      return ::grpc::Status::OK;
    }
    };

    return new RegisterEveryNSamplesEventReactor(*request, library_, session_repository_);
  }
  ::grpc::ServerWriteReactor<RegisterSignalEventResponse>*
  NiDAQmxService::RegisterSignalEvent(::grpc::CallbackServerContext* context, const RegisterSignalEventRequest* request)
  {
    using CallbackRouter = nidevice_grpc::CallbackRouter<int32, TaskHandle, int32>;
    class RegisterSignalEventReactor : public nidevice_grpc::ServerWriterReactor<RegisterSignalEventResponse, nidevice_grpc::CallbackRegistration> {
    public:
    RegisterSignalEventReactor(const RegisterSignalEventRequest& request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository)
    {
      auto status = start(&request, library, session_repository);
      if (!status.ok()) {
        this->Finish(status);
      }
    }

    ::grpc::Status start(const RegisterSignalEventRequest* request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository_)
    {
      try {
        auto handler = CallbackRouter::register_handler(
          [this](TaskHandle task, int32 signal_id) {
            RegisterSignalEventResponse callback_response;
            auto response = &callback_response;
            response->set_signal_id(signal_id);
            queue_write(callback_response);
            return 0;
        });

        auto task_grpc_session = request->task();
        TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
        int32 signal_id;
        switch (request->signal_id_enum_case()) {
          case nidaqmx_grpc::RegisterSignalEventRequest::SignalIdEnumCase::kSignalId: {
            signal_id = static_cast<int32>(request->signal_id());
            break;
          }
          case nidaqmx_grpc::RegisterSignalEventRequest::SignalIdEnumCase::kSignalIdRaw: {
            signal_id = static_cast<int32>(request->signal_id_raw());
            break;
          }
          case nidaqmx_grpc::RegisterSignalEventRequest::SignalIdEnumCase::SIGNAL_ID_ENUM_NOT_SET: {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_id was not specified or out of range");
            break;
          }
        }
  
        uInt32 options = request->options();

        auto status = library->RegisterSignalEvent(task, signal_id, options, CallbackRouter::handle_callback, handler->token());

        // SendInitialMetadata after the driver call so that WaitForInitialMetadata can be used to ensure that calls are serialized.
        StartSendInitialMetadata();

        if (status) {
          RegisterSignalEventResponse failed_to_register_response;
          failed_to_register_response.set_status(status);
          queue_write(failed_to_register_response);
        }

        this->set_producer(std::move(handler));
      }
      catch (nidevice_grpc::LibraryLoadException& ex) {
         return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
      }

      return ::grpc::Status::OK;
    }
    };

    return new RegisterSignalEventReactor(*request, library_, session_repository_);
  }
  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::RemoveCDAQSyncConnection(::grpc::ServerContext* context, const RemoveCDAQSyncConnectionRequest* request, RemoveCDAQSyncConnectionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto port_list = request->port_list().c_str();
      auto status = library_->RemoveCDAQSyncConnection(port_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReserveNetworkDevice(::grpc::ServerContext* context, const ReserveNetworkDeviceRequest* request, ReserveNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      bool32 override_reservation = request->override_reservation();
      auto status = library_->ReserveNetworkDevice(device_name, override_reservation);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIACExcitFreq(::grpc::ServerContext* context, const ResetAIACExcitFreqRequest* request, ResetAIACExcitFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIACExcitFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIACExcitSyncEnable(::grpc::ServerContext* context, const ResetAIACExcitSyncEnableRequest* request, ResetAIACExcitSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIACExcitSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIACExcitWireMode(::grpc::ServerContext* context, const ResetAIACExcitWireModeRequest* request, ResetAIACExcitWireModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIACExcitWireMode(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIADCCustomTimingMode(::grpc::ServerContext* context, const ResetAIADCCustomTimingModeRequest* request, ResetAIADCCustomTimingModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIADCCustomTimingMode(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIADCTimingMode(::grpc::ServerContext* context, const ResetAIADCTimingModeRequest* request, ResetAIADCTimingModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIADCTimingMode(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAccel4WireDCVoltageSensitivity(::grpc::ServerContext* context, const ResetAIAccel4WireDCVoltageSensitivityRequest* request, ResetAIAccel4WireDCVoltageSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAccel4WireDCVoltageSensitivity(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAccel4WireDCVoltageSensitivityUnits(::grpc::ServerContext* context, const ResetAIAccel4WireDCVoltageSensitivityUnitsRequest* request, ResetAIAccel4WireDCVoltageSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAccel4WireDCVoltageSensitivityUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAccelChargeSensitivity(::grpc::ServerContext* context, const ResetAIAccelChargeSensitivityRequest* request, ResetAIAccelChargeSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAccelChargeSensitivity(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAccelChargeSensitivityUnits(::grpc::ServerContext* context, const ResetAIAccelChargeSensitivityUnitsRequest* request, ResetAIAccelChargeSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAccelChargeSensitivityUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAccelSensitivity(::grpc::ServerContext* context, const ResetAIAccelSensitivityRequest* request, ResetAIAccelSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAccelSensitivity(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAccelSensitivityUnits(::grpc::ServerContext* context, const ResetAIAccelSensitivityUnitsRequest* request, ResetAIAccelSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAccelSensitivityUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAccelUnits(::grpc::ServerContext* context, const ResetAIAccelUnitsRequest* request, ResetAIAccelUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAccelUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAcceldBRef(::grpc::ServerContext* context, const ResetAIAcceldBRefRequest* request, ResetAIAcceldBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAcceldBRef(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAtten(::grpc::ServerContext* context, const ResetAIAttenRequest* request, ResetAIAttenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAtten(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAutoZeroMode(::grpc::ServerContext* context, const ResetAIAutoZeroModeRequest* request, ResetAIAutoZeroModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAutoZeroMode(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIAveragingWinSize(::grpc::ServerContext* context, const ResetAIAveragingWinSizeRequest* request, ResetAIAveragingWinSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIAveragingWinSize(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeBalanceCoarsePot(::grpc::ServerContext* context, const ResetAIBridgeBalanceCoarsePotRequest* request, ResetAIBridgeBalanceCoarsePotResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeBalanceCoarsePot(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeBalanceFinePot(::grpc::ServerContext* context, const ResetAIBridgeBalanceFinePotRequest* request, ResetAIBridgeBalanceFinePotResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeBalanceFinePot(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeCfg(::grpc::ServerContext* context, const ResetAIBridgeCfgRequest* request, ResetAIBridgeCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeElectricalUnits(::grpc::ServerContext* context, const ResetAIBridgeElectricalUnitsRequest* request, ResetAIBridgeElectricalUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeElectricalUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeInitialRatio(::grpc::ServerContext* context, const ResetAIBridgeInitialRatioRequest* request, ResetAIBridgeInitialRatioResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeInitialRatio(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeInitialVoltage(::grpc::ServerContext* context, const ResetAIBridgeInitialVoltageRequest* request, ResetAIBridgeInitialVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeInitialVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeNomResistance(::grpc::ServerContext* context, const ResetAIBridgeNomResistanceRequest* request, ResetAIBridgeNomResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeNomResistance(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgePhysicalUnits(::grpc::ServerContext* context, const ResetAIBridgePhysicalUnitsRequest* request, ResetAIBridgePhysicalUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgePhysicalUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgePolyForwardCoeff(::grpc::ServerContext* context, const ResetAIBridgePolyForwardCoeffRequest* request, ResetAIBridgePolyForwardCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgePolyForwardCoeff(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgePolyReverseCoeff(::grpc::ServerContext* context, const ResetAIBridgePolyReverseCoeffRequest* request, ResetAIBridgePolyReverseCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgePolyReverseCoeff(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeScaleType(::grpc::ServerContext* context, const ResetAIBridgeScaleTypeRequest* request, ResetAIBridgeScaleTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeScaleType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeShuntCalEnable(::grpc::ServerContext* context, const ResetAIBridgeShuntCalEnableRequest* request, ResetAIBridgeShuntCalEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeShuntCalEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeShuntCalGainAdjust(::grpc::ServerContext* context, const ResetAIBridgeShuntCalGainAdjustRequest* request, ResetAIBridgeShuntCalGainAdjustResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeShuntCalGainAdjust(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeShuntCalSelect(::grpc::ServerContext* context, const ResetAIBridgeShuntCalSelectRequest* request, ResetAIBridgeShuntCalSelectResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeShuntCalSelect(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeShuntCalShuntCalAActualResistance(::grpc::ServerContext* context, const ResetAIBridgeShuntCalShuntCalAActualResistanceRequest* request, ResetAIBridgeShuntCalShuntCalAActualResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeShuntCalShuntCalAActualResistance(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeShuntCalShuntCalAResistance(::grpc::ServerContext* context, const ResetAIBridgeShuntCalShuntCalAResistanceRequest* request, ResetAIBridgeShuntCalShuntCalAResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeShuntCalShuntCalAResistance(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeShuntCalShuntCalASrc(::grpc::ServerContext* context, const ResetAIBridgeShuntCalShuntCalASrcRequest* request, ResetAIBridgeShuntCalShuntCalASrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeShuntCalShuntCalASrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeShuntCalShuntCalBActualResistance(::grpc::ServerContext* context, const ResetAIBridgeShuntCalShuntCalBActualResistanceRequest* request, ResetAIBridgeShuntCalShuntCalBActualResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeShuntCalShuntCalBActualResistance(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeShuntCalShuntCalBResistance(::grpc::ServerContext* context, const ResetAIBridgeShuntCalShuntCalBResistanceRequest* request, ResetAIBridgeShuntCalShuntCalBResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeShuntCalShuntCalBResistance(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeTableElectricalVals(::grpc::ServerContext* context, const ResetAIBridgeTableElectricalValsRequest* request, ResetAIBridgeTableElectricalValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeTableElectricalVals(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeTablePhysicalVals(::grpc::ServerContext* context, const ResetAIBridgeTablePhysicalValsRequest* request, ResetAIBridgeTablePhysicalValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeTablePhysicalVals(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeTwoPointLinFirstElectricalVal(::grpc::ServerContext* context, const ResetAIBridgeTwoPointLinFirstElectricalValRequest* request, ResetAIBridgeTwoPointLinFirstElectricalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeTwoPointLinFirstElectricalVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeTwoPointLinFirstPhysicalVal(::grpc::ServerContext* context, const ResetAIBridgeTwoPointLinFirstPhysicalValRequest* request, ResetAIBridgeTwoPointLinFirstPhysicalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeTwoPointLinFirstPhysicalVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeTwoPointLinSecondElectricalVal(::grpc::ServerContext* context, const ResetAIBridgeTwoPointLinSecondElectricalValRequest* request, ResetAIBridgeTwoPointLinSecondElectricalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeTwoPointLinSecondElectricalVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeTwoPointLinSecondPhysicalVal(::grpc::ServerContext* context, const ResetAIBridgeTwoPointLinSecondPhysicalValRequest* request, ResetAIBridgeTwoPointLinSecondPhysicalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeTwoPointLinSecondPhysicalVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIBridgeUnits(::grpc::ServerContext* context, const ResetAIBridgeUnitsRequest* request, ResetAIBridgeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIBridgeUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalApplyCalIfExp(::grpc::ServerContext* context, const ResetAIChanCalApplyCalIfExpRequest* request, ResetAIChanCalApplyCalIfExpResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalApplyCalIfExp(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalDesc(::grpc::ServerContext* context, const ResetAIChanCalDescRequest* request, ResetAIChanCalDescResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalDesc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalEnableCal(::grpc::ServerContext* context, const ResetAIChanCalEnableCalRequest* request, ResetAIChanCalEnableCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalEnableCal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalOperatorName(::grpc::ServerContext* context, const ResetAIChanCalOperatorNameRequest* request, ResetAIChanCalOperatorNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalOperatorName(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalPolyForwardCoeff(::grpc::ServerContext* context, const ResetAIChanCalPolyForwardCoeffRequest* request, ResetAIChanCalPolyForwardCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalPolyForwardCoeff(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalPolyReverseCoeff(::grpc::ServerContext* context, const ResetAIChanCalPolyReverseCoeffRequest* request, ResetAIChanCalPolyReverseCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalPolyReverseCoeff(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalScaleType(::grpc::ServerContext* context, const ResetAIChanCalScaleTypeRequest* request, ResetAIChanCalScaleTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalScaleType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalTablePreScaledVals(::grpc::ServerContext* context, const ResetAIChanCalTablePreScaledValsRequest* request, ResetAIChanCalTablePreScaledValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalTablePreScaledVals(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalTableScaledVals(::grpc::ServerContext* context, const ResetAIChanCalTableScaledValsRequest* request, ResetAIChanCalTableScaledValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalTableScaledVals(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalVerifAcqVals(::grpc::ServerContext* context, const ResetAIChanCalVerifAcqValsRequest* request, ResetAIChanCalVerifAcqValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalVerifAcqVals(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChanCalVerifRefVals(::grpc::ServerContext* context, const ResetAIChanCalVerifRefValsRequest* request, ResetAIChanCalVerifRefValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChanCalVerifRefVals(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChargeUnits(::grpc::ServerContext* context, const ResetAIChargeUnitsRequest* request, ResetAIChargeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChargeUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIChopEnable(::grpc::ServerContext* context, const ResetAIChopEnableRequest* request, ResetAIChopEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIChopEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAICoupling(::grpc::ServerContext* context, const ResetAICouplingRequest* request, ResetAICouplingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAICoupling(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAICurrentACRMSUnits(::grpc::ServerContext* context, const ResetAICurrentACRMSUnitsRequest* request, ResetAICurrentACRMSUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAICurrentACRMSUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAICurrentShuntLoc(::grpc::ServerContext* context, const ResetAICurrentShuntLocRequest* request, ResetAICurrentShuntLocResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAICurrentShuntLoc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAICurrentShuntResistance(::grpc::ServerContext* context, const ResetAICurrentShuntResistanceRequest* request, ResetAICurrentShuntResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAICurrentShuntResistance(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAICurrentUnits(::grpc::ServerContext* context, const ResetAICurrentUnitsRequest* request, ResetAICurrentUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAICurrentUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAICustomScaleName(::grpc::ServerContext* context, const ResetAICustomScaleNameRequest* request, ResetAICustomScaleNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAICustomScaleName(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDCOffset(::grpc::ServerContext* context, const ResetAIDCOffsetRequest* request, ResetAIDCOffsetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDCOffset(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDataXferCustomThreshold(::grpc::ServerContext* context, const ResetAIDataXferCustomThresholdRequest* request, ResetAIDataXferCustomThresholdResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDataXferCustomThreshold(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDataXferMaxRate(::grpc::ServerContext* context, const ResetAIDataXferMaxRateRequest* request, ResetAIDataXferMaxRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDataXferMaxRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDataXferMech(::grpc::ServerContext* context, const ResetAIDataXferMechRequest* request, ResetAIDataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDataXferMech(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDataXferReqCond(::grpc::ServerContext* context, const ResetAIDataXferReqCondRequest* request, ResetAIDataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDataXferReqCond(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrBandpassCenterFreq(::grpc::ServerContext* context, const ResetAIDigFltrBandpassCenterFreqRequest* request, ResetAIDigFltrBandpassCenterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrBandpassCenterFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrBandpassWidth(::grpc::ServerContext* context, const ResetAIDigFltrBandpassWidthRequest* request, ResetAIDigFltrBandpassWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrBandpassWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrCoeff(::grpc::ServerContext* context, const ResetAIDigFltrCoeffRequest* request, ResetAIDigFltrCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrCoeff(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrEnable(::grpc::ServerContext* context, const ResetAIDigFltrEnableRequest* request, ResetAIDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrHighpassCutoffFreq(::grpc::ServerContext* context, const ResetAIDigFltrHighpassCutoffFreqRequest* request, ResetAIDigFltrHighpassCutoffFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrHighpassCutoffFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrLowpassCutoffFreq(::grpc::ServerContext* context, const ResetAIDigFltrLowpassCutoffFreqRequest* request, ResetAIDigFltrLowpassCutoffFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrLowpassCutoffFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrNotchCenterFreq(::grpc::ServerContext* context, const ResetAIDigFltrNotchCenterFreqRequest* request, ResetAIDigFltrNotchCenterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrNotchCenterFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrNotchWidth(::grpc::ServerContext* context, const ResetAIDigFltrNotchWidthRequest* request, ResetAIDigFltrNotchWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrNotchWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrOrder(::grpc::ServerContext* context, const ResetAIDigFltrOrderRequest* request, ResetAIDigFltrOrderResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrOrder(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrResponse(::grpc::ServerContext* context, const ResetAIDigFltrResponseRequest* request, ResetAIDigFltrResponseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrResponse(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDigFltrType(::grpc::ServerContext* context, const ResetAIDigFltrTypeRequest* request, ResetAIDigFltrTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDigFltrType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIDitherEnable(::grpc::ServerContext* context, const ResetAIDitherEnableRequest* request, ResetAIDitherEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIDitherEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIEddyCurrentProxProbeSensitivity(::grpc::ServerContext* context, const ResetAIEddyCurrentProxProbeSensitivityRequest* request, ResetAIEddyCurrentProxProbeSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIEddyCurrentProxProbeSensitivity(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIEddyCurrentProxProbeSensitivityUnits(::grpc::ServerContext* context, const ResetAIEddyCurrentProxProbeSensitivityUnitsRequest* request, ResetAIEddyCurrentProxProbeSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIEddyCurrentProxProbeSensitivityUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIEddyCurrentProxProbeUnits(::grpc::ServerContext* context, const ResetAIEddyCurrentProxProbeUnitsRequest* request, ResetAIEddyCurrentProxProbeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIEddyCurrentProxProbeUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIEnhancedAliasRejectionEnable(::grpc::ServerContext* context, const ResetAIEnhancedAliasRejectionEnableRequest* request, ResetAIEnhancedAliasRejectionEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIEnhancedAliasRejectionEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIExcitActualVal(::grpc::ServerContext* context, const ResetAIExcitActualValRequest* request, ResetAIExcitActualValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIExcitActualVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIExcitDCorAC(::grpc::ServerContext* context, const ResetAIExcitDCorACRequest* request, ResetAIExcitDCorACResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIExcitDCorAC(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIExcitIdleOutputBehavior(::grpc::ServerContext* context, const ResetAIExcitIdleOutputBehaviorRequest* request, ResetAIExcitIdleOutputBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIExcitIdleOutputBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIExcitSense(::grpc::ServerContext* context, const ResetAIExcitSenseRequest* request, ResetAIExcitSenseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIExcitSense(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIExcitSrc(::grpc::ServerContext* context, const ResetAIExcitSrcRequest* request, ResetAIExcitSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIExcitSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIExcitUseForScaling(::grpc::ServerContext* context, const ResetAIExcitUseForScalingRequest* request, ResetAIExcitUseForScalingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIExcitUseForScaling(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIExcitUseMultiplexed(::grpc::ServerContext* context, const ResetAIExcitUseMultiplexedRequest* request, ResetAIExcitUseMultiplexedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIExcitUseMultiplexed(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIExcitVal(::grpc::ServerContext* context, const ResetAIExcitValRequest* request, ResetAIExcitValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIExcitVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIExcitVoltageOrCurrent(::grpc::ServerContext* context, const ResetAIExcitVoltageOrCurrentRequest* request, ResetAIExcitVoltageOrCurrentResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIExcitVoltageOrCurrent(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIFilterDelayAdjustment(::grpc::ServerContext* context, const ResetAIFilterDelayAdjustmentRequest* request, ResetAIFilterDelayAdjustmentResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIFilterDelayAdjustment(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIFilterDelayUnits(::grpc::ServerContext* context, const ResetAIFilterDelayUnitsRequest* request, ResetAIFilterDelayUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIFilterDelayUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIFilterEnable(::grpc::ServerContext* context, const ResetAIFilterEnableRequest* request, ResetAIFilterEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIFilterEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIFilterFreq(::grpc::ServerContext* context, const ResetAIFilterFreqRequest* request, ResetAIFilterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIFilterFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIFilterOrder(::grpc::ServerContext* context, const ResetAIFilterOrderRequest* request, ResetAIFilterOrderResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIFilterOrder(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIFilterResponse(::grpc::ServerContext* context, const ResetAIFilterResponseRequest* request, ResetAIFilterResponseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIFilterResponse(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIForceIEPESensorSensitivity(::grpc::ServerContext* context, const ResetAIForceIEPESensorSensitivityRequest* request, ResetAIForceIEPESensorSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIForceIEPESensorSensitivity(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIForceIEPESensorSensitivityUnits(::grpc::ServerContext* context, const ResetAIForceIEPESensorSensitivityUnitsRequest* request, ResetAIForceIEPESensorSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIForceIEPESensorSensitivityUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIForceReadFromChan(::grpc::ServerContext* context, const ResetAIForceReadFromChanRequest* request, ResetAIForceReadFromChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIForceReadFromChan(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIForceUnits(::grpc::ServerContext* context, const ResetAIForceUnitsRequest* request, ResetAIForceUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIForceUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIFreqHyst(::grpc::ServerContext* context, const ResetAIFreqHystRequest* request, ResetAIFreqHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIFreqHyst(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIFreqThreshVoltage(::grpc::ServerContext* context, const ResetAIFreqThreshVoltageRequest* request, ResetAIFreqThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIFreqThreshVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIFreqUnits(::grpc::ServerContext* context, const ResetAIFreqUnitsRequest* request, ResetAIFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIFreqUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIGain(::grpc::ServerContext* context, const ResetAIGainRequest* request, ResetAIGainResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIGain(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIImpedance(::grpc::ServerContext* context, const ResetAIImpedanceRequest* request, ResetAIImpedanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIImpedance(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIInputLimitsFaultDetectEnable(::grpc::ServerContext* context, const ResetAIInputLimitsFaultDetectEnableRequest* request, ResetAIInputLimitsFaultDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIInputLimitsFaultDetectEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIInputLimitsFaultDetectLowerLimit(::grpc::ServerContext* context, const ResetAIInputLimitsFaultDetectLowerLimitRequest* request, ResetAIInputLimitsFaultDetectLowerLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIInputLimitsFaultDetectLowerLimit(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIInputLimitsFaultDetectUpperLimit(::grpc::ServerContext* context, const ResetAIInputLimitsFaultDetectUpperLimitRequest* request, ResetAIInputLimitsFaultDetectUpperLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIInputLimitsFaultDetectUpperLimit(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIInputSrc(::grpc::ServerContext* context, const ResetAIInputSrcRequest* request, ResetAIInputSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIInputSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILVDTSensitivity(::grpc::ServerContext* context, const ResetAILVDTSensitivityRequest* request, ResetAILVDTSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILVDTSensitivity(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILVDTSensitivityUnits(::grpc::ServerContext* context, const ResetAILVDTSensitivityUnitsRequest* request, ResetAILVDTSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILVDTSensitivityUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILVDTUnits(::grpc::ServerContext* context, const ResetAILVDTUnitsRequest* request, ResetAILVDTUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILVDTUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILeadWireResistance(::grpc::ServerContext* context, const ResetAILeadWireResistanceRequest* request, ResetAILeadWireResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILeadWireResistance(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILossyLSBRemovalCompressedSampSize(::grpc::ServerContext* context, const ResetAILossyLSBRemovalCompressedSampSizeRequest* request, ResetAILossyLSBRemovalCompressedSampSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILossyLSBRemovalCompressedSampSize(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILowpassCutoffFreq(::grpc::ServerContext* context, const ResetAILowpassCutoffFreqRequest* request, ResetAILowpassCutoffFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILowpassCutoffFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILowpassEnable(::grpc::ServerContext* context, const ResetAILowpassEnableRequest* request, ResetAILowpassEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILowpassEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILowpassSwitchCapClkSrc(::grpc::ServerContext* context, const ResetAILowpassSwitchCapClkSrcRequest* request, ResetAILowpassSwitchCapClkSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILowpassSwitchCapClkSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILowpassSwitchCapExtClkDiv(::grpc::ServerContext* context, const ResetAILowpassSwitchCapExtClkDivRequest* request, ResetAILowpassSwitchCapExtClkDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILowpassSwitchCapExtClkDiv(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILowpassSwitchCapExtClkFreq(::grpc::ServerContext* context, const ResetAILowpassSwitchCapExtClkFreqRequest* request, ResetAILowpassSwitchCapExtClkFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILowpassSwitchCapExtClkFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAILowpassSwitchCapOutClkDiv(::grpc::ServerContext* context, const ResetAILowpassSwitchCapOutClkDivRequest* request, ResetAILowpassSwitchCapOutClkDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAILowpassSwitchCapOutClkDiv(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIMax(::grpc::ServerContext* context, const ResetAIMaxRequest* request, ResetAIMaxResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIMax(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIMemMapEnable(::grpc::ServerContext* context, const ResetAIMemMapEnableRequest* request, ResetAIMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIMemMapEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIMicrophoneSensitivity(::grpc::ServerContext* context, const ResetAIMicrophoneSensitivityRequest* request, ResetAIMicrophoneSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIMicrophoneSensitivity(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIMin(::grpc::ServerContext* context, const ResetAIMinRequest* request, ResetAIMinResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIMin(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIOpenChanDetectEnable(::grpc::ServerContext* context, const ResetAIOpenChanDetectEnableRequest* request, ResetAIOpenChanDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIOpenChanDetectEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIOpenThrmcplDetectEnable(::grpc::ServerContext* context, const ResetAIOpenThrmcplDetectEnableRequest* request, ResetAIOpenThrmcplDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIOpenThrmcplDetectEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIOvercurrentDetectEnable(::grpc::ServerContext* context, const ResetAIOvercurrentDetectEnableRequest* request, ResetAIOvercurrentDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIOvercurrentDetectEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIPowerSupplyFaultDetectEnable(::grpc::ServerContext* context, const ResetAIPowerSupplyFaultDetectEnableRequest* request, ResetAIPowerSupplyFaultDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIPowerSupplyFaultDetectEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIPressureUnits(::grpc::ServerContext* context, const ResetAIPressureUnitsRequest* request, ResetAIPressureUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIPressureUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIProbeAtten(::grpc::ServerContext* context, const ResetAIProbeAttenRequest* request, ResetAIProbeAttenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIProbeAtten(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRTDA(::grpc::ServerContext* context, const ResetAIRTDARequest* request, ResetAIRTDAResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRTDA(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRTDB(::grpc::ServerContext* context, const ResetAIRTDBRequest* request, ResetAIRTDBResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRTDB(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRTDC(::grpc::ServerContext* context, const ResetAIRTDCRequest* request, ResetAIRTDCResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRTDC(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRTDR0(::grpc::ServerContext* context, const ResetAIRTDR0Request* request, ResetAIRTDR0Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRTDR0(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRTDType(::grpc::ServerContext* context, const ResetAIRTDTypeRequest* request, ResetAIRTDTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRTDType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRVDTSensitivity(::grpc::ServerContext* context, const ResetAIRVDTSensitivityRequest* request, ResetAIRVDTSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRVDTSensitivity(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRVDTSensitivityUnits(::grpc::ServerContext* context, const ResetAIRVDTSensitivityUnitsRequest* request, ResetAIRVDTSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRVDTSensitivityUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRVDTUnits(::grpc::ServerContext* context, const ResetAIRVDTUnitsRequest* request, ResetAIRVDTUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRVDTUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRawDataCompressionType(::grpc::ServerContext* context, const ResetAIRawDataCompressionTypeRequest* request, ResetAIRawDataCompressionTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRawDataCompressionType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRemoveFilterDelay(::grpc::ServerContext* context, const ResetAIRemoveFilterDelayRequest* request, ResetAIRemoveFilterDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRemoveFilterDelay(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIResistanceCfg(::grpc::ServerContext* context, const ResetAIResistanceCfgRequest* request, ResetAIResistanceCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIResistanceCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIResistanceUnits(::grpc::ServerContext* context, const ResetAIResistanceUnitsRequest* request, ResetAIResistanceUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIResistanceUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRngHigh(::grpc::ServerContext* context, const ResetAIRngHighRequest* request, ResetAIRngHighResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRngHigh(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRngLow(::grpc::ServerContext* context, const ResetAIRngLowRequest* request, ResetAIRngLowResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRngLow(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRosetteStrainGageOrientation(::grpc::ServerContext* context, const ResetAIRosetteStrainGageOrientationRequest* request, ResetAIRosetteStrainGageOrientationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRosetteStrainGageOrientation(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIRosetteStrainGageRosetteMeasType(::grpc::ServerContext* context, const ResetAIRosetteStrainGageRosetteMeasTypeRequest* request, ResetAIRosetteStrainGageRosetteMeasTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIRosetteStrainGageRosetteMeasType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAISampAndHoldEnable(::grpc::ServerContext* context, const ResetAISampAndHoldEnableRequest* request, ResetAISampAndHoldEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAISampAndHoldEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAISensorPowerCfg(::grpc::ServerContext* context, const ResetAISensorPowerCfgRequest* request, ResetAISensorPowerCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAISensorPowerCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAISensorPowerType(::grpc::ServerContext* context, const ResetAISensorPowerTypeRequest* request, ResetAISensorPowerTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAISensorPowerType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAISensorPowerVoltage(::grpc::ServerContext* context, const ResetAISensorPowerVoltageRequest* request, ResetAISensorPowerVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAISensorPowerVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAISoundPressureMaxSoundPressureLvl(::grpc::ServerContext* context, const ResetAISoundPressureMaxSoundPressureLvlRequest* request, ResetAISoundPressureMaxSoundPressureLvlResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAISoundPressureMaxSoundPressureLvl(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAISoundPressureUnits(::grpc::ServerContext* context, const ResetAISoundPressureUnitsRequest* request, ResetAISoundPressureUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAISoundPressureUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAISoundPressuredBRef(::grpc::ServerContext* context, const ResetAISoundPressuredBRefRequest* request, ResetAISoundPressuredBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAISoundPressuredBRef(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIStrainGageCfg(::grpc::ServerContext* context, const ResetAIStrainGageCfgRequest* request, ResetAIStrainGageCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIStrainGageCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIStrainGageForceReadFromChan(::grpc::ServerContext* context, const ResetAIStrainGageForceReadFromChanRequest* request, ResetAIStrainGageForceReadFromChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIStrainGageForceReadFromChan(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIStrainGageGageFactor(::grpc::ServerContext* context, const ResetAIStrainGageGageFactorRequest* request, ResetAIStrainGageGageFactorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIStrainGageGageFactor(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIStrainGagePoissonRatio(::grpc::ServerContext* context, const ResetAIStrainGagePoissonRatioRequest* request, ResetAIStrainGagePoissonRatioResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIStrainGagePoissonRatio(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIStrainUnits(::grpc::ServerContext* context, const ResetAIStrainUnitsRequest* request, ResetAIStrainUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIStrainUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAITempUnits(::grpc::ServerContext* context, const ResetAITempUnitsRequest* request, ResetAITempUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAITempUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAITermCfg(::grpc::ServerContext* context, const ResetAITermCfgRequest* request, ResetAITermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAITermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIThrmcplCJCVal(::grpc::ServerContext* context, const ResetAIThrmcplCJCValRequest* request, ResetAIThrmcplCJCValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIThrmcplCJCVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIThrmcplLeadOffsetVoltage(::grpc::ServerContext* context, const ResetAIThrmcplLeadOffsetVoltageRequest* request, ResetAIThrmcplLeadOffsetVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIThrmcplLeadOffsetVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIThrmcplScaleType(::grpc::ServerContext* context, const ResetAIThrmcplScaleTypeRequest* request, ResetAIThrmcplScaleTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIThrmcplScaleType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIThrmcplType(::grpc::ServerContext* context, const ResetAIThrmcplTypeRequest* request, ResetAIThrmcplTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIThrmcplType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIThrmstrA(::grpc::ServerContext* context, const ResetAIThrmstrARequest* request, ResetAIThrmstrAResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIThrmstrA(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIThrmstrB(::grpc::ServerContext* context, const ResetAIThrmstrBRequest* request, ResetAIThrmstrBResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIThrmstrB(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIThrmstrC(::grpc::ServerContext* context, const ResetAIThrmstrCRequest* request, ResetAIThrmstrCResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIThrmstrC(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIThrmstrR1(::grpc::ServerContext* context, const ResetAIThrmstrR1Request* request, ResetAIThrmstrR1Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIThrmstrR1(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAITorqueUnits(::grpc::ServerContext* context, const ResetAITorqueUnitsRequest* request, ResetAITorqueUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAITorqueUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIUsbXferReqCount(::grpc::ServerContext* context, const ResetAIUsbXferReqCountRequest* request, ResetAIUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIUsbXferReqCount(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIUsbXferReqSize(::grpc::ServerContext* context, const ResetAIUsbXferReqSizeRequest* request, ResetAIUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIUsbXferReqSize(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIVelocityIEPESensorSensitivity(::grpc::ServerContext* context, const ResetAIVelocityIEPESensorSensitivityRequest* request, ResetAIVelocityIEPESensorSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIVelocityIEPESensorSensitivity(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIVelocityIEPESensorSensitivityUnits(::grpc::ServerContext* context, const ResetAIVelocityIEPESensorSensitivityUnitsRequest* request, ResetAIVelocityIEPESensorSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIVelocityIEPESensorSensitivityUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIVelocityIEPESensordBRef(::grpc::ServerContext* context, const ResetAIVelocityIEPESensordBRefRequest* request, ResetAIVelocityIEPESensordBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIVelocityIEPESensordBRef(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIVelocityUnits(::grpc::ServerContext* context, const ResetAIVelocityUnitsRequest* request, ResetAIVelocityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIVelocityUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIVoltageACRMSUnits(::grpc::ServerContext* context, const ResetAIVoltageACRMSUnitsRequest* request, ResetAIVoltageACRMSUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIVoltageACRMSUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIVoltageUnits(::grpc::ServerContext* context, const ResetAIVoltageUnitsRequest* request, ResetAIVoltageUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIVoltageUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAIVoltagedBRef(::grpc::ServerContext* context, const ResetAIVoltagedBRefRequest* request, ResetAIVoltagedBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAIVoltagedBRef(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOCurrentUnits(::grpc::ServerContext* context, const ResetAOCurrentUnitsRequest* request, ResetAOCurrentUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOCurrentUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOCustomScaleName(::grpc::ServerContext* context, const ResetAOCustomScaleNameRequest* request, ResetAOCustomScaleNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOCustomScaleName(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODACOffsetExtSrc(::grpc::ServerContext* context, const ResetAODACOffsetExtSrcRequest* request, ResetAODACOffsetExtSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODACOffsetExtSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODACOffsetSrc(::grpc::ServerContext* context, const ResetAODACOffsetSrcRequest* request, ResetAODACOffsetSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODACOffsetSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODACOffsetVal(::grpc::ServerContext* context, const ResetAODACOffsetValRequest* request, ResetAODACOffsetValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODACOffsetVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODACRefAllowConnToGnd(::grpc::ServerContext* context, const ResetAODACRefAllowConnToGndRequest* request, ResetAODACRefAllowConnToGndResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODACRefAllowConnToGnd(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODACRefConnToGnd(::grpc::ServerContext* context, const ResetAODACRefConnToGndRequest* request, ResetAODACRefConnToGndResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODACRefConnToGnd(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODACRefExtSrc(::grpc::ServerContext* context, const ResetAODACRefExtSrcRequest* request, ResetAODACRefExtSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODACRefExtSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODACRefSrc(::grpc::ServerContext* context, const ResetAODACRefSrcRequest* request, ResetAODACRefSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODACRefSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODACRefVal(::grpc::ServerContext* context, const ResetAODACRefValRequest* request, ResetAODACRefValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODACRefVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODACRngHigh(::grpc::ServerContext* context, const ResetAODACRngHighRequest* request, ResetAODACRngHighResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODACRngHigh(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODACRngLow(::grpc::ServerContext* context, const ResetAODACRngLowRequest* request, ResetAODACRngLowResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODACRngLow(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODataXferMech(::grpc::ServerContext* context, const ResetAODataXferMechRequest* request, ResetAODataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODataXferMech(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAODataXferReqCond(::grpc::ServerContext* context, const ResetAODataXferReqCondRequest* request, ResetAODataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAODataXferReqCond(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOEnhancedImageRejectionEnable(::grpc::ServerContext* context, const ResetAOEnhancedImageRejectionEnableRequest* request, ResetAOEnhancedImageRejectionEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOEnhancedImageRejectionEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOFilterDelay(::grpc::ServerContext* context, const ResetAOFilterDelayRequest* request, ResetAOFilterDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOFilterDelay(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOFilterDelayAdjustment(::grpc::ServerContext* context, const ResetAOFilterDelayAdjustmentRequest* request, ResetAOFilterDelayAdjustmentResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOFilterDelayAdjustment(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOFilterDelayUnits(::grpc::ServerContext* context, const ResetAOFilterDelayUnitsRequest* request, ResetAOFilterDelayUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOFilterDelayUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOFuncGenAmplitude(::grpc::ServerContext* context, const ResetAOFuncGenAmplitudeRequest* request, ResetAOFuncGenAmplitudeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOFuncGenAmplitude(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOFuncGenFMDeviation(::grpc::ServerContext* context, const ResetAOFuncGenFMDeviationRequest* request, ResetAOFuncGenFMDeviationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOFuncGenFMDeviation(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOFuncGenFreq(::grpc::ServerContext* context, const ResetAOFuncGenFreqRequest* request, ResetAOFuncGenFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOFuncGenFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOFuncGenModulationType(::grpc::ServerContext* context, const ResetAOFuncGenModulationTypeRequest* request, ResetAOFuncGenModulationTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOFuncGenModulationType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOFuncGenOffset(::grpc::ServerContext* context, const ResetAOFuncGenOffsetRequest* request, ResetAOFuncGenOffsetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOFuncGenOffset(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOFuncGenSquareDutyCycle(::grpc::ServerContext* context, const ResetAOFuncGenSquareDutyCycleRequest* request, ResetAOFuncGenSquareDutyCycleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOFuncGenSquareDutyCycle(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOFuncGenType(::grpc::ServerContext* context, const ResetAOFuncGenTypeRequest* request, ResetAOFuncGenTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOFuncGenType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOGain(::grpc::ServerContext* context, const ResetAOGainRequest* request, ResetAOGainResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOGain(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOIdleOutputBehavior(::grpc::ServerContext* context, const ResetAOIdleOutputBehaviorRequest* request, ResetAOIdleOutputBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOIdleOutputBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOLoadImpedance(::grpc::ServerContext* context, const ResetAOLoadImpedanceRequest* request, ResetAOLoadImpedanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOLoadImpedance(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOMax(::grpc::ServerContext* context, const ResetAOMaxRequest* request, ResetAOMaxResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOMax(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOMemMapEnable(::grpc::ServerContext* context, const ResetAOMemMapEnableRequest* request, ResetAOMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOMemMapEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOMin(::grpc::ServerContext* context, const ResetAOMinRequest* request, ResetAOMinResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOMin(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOOutputImpedance(::grpc::ServerContext* context, const ResetAOOutputImpedanceRequest* request, ResetAOOutputImpedanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOOutputImpedance(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOReglitchEnable(::grpc::ServerContext* context, const ResetAOReglitchEnableRequest* request, ResetAOReglitchEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOReglitchEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOResolutionUnits(::grpc::ServerContext* context, const ResetAOResolutionUnitsRequest* request, ResetAOResolutionUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOResolutionUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOTermCfg(::grpc::ServerContext* context, const ResetAOTermCfgRequest* request, ResetAOTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOUsbXferReqCount(::grpc::ServerContext* context, const ResetAOUsbXferReqCountRequest* request, ResetAOUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOUsbXferReqCount(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOUsbXferReqSize(::grpc::ServerContext* context, const ResetAOUsbXferReqSizeRequest* request, ResetAOUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOUsbXferReqSize(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOUseOnlyOnBrdMem(::grpc::ServerContext* context, const ResetAOUseOnlyOnBrdMemRequest* request, ResetAOUseOnlyOnBrdMemResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOUseOnlyOnBrdMem(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOVoltageCurrentLimit(::grpc::ServerContext* context, const ResetAOVoltageCurrentLimitRequest* request, ResetAOVoltageCurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOVoltageCurrentLimit(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetAOVoltageUnits(::grpc::ServerContext* context, const ResetAOVoltageUnitsRequest* request, ResetAOVoltageUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetAOVoltageUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetBufInputBufSize(::grpc::ServerContext* context, const ResetBufInputBufSizeRequest* request, ResetBufInputBufSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->ResetBufInputBufSize(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetBufOutputBufSize(::grpc::ServerContext* context, const ResetBufOutputBufSizeRequest* request, ResetBufOutputBufSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->ResetBufOutputBufSize(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetBufOutputOnbrdBufSize(::grpc::ServerContext* context, const ResetBufOutputOnbrdBufSizeRequest* request, ResetBufOutputOnbrdBufSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->ResetBufOutputOnbrdBufSize(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIAngEncoderInitialAngle(::grpc::ServerContext* context, const ResetCIAngEncoderInitialAngleRequest* request, ResetCIAngEncoderInitialAngleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIAngEncoderInitialAngle(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIAngEncoderPulsesPerRev(::grpc::ServerContext* context, const ResetCIAngEncoderPulsesPerRevRequest* request, ResetCIAngEncoderPulsesPerRevResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIAngEncoderPulsesPerRev(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIAngEncoderUnits(::grpc::ServerContext* context, const ResetCIAngEncoderUnitsRequest* request, ResetCIAngEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIAngEncoderUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesActiveEdge(::grpc::ServerContext* context, const ResetCICountEdgesActiveEdgeRequest* request, ResetCICountEdgesActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesActiveEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountDirDigFltrEnable(::grpc::ServerContext* context, const ResetCICountEdgesCountDirDigFltrEnableRequest* request, ResetCICountEdgesCountDirDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountDirDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountDirDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCICountEdgesCountDirDigFltrMinPulseWidthRequest* request, ResetCICountEdgesCountDirDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountDirDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountDirDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCICountEdgesCountDirDigFltrTimebaseRateRequest* request, ResetCICountEdgesCountDirDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountDirDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountDirDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCICountEdgesCountDirDigFltrTimebaseSrcRequest* request, ResetCICountEdgesCountDirDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountDirDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountDirDigSyncEnable(::grpc::ServerContext* context, const ResetCICountEdgesCountDirDigSyncEnableRequest* request, ResetCICountEdgesCountDirDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountDirDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountDirHyst(::grpc::ServerContext* context, const ResetCICountEdgesCountDirHystRequest* request, ResetCICountEdgesCountDirHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountDirHyst(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountDirLogicLvlBehavior(::grpc::ServerContext* context, const ResetCICountEdgesCountDirLogicLvlBehaviorRequest* request, ResetCICountEdgesCountDirLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountDirLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountDirTermCfg(::grpc::ServerContext* context, const ResetCICountEdgesCountDirTermCfgRequest* request, ResetCICountEdgesCountDirTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountDirTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountDirThreshVoltage(::grpc::ServerContext* context, const ResetCICountEdgesCountDirThreshVoltageRequest* request, ResetCICountEdgesCountDirThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountDirThreshVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetActiveEdge(::grpc::ServerContext* context, const ResetCICountEdgesCountResetActiveEdgeRequest* request, ResetCICountEdgesCountResetActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetActiveEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetDigFltrEnable(::grpc::ServerContext* context, const ResetCICountEdgesCountResetDigFltrEnableRequest* request, ResetCICountEdgesCountResetDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCICountEdgesCountResetDigFltrMinPulseWidthRequest* request, ResetCICountEdgesCountResetDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCICountEdgesCountResetDigFltrTimebaseRateRequest* request, ResetCICountEdgesCountResetDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCICountEdgesCountResetDigFltrTimebaseSrcRequest* request, ResetCICountEdgesCountResetDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetDigSyncEnable(::grpc::ServerContext* context, const ResetCICountEdgesCountResetDigSyncEnableRequest* request, ResetCICountEdgesCountResetDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetEnable(::grpc::ServerContext* context, const ResetCICountEdgesCountResetEnableRequest* request, ResetCICountEdgesCountResetEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetHyst(::grpc::ServerContext* context, const ResetCICountEdgesCountResetHystRequest* request, ResetCICountEdgesCountResetHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetHyst(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetLogicLvlBehavior(::grpc::ServerContext* context, const ResetCICountEdgesCountResetLogicLvlBehaviorRequest* request, ResetCICountEdgesCountResetLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetResetCount(::grpc::ServerContext* context, const ResetCICountEdgesCountResetResetCountRequest* request, ResetCICountEdgesCountResetResetCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetResetCount(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetTerm(::grpc::ServerContext* context, const ResetCICountEdgesCountResetTermRequest* request, ResetCICountEdgesCountResetTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetTermCfg(::grpc::ServerContext* context, const ResetCICountEdgesCountResetTermCfgRequest* request, ResetCICountEdgesCountResetTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesCountResetThreshVoltage(::grpc::ServerContext* context, const ResetCICountEdgesCountResetThreshVoltageRequest* request, ResetCICountEdgesCountResetThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesCountResetThreshVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesDigFltrEnable(::grpc::ServerContext* context, const ResetCICountEdgesDigFltrEnableRequest* request, ResetCICountEdgesDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCICountEdgesDigFltrMinPulseWidthRequest* request, ResetCICountEdgesDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCICountEdgesDigFltrTimebaseRateRequest* request, ResetCICountEdgesDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCICountEdgesDigFltrTimebaseSrcRequest* request, ResetCICountEdgesDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesDigSyncEnable(::grpc::ServerContext* context, const ResetCICountEdgesDigSyncEnableRequest* request, ResetCICountEdgesDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesDir(::grpc::ServerContext* context, const ResetCICountEdgesDirRequest* request, ResetCICountEdgesDirResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesDir(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesDirTerm(::grpc::ServerContext* context, const ResetCICountEdgesDirTermRequest* request, ResetCICountEdgesDirTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesDirTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateDigFltrEnable(::grpc::ServerContext* context, const ResetCICountEdgesGateDigFltrEnableRequest* request, ResetCICountEdgesGateDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCICountEdgesGateDigFltrMinPulseWidthRequest* request, ResetCICountEdgesGateDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCICountEdgesGateDigFltrTimebaseRateRequest* request, ResetCICountEdgesGateDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCICountEdgesGateDigFltrTimebaseSrcRequest* request, ResetCICountEdgesGateDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateEnable(::grpc::ServerContext* context, const ResetCICountEdgesGateEnableRequest* request, ResetCICountEdgesGateEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateHyst(::grpc::ServerContext* context, const ResetCICountEdgesGateHystRequest* request, ResetCICountEdgesGateHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateHyst(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateLogicLvlBehavior(::grpc::ServerContext* context, const ResetCICountEdgesGateLogicLvlBehaviorRequest* request, ResetCICountEdgesGateLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateTerm(::grpc::ServerContext* context, const ResetCICountEdgesGateTermRequest* request, ResetCICountEdgesGateTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateTermCfg(::grpc::ServerContext* context, const ResetCICountEdgesGateTermCfgRequest* request, ResetCICountEdgesGateTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateThreshVoltage(::grpc::ServerContext* context, const ResetCICountEdgesGateThreshVoltageRequest* request, ResetCICountEdgesGateThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateThreshVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesGateWhen(::grpc::ServerContext* context, const ResetCICountEdgesGateWhenRequest* request, ResetCICountEdgesGateWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesGateWhen(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesHyst(::grpc::ServerContext* context, const ResetCICountEdgesHystRequest* request, ResetCICountEdgesHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesHyst(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesInitialCnt(::grpc::ServerContext* context, const ResetCICountEdgesInitialCntRequest* request, ResetCICountEdgesInitialCntResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesInitialCnt(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesLogicLvlBehavior(::grpc::ServerContext* context, const ResetCICountEdgesLogicLvlBehaviorRequest* request, ResetCICountEdgesLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesTerm(::grpc::ServerContext* context, const ResetCICountEdgesTermRequest* request, ResetCICountEdgesTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesTermCfg(::grpc::ServerContext* context, const ResetCICountEdgesTermCfgRequest* request, ResetCICountEdgesTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICountEdgesThreshVoltage(::grpc::ServerContext* context, const ResetCICountEdgesThreshVoltageRequest* request, ResetCICountEdgesThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICountEdgesThreshVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICtrTimebaseActiveEdge(::grpc::ServerContext* context, const ResetCICtrTimebaseActiveEdgeRequest* request, ResetCICtrTimebaseActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICtrTimebaseActiveEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICtrTimebaseDigFltrEnable(::grpc::ServerContext* context, const ResetCICtrTimebaseDigFltrEnableRequest* request, ResetCICtrTimebaseDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICtrTimebaseDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICtrTimebaseDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCICtrTimebaseDigFltrMinPulseWidthRequest* request, ResetCICtrTimebaseDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICtrTimebaseDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICtrTimebaseDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCICtrTimebaseDigFltrTimebaseRateRequest* request, ResetCICtrTimebaseDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICtrTimebaseDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICtrTimebaseDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCICtrTimebaseDigFltrTimebaseSrcRequest* request, ResetCICtrTimebaseDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICtrTimebaseDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICtrTimebaseDigSyncEnable(::grpc::ServerContext* context, const ResetCICtrTimebaseDigSyncEnableRequest* request, ResetCICtrTimebaseDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICtrTimebaseDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICtrTimebaseMasterTimebaseDiv(::grpc::ServerContext* context, const ResetCICtrTimebaseMasterTimebaseDivRequest* request, ResetCICtrTimebaseMasterTimebaseDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICtrTimebaseMasterTimebaseDiv(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICtrTimebaseRate(::grpc::ServerContext* context, const ResetCICtrTimebaseRateRequest* request, ResetCICtrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICtrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICtrTimebaseSrc(::grpc::ServerContext* context, const ResetCICtrTimebaseSrcRequest* request, ResetCICtrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICtrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCICustomScaleName(::grpc::ServerContext* context, const ResetCICustomScaleNameRequest* request, ResetCICustomScaleNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCICustomScaleName(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDataXferMech(::grpc::ServerContext* context, const ResetCIDataXferMechRequest* request, ResetCIDataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDataXferMech(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDataXferReqCond(::grpc::ServerContext* context, const ResetCIDataXferReqCondRequest* request, ResetCIDataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDataXferReqCond(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDupCountPrevent(::grpc::ServerContext* context, const ResetCIDupCountPreventRequest* request, ResetCIDupCountPreventResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDupCountPrevent(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDutyCycleDigFltrEnable(::grpc::ServerContext* context, const ResetCIDutyCycleDigFltrEnableRequest* request, ResetCIDutyCycleDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDutyCycleDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDutyCycleDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIDutyCycleDigFltrMinPulseWidthRequest* request, ResetCIDutyCycleDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDutyCycleDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDutyCycleDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIDutyCycleDigFltrTimebaseRateRequest* request, ResetCIDutyCycleDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDutyCycleDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDutyCycleDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIDutyCycleDigFltrTimebaseSrcRequest* request, ResetCIDutyCycleDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDutyCycleDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDutyCycleLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIDutyCycleLogicLvlBehaviorRequest* request, ResetCIDutyCycleLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDutyCycleLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDutyCycleStartingEdge(::grpc::ServerContext* context, const ResetCIDutyCycleStartingEdgeRequest* request, ResetCIDutyCycleStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDutyCycleStartingEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDutyCycleTerm(::grpc::ServerContext* context, const ResetCIDutyCycleTermRequest* request, ResetCIDutyCycleTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDutyCycleTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIDutyCycleTermCfg(::grpc::ServerContext* context, const ResetCIDutyCycleTermCfgRequest* request, ResetCIDutyCycleTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIDutyCycleTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderAInputDigFltrEnable(::grpc::ServerContext* context, const ResetCIEncoderAInputDigFltrEnableRequest* request, ResetCIEncoderAInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderAInputDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderAInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIEncoderAInputDigFltrMinPulseWidthRequest* request, ResetCIEncoderAInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderAInputDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderAInputDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIEncoderAInputDigFltrTimebaseRateRequest* request, ResetCIEncoderAInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderAInputDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderAInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIEncoderAInputDigFltrTimebaseSrcRequest* request, ResetCIEncoderAInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderAInputDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderAInputDigSyncEnable(::grpc::ServerContext* context, const ResetCIEncoderAInputDigSyncEnableRequest* request, ResetCIEncoderAInputDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderAInputDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderAInputLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIEncoderAInputLogicLvlBehaviorRequest* request, ResetCIEncoderAInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderAInputLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderAInputTerm(::grpc::ServerContext* context, const ResetCIEncoderAInputTermRequest* request, ResetCIEncoderAInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderAInputTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderAInputTermCfg(::grpc::ServerContext* context, const ResetCIEncoderAInputTermCfgRequest* request, ResetCIEncoderAInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderAInputTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderBInputDigFltrEnable(::grpc::ServerContext* context, const ResetCIEncoderBInputDigFltrEnableRequest* request, ResetCIEncoderBInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderBInputDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderBInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIEncoderBInputDigFltrMinPulseWidthRequest* request, ResetCIEncoderBInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderBInputDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderBInputDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIEncoderBInputDigFltrTimebaseRateRequest* request, ResetCIEncoderBInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderBInputDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderBInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIEncoderBInputDigFltrTimebaseSrcRequest* request, ResetCIEncoderBInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderBInputDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderBInputDigSyncEnable(::grpc::ServerContext* context, const ResetCIEncoderBInputDigSyncEnableRequest* request, ResetCIEncoderBInputDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderBInputDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderBInputLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIEncoderBInputLogicLvlBehaviorRequest* request, ResetCIEncoderBInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderBInputLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderBInputTerm(::grpc::ServerContext* context, const ResetCIEncoderBInputTermRequest* request, ResetCIEncoderBInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderBInputTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderBInputTermCfg(::grpc::ServerContext* context, const ResetCIEncoderBInputTermCfgRequest* request, ResetCIEncoderBInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderBInputTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderDecodingType(::grpc::ServerContext* context, const ResetCIEncoderDecodingTypeRequest* request, ResetCIEncoderDecodingTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderDecodingType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZIndexEnable(::grpc::ServerContext* context, const ResetCIEncoderZIndexEnableRequest* request, ResetCIEncoderZIndexEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZIndexEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZIndexPhase(::grpc::ServerContext* context, const ResetCIEncoderZIndexPhaseRequest* request, ResetCIEncoderZIndexPhaseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZIndexPhase(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZIndexVal(::grpc::ServerContext* context, const ResetCIEncoderZIndexValRequest* request, ResetCIEncoderZIndexValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZIndexVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZInputDigFltrEnable(::grpc::ServerContext* context, const ResetCIEncoderZInputDigFltrEnableRequest* request, ResetCIEncoderZInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZInputDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIEncoderZInputDigFltrMinPulseWidthRequest* request, ResetCIEncoderZInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZInputDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZInputDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIEncoderZInputDigFltrTimebaseRateRequest* request, ResetCIEncoderZInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZInputDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIEncoderZInputDigFltrTimebaseSrcRequest* request, ResetCIEncoderZInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZInputDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZInputDigSyncEnable(::grpc::ServerContext* context, const ResetCIEncoderZInputDigSyncEnableRequest* request, ResetCIEncoderZInputDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZInputDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZInputLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIEncoderZInputLogicLvlBehaviorRequest* request, ResetCIEncoderZInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZInputLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZInputTerm(::grpc::ServerContext* context, const ResetCIEncoderZInputTermRequest* request, ResetCIEncoderZInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZInputTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIEncoderZInputTermCfg(::grpc::ServerContext* context, const ResetCIEncoderZInputTermCfgRequest* request, ResetCIEncoderZInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIEncoderZInputTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFilterDelayUnits(::grpc::ServerContext* context, const ResetCIFilterDelayUnitsRequest* request, ResetCIFilterDelayUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFilterDelayUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFilterEnable(::grpc::ServerContext* context, const ResetCIFilterEnableRequest* request, ResetCIFilterEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFilterEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFilterFreq(::grpc::ServerContext* context, const ResetCIFilterFreqRequest* request, ResetCIFilterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFilterFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFilterOrder(::grpc::ServerContext* context, const ResetCIFilterOrderRequest* request, ResetCIFilterOrderResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFilterOrder(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFilterResponse(::grpc::ServerContext* context, const ResetCIFilterResponseRequest* request, ResetCIFilterResponseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFilterResponse(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqDigFltrEnable(::grpc::ServerContext* context, const ResetCIFreqDigFltrEnableRequest* request, ResetCIFreqDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIFreqDigFltrMinPulseWidthRequest* request, ResetCIFreqDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIFreqDigFltrTimebaseRateRequest* request, ResetCIFreqDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIFreqDigFltrTimebaseSrcRequest* request, ResetCIFreqDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqDigSyncEnable(::grpc::ServerContext* context, const ResetCIFreqDigSyncEnableRequest* request, ResetCIFreqDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqDiv(::grpc::ServerContext* context, const ResetCIFreqDivRequest* request, ResetCIFreqDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqDiv(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqEnableAveraging(::grpc::ServerContext* context, const ResetCIFreqEnableAveragingRequest* request, ResetCIFreqEnableAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqEnableAveraging(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqHyst(::grpc::ServerContext* context, const ResetCIFreqHystRequest* request, ResetCIFreqHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqHyst(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIFreqLogicLvlBehaviorRequest* request, ResetCIFreqLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqMeasMeth(::grpc::ServerContext* context, const ResetCIFreqMeasMethRequest* request, ResetCIFreqMeasMethResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqMeasMeth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqMeasTime(::grpc::ServerContext* context, const ResetCIFreqMeasTimeRequest* request, ResetCIFreqMeasTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqMeasTime(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqStartingEdge(::grpc::ServerContext* context, const ResetCIFreqStartingEdgeRequest* request, ResetCIFreqStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqStartingEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqTerm(::grpc::ServerContext* context, const ResetCIFreqTermRequest* request, ResetCIFreqTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqTermCfg(::grpc::ServerContext* context, const ResetCIFreqTermCfgRequest* request, ResetCIFreqTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqThreshVoltage(::grpc::ServerContext* context, const ResetCIFreqThreshVoltageRequest* request, ResetCIFreqThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqThreshVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIFreqUnits(::grpc::ServerContext* context, const ResetCIFreqUnitsRequest* request, ResetCIFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIFreqUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIGPSSyncMethod(::grpc::ServerContext* context, const ResetCIGPSSyncMethodRequest* request, ResetCIGPSSyncMethodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIGPSSyncMethod(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIGPSSyncSrc(::grpc::ServerContext* context, const ResetCIGPSSyncSrcRequest* request, ResetCIGPSSyncSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIGPSSyncSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCILinEncoderDistPerPulse(::grpc::ServerContext* context, const ResetCILinEncoderDistPerPulseRequest* request, ResetCILinEncoderDistPerPulseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCILinEncoderDistPerPulse(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCILinEncoderInitialPos(::grpc::ServerContext* context, const ResetCILinEncoderInitialPosRequest* request, ResetCILinEncoderInitialPosResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCILinEncoderInitialPos(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCILinEncoderUnits(::grpc::ServerContext* context, const ResetCILinEncoderUnitsRequest* request, ResetCILinEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCILinEncoderUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIMax(::grpc::ServerContext* context, const ResetCIMaxRequest* request, ResetCIMaxResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIMax(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIMaxMeasPeriod(::grpc::ServerContext* context, const ResetCIMaxMeasPeriodRequest* request, ResetCIMaxMeasPeriodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIMaxMeasPeriod(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIMemMapEnable(::grpc::ServerContext* context, const ResetCIMemMapEnableRequest* request, ResetCIMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIMemMapEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIMin(::grpc::ServerContext* context, const ResetCIMinRequest* request, ResetCIMinResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIMin(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodDigFltrEnable(::grpc::ServerContext* context, const ResetCIPeriodDigFltrEnableRequest* request, ResetCIPeriodDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIPeriodDigFltrMinPulseWidthRequest* request, ResetCIPeriodDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIPeriodDigFltrTimebaseRateRequest* request, ResetCIPeriodDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIPeriodDigFltrTimebaseSrcRequest* request, ResetCIPeriodDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodDigSyncEnable(::grpc::ServerContext* context, const ResetCIPeriodDigSyncEnableRequest* request, ResetCIPeriodDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodDiv(::grpc::ServerContext* context, const ResetCIPeriodDivRequest* request, ResetCIPeriodDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodDiv(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodEnableAveraging(::grpc::ServerContext* context, const ResetCIPeriodEnableAveragingRequest* request, ResetCIPeriodEnableAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodEnableAveraging(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodHyst(::grpc::ServerContext* context, const ResetCIPeriodHystRequest* request, ResetCIPeriodHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodHyst(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIPeriodLogicLvlBehaviorRequest* request, ResetCIPeriodLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodMeasMeth(::grpc::ServerContext* context, const ResetCIPeriodMeasMethRequest* request, ResetCIPeriodMeasMethResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodMeasMeth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodMeasTime(::grpc::ServerContext* context, const ResetCIPeriodMeasTimeRequest* request, ResetCIPeriodMeasTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodMeasTime(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodStartingEdge(::grpc::ServerContext* context, const ResetCIPeriodStartingEdgeRequest* request, ResetCIPeriodStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodStartingEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodTerm(::grpc::ServerContext* context, const ResetCIPeriodTermRequest* request, ResetCIPeriodTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodTermCfg(::grpc::ServerContext* context, const ResetCIPeriodTermCfgRequest* request, ResetCIPeriodTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodThreshVoltage(::grpc::ServerContext* context, const ResetCIPeriodThreshVoltageRequest* request, ResetCIPeriodThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodThreshVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPeriodUnits(::grpc::ServerContext* context, const ResetCIPeriodUnitsRequest* request, ResetCIPeriodUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPeriodUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPrescaler(::grpc::ServerContext* context, const ResetCIPrescalerRequest* request, ResetCIPrescalerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPrescaler(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseFreqDigFltrEnable(::grpc::ServerContext* context, const ResetCIPulseFreqDigFltrEnableRequest* request, ResetCIPulseFreqDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseFreqDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseFreqDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIPulseFreqDigFltrMinPulseWidthRequest* request, ResetCIPulseFreqDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseFreqDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseFreqDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIPulseFreqDigFltrTimebaseRateRequest* request, ResetCIPulseFreqDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseFreqDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseFreqDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIPulseFreqDigFltrTimebaseSrcRequest* request, ResetCIPulseFreqDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseFreqDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseFreqDigSyncEnable(::grpc::ServerContext* context, const ResetCIPulseFreqDigSyncEnableRequest* request, ResetCIPulseFreqDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseFreqDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseFreqLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIPulseFreqLogicLvlBehaviorRequest* request, ResetCIPulseFreqLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseFreqLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseFreqStartEdge(::grpc::ServerContext* context, const ResetCIPulseFreqStartEdgeRequest* request, ResetCIPulseFreqStartEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseFreqStartEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseFreqTerm(::grpc::ServerContext* context, const ResetCIPulseFreqTermRequest* request, ResetCIPulseFreqTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseFreqTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseFreqTermCfg(::grpc::ServerContext* context, const ResetCIPulseFreqTermCfgRequest* request, ResetCIPulseFreqTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseFreqTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseFreqUnits(::grpc::ServerContext* context, const ResetCIPulseFreqUnitsRequest* request, ResetCIPulseFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseFreqUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTicksDigFltrEnable(::grpc::ServerContext* context, const ResetCIPulseTicksDigFltrEnableRequest* request, ResetCIPulseTicksDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTicksDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTicksDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIPulseTicksDigFltrMinPulseWidthRequest* request, ResetCIPulseTicksDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTicksDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTicksDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIPulseTicksDigFltrTimebaseRateRequest* request, ResetCIPulseTicksDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTicksDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTicksDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIPulseTicksDigFltrTimebaseSrcRequest* request, ResetCIPulseTicksDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTicksDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTicksDigSyncEnable(::grpc::ServerContext* context, const ResetCIPulseTicksDigSyncEnableRequest* request, ResetCIPulseTicksDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTicksDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTicksLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIPulseTicksLogicLvlBehaviorRequest* request, ResetCIPulseTicksLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTicksLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTicksStartEdge(::grpc::ServerContext* context, const ResetCIPulseTicksStartEdgeRequest* request, ResetCIPulseTicksStartEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTicksStartEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTicksTerm(::grpc::ServerContext* context, const ResetCIPulseTicksTermRequest* request, ResetCIPulseTicksTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTicksTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTicksTermCfg(::grpc::ServerContext* context, const ResetCIPulseTicksTermCfgRequest* request, ResetCIPulseTicksTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTicksTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTimeDigFltrEnable(::grpc::ServerContext* context, const ResetCIPulseTimeDigFltrEnableRequest* request, ResetCIPulseTimeDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTimeDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTimeDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIPulseTimeDigFltrMinPulseWidthRequest* request, ResetCIPulseTimeDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTimeDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTimeDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIPulseTimeDigFltrTimebaseRateRequest* request, ResetCIPulseTimeDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTimeDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTimeDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIPulseTimeDigFltrTimebaseSrcRequest* request, ResetCIPulseTimeDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTimeDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTimeDigSyncEnable(::grpc::ServerContext* context, const ResetCIPulseTimeDigSyncEnableRequest* request, ResetCIPulseTimeDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTimeDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTimeLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIPulseTimeLogicLvlBehaviorRequest* request, ResetCIPulseTimeLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTimeLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTimeStartEdge(::grpc::ServerContext* context, const ResetCIPulseTimeStartEdgeRequest* request, ResetCIPulseTimeStartEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTimeStartEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTimeTerm(::grpc::ServerContext* context, const ResetCIPulseTimeTermRequest* request, ResetCIPulseTimeTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTimeTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTimeTermCfg(::grpc::ServerContext* context, const ResetCIPulseTimeTermCfgRequest* request, ResetCIPulseTimeTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTimeTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseTimeUnits(::grpc::ServerContext* context, const ResetCIPulseTimeUnitsRequest* request, ResetCIPulseTimeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseTimeUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseWidthDigFltrEnable(::grpc::ServerContext* context, const ResetCIPulseWidthDigFltrEnableRequest* request, ResetCIPulseWidthDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseWidthDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseWidthDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIPulseWidthDigFltrMinPulseWidthRequest* request, ResetCIPulseWidthDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseWidthDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseWidthDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIPulseWidthDigFltrTimebaseRateRequest* request, ResetCIPulseWidthDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseWidthDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseWidthDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIPulseWidthDigFltrTimebaseSrcRequest* request, ResetCIPulseWidthDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseWidthDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseWidthDigSyncEnable(::grpc::ServerContext* context, const ResetCIPulseWidthDigSyncEnableRequest* request, ResetCIPulseWidthDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseWidthDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseWidthLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIPulseWidthLogicLvlBehaviorRequest* request, ResetCIPulseWidthLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseWidthLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseWidthStartingEdge(::grpc::ServerContext* context, const ResetCIPulseWidthStartingEdgeRequest* request, ResetCIPulseWidthStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseWidthStartingEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseWidthTerm(::grpc::ServerContext* context, const ResetCIPulseWidthTermRequest* request, ResetCIPulseWidthTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseWidthTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseWidthTermCfg(::grpc::ServerContext* context, const ResetCIPulseWidthTermCfgRequest* request, ResetCIPulseWidthTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseWidthTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIPulseWidthUnits(::grpc::ServerContext* context, const ResetCIPulseWidthUnitsRequest* request, ResetCIPulseWidthUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIPulseWidthUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISampClkOverrunBehavior(::grpc::ServerContext* context, const ResetCISampClkOverrunBehaviorRequest* request, ResetCISampClkOverrunBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISampClkOverrunBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISampClkOverrunSentinelVal(::grpc::ServerContext* context, const ResetCISampClkOverrunSentinelValRequest* request, ResetCISampClkOverrunSentinelValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISampClkOverrunSentinelVal(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISemiPeriodDigFltrEnable(::grpc::ServerContext* context, const ResetCISemiPeriodDigFltrEnableRequest* request, ResetCISemiPeriodDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISemiPeriodDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISemiPeriodDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCISemiPeriodDigFltrMinPulseWidthRequest* request, ResetCISemiPeriodDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISemiPeriodDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISemiPeriodDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCISemiPeriodDigFltrTimebaseRateRequest* request, ResetCISemiPeriodDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISemiPeriodDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISemiPeriodDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCISemiPeriodDigFltrTimebaseSrcRequest* request, ResetCISemiPeriodDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISemiPeriodDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISemiPeriodDigSyncEnable(::grpc::ServerContext* context, const ResetCISemiPeriodDigSyncEnableRequest* request, ResetCISemiPeriodDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISemiPeriodDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISemiPeriodLogicLvlBehavior(::grpc::ServerContext* context, const ResetCISemiPeriodLogicLvlBehaviorRequest* request, ResetCISemiPeriodLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISemiPeriodLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISemiPeriodStartingEdge(::grpc::ServerContext* context, const ResetCISemiPeriodStartingEdgeRequest* request, ResetCISemiPeriodStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISemiPeriodStartingEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISemiPeriodTerm(::grpc::ServerContext* context, const ResetCISemiPeriodTermRequest* request, ResetCISemiPeriodTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISemiPeriodTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISemiPeriodTermCfg(::grpc::ServerContext* context, const ResetCISemiPeriodTermCfgRequest* request, ResetCISemiPeriodTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISemiPeriodTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCISemiPeriodUnits(::grpc::ServerContext* context, const ResetCISemiPeriodUnitsRequest* request, ResetCISemiPeriodUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCISemiPeriodUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIThreshVoltage(::grpc::ServerContext* context, const ResetCIThreshVoltageRequest* request, ResetCIThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIThreshVoltage(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITimestampInitialSeconds(::grpc::ServerContext* context, const ResetCITimestampInitialSecondsRequest* request, ResetCITimestampInitialSecondsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITimestampInitialSeconds(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITimestampUnits(::grpc::ServerContext* context, const ResetCITimestampUnitsRequest* request, ResetCITimestampUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITimestampUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepFirstDigFltrEnable(::grpc::ServerContext* context, const ResetCITwoEdgeSepFirstDigFltrEnableRequest* request, ResetCITwoEdgeSepFirstDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepFirstDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepFirstDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCITwoEdgeSepFirstDigFltrMinPulseWidthRequest* request, ResetCITwoEdgeSepFirstDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepFirstDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepFirstDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCITwoEdgeSepFirstDigFltrTimebaseRateRequest* request, ResetCITwoEdgeSepFirstDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepFirstDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepFirstDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCITwoEdgeSepFirstDigFltrTimebaseSrcRequest* request, ResetCITwoEdgeSepFirstDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepFirstDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepFirstDigSyncEnable(::grpc::ServerContext* context, const ResetCITwoEdgeSepFirstDigSyncEnableRequest* request, ResetCITwoEdgeSepFirstDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepFirstDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepFirstEdge(::grpc::ServerContext* context, const ResetCITwoEdgeSepFirstEdgeRequest* request, ResetCITwoEdgeSepFirstEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepFirstEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepFirstLogicLvlBehavior(::grpc::ServerContext* context, const ResetCITwoEdgeSepFirstLogicLvlBehaviorRequest* request, ResetCITwoEdgeSepFirstLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepFirstLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepFirstTerm(::grpc::ServerContext* context, const ResetCITwoEdgeSepFirstTermRequest* request, ResetCITwoEdgeSepFirstTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepFirstTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepFirstTermCfg(::grpc::ServerContext* context, const ResetCITwoEdgeSepFirstTermCfgRequest* request, ResetCITwoEdgeSepFirstTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepFirstTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepSecondDigFltrEnable(::grpc::ServerContext* context, const ResetCITwoEdgeSepSecondDigFltrEnableRequest* request, ResetCITwoEdgeSepSecondDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepSecondDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepSecondDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCITwoEdgeSepSecondDigFltrMinPulseWidthRequest* request, ResetCITwoEdgeSepSecondDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepSecondDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepSecondDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCITwoEdgeSepSecondDigFltrTimebaseRateRequest* request, ResetCITwoEdgeSepSecondDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepSecondDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepSecondDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCITwoEdgeSepSecondDigFltrTimebaseSrcRequest* request, ResetCITwoEdgeSepSecondDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepSecondDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepSecondDigSyncEnable(::grpc::ServerContext* context, const ResetCITwoEdgeSepSecondDigSyncEnableRequest* request, ResetCITwoEdgeSepSecondDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepSecondDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepSecondEdge(::grpc::ServerContext* context, const ResetCITwoEdgeSepSecondEdgeRequest* request, ResetCITwoEdgeSepSecondEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepSecondEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepSecondLogicLvlBehavior(::grpc::ServerContext* context, const ResetCITwoEdgeSepSecondLogicLvlBehaviorRequest* request, ResetCITwoEdgeSepSecondLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepSecondLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepSecondTerm(::grpc::ServerContext* context, const ResetCITwoEdgeSepSecondTermRequest* request, ResetCITwoEdgeSepSecondTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepSecondTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepSecondTermCfg(::grpc::ServerContext* context, const ResetCITwoEdgeSepSecondTermCfgRequest* request, ResetCITwoEdgeSepSecondTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepSecondTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCITwoEdgeSepUnits(::grpc::ServerContext* context, const ResetCITwoEdgeSepUnitsRequest* request, ResetCITwoEdgeSepUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCITwoEdgeSepUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIUsbXferReqCount(::grpc::ServerContext* context, const ResetCIUsbXferReqCountRequest* request, ResetCIUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIUsbXferReqCount(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIUsbXferReqSize(::grpc::ServerContext* context, const ResetCIUsbXferReqSizeRequest* request, ResetCIUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIUsbXferReqSize(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityAngEncoderPulsesPerRev(::grpc::ServerContext* context, const ResetCIVelocityAngEncoderPulsesPerRevRequest* request, ResetCIVelocityAngEncoderPulsesPerRevResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityAngEncoderPulsesPerRev(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityAngEncoderUnits(::grpc::ServerContext* context, const ResetCIVelocityAngEncoderUnitsRequest* request, ResetCIVelocityAngEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityAngEncoderUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityDiv(::grpc::ServerContext* context, const ResetCIVelocityDivRequest* request, ResetCIVelocityDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityDiv(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderAInputDigFltrEnable(::grpc::ServerContext* context, const ResetCIVelocityEncoderAInputDigFltrEnableRequest* request, ResetCIVelocityEncoderAInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderAInputDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderAInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIVelocityEncoderAInputDigFltrMinPulseWidthRequest* request, ResetCIVelocityEncoderAInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderAInputDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderAInputDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIVelocityEncoderAInputDigFltrTimebaseRateRequest* request, ResetCIVelocityEncoderAInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderAInputDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderAInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIVelocityEncoderAInputDigFltrTimebaseSrcRequest* request, ResetCIVelocityEncoderAInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderAInputDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderAInputLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIVelocityEncoderAInputLogicLvlBehaviorRequest* request, ResetCIVelocityEncoderAInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderAInputLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderAInputTerm(::grpc::ServerContext* context, const ResetCIVelocityEncoderAInputTermRequest* request, ResetCIVelocityEncoderAInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderAInputTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderAInputTermCfg(::grpc::ServerContext* context, const ResetCIVelocityEncoderAInputTermCfgRequest* request, ResetCIVelocityEncoderAInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderAInputTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderBInputDigFltrEnable(::grpc::ServerContext* context, const ResetCIVelocityEncoderBInputDigFltrEnableRequest* request, ResetCIVelocityEncoderBInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderBInputDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderBInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCIVelocityEncoderBInputDigFltrMinPulseWidthRequest* request, ResetCIVelocityEncoderBInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderBInputDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderBInputDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCIVelocityEncoderBInputDigFltrTimebaseRateRequest* request, ResetCIVelocityEncoderBInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderBInputDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderBInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCIVelocityEncoderBInputDigFltrTimebaseSrcRequest* request, ResetCIVelocityEncoderBInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderBInputDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderBInputLogicLvlBehavior(::grpc::ServerContext* context, const ResetCIVelocityEncoderBInputLogicLvlBehaviorRequest* request, ResetCIVelocityEncoderBInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderBInputLogicLvlBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderBInputTerm(::grpc::ServerContext* context, const ResetCIVelocityEncoderBInputTermRequest* request, ResetCIVelocityEncoderBInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderBInputTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderBInputTermCfg(::grpc::ServerContext* context, const ResetCIVelocityEncoderBInputTermCfgRequest* request, ResetCIVelocityEncoderBInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderBInputTermCfg(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityEncoderDecodingType(::grpc::ServerContext* context, const ResetCIVelocityEncoderDecodingTypeRequest* request, ResetCIVelocityEncoderDecodingTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityEncoderDecodingType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityLinEncoderDistPerPulse(::grpc::ServerContext* context, const ResetCIVelocityLinEncoderDistPerPulseRequest* request, ResetCIVelocityLinEncoderDistPerPulseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityLinEncoderDistPerPulse(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityLinEncoderUnits(::grpc::ServerContext* context, const ResetCIVelocityLinEncoderUnitsRequest* request, ResetCIVelocityLinEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityLinEncoderUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCIVelocityMeasTime(::grpc::ServerContext* context, const ResetCIVelocityMeasTimeRequest* request, ResetCIVelocityMeasTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCIVelocityMeasTime(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOAutoIncrCnt(::grpc::ServerContext* context, const ResetCOAutoIncrCntRequest* request, ResetCOAutoIncrCntResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOAutoIncrCnt(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOConstrainedGenMode(::grpc::ServerContext* context, const ResetCOConstrainedGenModeRequest* request, ResetCOConstrainedGenModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOConstrainedGenMode(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOCtrTimebaseActiveEdge(::grpc::ServerContext* context, const ResetCOCtrTimebaseActiveEdgeRequest* request, ResetCOCtrTimebaseActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOCtrTimebaseActiveEdge(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOCtrTimebaseDigFltrEnable(::grpc::ServerContext* context, const ResetCOCtrTimebaseDigFltrEnableRequest* request, ResetCOCtrTimebaseDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOCtrTimebaseDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOCtrTimebaseDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetCOCtrTimebaseDigFltrMinPulseWidthRequest* request, ResetCOCtrTimebaseDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOCtrTimebaseDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOCtrTimebaseDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetCOCtrTimebaseDigFltrTimebaseRateRequest* request, ResetCOCtrTimebaseDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOCtrTimebaseDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOCtrTimebaseDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetCOCtrTimebaseDigFltrTimebaseSrcRequest* request, ResetCOCtrTimebaseDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOCtrTimebaseDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOCtrTimebaseDigSyncEnable(::grpc::ServerContext* context, const ResetCOCtrTimebaseDigSyncEnableRequest* request, ResetCOCtrTimebaseDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOCtrTimebaseDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOCtrTimebaseMasterTimebaseDiv(::grpc::ServerContext* context, const ResetCOCtrTimebaseMasterTimebaseDivRequest* request, ResetCOCtrTimebaseMasterTimebaseDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOCtrTimebaseMasterTimebaseDiv(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOCtrTimebaseRate(::grpc::ServerContext* context, const ResetCOCtrTimebaseRateRequest* request, ResetCOCtrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOCtrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOCtrTimebaseSrc(::grpc::ServerContext* context, const ResetCOCtrTimebaseSrcRequest* request, ResetCOCtrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOCtrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCODataXferMech(::grpc::ServerContext* context, const ResetCODataXferMechRequest* request, ResetCODataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCODataXferMech(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCODataXferReqCond(::grpc::ServerContext* context, const ResetCODataXferReqCondRequest* request, ResetCODataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCODataXferReqCond(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOEnableInitialDelayOnRetrigger(::grpc::ServerContext* context, const ResetCOEnableInitialDelayOnRetriggerRequest* request, ResetCOEnableInitialDelayOnRetriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOEnableInitialDelayOnRetrigger(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOMemMapEnable(::grpc::ServerContext* context, const ResetCOMemMapEnableRequest* request, ResetCOMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOMemMapEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPrescaler(::grpc::ServerContext* context, const ResetCOPrescalerRequest* request, ResetCOPrescalerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPrescaler(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseDutyCyc(::grpc::ServerContext* context, const ResetCOPulseDutyCycRequest* request, ResetCOPulseDutyCycResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseDutyCyc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseFreq(::grpc::ServerContext* context, const ResetCOPulseFreqRequest* request, ResetCOPulseFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseFreq(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseFreqInitialDelay(::grpc::ServerContext* context, const ResetCOPulseFreqInitialDelayRequest* request, ResetCOPulseFreqInitialDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseFreqInitialDelay(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseFreqUnits(::grpc::ServerContext* context, const ResetCOPulseFreqUnitsRequest* request, ResetCOPulseFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseFreqUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseHighTicks(::grpc::ServerContext* context, const ResetCOPulseHighTicksRequest* request, ResetCOPulseHighTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseHighTicks(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseHighTime(::grpc::ServerContext* context, const ResetCOPulseHighTimeRequest* request, ResetCOPulseHighTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseHighTime(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseIdleState(::grpc::ServerContext* context, const ResetCOPulseIdleStateRequest* request, ResetCOPulseIdleStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseIdleState(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseLowTicks(::grpc::ServerContext* context, const ResetCOPulseLowTicksRequest* request, ResetCOPulseLowTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseLowTicks(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseLowTime(::grpc::ServerContext* context, const ResetCOPulseLowTimeRequest* request, ResetCOPulseLowTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseLowTime(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseTerm(::grpc::ServerContext* context, const ResetCOPulseTermRequest* request, ResetCOPulseTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseTerm(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseTicksInitialDelay(::grpc::ServerContext* context, const ResetCOPulseTicksInitialDelayRequest* request, ResetCOPulseTicksInitialDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseTicksInitialDelay(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseTimeInitialDelay(::grpc::ServerContext* context, const ResetCOPulseTimeInitialDelayRequest* request, ResetCOPulseTimeInitialDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseTimeInitialDelay(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOPulseTimeUnits(::grpc::ServerContext* context, const ResetCOPulseTimeUnitsRequest* request, ResetCOPulseTimeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOPulseTimeUnits(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOUsbXferReqCount(::grpc::ServerContext* context, const ResetCOUsbXferReqCountRequest* request, ResetCOUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOUsbXferReqCount(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOUsbXferReqSize(::grpc::ServerContext* context, const ResetCOUsbXferReqSizeRequest* request, ResetCOUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOUsbXferReqSize(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetCOUseOnlyOnBrdMem(::grpc::ServerContext* context, const ResetCOUseOnlyOnBrdMemRequest* request, ResetCOUseOnlyOnBrdMemResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetCOUseOnlyOnBrdMem(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetChanDescr(::grpc::ServerContext* context, const ResetChanDescrRequest* request, ResetChanDescrResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetChanDescr(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetChanSyncUnlockBehavior(::grpc::ServerContext* context, const ResetChanSyncUnlockBehaviorRequest* request, ResetChanSyncUnlockBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetChanSyncUnlockBehavior(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIAcquireOn(::grpc::ServerContext* context, const ResetDIAcquireOnRequest* request, ResetDIAcquireOnResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIAcquireOn(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIDataXferMech(::grpc::ServerContext* context, const ResetDIDataXferMechRequest* request, ResetDIDataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIDataXferMech(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIDataXferReqCond(::grpc::ServerContext* context, const ResetDIDataXferReqCondRequest* request, ResetDIDataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIDataXferReqCond(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIDigFltrEnable(::grpc::ServerContext* context, const ResetDIDigFltrEnableRequest* request, ResetDIDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIDigFltrEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIDigFltrEnableBusMode(::grpc::ServerContext* context, const ResetDIDigFltrEnableBusModeRequest* request, ResetDIDigFltrEnableBusModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIDigFltrEnableBusMode(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIDigFltrMinPulseWidth(::grpc::ServerContext* context, const ResetDIDigFltrMinPulseWidthRequest* request, ResetDIDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIDigFltrMinPulseWidth(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIDigFltrTimebaseRate(::grpc::ServerContext* context, const ResetDIDigFltrTimebaseRateRequest* request, ResetDIDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIDigFltrTimebaseRate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIDigFltrTimebaseSrc(::grpc::ServerContext* context, const ResetDIDigFltrTimebaseSrcRequest* request, ResetDIDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIDigFltrTimebaseSrc(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIDigSyncEnable(::grpc::ServerContext* context, const ResetDIDigSyncEnableRequest* request, ResetDIDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIDigSyncEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIInvertLines(::grpc::ServerContext* context, const ResetDIInvertLinesRequest* request, ResetDIInvertLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIInvertLines(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDILogicFamily(::grpc::ServerContext* context, const ResetDILogicFamilyRequest* request, ResetDILogicFamilyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDILogicFamily(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIMemMapEnable(::grpc::ServerContext* context, const ResetDIMemMapEnableRequest* request, ResetDIMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIMemMapEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDITristate(::grpc::ServerContext* context, const ResetDITristateRequest* request, ResetDITristateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDITristate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIUsbXferReqCount(::grpc::ServerContext* context, const ResetDIUsbXferReqCountRequest* request, ResetDIUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIUsbXferReqCount(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDIUsbXferReqSize(::grpc::ServerContext* context, const ResetDIUsbXferReqSizeRequest* request, ResetDIUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDIUsbXferReqSize(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDODataXferMech(::grpc::ServerContext* context, const ResetDODataXferMechRequest* request, ResetDODataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDODataXferMech(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDODataXferReqCond(::grpc::ServerContext* context, const ResetDODataXferReqCondRequest* request, ResetDODataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDODataXferReqCond(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOGenerateOn(::grpc::ServerContext* context, const ResetDOGenerateOnRequest* request, ResetDOGenerateOnResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOGenerateOn(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOInvertLines(::grpc::ServerContext* context, const ResetDOInvertLinesRequest* request, ResetDOInvertLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOInvertLines(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOLineStatesDoneState(::grpc::ServerContext* context, const ResetDOLineStatesDoneStateRequest* request, ResetDOLineStatesDoneStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOLineStatesDoneState(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOLineStatesPausedState(::grpc::ServerContext* context, const ResetDOLineStatesPausedStateRequest* request, ResetDOLineStatesPausedStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOLineStatesPausedState(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOLineStatesStartState(::grpc::ServerContext* context, const ResetDOLineStatesStartStateRequest* request, ResetDOLineStatesStartStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOLineStatesStartState(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOLogicFamily(::grpc::ServerContext* context, const ResetDOLogicFamilyRequest* request, ResetDOLogicFamilyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOLogicFamily(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOMemMapEnable(::grpc::ServerContext* context, const ResetDOMemMapEnableRequest* request, ResetDOMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOMemMapEnable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOOutputDriveType(::grpc::ServerContext* context, const ResetDOOutputDriveTypeRequest* request, ResetDOOutputDriveTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOOutputDriveType(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOOvercurrentAutoReenable(::grpc::ServerContext* context, const ResetDOOvercurrentAutoReenableRequest* request, ResetDOOvercurrentAutoReenableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOOvercurrentAutoReenable(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOOvercurrentLimit(::grpc::ServerContext* context, const ResetDOOvercurrentLimitRequest* request, ResetDOOvercurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOOvercurrentLimit(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOOvercurrentReenablePeriod(::grpc::ServerContext* context, const ResetDOOvercurrentReenablePeriodRequest* request, ResetDOOvercurrentReenablePeriodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOOvercurrentReenablePeriod(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOTristate(::grpc::ServerContext* context, const ResetDOTristateRequest* request, ResetDOTristateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOTristate(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOUsbXferReqCount(::grpc::ServerContext* context, const ResetDOUsbXferReqCountRequest* request, ResetDOUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOUsbXferReqCount(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOUsbXferReqSize(::grpc::ServerContext* context, const ResetDOUsbXferReqSizeRequest* request, ResetDOUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOUsbXferReqSize(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDOUseOnlyOnBrdMem(::grpc::ServerContext* context, const ResetDOUseOnlyOnBrdMemRequest* request, ResetDOUseOnlyOnBrdMemResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto status = library_->ResetDOUseOnlyOnBrdMem(task, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDevice(::grpc::ServerContext* context, const ResetDeviceRequest* request, ResetDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->ResetDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SaveGlobalChan(::grpc::ServerContext* context, const SaveGlobalChanRequest* request, SaveGlobalChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      auto save_as = request->save_as().c_str();
      auto author = request->author().c_str();
      uInt32 options;
      switch (request->options_enum_case()) {
        case nidaqmx_grpc::SaveGlobalChanRequest::OptionsEnumCase::kOptions: {
          options = static_cast<uInt32>(request->options());
          break;
        }
        case nidaqmx_grpc::SaveGlobalChanRequest::OptionsEnumCase::kOptionsRaw: {
          options = static_cast<uInt32>(request->options_raw());
          break;
        }
        case nidaqmx_grpc::SaveGlobalChanRequest::OptionsEnumCase::OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for options was not specified or out of range");
          break;
        }
      }

      auto status = library_->SaveGlobalChan(task, channel_name, save_as, author, options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SaveScale(::grpc::ServerContext* context, const SaveScaleRequest* request, SaveScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      auto save_as = request->save_as().c_str();
      auto author = request->author().c_str();
      uInt32 options;
      switch (request->options_enum_case()) {
        case nidaqmx_grpc::SaveScaleRequest::OptionsEnumCase::kOptions: {
          options = static_cast<uInt32>(request->options());
          break;
        }
        case nidaqmx_grpc::SaveScaleRequest::OptionsEnumCase::kOptionsRaw: {
          options = static_cast<uInt32>(request->options_raw());
          break;
        }
        case nidaqmx_grpc::SaveScaleRequest::OptionsEnumCase::OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for options was not specified or out of range");
          break;
        }
      }

      auto status = library_->SaveScale(scale_name, save_as, author, options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SaveTask(::grpc::ServerContext* context, const SaveTaskRequest* request, SaveTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto save_as = request->save_as().c_str();
      auto author = request->author().c_str();
      uInt32 options;
      switch (request->options_enum_case()) {
        case nidaqmx_grpc::SaveTaskRequest::OptionsEnumCase::kOptions: {
          options = static_cast<uInt32>(request->options());
          break;
        }
        case nidaqmx_grpc::SaveTaskRequest::OptionsEnumCase::kOptionsRaw: {
          options = static_cast<uInt32>(request->options_raw());
          break;
        }
        case nidaqmx_grpc::SaveTaskRequest::OptionsEnumCase::OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for options was not specified or out of range");
          break;
        }
      }

      auto status = library_->SaveTask(task, save_as, author, options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SelfCal(::grpc::ServerContext* context, const SelfCalRequest* request, SelfCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->SelfCal(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SelfTestDevice(::grpc::ServerContext* context, const SelfTestDeviceRequest* request, SelfTestDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->SelfTestDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIACExcitFreq(::grpc::ServerContext* context, const SetAIACExcitFreqRequest* request, SetAIACExcitFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIACExcitFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIACExcitSyncEnable(::grpc::ServerContext* context, const SetAIACExcitSyncEnableRequest* request, SetAIACExcitSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIACExcitSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIACExcitWireMode(::grpc::ServerContext* context, const SetAIACExcitWireModeRequest* request, SetAIACExcitWireModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIACExcitWireModeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIACExcitWireModeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIACExcitWireModeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIACExcitWireMode(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIADCCustomTimingMode(::grpc::ServerContext* context, const SetAIADCCustomTimingModeRequest* request, SetAIADCCustomTimingModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAIADCCustomTimingMode(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIADCTimingMode(::grpc::ServerContext* context, const SetAIADCTimingModeRequest* request, SetAIADCTimingModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIADCTimingModeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIADCTimingModeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIADCTimingModeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIADCTimingMode(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAccel4WireDCVoltageSensitivity(::grpc::ServerContext* context, const SetAIAccel4WireDCVoltageSensitivityRequest* request, SetAIAccel4WireDCVoltageSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIAccel4WireDCVoltageSensitivity(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAccel4WireDCVoltageSensitivityUnits(::grpc::ServerContext* context, const SetAIAccel4WireDCVoltageSensitivityUnitsRequest* request, SetAIAccel4WireDCVoltageSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIAccel4WireDCVoltageSensitivityUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIAccel4WireDCVoltageSensitivityUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIAccel4WireDCVoltageSensitivityUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIAccel4WireDCVoltageSensitivityUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAccelChargeSensitivity(::grpc::ServerContext* context, const SetAIAccelChargeSensitivityRequest* request, SetAIAccelChargeSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIAccelChargeSensitivity(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAccelChargeSensitivityUnits(::grpc::ServerContext* context, const SetAIAccelChargeSensitivityUnitsRequest* request, SetAIAccelChargeSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIAccelChargeSensitivityUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIAccelChargeSensitivityUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIAccelChargeSensitivityUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIAccelChargeSensitivityUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAccelSensitivity(::grpc::ServerContext* context, const SetAIAccelSensitivityRequest* request, SetAIAccelSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIAccelSensitivity(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAccelSensitivityUnits(::grpc::ServerContext* context, const SetAIAccelSensitivityUnitsRequest* request, SetAIAccelSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIAccelSensitivityUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIAccelSensitivityUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIAccelSensitivityUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIAccelSensitivityUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAccelUnits(::grpc::ServerContext* context, const SetAIAccelUnitsRequest* request, SetAIAccelUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIAccelUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIAccelUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIAccelUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIAccelUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAcceldBRef(::grpc::ServerContext* context, const SetAIAcceldBRefRequest* request, SetAIAcceldBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIAcceldBRef(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAtten(::grpc::ServerContext* context, const SetAIAttenRequest* request, SetAIAttenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIAtten(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAutoZeroMode(::grpc::ServerContext* context, const SetAIAutoZeroModeRequest* request, SetAIAutoZeroModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIAutoZeroModeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIAutoZeroModeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIAutoZeroModeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIAutoZeroMode(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIAveragingWinSize(::grpc::ServerContext* context, const SetAIAveragingWinSizeRequest* request, SetAIAveragingWinSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAIAveragingWinSize(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeBalanceCoarsePot(::grpc::ServerContext* context, const SetAIBridgeBalanceCoarsePotRequest* request, SetAIBridgeBalanceCoarsePotResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data = request->data();
      auto status = library_->SetAIBridgeBalanceCoarsePot(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeBalanceFinePot(::grpc::ServerContext* context, const SetAIBridgeBalanceFinePotRequest* request, SetAIBridgeBalanceFinePotResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data = request->data();
      auto status = library_->SetAIBridgeBalanceFinePot(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeCfg(::grpc::ServerContext* context, const SetAIBridgeCfgRequest* request, SetAIBridgeCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIBridgeCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIBridgeCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeElectricalUnits(::grpc::ServerContext* context, const SetAIBridgeElectricalUnitsRequest* request, SetAIBridgeElectricalUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIBridgeElectricalUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeElectricalUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeElectricalUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIBridgeElectricalUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeInitialRatio(::grpc::ServerContext* context, const SetAIBridgeInitialRatioRequest* request, SetAIBridgeInitialRatioResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeInitialRatio(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeInitialVoltage(::grpc::ServerContext* context, const SetAIBridgeInitialVoltageRequest* request, SetAIBridgeInitialVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeInitialVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeNomResistance(::grpc::ServerContext* context, const SetAIBridgeNomResistanceRequest* request, SetAIBridgeNomResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeNomResistance(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgePhysicalUnits(::grpc::ServerContext* context, const SetAIBridgePhysicalUnitsRequest* request, SetAIBridgePhysicalUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIBridgePhysicalUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIBridgePhysicalUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIBridgePhysicalUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIBridgePhysicalUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgePolyForwardCoeff(::grpc::ServerContext* context, const SetAIBridgePolyForwardCoeffRequest* request, SetAIBridgePolyForwardCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIBridgePolyForwardCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgePolyReverseCoeff(::grpc::ServerContext* context, const SetAIBridgePolyReverseCoeffRequest* request, SetAIBridgePolyReverseCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIBridgePolyReverseCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeScaleType(::grpc::ServerContext* context, const SetAIBridgeScaleTypeRequest* request, SetAIBridgeScaleTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIBridgeScaleTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeScaleTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeScaleTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIBridgeScaleType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeShuntCalEnable(::grpc::ServerContext* context, const SetAIBridgeShuntCalEnableRequest* request, SetAIBridgeShuntCalEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIBridgeShuntCalEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeShuntCalGainAdjust(::grpc::ServerContext* context, const SetAIBridgeShuntCalGainAdjustRequest* request, SetAIBridgeShuntCalGainAdjustResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeShuntCalGainAdjust(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeShuntCalSelect(::grpc::ServerContext* context, const SetAIBridgeShuntCalSelectRequest* request, SetAIBridgeShuntCalSelectResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIBridgeShuntCalSelectRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeShuntCalSelectRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeShuntCalSelectRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIBridgeShuntCalSelect(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeShuntCalShuntCalAActualResistance(::grpc::ServerContext* context, const SetAIBridgeShuntCalShuntCalAActualResistanceRequest* request, SetAIBridgeShuntCalShuntCalAActualResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeShuntCalShuntCalAActualResistance(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeShuntCalShuntCalAResistance(::grpc::ServerContext* context, const SetAIBridgeShuntCalShuntCalAResistanceRequest* request, SetAIBridgeShuntCalShuntCalAResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeShuntCalShuntCalAResistance(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeShuntCalShuntCalASrc(::grpc::ServerContext* context, const SetAIBridgeShuntCalShuntCalASrcRequest* request, SetAIBridgeShuntCalShuntCalASrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIBridgeShuntCalShuntCalASrcRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeShuntCalShuntCalASrcRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeShuntCalShuntCalASrcRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIBridgeShuntCalShuntCalASrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeShuntCalShuntCalBActualResistance(::grpc::ServerContext* context, const SetAIBridgeShuntCalShuntCalBActualResistanceRequest* request, SetAIBridgeShuntCalShuntCalBActualResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeShuntCalShuntCalBActualResistance(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeShuntCalShuntCalBResistance(::grpc::ServerContext* context, const SetAIBridgeShuntCalShuntCalBResistanceRequest* request, SetAIBridgeShuntCalShuntCalBResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeShuntCalShuntCalBResistance(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeTableElectricalVals(::grpc::ServerContext* context, const SetAIBridgeTableElectricalValsRequest* request, SetAIBridgeTableElectricalValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIBridgeTableElectricalVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeTablePhysicalVals(::grpc::ServerContext* context, const SetAIBridgeTablePhysicalValsRequest* request, SetAIBridgeTablePhysicalValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIBridgeTablePhysicalVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeTwoPointLinFirstElectricalVal(::grpc::ServerContext* context, const SetAIBridgeTwoPointLinFirstElectricalValRequest* request, SetAIBridgeTwoPointLinFirstElectricalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeTwoPointLinFirstElectricalVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeTwoPointLinFirstPhysicalVal(::grpc::ServerContext* context, const SetAIBridgeTwoPointLinFirstPhysicalValRequest* request, SetAIBridgeTwoPointLinFirstPhysicalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeTwoPointLinFirstPhysicalVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeTwoPointLinSecondElectricalVal(::grpc::ServerContext* context, const SetAIBridgeTwoPointLinSecondElectricalValRequest* request, SetAIBridgeTwoPointLinSecondElectricalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeTwoPointLinSecondElectricalVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeTwoPointLinSecondPhysicalVal(::grpc::ServerContext* context, const SetAIBridgeTwoPointLinSecondPhysicalValRequest* request, SetAIBridgeTwoPointLinSecondPhysicalValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIBridgeTwoPointLinSecondPhysicalVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIBridgeUnits(::grpc::ServerContext* context, const SetAIBridgeUnitsRequest* request, SetAIBridgeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIBridgeUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIBridgeUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIBridgeUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalApplyCalIfExp(::grpc::ServerContext* context, const SetAIChanCalApplyCalIfExpRequest* request, SetAIChanCalApplyCalIfExpResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIChanCalApplyCalIfExp(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalCalDate(::grpc::ServerContext* context, const SetAIChanCalCalDateRequest* request, SetAIChanCalCalDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year = request->year();
      uInt32 month = request->month();
      uInt32 day = request->day();
      uInt32 hour = request->hour();
      uInt32 minute = request->minute();
      auto status = library_->SetAIChanCalCalDate(task, channel_name, year, month, day, hour, minute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalDesc(::grpc::ServerContext* context, const SetAIChanCalDescRequest* request, SetAIChanCalDescResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetAIChanCalDesc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalEnableCal(::grpc::ServerContext* context, const SetAIChanCalEnableCalRequest* request, SetAIChanCalEnableCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIChanCalEnableCal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalExpDate(::grpc::ServerContext* context, const SetAIChanCalExpDateRequest* request, SetAIChanCalExpDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year = request->year();
      uInt32 month = request->month();
      uInt32 day = request->day();
      uInt32 hour = request->hour();
      uInt32 minute = request->minute();
      auto status = library_->SetAIChanCalExpDate(task, channel_name, year, month, day, hour, minute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalOperatorName(::grpc::ServerContext* context, const SetAIChanCalOperatorNameRequest* request, SetAIChanCalOperatorNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetAIChanCalOperatorName(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalPolyForwardCoeff(::grpc::ServerContext* context, const SetAIChanCalPolyForwardCoeffRequest* request, SetAIChanCalPolyForwardCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIChanCalPolyForwardCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalPolyReverseCoeff(::grpc::ServerContext* context, const SetAIChanCalPolyReverseCoeffRequest* request, SetAIChanCalPolyReverseCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIChanCalPolyReverseCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalScaleType(::grpc::ServerContext* context, const SetAIChanCalScaleTypeRequest* request, SetAIChanCalScaleTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIChanCalScaleTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIChanCalScaleTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIChanCalScaleTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIChanCalScaleType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalTablePreScaledVals(::grpc::ServerContext* context, const SetAIChanCalTablePreScaledValsRequest* request, SetAIChanCalTablePreScaledValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIChanCalTablePreScaledVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalTableScaledVals(::grpc::ServerContext* context, const SetAIChanCalTableScaledValsRequest* request, SetAIChanCalTableScaledValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIChanCalTableScaledVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalVerifAcqVals(::grpc::ServerContext* context, const SetAIChanCalVerifAcqValsRequest* request, SetAIChanCalVerifAcqValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIChanCalVerifAcqVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalVerifRefVals(::grpc::ServerContext* context, const SetAIChanCalVerifRefValsRequest* request, SetAIChanCalVerifRefValsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIChanCalVerifRefVals(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChargeUnits(::grpc::ServerContext* context, const SetAIChargeUnitsRequest* request, SetAIChargeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIChargeUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIChargeUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIChargeUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIChargeUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChopEnable(::grpc::ServerContext* context, const SetAIChopEnableRequest* request, SetAIChopEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIChopEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAICoupling(::grpc::ServerContext* context, const SetAICouplingRequest* request, SetAICouplingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAICouplingRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAICouplingRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAICouplingRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAICoupling(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAICurrentACRMSUnits(::grpc::ServerContext* context, const SetAICurrentACRMSUnitsRequest* request, SetAICurrentACRMSUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAICurrentACRMSUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAICurrentACRMSUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAICurrentACRMSUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAICurrentACRMSUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAICurrentShuntLoc(::grpc::ServerContext* context, const SetAICurrentShuntLocRequest* request, SetAICurrentShuntLocResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAICurrentShuntLocRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAICurrentShuntLocRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAICurrentShuntLocRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAICurrentShuntLoc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAICurrentShuntResistance(::grpc::ServerContext* context, const SetAICurrentShuntResistanceRequest* request, SetAICurrentShuntResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAICurrentShuntResistance(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAICurrentUnits(::grpc::ServerContext* context, const SetAICurrentUnitsRequest* request, SetAICurrentUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAICurrentUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAICurrentUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAICurrentUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAICurrentUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAICustomScaleName(::grpc::ServerContext* context, const SetAICustomScaleNameRequest* request, SetAICustomScaleNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetAICustomScaleName(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDCOffset(::grpc::ServerContext* context, const SetAIDCOffsetRequest* request, SetAIDCOffsetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIDCOffset(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDataXferCustomThreshold(::grpc::ServerContext* context, const SetAIDataXferCustomThresholdRequest* request, SetAIDataXferCustomThresholdResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAIDataXferCustomThreshold(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDataXferMaxRate(::grpc::ServerContext* context, const SetAIDataXferMaxRateRequest* request, SetAIDataXferMaxRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIDataXferMaxRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDataXferMech(::grpc::ServerContext* context, const SetAIDataXferMechRequest* request, SetAIDataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIDataXferMechRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIDataXferMechRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIDataXferMechRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIDataXferMech(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDataXferReqCond(::grpc::ServerContext* context, const SetAIDataXferReqCondRequest* request, SetAIDataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIDataXferReqCondRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIDataXferReqCondRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIDataXferReqCondRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIDataXferReqCond(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrBandpassCenterFreq(::grpc::ServerContext* context, const SetAIDigFltrBandpassCenterFreqRequest* request, SetAIDigFltrBandpassCenterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIDigFltrBandpassCenterFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrBandpassWidth(::grpc::ServerContext* context, const SetAIDigFltrBandpassWidthRequest* request, SetAIDigFltrBandpassWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIDigFltrBandpassWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrCoeff(::grpc::ServerContext* context, const SetAIDigFltrCoeffRequest* request, SetAIDigFltrCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 array_size_in_elements = request->array_size_in_elements();
      float64 data {};
      auto status = library_->SetAIDigFltrCoeff(task, channel, &data, array_size_in_elements);
      response->set_status(status);
      if (status == 0) {
        response->set_data(data);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrEnable(::grpc::ServerContext* context, const SetAIDigFltrEnableRequest* request, SetAIDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrHighpassCutoffFreq(::grpc::ServerContext* context, const SetAIDigFltrHighpassCutoffFreqRequest* request, SetAIDigFltrHighpassCutoffFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIDigFltrHighpassCutoffFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrLowpassCutoffFreq(::grpc::ServerContext* context, const SetAIDigFltrLowpassCutoffFreqRequest* request, SetAIDigFltrLowpassCutoffFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIDigFltrLowpassCutoffFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrNotchCenterFreq(::grpc::ServerContext* context, const SetAIDigFltrNotchCenterFreqRequest* request, SetAIDigFltrNotchCenterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIDigFltrNotchCenterFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrNotchWidth(::grpc::ServerContext* context, const SetAIDigFltrNotchWidthRequest* request, SetAIDigFltrNotchWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIDigFltrNotchWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrOrder(::grpc::ServerContext* context, const SetAIDigFltrOrderRequest* request, SetAIDigFltrOrderResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAIDigFltrOrder(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrResponse(::grpc::ServerContext* context, const SetAIDigFltrResponseRequest* request, SetAIDigFltrResponseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIDigFltrResponseRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIDigFltrResponseRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIDigFltrResponseRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIDigFltrResponse(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDigFltrType(::grpc::ServerContext* context, const SetAIDigFltrTypeRequest* request, SetAIDigFltrTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIDigFltrTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIDigFltrTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIDigFltrTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIDigFltrType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIDitherEnable(::grpc::ServerContext* context, const SetAIDitherEnableRequest* request, SetAIDitherEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIDitherEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIEddyCurrentProxProbeSensitivity(::grpc::ServerContext* context, const SetAIEddyCurrentProxProbeSensitivityRequest* request, SetAIEddyCurrentProxProbeSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIEddyCurrentProxProbeSensitivity(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIEddyCurrentProxProbeSensitivityUnits(::grpc::ServerContext* context, const SetAIEddyCurrentProxProbeSensitivityUnitsRequest* request, SetAIEddyCurrentProxProbeSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIEddyCurrentProxProbeSensitivityUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIEddyCurrentProxProbeSensitivityUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIEddyCurrentProxProbeSensitivityUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIEddyCurrentProxProbeSensitivityUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIEddyCurrentProxProbeUnits(::grpc::ServerContext* context, const SetAIEddyCurrentProxProbeUnitsRequest* request, SetAIEddyCurrentProxProbeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIEddyCurrentProxProbeUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIEddyCurrentProxProbeUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIEddyCurrentProxProbeUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIEddyCurrentProxProbeUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIEnhancedAliasRejectionEnable(::grpc::ServerContext* context, const SetAIEnhancedAliasRejectionEnableRequest* request, SetAIEnhancedAliasRejectionEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIEnhancedAliasRejectionEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIExcitActualVal(::grpc::ServerContext* context, const SetAIExcitActualValRequest* request, SetAIExcitActualValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIExcitActualVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIExcitDCorAC(::grpc::ServerContext* context, const SetAIExcitDCorACRequest* request, SetAIExcitDCorACResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIExcitDCorACRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIExcitDCorACRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIExcitDCorACRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIExcitDCorAC(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIExcitIdleOutputBehavior(::grpc::ServerContext* context, const SetAIExcitIdleOutputBehaviorRequest* request, SetAIExcitIdleOutputBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIExcitIdleOutputBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIExcitIdleOutputBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIExcitIdleOutputBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIExcitIdleOutputBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIExcitSense(::grpc::ServerContext* context, const SetAIExcitSenseRequest* request, SetAIExcitSenseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIExcitSenseRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIExcitSenseRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIExcitSenseRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIExcitSense(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIExcitSrc(::grpc::ServerContext* context, const SetAIExcitSrcRequest* request, SetAIExcitSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIExcitSrcRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIExcitSrcRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIExcitSrcRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIExcitSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIExcitUseForScaling(::grpc::ServerContext* context, const SetAIExcitUseForScalingRequest* request, SetAIExcitUseForScalingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIExcitUseForScaling(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIExcitUseMultiplexed(::grpc::ServerContext* context, const SetAIExcitUseMultiplexedRequest* request, SetAIExcitUseMultiplexedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIExcitUseMultiplexed(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIExcitVal(::grpc::ServerContext* context, const SetAIExcitValRequest* request, SetAIExcitValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIExcitVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIExcitVoltageOrCurrent(::grpc::ServerContext* context, const SetAIExcitVoltageOrCurrentRequest* request, SetAIExcitVoltageOrCurrentResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIExcitVoltageOrCurrentRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIExcitVoltageOrCurrentRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIExcitVoltageOrCurrentRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIExcitVoltageOrCurrent(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIFilterDelayAdjustment(::grpc::ServerContext* context, const SetAIFilterDelayAdjustmentRequest* request, SetAIFilterDelayAdjustmentResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIFilterDelayAdjustment(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIFilterDelayUnits(::grpc::ServerContext* context, const SetAIFilterDelayUnitsRequest* request, SetAIFilterDelayUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIFilterDelayUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIFilterDelayUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIFilterDelayUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIFilterDelayUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIFilterEnable(::grpc::ServerContext* context, const SetAIFilterEnableRequest* request, SetAIFilterEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIFilterEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIFilterFreq(::grpc::ServerContext* context, const SetAIFilterFreqRequest* request, SetAIFilterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIFilterFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIFilterOrder(::grpc::ServerContext* context, const SetAIFilterOrderRequest* request, SetAIFilterOrderResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAIFilterOrder(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIFilterResponse(::grpc::ServerContext* context, const SetAIFilterResponseRequest* request, SetAIFilterResponseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIFilterResponseRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIFilterResponseRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIFilterResponseRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIFilterResponse(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIForceIEPESensorSensitivity(::grpc::ServerContext* context, const SetAIForceIEPESensorSensitivityRequest* request, SetAIForceIEPESensorSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIForceIEPESensorSensitivity(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIForceIEPESensorSensitivityUnits(::grpc::ServerContext* context, const SetAIForceIEPESensorSensitivityUnitsRequest* request, SetAIForceIEPESensorSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIForceIEPESensorSensitivityUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIForceIEPESensorSensitivityUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIForceIEPESensorSensitivityUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIForceIEPESensorSensitivityUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIForceReadFromChan(::grpc::ServerContext* context, const SetAIForceReadFromChanRequest* request, SetAIForceReadFromChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIForceReadFromChan(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIForceUnits(::grpc::ServerContext* context, const SetAIForceUnitsRequest* request, SetAIForceUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIForceUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIForceUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIForceUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIForceUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIFreqHyst(::grpc::ServerContext* context, const SetAIFreqHystRequest* request, SetAIFreqHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIFreqHyst(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIFreqThreshVoltage(::grpc::ServerContext* context, const SetAIFreqThreshVoltageRequest* request, SetAIFreqThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIFreqThreshVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIFreqUnits(::grpc::ServerContext* context, const SetAIFreqUnitsRequest* request, SetAIFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIFreqUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIFreqUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIFreqUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIFreqUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIGain(::grpc::ServerContext* context, const SetAIGainRequest* request, SetAIGainResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIGain(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIInputLimitsFaultDetectEnable(::grpc::ServerContext* context, const SetAIInputLimitsFaultDetectEnableRequest* request, SetAIInputLimitsFaultDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIInputLimitsFaultDetectEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIInputLimitsFaultDetectLowerLimit(::grpc::ServerContext* context, const SetAIInputLimitsFaultDetectLowerLimitRequest* request, SetAIInputLimitsFaultDetectLowerLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIInputLimitsFaultDetectLowerLimit(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIInputLimitsFaultDetectUpperLimit(::grpc::ServerContext* context, const SetAIInputLimitsFaultDetectUpperLimitRequest* request, SetAIInputLimitsFaultDetectUpperLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIInputLimitsFaultDetectUpperLimit(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIInputSrc(::grpc::ServerContext* context, const SetAIInputSrcRequest* request, SetAIInputSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetAIInputSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILVDTSensitivity(::grpc::ServerContext* context, const SetAILVDTSensitivityRequest* request, SetAILVDTSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAILVDTSensitivity(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILVDTSensitivityUnits(::grpc::ServerContext* context, const SetAILVDTSensitivityUnitsRequest* request, SetAILVDTSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAILVDTSensitivityUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAILVDTSensitivityUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAILVDTSensitivityUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAILVDTSensitivityUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILVDTUnits(::grpc::ServerContext* context, const SetAILVDTUnitsRequest* request, SetAILVDTUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAILVDTUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAILVDTUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAILVDTUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAILVDTUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILeadWireResistance(::grpc::ServerContext* context, const SetAILeadWireResistanceRequest* request, SetAILeadWireResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAILeadWireResistance(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILossyLSBRemovalCompressedSampSize(::grpc::ServerContext* context, const SetAILossyLSBRemovalCompressedSampSizeRequest* request, SetAILossyLSBRemovalCompressedSampSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAILossyLSBRemovalCompressedSampSize(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILowpassCutoffFreq(::grpc::ServerContext* context, const SetAILowpassCutoffFreqRequest* request, SetAILowpassCutoffFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAILowpassCutoffFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILowpassEnable(::grpc::ServerContext* context, const SetAILowpassEnableRequest* request, SetAILowpassEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAILowpassEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILowpassSwitchCapClkSrc(::grpc::ServerContext* context, const SetAILowpassSwitchCapClkSrcRequest* request, SetAILowpassSwitchCapClkSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAILowpassSwitchCapClkSrcRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAILowpassSwitchCapClkSrcRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAILowpassSwitchCapClkSrcRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAILowpassSwitchCapClkSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILowpassSwitchCapExtClkDiv(::grpc::ServerContext* context, const SetAILowpassSwitchCapExtClkDivRequest* request, SetAILowpassSwitchCapExtClkDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAILowpassSwitchCapExtClkDiv(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILowpassSwitchCapExtClkFreq(::grpc::ServerContext* context, const SetAILowpassSwitchCapExtClkFreqRequest* request, SetAILowpassSwitchCapExtClkFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAILowpassSwitchCapExtClkFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAILowpassSwitchCapOutClkDiv(::grpc::ServerContext* context, const SetAILowpassSwitchCapOutClkDivRequest* request, SetAILowpassSwitchCapOutClkDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAILowpassSwitchCapOutClkDiv(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIMax(::grpc::ServerContext* context, const SetAIMaxRequest* request, SetAIMaxResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIMax(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIMemMapEnable(::grpc::ServerContext* context, const SetAIMemMapEnableRequest* request, SetAIMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIMemMapEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIMicrophoneSensitivity(::grpc::ServerContext* context, const SetAIMicrophoneSensitivityRequest* request, SetAIMicrophoneSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIMicrophoneSensitivity(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIMin(::grpc::ServerContext* context, const SetAIMinRequest* request, SetAIMinResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIMin(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIOpenChanDetectEnable(::grpc::ServerContext* context, const SetAIOpenChanDetectEnableRequest* request, SetAIOpenChanDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIOpenChanDetectEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIOpenThrmcplDetectEnable(::grpc::ServerContext* context, const SetAIOpenThrmcplDetectEnableRequest* request, SetAIOpenThrmcplDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIOpenThrmcplDetectEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIOvercurrentDetectEnable(::grpc::ServerContext* context, const SetAIOvercurrentDetectEnableRequest* request, SetAIOvercurrentDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIOvercurrentDetectEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIPowerSupplyFaultDetectEnable(::grpc::ServerContext* context, const SetAIPowerSupplyFaultDetectEnableRequest* request, SetAIPowerSupplyFaultDetectEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIPowerSupplyFaultDetectEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIPressureUnits(::grpc::ServerContext* context, const SetAIPressureUnitsRequest* request, SetAIPressureUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIPressureUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIPressureUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIPressureUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIPressureUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIProbeAtten(::grpc::ServerContext* context, const SetAIProbeAttenRequest* request, SetAIProbeAttenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIProbeAtten(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRTDA(::grpc::ServerContext* context, const SetAIRTDARequest* request, SetAIRTDAResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIRTDA(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRTDB(::grpc::ServerContext* context, const SetAIRTDBRequest* request, SetAIRTDBResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIRTDB(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRTDC(::grpc::ServerContext* context, const SetAIRTDCRequest* request, SetAIRTDCResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIRTDC(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRTDR0(::grpc::ServerContext* context, const SetAIRTDR0Request* request, SetAIRTDR0Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIRTDR0(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRTDType(::grpc::ServerContext* context, const SetAIRTDTypeRequest* request, SetAIRTDTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIRTDTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIRTDTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIRTDTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIRTDType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRVDTSensitivity(::grpc::ServerContext* context, const SetAIRVDTSensitivityRequest* request, SetAIRVDTSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIRVDTSensitivity(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRVDTSensitivityUnits(::grpc::ServerContext* context, const SetAIRVDTSensitivityUnitsRequest* request, SetAIRVDTSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIRVDTSensitivityUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIRVDTSensitivityUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIRVDTSensitivityUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIRVDTSensitivityUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRVDTUnits(::grpc::ServerContext* context, const SetAIRVDTUnitsRequest* request, SetAIRVDTUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIRVDTUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIRVDTUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIRVDTUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIRVDTUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRawDataCompressionType(::grpc::ServerContext* context, const SetAIRawDataCompressionTypeRequest* request, SetAIRawDataCompressionTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIRawDataCompressionTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIRawDataCompressionTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIRawDataCompressionTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIRawDataCompressionType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRemoveFilterDelay(::grpc::ServerContext* context, const SetAIRemoveFilterDelayRequest* request, SetAIRemoveFilterDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIRemoveFilterDelay(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIResistanceCfg(::grpc::ServerContext* context, const SetAIResistanceCfgRequest* request, SetAIResistanceCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIResistanceCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIResistanceCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIResistanceCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIResistanceCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIResistanceUnits(::grpc::ServerContext* context, const SetAIResistanceUnitsRequest* request, SetAIResistanceUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIResistanceUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIResistanceUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIResistanceUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIResistanceUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRngHigh(::grpc::ServerContext* context, const SetAIRngHighRequest* request, SetAIRngHighResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIRngHigh(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRngLow(::grpc::ServerContext* context, const SetAIRngLowRequest* request, SetAIRngLowResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIRngLow(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRosetteStrainGageOrientation(::grpc::ServerContext* context, const SetAIRosetteStrainGageOrientationRequest* request, SetAIRosetteStrainGageOrientationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIRosetteStrainGageOrientation(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIRosetteStrainGageRosetteMeasType(::grpc::ServerContext* context, const SetAIRosetteStrainGageRosetteMeasTypeRequest* request, SetAIRosetteStrainGageRosetteMeasTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIRosetteStrainGageRosetteMeasTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIRosetteStrainGageRosetteMeasTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIRosetteStrainGageRosetteMeasTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIRosetteStrainGageRosetteMeasType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAISampAndHoldEnable(::grpc::ServerContext* context, const SetAISampAndHoldEnableRequest* request, SetAISampAndHoldEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAISampAndHoldEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAISensorPowerCfg(::grpc::ServerContext* context, const SetAISensorPowerCfgRequest* request, SetAISensorPowerCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAISensorPowerCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAISensorPowerCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAISensorPowerCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAISensorPowerCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAISensorPowerType(::grpc::ServerContext* context, const SetAISensorPowerTypeRequest* request, SetAISensorPowerTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAISensorPowerTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAISensorPowerTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAISensorPowerTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAISensorPowerType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAISensorPowerVoltage(::grpc::ServerContext* context, const SetAISensorPowerVoltageRequest* request, SetAISensorPowerVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAISensorPowerVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAISoundPressureMaxSoundPressureLvl(::grpc::ServerContext* context, const SetAISoundPressureMaxSoundPressureLvlRequest* request, SetAISoundPressureMaxSoundPressureLvlResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAISoundPressureMaxSoundPressureLvl(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAISoundPressureUnits(::grpc::ServerContext* context, const SetAISoundPressureUnitsRequest* request, SetAISoundPressureUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAISoundPressureUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAISoundPressureUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAISoundPressureUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAISoundPressureUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAISoundPressuredBRef(::grpc::ServerContext* context, const SetAISoundPressuredBRefRequest* request, SetAISoundPressuredBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAISoundPressuredBRef(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIStrainGageCfg(::grpc::ServerContext* context, const SetAIStrainGageCfgRequest* request, SetAIStrainGageCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIStrainGageCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIStrainGageCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIStrainGageCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIStrainGageCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIStrainGageForceReadFromChan(::grpc::ServerContext* context, const SetAIStrainGageForceReadFromChanRequest* request, SetAIStrainGageForceReadFromChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAIStrainGageForceReadFromChan(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIStrainGageGageFactor(::grpc::ServerContext* context, const SetAIStrainGageGageFactorRequest* request, SetAIStrainGageGageFactorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIStrainGageGageFactor(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIStrainGagePoissonRatio(::grpc::ServerContext* context, const SetAIStrainGagePoissonRatioRequest* request, SetAIStrainGagePoissonRatioResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIStrainGagePoissonRatio(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIStrainUnits(::grpc::ServerContext* context, const SetAIStrainUnitsRequest* request, SetAIStrainUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIStrainUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIStrainUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIStrainUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIStrainUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAITempUnits(::grpc::ServerContext* context, const SetAITempUnitsRequest* request, SetAITempUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAITempUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAITempUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAITempUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAITempUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAITermCfg(::grpc::ServerContext* context, const SetAITermCfgRequest* request, SetAITermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAITermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAITermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAITermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAITermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIThrmcplCJCVal(::grpc::ServerContext* context, const SetAIThrmcplCJCValRequest* request, SetAIThrmcplCJCValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIThrmcplCJCVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIThrmcplLeadOffsetVoltage(::grpc::ServerContext* context, const SetAIThrmcplLeadOffsetVoltageRequest* request, SetAIThrmcplLeadOffsetVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIThrmcplLeadOffsetVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIThrmcplScaleType(::grpc::ServerContext* context, const SetAIThrmcplScaleTypeRequest* request, SetAIThrmcplScaleTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIThrmcplScaleTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIThrmcplScaleTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIThrmcplScaleTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIThrmcplScaleType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIThrmcplType(::grpc::ServerContext* context, const SetAIThrmcplTypeRequest* request, SetAIThrmcplTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIThrmcplTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIThrmcplTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIThrmcplTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIThrmcplType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIThrmstrA(::grpc::ServerContext* context, const SetAIThrmstrARequest* request, SetAIThrmstrAResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIThrmstrA(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIThrmstrB(::grpc::ServerContext* context, const SetAIThrmstrBRequest* request, SetAIThrmstrBResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIThrmstrB(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIThrmstrC(::grpc::ServerContext* context, const SetAIThrmstrCRequest* request, SetAIThrmstrCResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIThrmstrC(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIThrmstrR1(::grpc::ServerContext* context, const SetAIThrmstrR1Request* request, SetAIThrmstrR1Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIThrmstrR1(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAITorqueUnits(::grpc::ServerContext* context, const SetAITorqueUnitsRequest* request, SetAITorqueUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAITorqueUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAITorqueUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAITorqueUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAITorqueUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIUsbXferReqCount(::grpc::ServerContext* context, const SetAIUsbXferReqCountRequest* request, SetAIUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAIUsbXferReqCount(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIUsbXferReqSize(::grpc::ServerContext* context, const SetAIUsbXferReqSizeRequest* request, SetAIUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAIUsbXferReqSize(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIVelocityIEPESensorSensitivity(::grpc::ServerContext* context, const SetAIVelocityIEPESensorSensitivityRequest* request, SetAIVelocityIEPESensorSensitivityResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIVelocityIEPESensorSensitivity(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIVelocityIEPESensorSensitivityUnits(::grpc::ServerContext* context, const SetAIVelocityIEPESensorSensitivityUnitsRequest* request, SetAIVelocityIEPESensorSensitivityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIVelocityIEPESensorSensitivityUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIVelocityIEPESensorSensitivityUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIVelocityIEPESensorSensitivityUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIVelocityIEPESensorSensitivityUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIVelocityIEPESensordBRef(::grpc::ServerContext* context, const SetAIVelocityIEPESensordBRefRequest* request, SetAIVelocityIEPESensordBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIVelocityIEPESensordBRef(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIVelocityUnits(::grpc::ServerContext* context, const SetAIVelocityUnitsRequest* request, SetAIVelocityUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIVelocityUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIVelocityUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIVelocityUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIVelocityUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIVoltageACRMSUnits(::grpc::ServerContext* context, const SetAIVoltageACRMSUnitsRequest* request, SetAIVoltageACRMSUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIVoltageACRMSUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIVoltageACRMSUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIVoltageACRMSUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIVoltageACRMSUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIVoltageUnits(::grpc::ServerContext* context, const SetAIVoltageUnitsRequest* request, SetAIVoltageUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAIVoltageUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAIVoltageUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAIVoltageUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAIVoltageUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIVoltagedBRef(::grpc::ServerContext* context, const SetAIVoltagedBRefRequest* request, SetAIVoltagedBRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAIVoltagedBRef(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOCurrentUnits(::grpc::ServerContext* context, const SetAOCurrentUnitsRequest* request, SetAOCurrentUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAOCurrentUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAOCurrentUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAOCurrentUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAOCurrentUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOCustomScaleName(::grpc::ServerContext* context, const SetAOCustomScaleNameRequest* request, SetAOCustomScaleNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetAOCustomScaleName(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODACOffsetExtSrc(::grpc::ServerContext* context, const SetAODACOffsetExtSrcRequest* request, SetAODACOffsetExtSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetAODACOffsetExtSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODACOffsetSrc(::grpc::ServerContext* context, const SetAODACOffsetSrcRequest* request, SetAODACOffsetSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAODACOffsetSrcRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAODACOffsetSrcRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAODACOffsetSrcRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAODACOffsetSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODACOffsetVal(::grpc::ServerContext* context, const SetAODACOffsetValRequest* request, SetAODACOffsetValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAODACOffsetVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODACRefAllowConnToGnd(::grpc::ServerContext* context, const SetAODACRefAllowConnToGndRequest* request, SetAODACRefAllowConnToGndResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAODACRefAllowConnToGnd(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODACRefConnToGnd(::grpc::ServerContext* context, const SetAODACRefConnToGndRequest* request, SetAODACRefConnToGndResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAODACRefConnToGnd(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODACRefExtSrc(::grpc::ServerContext* context, const SetAODACRefExtSrcRequest* request, SetAODACRefExtSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetAODACRefExtSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODACRefSrc(::grpc::ServerContext* context, const SetAODACRefSrcRequest* request, SetAODACRefSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAODACRefSrcRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAODACRefSrcRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAODACRefSrcRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAODACRefSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODACRefVal(::grpc::ServerContext* context, const SetAODACRefValRequest* request, SetAODACRefValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAODACRefVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODACRngHigh(::grpc::ServerContext* context, const SetAODACRngHighRequest* request, SetAODACRngHighResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAODACRngHigh(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODACRngLow(::grpc::ServerContext* context, const SetAODACRngLowRequest* request, SetAODACRngLowResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAODACRngLow(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODataXferMech(::grpc::ServerContext* context, const SetAODataXferMechRequest* request, SetAODataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAODataXferMechRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAODataXferMechRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAODataXferMechRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAODataXferMech(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAODataXferReqCond(::grpc::ServerContext* context, const SetAODataXferReqCondRequest* request, SetAODataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAODataXferReqCondRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAODataXferReqCondRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAODataXferReqCondRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAODataXferReqCond(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOEnhancedImageRejectionEnable(::grpc::ServerContext* context, const SetAOEnhancedImageRejectionEnableRequest* request, SetAOEnhancedImageRejectionEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAOEnhancedImageRejectionEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOFilterDelay(::grpc::ServerContext* context, const SetAOFilterDelayRequest* request, SetAOFilterDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOFilterDelay(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOFilterDelayAdjustment(::grpc::ServerContext* context, const SetAOFilterDelayAdjustmentRequest* request, SetAOFilterDelayAdjustmentResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOFilterDelayAdjustment(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOFilterDelayUnits(::grpc::ServerContext* context, const SetAOFilterDelayUnitsRequest* request, SetAOFilterDelayUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAOFilterDelayUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAOFilterDelayUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAOFilterDelayUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAOFilterDelayUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOFuncGenAmplitude(::grpc::ServerContext* context, const SetAOFuncGenAmplitudeRequest* request, SetAOFuncGenAmplitudeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOFuncGenAmplitude(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOFuncGenFMDeviation(::grpc::ServerContext* context, const SetAOFuncGenFMDeviationRequest* request, SetAOFuncGenFMDeviationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOFuncGenFMDeviation(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOFuncGenFreq(::grpc::ServerContext* context, const SetAOFuncGenFreqRequest* request, SetAOFuncGenFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOFuncGenFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOFuncGenModulationType(::grpc::ServerContext* context, const SetAOFuncGenModulationTypeRequest* request, SetAOFuncGenModulationTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAOFuncGenModulationTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAOFuncGenModulationTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAOFuncGenModulationTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAOFuncGenModulationType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOFuncGenOffset(::grpc::ServerContext* context, const SetAOFuncGenOffsetRequest* request, SetAOFuncGenOffsetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOFuncGenOffset(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOFuncGenSquareDutyCycle(::grpc::ServerContext* context, const SetAOFuncGenSquareDutyCycleRequest* request, SetAOFuncGenSquareDutyCycleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOFuncGenSquareDutyCycle(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOFuncGenType(::grpc::ServerContext* context, const SetAOFuncGenTypeRequest* request, SetAOFuncGenTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAOFuncGenTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAOFuncGenTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAOFuncGenTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAOFuncGenType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOGain(::grpc::ServerContext* context, const SetAOGainRequest* request, SetAOGainResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOGain(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOIdleOutputBehavior(::grpc::ServerContext* context, const SetAOIdleOutputBehaviorRequest* request, SetAOIdleOutputBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAOIdleOutputBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAOIdleOutputBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAOIdleOutputBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAOIdleOutputBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOLoadImpedance(::grpc::ServerContext* context, const SetAOLoadImpedanceRequest* request, SetAOLoadImpedanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOLoadImpedance(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOMax(::grpc::ServerContext* context, const SetAOMaxRequest* request, SetAOMaxResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOMax(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOMemMapEnable(::grpc::ServerContext* context, const SetAOMemMapEnableRequest* request, SetAOMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAOMemMapEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOMin(::grpc::ServerContext* context, const SetAOMinRequest* request, SetAOMinResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOMin(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOOutputImpedance(::grpc::ServerContext* context, const SetAOOutputImpedanceRequest* request, SetAOOutputImpedanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOOutputImpedance(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOReglitchEnable(::grpc::ServerContext* context, const SetAOReglitchEnableRequest* request, SetAOReglitchEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAOReglitchEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOResolutionUnits(::grpc::ServerContext* context, const SetAOResolutionUnitsRequest* request, SetAOResolutionUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAOResolutionUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAOResolutionUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAOResolutionUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAOResolutionUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOTermCfg(::grpc::ServerContext* context, const SetAOTermCfgRequest* request, SetAOTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAOTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAOTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAOTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAOTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOUsbXferReqCount(::grpc::ServerContext* context, const SetAOUsbXferReqCountRequest* request, SetAOUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAOUsbXferReqCount(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOUsbXferReqSize(::grpc::ServerContext* context, const SetAOUsbXferReqSizeRequest* request, SetAOUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetAOUsbXferReqSize(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOUseOnlyOnBrdMem(::grpc::ServerContext* context, const SetAOUseOnlyOnBrdMemRequest* request, SetAOUseOnlyOnBrdMemResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetAOUseOnlyOnBrdMem(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOVoltageCurrentLimit(::grpc::ServerContext* context, const SetAOVoltageCurrentLimitRequest* request, SetAOVoltageCurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetAOVoltageCurrentLimit(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAOVoltageUnits(::grpc::ServerContext* context, const SetAOVoltageUnitsRequest* request, SetAOVoltageUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetAOVoltageUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetAOVoltageUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetAOVoltageUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAOVoltageUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetArmStartTrigTrigWhen(::grpc::ServerContext* context, const SetArmStartTrigTrigWhenRequest* request, SetArmStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetArmStartTrigTrigWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetBufInputBufSize(::grpc::ServerContext* context, const SetBufInputBufSizeRequest* request, SetBufInputBufSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 data = request->data();
      auto status = library_->SetBufInputBufSize(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetBufOutputBufSize(::grpc::ServerContext* context, const SetBufOutputBufSizeRequest* request, SetBufOutputBufSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 data = request->data();
      auto status = library_->SetBufOutputBufSize(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetBufOutputOnbrdBufSize(::grpc::ServerContext* context, const SetBufOutputOnbrdBufSizeRequest* request, SetBufOutputOnbrdBufSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 data = request->data();
      auto status = library_->SetBufOutputOnbrdBufSize(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIAngEncoderInitialAngle(::grpc::ServerContext* context, const SetCIAngEncoderInitialAngleRequest* request, SetCIAngEncoderInitialAngleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIAngEncoderInitialAngle(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIAngEncoderPulsesPerRev(::grpc::ServerContext* context, const SetCIAngEncoderPulsesPerRevRequest* request, SetCIAngEncoderPulsesPerRevResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCIAngEncoderPulsesPerRev(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIAngEncoderUnits(::grpc::ServerContext* context, const SetCIAngEncoderUnitsRequest* request, SetCIAngEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIAngEncoderUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIAngEncoderUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIAngEncoderUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIAngEncoderUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesActiveEdge(::grpc::ServerContext* context, const SetCICountEdgesActiveEdgeRequest* request, SetCICountEdgesActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesActiveEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesActiveEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesActiveEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesActiveEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountDirDigFltrEnable(::grpc::ServerContext* context, const SetCICountEdgesCountDirDigFltrEnableRequest* request, SetCICountEdgesCountDirDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICountEdgesCountDirDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountDirDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCICountEdgesCountDirDigFltrMinPulseWidthRequest* request, SetCICountEdgesCountDirDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesCountDirDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountDirDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCICountEdgesCountDirDigFltrTimebaseRateRequest* request, SetCICountEdgesCountDirDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesCountDirDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountDirDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCICountEdgesCountDirDigFltrTimebaseSrcRequest* request, SetCICountEdgesCountDirDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICountEdgesCountDirDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountDirDigSyncEnable(::grpc::ServerContext* context, const SetCICountEdgesCountDirDigSyncEnableRequest* request, SetCICountEdgesCountDirDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICountEdgesCountDirDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountDirHyst(::grpc::ServerContext* context, const SetCICountEdgesCountDirHystRequest* request, SetCICountEdgesCountDirHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesCountDirHyst(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountDirLogicLvlBehavior(::grpc::ServerContext* context, const SetCICountEdgesCountDirLogicLvlBehaviorRequest* request, SetCICountEdgesCountDirLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesCountDirLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesCountDirLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesCountDirLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesCountDirLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountDirTermCfg(::grpc::ServerContext* context, const SetCICountEdgesCountDirTermCfgRequest* request, SetCICountEdgesCountDirTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesCountDirTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesCountDirTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesCountDirTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesCountDirTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountDirThreshVoltage(::grpc::ServerContext* context, const SetCICountEdgesCountDirThreshVoltageRequest* request, SetCICountEdgesCountDirThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesCountDirThreshVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetActiveEdge(::grpc::ServerContext* context, const SetCICountEdgesCountResetActiveEdgeRequest* request, SetCICountEdgesCountResetActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesCountResetActiveEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesCountResetActiveEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesCountResetActiveEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesCountResetActiveEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetDigFltrEnable(::grpc::ServerContext* context, const SetCICountEdgesCountResetDigFltrEnableRequest* request, SetCICountEdgesCountResetDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICountEdgesCountResetDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCICountEdgesCountResetDigFltrMinPulseWidthRequest* request, SetCICountEdgesCountResetDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesCountResetDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCICountEdgesCountResetDigFltrTimebaseRateRequest* request, SetCICountEdgesCountResetDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesCountResetDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCICountEdgesCountResetDigFltrTimebaseSrcRequest* request, SetCICountEdgesCountResetDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICountEdgesCountResetDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetDigSyncEnable(::grpc::ServerContext* context, const SetCICountEdgesCountResetDigSyncEnableRequest* request, SetCICountEdgesCountResetDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICountEdgesCountResetDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetEnable(::grpc::ServerContext* context, const SetCICountEdgesCountResetEnableRequest* request, SetCICountEdgesCountResetEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICountEdgesCountResetEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetHyst(::grpc::ServerContext* context, const SetCICountEdgesCountResetHystRequest* request, SetCICountEdgesCountResetHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesCountResetHyst(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetLogicLvlBehavior(::grpc::ServerContext* context, const SetCICountEdgesCountResetLogicLvlBehaviorRequest* request, SetCICountEdgesCountResetLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesCountResetLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesCountResetLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesCountResetLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesCountResetLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetResetCount(::grpc::ServerContext* context, const SetCICountEdgesCountResetResetCountRequest* request, SetCICountEdgesCountResetResetCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCICountEdgesCountResetResetCount(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetTerm(::grpc::ServerContext* context, const SetCICountEdgesCountResetTermRequest* request, SetCICountEdgesCountResetTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICountEdgesCountResetTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetTermCfg(::grpc::ServerContext* context, const SetCICountEdgesCountResetTermCfgRequest* request, SetCICountEdgesCountResetTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesCountResetTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesCountResetTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesCountResetTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesCountResetTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesCountResetThreshVoltage(::grpc::ServerContext* context, const SetCICountEdgesCountResetThreshVoltageRequest* request, SetCICountEdgesCountResetThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesCountResetThreshVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesDigFltrEnable(::grpc::ServerContext* context, const SetCICountEdgesDigFltrEnableRequest* request, SetCICountEdgesDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICountEdgesDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCICountEdgesDigFltrMinPulseWidthRequest* request, SetCICountEdgesDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCICountEdgesDigFltrTimebaseRateRequest* request, SetCICountEdgesDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCICountEdgesDigFltrTimebaseSrcRequest* request, SetCICountEdgesDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICountEdgesDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesDigSyncEnable(::grpc::ServerContext* context, const SetCICountEdgesDigSyncEnableRequest* request, SetCICountEdgesDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICountEdgesDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesDir(::grpc::ServerContext* context, const SetCICountEdgesDirRequest* request, SetCICountEdgesDirResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesDirRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesDirRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesDirRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesDir(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesDirTerm(::grpc::ServerContext* context, const SetCICountEdgesDirTermRequest* request, SetCICountEdgesDirTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICountEdgesDirTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateDigFltrEnable(::grpc::ServerContext* context, const SetCICountEdgesGateDigFltrEnableRequest* request, SetCICountEdgesGateDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICountEdgesGateDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCICountEdgesGateDigFltrMinPulseWidthRequest* request, SetCICountEdgesGateDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesGateDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCICountEdgesGateDigFltrTimebaseRateRequest* request, SetCICountEdgesGateDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesGateDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCICountEdgesGateDigFltrTimebaseSrcRequest* request, SetCICountEdgesGateDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICountEdgesGateDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateEnable(::grpc::ServerContext* context, const SetCICountEdgesGateEnableRequest* request, SetCICountEdgesGateEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICountEdgesGateEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateHyst(::grpc::ServerContext* context, const SetCICountEdgesGateHystRequest* request, SetCICountEdgesGateHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesGateHyst(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateLogicLvlBehavior(::grpc::ServerContext* context, const SetCICountEdgesGateLogicLvlBehaviorRequest* request, SetCICountEdgesGateLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesGateLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesGateLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesGateLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesGateLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateTerm(::grpc::ServerContext* context, const SetCICountEdgesGateTermRequest* request, SetCICountEdgesGateTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICountEdgesGateTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateTermCfg(::grpc::ServerContext* context, const SetCICountEdgesGateTermCfgRequest* request, SetCICountEdgesGateTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesGateTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesGateTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesGateTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesGateTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateThreshVoltage(::grpc::ServerContext* context, const SetCICountEdgesGateThreshVoltageRequest* request, SetCICountEdgesGateThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesGateThreshVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesGateWhen(::grpc::ServerContext* context, const SetCICountEdgesGateWhenRequest* request, SetCICountEdgesGateWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesGateWhenRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesGateWhenRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesGateWhenRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesGateWhen(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesHyst(::grpc::ServerContext* context, const SetCICountEdgesHystRequest* request, SetCICountEdgesHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesHyst(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesInitialCnt(::grpc::ServerContext* context, const SetCICountEdgesInitialCntRequest* request, SetCICountEdgesInitialCntResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCICountEdgesInitialCnt(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesLogicLvlBehavior(::grpc::ServerContext* context, const SetCICountEdgesLogicLvlBehaviorRequest* request, SetCICountEdgesLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesTerm(::grpc::ServerContext* context, const SetCICountEdgesTermRequest* request, SetCICountEdgesTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICountEdgesTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesTermCfg(::grpc::ServerContext* context, const SetCICountEdgesTermCfgRequest* request, SetCICountEdgesTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICountEdgesTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICountEdgesTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICountEdgesTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICountEdgesThreshVoltage(::grpc::ServerContext* context, const SetCICountEdgesThreshVoltageRequest* request, SetCICountEdgesThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICountEdgesThreshVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICtrTimebaseActiveEdge(::grpc::ServerContext* context, const SetCICtrTimebaseActiveEdgeRequest* request, SetCICtrTimebaseActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCICtrTimebaseActiveEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCICtrTimebaseActiveEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCICtrTimebaseActiveEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCICtrTimebaseActiveEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICtrTimebaseDigFltrEnable(::grpc::ServerContext* context, const SetCICtrTimebaseDigFltrEnableRequest* request, SetCICtrTimebaseDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICtrTimebaseDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICtrTimebaseDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCICtrTimebaseDigFltrMinPulseWidthRequest* request, SetCICtrTimebaseDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICtrTimebaseDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICtrTimebaseDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCICtrTimebaseDigFltrTimebaseRateRequest* request, SetCICtrTimebaseDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICtrTimebaseDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICtrTimebaseDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCICtrTimebaseDigFltrTimebaseSrcRequest* request, SetCICtrTimebaseDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICtrTimebaseDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICtrTimebaseDigSyncEnable(::grpc::ServerContext* context, const SetCICtrTimebaseDigSyncEnableRequest* request, SetCICtrTimebaseDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCICtrTimebaseDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICtrTimebaseMasterTimebaseDiv(::grpc::ServerContext* context, const SetCICtrTimebaseMasterTimebaseDivRequest* request, SetCICtrTimebaseMasterTimebaseDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCICtrTimebaseMasterTimebaseDiv(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICtrTimebaseRate(::grpc::ServerContext* context, const SetCICtrTimebaseRateRequest* request, SetCICtrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCICtrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICtrTimebaseSrc(::grpc::ServerContext* context, const SetCICtrTimebaseSrcRequest* request, SetCICtrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICtrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCICustomScaleName(::grpc::ServerContext* context, const SetCICustomScaleNameRequest* request, SetCICustomScaleNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCICustomScaleName(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDataXferMech(::grpc::ServerContext* context, const SetCIDataXferMechRequest* request, SetCIDataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIDataXferMechRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIDataXferMechRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIDataXferMechRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIDataXferMech(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDataXferReqCond(::grpc::ServerContext* context, const SetCIDataXferReqCondRequest* request, SetCIDataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIDataXferReqCondRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIDataXferReqCondRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIDataXferReqCondRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIDataXferReqCond(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDupCountPrevent(::grpc::ServerContext* context, const SetCIDupCountPreventRequest* request, SetCIDupCountPreventResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIDupCountPrevent(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDutyCycleDigFltrEnable(::grpc::ServerContext* context, const SetCIDutyCycleDigFltrEnableRequest* request, SetCIDutyCycleDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIDutyCycleDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDutyCycleDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIDutyCycleDigFltrMinPulseWidthRequest* request, SetCIDutyCycleDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIDutyCycleDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDutyCycleDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIDutyCycleDigFltrTimebaseRateRequest* request, SetCIDutyCycleDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIDutyCycleDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDutyCycleDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIDutyCycleDigFltrTimebaseSrcRequest* request, SetCIDutyCycleDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIDutyCycleDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDutyCycleLogicLvlBehavior(::grpc::ServerContext* context, const SetCIDutyCycleLogicLvlBehaviorRequest* request, SetCIDutyCycleLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIDutyCycleLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIDutyCycleLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIDutyCycleLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIDutyCycleLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDutyCycleStartingEdge(::grpc::ServerContext* context, const SetCIDutyCycleStartingEdgeRequest* request, SetCIDutyCycleStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIDutyCycleStartingEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIDutyCycleStartingEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIDutyCycleStartingEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIDutyCycleStartingEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDutyCycleTerm(::grpc::ServerContext* context, const SetCIDutyCycleTermRequest* request, SetCIDutyCycleTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIDutyCycleTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIDutyCycleTermCfg(::grpc::ServerContext* context, const SetCIDutyCycleTermCfgRequest* request, SetCIDutyCycleTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIDutyCycleTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIDutyCycleTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIDutyCycleTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIDutyCycleTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderAInputDigFltrEnable(::grpc::ServerContext* context, const SetCIEncoderAInputDigFltrEnableRequest* request, SetCIEncoderAInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIEncoderAInputDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderAInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIEncoderAInputDigFltrMinPulseWidthRequest* request, SetCIEncoderAInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIEncoderAInputDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderAInputDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIEncoderAInputDigFltrTimebaseRateRequest* request, SetCIEncoderAInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIEncoderAInputDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderAInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIEncoderAInputDigFltrTimebaseSrcRequest* request, SetCIEncoderAInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIEncoderAInputDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderAInputDigSyncEnable(::grpc::ServerContext* context, const SetCIEncoderAInputDigSyncEnableRequest* request, SetCIEncoderAInputDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIEncoderAInputDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderAInputLogicLvlBehavior(::grpc::ServerContext* context, const SetCIEncoderAInputLogicLvlBehaviorRequest* request, SetCIEncoderAInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIEncoderAInputLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderAInputLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderAInputLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIEncoderAInputLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderAInputTerm(::grpc::ServerContext* context, const SetCIEncoderAInputTermRequest* request, SetCIEncoderAInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIEncoderAInputTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderAInputTermCfg(::grpc::ServerContext* context, const SetCIEncoderAInputTermCfgRequest* request, SetCIEncoderAInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIEncoderAInputTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderAInputTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderAInputTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIEncoderAInputTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderBInputDigFltrEnable(::grpc::ServerContext* context, const SetCIEncoderBInputDigFltrEnableRequest* request, SetCIEncoderBInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIEncoderBInputDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderBInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIEncoderBInputDigFltrMinPulseWidthRequest* request, SetCIEncoderBInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIEncoderBInputDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderBInputDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIEncoderBInputDigFltrTimebaseRateRequest* request, SetCIEncoderBInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIEncoderBInputDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderBInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIEncoderBInputDigFltrTimebaseSrcRequest* request, SetCIEncoderBInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIEncoderBInputDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderBInputDigSyncEnable(::grpc::ServerContext* context, const SetCIEncoderBInputDigSyncEnableRequest* request, SetCIEncoderBInputDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIEncoderBInputDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderBInputLogicLvlBehavior(::grpc::ServerContext* context, const SetCIEncoderBInputLogicLvlBehaviorRequest* request, SetCIEncoderBInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIEncoderBInputLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderBInputLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderBInputLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIEncoderBInputLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderBInputTerm(::grpc::ServerContext* context, const SetCIEncoderBInputTermRequest* request, SetCIEncoderBInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIEncoderBInputTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderBInputTermCfg(::grpc::ServerContext* context, const SetCIEncoderBInputTermCfgRequest* request, SetCIEncoderBInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIEncoderBInputTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderBInputTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderBInputTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIEncoderBInputTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderDecodingType(::grpc::ServerContext* context, const SetCIEncoderDecodingTypeRequest* request, SetCIEncoderDecodingTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIEncoderDecodingTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderDecodingTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderDecodingTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIEncoderDecodingType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZIndexEnable(::grpc::ServerContext* context, const SetCIEncoderZIndexEnableRequest* request, SetCIEncoderZIndexEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIEncoderZIndexEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZIndexPhase(::grpc::ServerContext* context, const SetCIEncoderZIndexPhaseRequest* request, SetCIEncoderZIndexPhaseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIEncoderZIndexPhaseRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderZIndexPhaseRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderZIndexPhaseRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIEncoderZIndexPhase(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZIndexVal(::grpc::ServerContext* context, const SetCIEncoderZIndexValRequest* request, SetCIEncoderZIndexValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIEncoderZIndexVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZInputDigFltrEnable(::grpc::ServerContext* context, const SetCIEncoderZInputDigFltrEnableRequest* request, SetCIEncoderZInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIEncoderZInputDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIEncoderZInputDigFltrMinPulseWidthRequest* request, SetCIEncoderZInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIEncoderZInputDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZInputDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIEncoderZInputDigFltrTimebaseRateRequest* request, SetCIEncoderZInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIEncoderZInputDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIEncoderZInputDigFltrTimebaseSrcRequest* request, SetCIEncoderZInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIEncoderZInputDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZInputDigSyncEnable(::grpc::ServerContext* context, const SetCIEncoderZInputDigSyncEnableRequest* request, SetCIEncoderZInputDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIEncoderZInputDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZInputLogicLvlBehavior(::grpc::ServerContext* context, const SetCIEncoderZInputLogicLvlBehaviorRequest* request, SetCIEncoderZInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIEncoderZInputLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderZInputLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderZInputLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIEncoderZInputLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZInputTerm(::grpc::ServerContext* context, const SetCIEncoderZInputTermRequest* request, SetCIEncoderZInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIEncoderZInputTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIEncoderZInputTermCfg(::grpc::ServerContext* context, const SetCIEncoderZInputTermCfgRequest* request, SetCIEncoderZInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIEncoderZInputTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderZInputTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIEncoderZInputTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIEncoderZInputTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFilterDelayUnits(::grpc::ServerContext* context, const SetCIFilterDelayUnitsRequest* request, SetCIFilterDelayUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIFilterDelayUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIFilterDelayUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIFilterDelayUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIFilterDelayUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFilterEnable(::grpc::ServerContext* context, const SetCIFilterEnableRequest* request, SetCIFilterEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIFilterEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFilterFreq(::grpc::ServerContext* context, const SetCIFilterFreqRequest* request, SetCIFilterFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIFilterFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFilterOrder(::grpc::ServerContext* context, const SetCIFilterOrderRequest* request, SetCIFilterOrderResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCIFilterOrder(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFilterResponse(::grpc::ServerContext* context, const SetCIFilterResponseRequest* request, SetCIFilterResponseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIFilterResponseRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIFilterResponseRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIFilterResponseRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIFilterResponse(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqDigFltrEnable(::grpc::ServerContext* context, const SetCIFreqDigFltrEnableRequest* request, SetCIFreqDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIFreqDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIFreqDigFltrMinPulseWidthRequest* request, SetCIFreqDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIFreqDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIFreqDigFltrTimebaseRateRequest* request, SetCIFreqDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIFreqDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIFreqDigFltrTimebaseSrcRequest* request, SetCIFreqDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIFreqDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqDigSyncEnable(::grpc::ServerContext* context, const SetCIFreqDigSyncEnableRequest* request, SetCIFreqDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIFreqDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqDiv(::grpc::ServerContext* context, const SetCIFreqDivRequest* request, SetCIFreqDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCIFreqDiv(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqEnableAveraging(::grpc::ServerContext* context, const SetCIFreqEnableAveragingRequest* request, SetCIFreqEnableAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIFreqEnableAveraging(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqHyst(::grpc::ServerContext* context, const SetCIFreqHystRequest* request, SetCIFreqHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIFreqHyst(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqLogicLvlBehavior(::grpc::ServerContext* context, const SetCIFreqLogicLvlBehaviorRequest* request, SetCIFreqLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIFreqLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIFreqLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIFreqLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIFreqLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqMeasMeth(::grpc::ServerContext* context, const SetCIFreqMeasMethRequest* request, SetCIFreqMeasMethResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIFreqMeasMethRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIFreqMeasMethRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIFreqMeasMethRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIFreqMeasMeth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqMeasTime(::grpc::ServerContext* context, const SetCIFreqMeasTimeRequest* request, SetCIFreqMeasTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIFreqMeasTime(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqStartingEdge(::grpc::ServerContext* context, const SetCIFreqStartingEdgeRequest* request, SetCIFreqStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIFreqStartingEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIFreqStartingEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIFreqStartingEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIFreqStartingEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqTerm(::grpc::ServerContext* context, const SetCIFreqTermRequest* request, SetCIFreqTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIFreqTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqTermCfg(::grpc::ServerContext* context, const SetCIFreqTermCfgRequest* request, SetCIFreqTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIFreqTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIFreqTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIFreqTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIFreqTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqThreshVoltage(::grpc::ServerContext* context, const SetCIFreqThreshVoltageRequest* request, SetCIFreqThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIFreqThreshVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIFreqUnits(::grpc::ServerContext* context, const SetCIFreqUnitsRequest* request, SetCIFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIFreqUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIFreqUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIFreqUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIFreqUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIGPSSyncMethod(::grpc::ServerContext* context, const SetCIGPSSyncMethodRequest* request, SetCIGPSSyncMethodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIGPSSyncMethodRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIGPSSyncMethodRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIGPSSyncMethodRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIGPSSyncMethod(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIGPSSyncSrc(::grpc::ServerContext* context, const SetCIGPSSyncSrcRequest* request, SetCIGPSSyncSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIGPSSyncSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCILinEncoderDistPerPulse(::grpc::ServerContext* context, const SetCILinEncoderDistPerPulseRequest* request, SetCILinEncoderDistPerPulseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCILinEncoderDistPerPulse(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCILinEncoderInitialPos(::grpc::ServerContext* context, const SetCILinEncoderInitialPosRequest* request, SetCILinEncoderInitialPosResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCILinEncoderInitialPos(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCILinEncoderUnits(::grpc::ServerContext* context, const SetCILinEncoderUnitsRequest* request, SetCILinEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCILinEncoderUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCILinEncoderUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCILinEncoderUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCILinEncoderUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIMax(::grpc::ServerContext* context, const SetCIMaxRequest* request, SetCIMaxResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIMax(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIMaxMeasPeriod(::grpc::ServerContext* context, const SetCIMaxMeasPeriodRequest* request, SetCIMaxMeasPeriodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIMaxMeasPeriod(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIMemMapEnable(::grpc::ServerContext* context, const SetCIMemMapEnableRequest* request, SetCIMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIMemMapEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIMin(::grpc::ServerContext* context, const SetCIMinRequest* request, SetCIMinResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIMin(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodDigFltrEnable(::grpc::ServerContext* context, const SetCIPeriodDigFltrEnableRequest* request, SetCIPeriodDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPeriodDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIPeriodDigFltrMinPulseWidthRequest* request, SetCIPeriodDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPeriodDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIPeriodDigFltrTimebaseRateRequest* request, SetCIPeriodDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPeriodDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIPeriodDigFltrTimebaseSrcRequest* request, SetCIPeriodDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIPeriodDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodDigSyncEnable(::grpc::ServerContext* context, const SetCIPeriodDigSyncEnableRequest* request, SetCIPeriodDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPeriodDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodDiv(::grpc::ServerContext* context, const SetCIPeriodDivRequest* request, SetCIPeriodDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCIPeriodDiv(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodEnableAveraging(::grpc::ServerContext* context, const SetCIPeriodEnableAveragingRequest* request, SetCIPeriodEnableAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPeriodEnableAveraging(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodHyst(::grpc::ServerContext* context, const SetCIPeriodHystRequest* request, SetCIPeriodHystResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPeriodHyst(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodLogicLvlBehavior(::grpc::ServerContext* context, const SetCIPeriodLogicLvlBehaviorRequest* request, SetCIPeriodLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPeriodLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPeriodLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPeriodLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPeriodLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodMeasMeth(::grpc::ServerContext* context, const SetCIPeriodMeasMethRequest* request, SetCIPeriodMeasMethResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPeriodMeasMethRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPeriodMeasMethRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPeriodMeasMethRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPeriodMeasMeth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodMeasTime(::grpc::ServerContext* context, const SetCIPeriodMeasTimeRequest* request, SetCIPeriodMeasTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPeriodMeasTime(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodStartingEdge(::grpc::ServerContext* context, const SetCIPeriodStartingEdgeRequest* request, SetCIPeriodStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPeriodStartingEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPeriodStartingEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPeriodStartingEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPeriodStartingEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodTerm(::grpc::ServerContext* context, const SetCIPeriodTermRequest* request, SetCIPeriodTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIPeriodTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodTermCfg(::grpc::ServerContext* context, const SetCIPeriodTermCfgRequest* request, SetCIPeriodTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPeriodTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPeriodTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPeriodTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPeriodTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodThreshVoltage(::grpc::ServerContext* context, const SetCIPeriodThreshVoltageRequest* request, SetCIPeriodThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPeriodThreshVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPeriodUnits(::grpc::ServerContext* context, const SetCIPeriodUnitsRequest* request, SetCIPeriodUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPeriodUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPeriodUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPeriodUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPeriodUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPrescaler(::grpc::ServerContext* context, const SetCIPrescalerRequest* request, SetCIPrescalerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCIPrescaler(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseFreqDigFltrEnable(::grpc::ServerContext* context, const SetCIPulseFreqDigFltrEnableRequest* request, SetCIPulseFreqDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPulseFreqDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseFreqDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIPulseFreqDigFltrMinPulseWidthRequest* request, SetCIPulseFreqDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPulseFreqDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseFreqDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIPulseFreqDigFltrTimebaseRateRequest* request, SetCIPulseFreqDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPulseFreqDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseFreqDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIPulseFreqDigFltrTimebaseSrcRequest* request, SetCIPulseFreqDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIPulseFreqDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseFreqDigSyncEnable(::grpc::ServerContext* context, const SetCIPulseFreqDigSyncEnableRequest* request, SetCIPulseFreqDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPulseFreqDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseFreqLogicLvlBehavior(::grpc::ServerContext* context, const SetCIPulseFreqLogicLvlBehaviorRequest* request, SetCIPulseFreqLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseFreqLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseFreqLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseFreqLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseFreqLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseFreqStartEdge(::grpc::ServerContext* context, const SetCIPulseFreqStartEdgeRequest* request, SetCIPulseFreqStartEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseFreqStartEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseFreqStartEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseFreqStartEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseFreqStartEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseFreqTerm(::grpc::ServerContext* context, const SetCIPulseFreqTermRequest* request, SetCIPulseFreqTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIPulseFreqTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseFreqTermCfg(::grpc::ServerContext* context, const SetCIPulseFreqTermCfgRequest* request, SetCIPulseFreqTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseFreqTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseFreqTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseFreqTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseFreqTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseFreqUnits(::grpc::ServerContext* context, const SetCIPulseFreqUnitsRequest* request, SetCIPulseFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseFreqUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseFreqUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseFreqUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseFreqUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTicksDigFltrEnable(::grpc::ServerContext* context, const SetCIPulseTicksDigFltrEnableRequest* request, SetCIPulseTicksDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPulseTicksDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTicksDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIPulseTicksDigFltrMinPulseWidthRequest* request, SetCIPulseTicksDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPulseTicksDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTicksDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIPulseTicksDigFltrTimebaseRateRequest* request, SetCIPulseTicksDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPulseTicksDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTicksDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIPulseTicksDigFltrTimebaseSrcRequest* request, SetCIPulseTicksDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIPulseTicksDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTicksDigSyncEnable(::grpc::ServerContext* context, const SetCIPulseTicksDigSyncEnableRequest* request, SetCIPulseTicksDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPulseTicksDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTicksLogicLvlBehavior(::grpc::ServerContext* context, const SetCIPulseTicksLogicLvlBehaviorRequest* request, SetCIPulseTicksLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseTicksLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTicksLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTicksLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseTicksLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTicksStartEdge(::grpc::ServerContext* context, const SetCIPulseTicksStartEdgeRequest* request, SetCIPulseTicksStartEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseTicksStartEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTicksStartEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTicksStartEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseTicksStartEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTicksTerm(::grpc::ServerContext* context, const SetCIPulseTicksTermRequest* request, SetCIPulseTicksTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIPulseTicksTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTicksTermCfg(::grpc::ServerContext* context, const SetCIPulseTicksTermCfgRequest* request, SetCIPulseTicksTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseTicksTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTicksTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTicksTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseTicksTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTimeDigFltrEnable(::grpc::ServerContext* context, const SetCIPulseTimeDigFltrEnableRequest* request, SetCIPulseTimeDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPulseTimeDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTimeDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIPulseTimeDigFltrMinPulseWidthRequest* request, SetCIPulseTimeDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPulseTimeDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTimeDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIPulseTimeDigFltrTimebaseRateRequest* request, SetCIPulseTimeDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPulseTimeDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTimeDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIPulseTimeDigFltrTimebaseSrcRequest* request, SetCIPulseTimeDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIPulseTimeDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTimeDigSyncEnable(::grpc::ServerContext* context, const SetCIPulseTimeDigSyncEnableRequest* request, SetCIPulseTimeDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPulseTimeDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTimeLogicLvlBehavior(::grpc::ServerContext* context, const SetCIPulseTimeLogicLvlBehaviorRequest* request, SetCIPulseTimeLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseTimeLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTimeLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTimeLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseTimeLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTimeStartEdge(::grpc::ServerContext* context, const SetCIPulseTimeStartEdgeRequest* request, SetCIPulseTimeStartEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseTimeStartEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTimeStartEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTimeStartEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseTimeStartEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTimeTerm(::grpc::ServerContext* context, const SetCIPulseTimeTermRequest* request, SetCIPulseTimeTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIPulseTimeTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTimeTermCfg(::grpc::ServerContext* context, const SetCIPulseTimeTermCfgRequest* request, SetCIPulseTimeTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseTimeTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTimeTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTimeTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseTimeTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseTimeUnits(::grpc::ServerContext* context, const SetCIPulseTimeUnitsRequest* request, SetCIPulseTimeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseTimeUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTimeUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseTimeUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseTimeUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseWidthDigFltrEnable(::grpc::ServerContext* context, const SetCIPulseWidthDigFltrEnableRequest* request, SetCIPulseWidthDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPulseWidthDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseWidthDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIPulseWidthDigFltrMinPulseWidthRequest* request, SetCIPulseWidthDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPulseWidthDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseWidthDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIPulseWidthDigFltrTimebaseRateRequest* request, SetCIPulseWidthDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIPulseWidthDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseWidthDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIPulseWidthDigFltrTimebaseSrcRequest* request, SetCIPulseWidthDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIPulseWidthDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseWidthDigSyncEnable(::grpc::ServerContext* context, const SetCIPulseWidthDigSyncEnableRequest* request, SetCIPulseWidthDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIPulseWidthDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseWidthLogicLvlBehavior(::grpc::ServerContext* context, const SetCIPulseWidthLogicLvlBehaviorRequest* request, SetCIPulseWidthLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseWidthLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseWidthLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseWidthLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseWidthLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseWidthStartingEdge(::grpc::ServerContext* context, const SetCIPulseWidthStartingEdgeRequest* request, SetCIPulseWidthStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseWidthStartingEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseWidthStartingEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseWidthStartingEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseWidthStartingEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseWidthTerm(::grpc::ServerContext* context, const SetCIPulseWidthTermRequest* request, SetCIPulseWidthTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIPulseWidthTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseWidthTermCfg(::grpc::ServerContext* context, const SetCIPulseWidthTermCfgRequest* request, SetCIPulseWidthTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseWidthTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseWidthTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseWidthTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseWidthTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIPulseWidthUnits(::grpc::ServerContext* context, const SetCIPulseWidthUnitsRequest* request, SetCIPulseWidthUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIPulseWidthUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIPulseWidthUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIPulseWidthUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIPulseWidthUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISampClkOverrunBehavior(::grpc::ServerContext* context, const SetCISampClkOverrunBehaviorRequest* request, SetCISampClkOverrunBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCISampClkOverrunBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCISampClkOverrunBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCISampClkOverrunBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCISampClkOverrunBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISampClkOverrunSentinelVal(::grpc::ServerContext* context, const SetCISampClkOverrunSentinelValRequest* request, SetCISampClkOverrunSentinelValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data = request->data();
      auto status = library_->SetCISampClkOverrunSentinelVal(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISemiPeriodDigFltrEnable(::grpc::ServerContext* context, const SetCISemiPeriodDigFltrEnableRequest* request, SetCISemiPeriodDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCISemiPeriodDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISemiPeriodDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCISemiPeriodDigFltrMinPulseWidthRequest* request, SetCISemiPeriodDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCISemiPeriodDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISemiPeriodDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCISemiPeriodDigFltrTimebaseRateRequest* request, SetCISemiPeriodDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCISemiPeriodDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISemiPeriodDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCISemiPeriodDigFltrTimebaseSrcRequest* request, SetCISemiPeriodDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCISemiPeriodDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISemiPeriodDigSyncEnable(::grpc::ServerContext* context, const SetCISemiPeriodDigSyncEnableRequest* request, SetCISemiPeriodDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCISemiPeriodDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISemiPeriodLogicLvlBehavior(::grpc::ServerContext* context, const SetCISemiPeriodLogicLvlBehaviorRequest* request, SetCISemiPeriodLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCISemiPeriodLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCISemiPeriodLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCISemiPeriodLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCISemiPeriodLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISemiPeriodStartingEdge(::grpc::ServerContext* context, const SetCISemiPeriodStartingEdgeRequest* request, SetCISemiPeriodStartingEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCISemiPeriodStartingEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCISemiPeriodStartingEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCISemiPeriodStartingEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCISemiPeriodStartingEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISemiPeriodTerm(::grpc::ServerContext* context, const SetCISemiPeriodTermRequest* request, SetCISemiPeriodTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCISemiPeriodTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISemiPeriodTermCfg(::grpc::ServerContext* context, const SetCISemiPeriodTermCfgRequest* request, SetCISemiPeriodTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCISemiPeriodTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCISemiPeriodTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCISemiPeriodTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCISemiPeriodTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCISemiPeriodUnits(::grpc::ServerContext* context, const SetCISemiPeriodUnitsRequest* request, SetCISemiPeriodUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCISemiPeriodUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCISemiPeriodUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCISemiPeriodUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCISemiPeriodUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIThreshVoltage(::grpc::ServerContext* context, const SetCIThreshVoltageRequest* request, SetCIThreshVoltageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIThreshVoltage(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITimestampInitialSeconds(::grpc::ServerContext* context, const SetCITimestampInitialSecondsRequest* request, SetCITimestampInitialSecondsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCITimestampInitialSeconds(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITimestampUnits(::grpc::ServerContext* context, const SetCITimestampUnitsRequest* request, SetCITimestampUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCITimestampUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCITimestampUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCITimestampUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCITimestampUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepFirstDigFltrEnable(::grpc::ServerContext* context, const SetCITwoEdgeSepFirstDigFltrEnableRequest* request, SetCITwoEdgeSepFirstDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCITwoEdgeSepFirstDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepFirstDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCITwoEdgeSepFirstDigFltrMinPulseWidthRequest* request, SetCITwoEdgeSepFirstDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCITwoEdgeSepFirstDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepFirstDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCITwoEdgeSepFirstDigFltrTimebaseRateRequest* request, SetCITwoEdgeSepFirstDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCITwoEdgeSepFirstDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepFirstDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCITwoEdgeSepFirstDigFltrTimebaseSrcRequest* request, SetCITwoEdgeSepFirstDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCITwoEdgeSepFirstDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepFirstDigSyncEnable(::grpc::ServerContext* context, const SetCITwoEdgeSepFirstDigSyncEnableRequest* request, SetCITwoEdgeSepFirstDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCITwoEdgeSepFirstDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepFirstEdge(::grpc::ServerContext* context, const SetCITwoEdgeSepFirstEdgeRequest* request, SetCITwoEdgeSepFirstEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCITwoEdgeSepFirstEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepFirstEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepFirstEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCITwoEdgeSepFirstEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepFirstLogicLvlBehavior(::grpc::ServerContext* context, const SetCITwoEdgeSepFirstLogicLvlBehaviorRequest* request, SetCITwoEdgeSepFirstLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCITwoEdgeSepFirstLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepFirstLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepFirstLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCITwoEdgeSepFirstLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepFirstTerm(::grpc::ServerContext* context, const SetCITwoEdgeSepFirstTermRequest* request, SetCITwoEdgeSepFirstTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCITwoEdgeSepFirstTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepFirstTermCfg(::grpc::ServerContext* context, const SetCITwoEdgeSepFirstTermCfgRequest* request, SetCITwoEdgeSepFirstTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCITwoEdgeSepFirstTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepFirstTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepFirstTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCITwoEdgeSepFirstTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepSecondDigFltrEnable(::grpc::ServerContext* context, const SetCITwoEdgeSepSecondDigFltrEnableRequest* request, SetCITwoEdgeSepSecondDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCITwoEdgeSepSecondDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepSecondDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCITwoEdgeSepSecondDigFltrMinPulseWidthRequest* request, SetCITwoEdgeSepSecondDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCITwoEdgeSepSecondDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepSecondDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCITwoEdgeSepSecondDigFltrTimebaseRateRequest* request, SetCITwoEdgeSepSecondDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCITwoEdgeSepSecondDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepSecondDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCITwoEdgeSepSecondDigFltrTimebaseSrcRequest* request, SetCITwoEdgeSepSecondDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCITwoEdgeSepSecondDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepSecondDigSyncEnable(::grpc::ServerContext* context, const SetCITwoEdgeSepSecondDigSyncEnableRequest* request, SetCITwoEdgeSepSecondDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCITwoEdgeSepSecondDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepSecondEdge(::grpc::ServerContext* context, const SetCITwoEdgeSepSecondEdgeRequest* request, SetCITwoEdgeSepSecondEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCITwoEdgeSepSecondEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepSecondEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepSecondEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCITwoEdgeSepSecondEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepSecondLogicLvlBehavior(::grpc::ServerContext* context, const SetCITwoEdgeSepSecondLogicLvlBehaviorRequest* request, SetCITwoEdgeSepSecondLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCITwoEdgeSepSecondLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepSecondLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepSecondLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCITwoEdgeSepSecondLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepSecondTerm(::grpc::ServerContext* context, const SetCITwoEdgeSepSecondTermRequest* request, SetCITwoEdgeSepSecondTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCITwoEdgeSepSecondTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepSecondTermCfg(::grpc::ServerContext* context, const SetCITwoEdgeSepSecondTermCfgRequest* request, SetCITwoEdgeSepSecondTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCITwoEdgeSepSecondTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepSecondTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepSecondTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCITwoEdgeSepSecondTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCITwoEdgeSepUnits(::grpc::ServerContext* context, const SetCITwoEdgeSepUnitsRequest* request, SetCITwoEdgeSepUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCITwoEdgeSepUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCITwoEdgeSepUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCITwoEdgeSepUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIUsbXferReqCount(::grpc::ServerContext* context, const SetCIUsbXferReqCountRequest* request, SetCIUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCIUsbXferReqCount(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIUsbXferReqSize(::grpc::ServerContext* context, const SetCIUsbXferReqSizeRequest* request, SetCIUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCIUsbXferReqSize(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityAngEncoderPulsesPerRev(::grpc::ServerContext* context, const SetCIVelocityAngEncoderPulsesPerRevRequest* request, SetCIVelocityAngEncoderPulsesPerRevResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCIVelocityAngEncoderPulsesPerRev(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityAngEncoderUnits(::grpc::ServerContext* context, const SetCIVelocityAngEncoderUnitsRequest* request, SetCIVelocityAngEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIVelocityAngEncoderUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityAngEncoderUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityAngEncoderUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIVelocityAngEncoderUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityDiv(::grpc::ServerContext* context, const SetCIVelocityDivRequest* request, SetCIVelocityDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCIVelocityDiv(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderAInputDigFltrEnable(::grpc::ServerContext* context, const SetCIVelocityEncoderAInputDigFltrEnableRequest* request, SetCIVelocityEncoderAInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIVelocityEncoderAInputDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderAInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIVelocityEncoderAInputDigFltrMinPulseWidthRequest* request, SetCIVelocityEncoderAInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIVelocityEncoderAInputDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderAInputDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIVelocityEncoderAInputDigFltrTimebaseRateRequest* request, SetCIVelocityEncoderAInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIVelocityEncoderAInputDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderAInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIVelocityEncoderAInputDigFltrTimebaseSrcRequest* request, SetCIVelocityEncoderAInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIVelocityEncoderAInputDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderAInputLogicLvlBehavior(::grpc::ServerContext* context, const SetCIVelocityEncoderAInputLogicLvlBehaviorRequest* request, SetCIVelocityEncoderAInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIVelocityEncoderAInputLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityEncoderAInputLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityEncoderAInputLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIVelocityEncoderAInputLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderAInputTerm(::grpc::ServerContext* context, const SetCIVelocityEncoderAInputTermRequest* request, SetCIVelocityEncoderAInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIVelocityEncoderAInputTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderAInputTermCfg(::grpc::ServerContext* context, const SetCIVelocityEncoderAInputTermCfgRequest* request, SetCIVelocityEncoderAInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIVelocityEncoderAInputTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityEncoderAInputTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityEncoderAInputTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIVelocityEncoderAInputTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderBInputDigFltrEnable(::grpc::ServerContext* context, const SetCIVelocityEncoderBInputDigFltrEnableRequest* request, SetCIVelocityEncoderBInputDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCIVelocityEncoderBInputDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderBInputDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCIVelocityEncoderBInputDigFltrMinPulseWidthRequest* request, SetCIVelocityEncoderBInputDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIVelocityEncoderBInputDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderBInputDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCIVelocityEncoderBInputDigFltrTimebaseRateRequest* request, SetCIVelocityEncoderBInputDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIVelocityEncoderBInputDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderBInputDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCIVelocityEncoderBInputDigFltrTimebaseSrcRequest* request, SetCIVelocityEncoderBInputDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIVelocityEncoderBInputDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderBInputLogicLvlBehavior(::grpc::ServerContext* context, const SetCIVelocityEncoderBInputLogicLvlBehaviorRequest* request, SetCIVelocityEncoderBInputLogicLvlBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIVelocityEncoderBInputLogicLvlBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityEncoderBInputLogicLvlBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityEncoderBInputLogicLvlBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIVelocityEncoderBInputLogicLvlBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderBInputTerm(::grpc::ServerContext* context, const SetCIVelocityEncoderBInputTermRequest* request, SetCIVelocityEncoderBInputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCIVelocityEncoderBInputTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderBInputTermCfg(::grpc::ServerContext* context, const SetCIVelocityEncoderBInputTermCfgRequest* request, SetCIVelocityEncoderBInputTermCfgResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIVelocityEncoderBInputTermCfgRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityEncoderBInputTermCfgRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityEncoderBInputTermCfgRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIVelocityEncoderBInputTermCfg(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityEncoderDecodingType(::grpc::ServerContext* context, const SetCIVelocityEncoderDecodingTypeRequest* request, SetCIVelocityEncoderDecodingTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIVelocityEncoderDecodingTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityEncoderDecodingTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityEncoderDecodingTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIVelocityEncoderDecodingType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityLinEncoderDistPerPulse(::grpc::ServerContext* context, const SetCIVelocityLinEncoderDistPerPulseRequest* request, SetCIVelocityLinEncoderDistPerPulseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIVelocityLinEncoderDistPerPulse(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityLinEncoderUnits(::grpc::ServerContext* context, const SetCIVelocityLinEncoderUnitsRequest* request, SetCIVelocityLinEncoderUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCIVelocityLinEncoderUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityLinEncoderUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCIVelocityLinEncoderUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCIVelocityLinEncoderUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCIVelocityMeasTime(::grpc::ServerContext* context, const SetCIVelocityMeasTimeRequest* request, SetCIVelocityMeasTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCIVelocityMeasTime(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOAutoIncrCnt(::grpc::ServerContext* context, const SetCOAutoIncrCntRequest* request, SetCOAutoIncrCntResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCOAutoIncrCnt(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOConstrainedGenMode(::grpc::ServerContext* context, const SetCOConstrainedGenModeRequest* request, SetCOConstrainedGenModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCOConstrainedGenModeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCOConstrainedGenModeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCOConstrainedGenModeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCOConstrainedGenMode(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOCtrTimebaseActiveEdge(::grpc::ServerContext* context, const SetCOCtrTimebaseActiveEdgeRequest* request, SetCOCtrTimebaseActiveEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCOCtrTimebaseActiveEdgeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCOCtrTimebaseActiveEdgeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCOCtrTimebaseActiveEdgeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCOCtrTimebaseActiveEdge(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOCtrTimebaseDigFltrEnable(::grpc::ServerContext* context, const SetCOCtrTimebaseDigFltrEnableRequest* request, SetCOCtrTimebaseDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCOCtrTimebaseDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOCtrTimebaseDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetCOCtrTimebaseDigFltrMinPulseWidthRequest* request, SetCOCtrTimebaseDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCOCtrTimebaseDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOCtrTimebaseDigFltrTimebaseRate(::grpc::ServerContext* context, const SetCOCtrTimebaseDigFltrTimebaseRateRequest* request, SetCOCtrTimebaseDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCOCtrTimebaseDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOCtrTimebaseDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetCOCtrTimebaseDigFltrTimebaseSrcRequest* request, SetCOCtrTimebaseDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCOCtrTimebaseDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOCtrTimebaseDigSyncEnable(::grpc::ServerContext* context, const SetCOCtrTimebaseDigSyncEnableRequest* request, SetCOCtrTimebaseDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCOCtrTimebaseDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOCtrTimebaseMasterTimebaseDiv(::grpc::ServerContext* context, const SetCOCtrTimebaseMasterTimebaseDivRequest* request, SetCOCtrTimebaseMasterTimebaseDivResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCOCtrTimebaseMasterTimebaseDiv(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOCtrTimebaseRate(::grpc::ServerContext* context, const SetCOCtrTimebaseRateRequest* request, SetCOCtrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCOCtrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOCtrTimebaseSrc(::grpc::ServerContext* context, const SetCOCtrTimebaseSrcRequest* request, SetCOCtrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCOCtrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCODataXferMech(::grpc::ServerContext* context, const SetCODataXferMechRequest* request, SetCODataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCODataXferMechRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCODataXferMechRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCODataXferMechRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCODataXferMech(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCODataXferReqCond(::grpc::ServerContext* context, const SetCODataXferReqCondRequest* request, SetCODataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCODataXferReqCondRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCODataXferReqCondRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCODataXferReqCondRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCODataXferReqCond(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOEnableInitialDelayOnRetrigger(::grpc::ServerContext* context, const SetCOEnableInitialDelayOnRetriggerRequest* request, SetCOEnableInitialDelayOnRetriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCOEnableInitialDelayOnRetrigger(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOMemMapEnable(::grpc::ServerContext* context, const SetCOMemMapEnableRequest* request, SetCOMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCOMemMapEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPrescaler(::grpc::ServerContext* context, const SetCOPrescalerRequest* request, SetCOPrescalerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCOPrescaler(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseDutyCyc(::grpc::ServerContext* context, const SetCOPulseDutyCycRequest* request, SetCOPulseDutyCycResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCOPulseDutyCyc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseFreq(::grpc::ServerContext* context, const SetCOPulseFreqRequest* request, SetCOPulseFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCOPulseFreq(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseFreqInitialDelay(::grpc::ServerContext* context, const SetCOPulseFreqInitialDelayRequest* request, SetCOPulseFreqInitialDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCOPulseFreqInitialDelay(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseFreqUnits(::grpc::ServerContext* context, const SetCOPulseFreqUnitsRequest* request, SetCOPulseFreqUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCOPulseFreqUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCOPulseFreqUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCOPulseFreqUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCOPulseFreqUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseHighTicks(::grpc::ServerContext* context, const SetCOPulseHighTicksRequest* request, SetCOPulseHighTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCOPulseHighTicks(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseHighTime(::grpc::ServerContext* context, const SetCOPulseHighTimeRequest* request, SetCOPulseHighTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCOPulseHighTime(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseIdleState(::grpc::ServerContext* context, const SetCOPulseIdleStateRequest* request, SetCOPulseIdleStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCOPulseIdleStateRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCOPulseIdleStateRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCOPulseIdleStateRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCOPulseIdleState(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseLowTicks(::grpc::ServerContext* context, const SetCOPulseLowTicksRequest* request, SetCOPulseLowTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCOPulseLowTicks(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseLowTime(::grpc::ServerContext* context, const SetCOPulseLowTimeRequest* request, SetCOPulseLowTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCOPulseLowTime(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseTerm(::grpc::ServerContext* context, const SetCOPulseTermRequest* request, SetCOPulseTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCOPulseTerm(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseTicksInitialDelay(::grpc::ServerContext* context, const SetCOPulseTicksInitialDelayRequest* request, SetCOPulseTicksInitialDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCOPulseTicksInitialDelay(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseTimeInitialDelay(::grpc::ServerContext* context, const SetCOPulseTimeInitialDelayRequest* request, SetCOPulseTimeInitialDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetCOPulseTimeInitialDelay(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOPulseTimeUnits(::grpc::ServerContext* context, const SetCOPulseTimeUnitsRequest* request, SetCOPulseTimeUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetCOPulseTimeUnitsRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetCOPulseTimeUnitsRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetCOPulseTimeUnitsRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetCOPulseTimeUnits(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOUsbXferReqCount(::grpc::ServerContext* context, const SetCOUsbXferReqCountRequest* request, SetCOUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCOUsbXferReqCount(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOUsbXferReqSize(::grpc::ServerContext* context, const SetCOUsbXferReqSizeRequest* request, SetCOUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCOUsbXferReqSize(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCOUseOnlyOnBrdMem(::grpc::ServerContext* context, const SetCOUseOnlyOnBrdMemRequest* request, SetCOUseOnlyOnBrdMemResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetCOUseOnlyOnBrdMem(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCalAccConnectionCount(::grpc::ServerContext* context, const SetCalAccConnectionCountRequest* request, SetCalAccConnectionCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      uInt32 data = request->data();
      auto status = library_->SetCalAccConnectionCount(device_name, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCalUserDefinedInfo(::grpc::ServerContext* context, const SetCalUserDefinedInfoRequest* request, SetCalUserDefinedInfoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetCalUserDefinedInfo(device_name, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanDescr(::grpc::ServerContext* context, const SetChanDescrRequest* request, SetChanDescrResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetChanDescr(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanSyncUnlockBehavior(::grpc::ServerContext* context, const SetChanSyncUnlockBehaviorRequest* request, SetChanSyncUnlockBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetChanSyncUnlockBehaviorRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetChanSyncUnlockBehaviorRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetChanSyncUnlockBehaviorRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetChanSyncUnlockBehavior(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIAcquireOn(::grpc::ServerContext* context, const SetDIAcquireOnRequest* request, SetDIAcquireOnResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDIAcquireOnRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDIAcquireOnRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDIAcquireOnRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDIAcquireOn(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIDataXferMech(::grpc::ServerContext* context, const SetDIDataXferMechRequest* request, SetDIDataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDIDataXferMechRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDIDataXferMechRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDIDataXferMechRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDIDataXferMech(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIDataXferReqCond(::grpc::ServerContext* context, const SetDIDataXferReqCondRequest* request, SetDIDataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDIDataXferReqCondRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDIDataXferReqCondRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDIDataXferReqCondRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDIDataXferReqCond(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIDigFltrEnable(::grpc::ServerContext* context, const SetDIDigFltrEnableRequest* request, SetDIDigFltrEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDIDigFltrEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIDigFltrEnableBusMode(::grpc::ServerContext* context, const SetDIDigFltrEnableBusModeRequest* request, SetDIDigFltrEnableBusModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDIDigFltrEnableBusMode(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIDigFltrMinPulseWidth(::grpc::ServerContext* context, const SetDIDigFltrMinPulseWidthRequest* request, SetDIDigFltrMinPulseWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetDIDigFltrMinPulseWidth(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIDigFltrTimebaseRate(::grpc::ServerContext* context, const SetDIDigFltrTimebaseRateRequest* request, SetDIDigFltrTimebaseRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetDIDigFltrTimebaseRate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIDigFltrTimebaseSrc(::grpc::ServerContext* context, const SetDIDigFltrTimebaseSrcRequest* request, SetDIDigFltrTimebaseSrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetDIDigFltrTimebaseSrc(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIDigSyncEnable(::grpc::ServerContext* context, const SetDIDigSyncEnableRequest* request, SetDIDigSyncEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDIDigSyncEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIInvertLines(::grpc::ServerContext* context, const SetDIInvertLinesRequest* request, SetDIInvertLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDIInvertLines(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDILogicFamily(::grpc::ServerContext* context, const SetDILogicFamilyRequest* request, SetDILogicFamilyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDILogicFamilyRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDILogicFamilyRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDILogicFamilyRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDILogicFamily(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIMemMapEnable(::grpc::ServerContext* context, const SetDIMemMapEnableRequest* request, SetDIMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDIMemMapEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDITristate(::grpc::ServerContext* context, const SetDITristateRequest* request, SetDITristateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDITristate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIUsbXferReqCount(::grpc::ServerContext* context, const SetDIUsbXferReqCountRequest* request, SetDIUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetDIUsbXferReqCount(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDIUsbXferReqSize(::grpc::ServerContext* context, const SetDIUsbXferReqSizeRequest* request, SetDIUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetDIUsbXferReqSize(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDODataXferMech(::grpc::ServerContext* context, const SetDODataXferMechRequest* request, SetDODataXferMechResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDODataXferMechRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDODataXferMechRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDODataXferMechRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDODataXferMech(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDODataXferReqCond(::grpc::ServerContext* context, const SetDODataXferReqCondRequest* request, SetDODataXferReqCondResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDODataXferReqCondRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDODataXferReqCondRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDODataXferReqCondRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDODataXferReqCond(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOGenerateOn(::grpc::ServerContext* context, const SetDOGenerateOnRequest* request, SetDOGenerateOnResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDOGenerateOnRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDOGenerateOnRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDOGenerateOnRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDOGenerateOn(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOInvertLines(::grpc::ServerContext* context, const SetDOInvertLinesRequest* request, SetDOInvertLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDOInvertLines(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOLineStatesDoneState(::grpc::ServerContext* context, const SetDOLineStatesDoneStateRequest* request, SetDOLineStatesDoneStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDOLineStatesDoneStateRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDOLineStatesDoneStateRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDOLineStatesDoneStateRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDOLineStatesDoneState(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOLineStatesPausedState(::grpc::ServerContext* context, const SetDOLineStatesPausedStateRequest* request, SetDOLineStatesPausedStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDOLineStatesPausedStateRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDOLineStatesPausedStateRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDOLineStatesPausedStateRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDOLineStatesPausedState(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOLineStatesStartState(::grpc::ServerContext* context, const SetDOLineStatesStartStateRequest* request, SetDOLineStatesStartStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDOLineStatesStartStateRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDOLineStatesStartStateRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDOLineStatesStartStateRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDOLineStatesStartState(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOLogicFamily(::grpc::ServerContext* context, const SetDOLogicFamilyRequest* request, SetDOLogicFamilyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDOLogicFamilyRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDOLogicFamilyRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDOLogicFamilyRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDOLogicFamily(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOMemMapEnable(::grpc::ServerContext* context, const SetDOMemMapEnableRequest* request, SetDOMemMapEnableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDOMemMapEnable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOOutputDriveType(::grpc::ServerContext* context, const SetDOOutputDriveTypeRequest* request, SetDOOutputDriveTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 data;
      switch (request->data_enum_case()) {
        case nidaqmx_grpc::SetDOOutputDriveTypeRequest::DataEnumCase::kData: {
          data = static_cast<int32>(request->data());
          break;
        }
        case nidaqmx_grpc::SetDOOutputDriveTypeRequest::DataEnumCase::kDataRaw: {
          data = static_cast<int32>(request->data_raw());
          break;
        }
        case nidaqmx_grpc::SetDOOutputDriveTypeRequest::DataEnumCase::DATA_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDOOutputDriveType(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOOvercurrentAutoReenable(::grpc::ServerContext* context, const SetDOOvercurrentAutoReenableRequest* request, SetDOOvercurrentAutoReenableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDOOvercurrentAutoReenable(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOOvercurrentLimit(::grpc::ServerContext* context, const SetDOOvercurrentLimitRequest* request, SetDOOvercurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetDOOvercurrentLimit(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOOvercurrentReenablePeriod(::grpc::ServerContext* context, const SetDOOvercurrentReenablePeriodRequest* request, SetDOOvercurrentReenablePeriodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      float64 data = request->data();
      auto status = library_->SetDOOvercurrentReenablePeriod(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOTristate(::grpc::ServerContext* context, const SetDOTristateRequest* request, SetDOTristateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDOTristate(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOUsbXferReqCount(::grpc::ServerContext* context, const SetDOUsbXferReqCountRequest* request, SetDOUsbXferReqCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetDOUsbXferReqCount(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOUsbXferReqSize(::grpc::ServerContext* context, const SetDOUsbXferReqSizeRequest* request, SetDOUsbXferReqSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      uInt32 data = request->data();
      auto status = library_->SetDOUsbXferReqSize(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDOUseOnlyOnBrdMem(::grpc::ServerContext* context, const SetDOUseOnlyOnBrdMemRequest* request, SetDOUseOnlyOnBrdMemResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      bool32 data = request->data();
      auto status = library_->SetDOUseOnlyOnBrdMem(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDigitalLogicFamilyPowerUpState(::grpc::ServerContext* context, const SetDigitalLogicFamilyPowerUpStateRequest* request, SetDigitalLogicFamilyPowerUpStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 logic_family;
      switch (request->logic_family_enum_case()) {
        case nidaqmx_grpc::SetDigitalLogicFamilyPowerUpStateRequest::LogicFamilyEnumCase::kLogicFamily: {
          logic_family = static_cast<int32>(request->logic_family());
          break;
        }
        case nidaqmx_grpc::SetDigitalLogicFamilyPowerUpStateRequest::LogicFamilyEnumCase::kLogicFamilyRaw: {
          logic_family = static_cast<int32>(request->logic_family_raw());
          break;
        }
        case nidaqmx_grpc::SetDigitalLogicFamilyPowerUpStateRequest::LogicFamilyEnumCase::LOGIC_FAMILY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for logic_family was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDigitalLogicFamilyPowerUpState(device_name, logic_family);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetFirstSampClkWhen(::grpc::ServerContext* context, const SetFirstSampClkWhenRequest* request, SetFirstSampClkWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetFirstSampClkWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetPhysicalChanName(::grpc::ServerContext* context, const SetPhysicalChanNameRequest* request, SetPhysicalChanNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      auto data = request->data().c_str();
      auto status = library_->SetPhysicalChanName(task, channel, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetStartTrigTrigWhen(::grpc::ServerContext* context, const SetStartTrigTrigWhenRequest* request, SetStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetStartTrigTrigWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetSyncPulseTimeWhen(::grpc::ServerContext* context, const SetSyncPulseTimeWhenRequest* request, SetSyncPulseTimeWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetSyncPulseTimeWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StartNewFile(::grpc::ServerContext* context, const StartNewFileRequest* request, StartNewFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->StartNewFile(task, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StartTask(::grpc::ServerContext* context, const StartTaskRequest* request, StartTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->StartTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StopTask(::grpc::ServerContext* context, const StopTaskRequest* request, StopTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->StopTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::TaskControl(::grpc::ServerContext* context, const TaskControlRequest* request, TaskControlResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 action;
      switch (request->action_enum_case()) {
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::kAction: {
          action = static_cast<int32>(request->action());
          break;
        }
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::kActionRaw: {
          action = static_cast<int32>(request->action_raw());
          break;
        }
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::ACTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for action was not specified or out of range");
          break;
        }
      }

      auto status = library_->TaskControl(task, action);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::TristateOutputTerm(::grpc::ServerContext* context, const TristateOutputTermRequest* request, TristateOutputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto output_terminal = request->output_terminal().c_str();
      auto status = library_->TristateOutputTerm(output_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::UnreserveNetworkDevice(::grpc::ServerContext* context, const UnreserveNetworkDeviceRequest* request, UnreserveNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->UnreserveNetworkDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WaitForNextSampleClock(::grpc::ServerContext* context, const WaitForNextSampleClockRequest* request, WaitForNextSampleClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      bool32 is_late {};
      auto status = library_->WaitForNextSampleClock(task, timeout, &is_late);
      response->set_status(status);
      if (status == 0) {
        response->set_is_late(is_late);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WaitForValidTimestamp(::grpc::ServerContext* context, const WaitForValidTimestampRequest* request, WaitForValidTimestampResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 timestamp_event;
      switch (request->timestamp_event_enum_case()) {
        case nidaqmx_grpc::WaitForValidTimestampRequest::TimestampEventEnumCase::kTimestampEvent: {
          timestamp_event = static_cast<int32>(request->timestamp_event());
          break;
        }
        case nidaqmx_grpc::WaitForValidTimestampRequest::TimestampEventEnumCase::kTimestampEventRaw: {
          timestamp_event = static_cast<int32>(request->timestamp_event_raw());
          break;
        }
        case nidaqmx_grpc::WaitForValidTimestampRequest::TimestampEventEnumCase::TIMESTAMP_EVENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timestamp_event was not specified or out of range");
          break;
        }
      }

      float64 timeout = request->timeout();
      CVIAbsoluteTime timestamp {};
      auto status = library_->WaitForValidTimestamp(task, timestamp_event, timeout, &timestamp);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(timestamp, response->mutable_timestamp());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WaitUntilTaskDone(::grpc::ServerContext* context, const WaitUntilTaskDoneRequest* request, WaitUntilTaskDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 time_to_wait = request->time_to_wait();
      auto status = library_->WaitUntilTaskDone(task, time_to_wait);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteAnalogF64(::grpc::ServerContext* context, const WriteAnalogF64Request* request, WriteAnalogF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = const_cast<const float64*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteAnalogF64(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteAnalogScalarF64(::grpc::ServerContext* context, const WriteAnalogScalarF64Request* request, WriteAnalogScalarF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      float64 value = request->value();
      auto reserved = nullptr;
      auto status = library_->WriteAnalogScalarF64(task, auto_start, timeout, value, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryI16(::grpc::ServerContext* context, const WriteBinaryI16Request* request, WriteBinaryI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryI16Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI16Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI16Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array_raw = request->write_array();
      auto write_array = std::vector<int16>();
      write_array.reserve(write_array_raw.size());
      std::transform(
        write_array_raw.begin(),
        write_array_raw.end(),
        std::back_inserter(write_array),
        [](auto x) { 
              if (x < std::numeric_limits<int16>::min() || x > std::numeric_limits<int16>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("int16");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<int16>(x);
        });

      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryI16(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array.data(), &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryI32(::grpc::ServerContext* context, const WriteBinaryI32Request* request, WriteBinaryI32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryI32Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI32Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI32Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->write_array().data()));
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryI32(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryU16(::grpc::ServerContext* context, const WriteBinaryU16Request* request, WriteBinaryU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryU16Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU16Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU16Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array_raw = request->write_array();
      auto write_array = std::vector<uInt16>();
      write_array.reserve(write_array_raw.size());
      std::transform(
        write_array_raw.begin(),
        write_array_raw.end(),
        std::back_inserter(write_array),
        [](auto x) { 
              if (x < std::numeric_limits<uInt16>::min() || x > std::numeric_limits<uInt16>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("uInt16");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<uInt16>(x);
        });

      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryU16(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array.data(), &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryU32(::grpc::ServerContext* context, const WriteBinaryU32Request* request, WriteBinaryU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryU32Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU32Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU32Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = reinterpret_cast<const uInt32*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryU32(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrFreq(::grpc::ServerContext* context, const WriteCtrFreqRequest* request, WriteCtrFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteCtrFreqRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteCtrFreqRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteCtrFreqRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto frequency = const_cast<const float64*>(request->frequency().data());
      auto duty_cycle = const_cast<const float64*>(request->duty_cycle().data());
      auto reserved = nullptr;
      int32 num_samps_per_chan_written {};
      auto status = library_->WriteCtrFreq(task, num_samps_per_chan, auto_start, timeout, data_layout, frequency, duty_cycle, &num_samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_num_samps_per_chan_written(num_samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrFreqScalar(::grpc::ServerContext* context, const WriteCtrFreqScalarRequest* request, WriteCtrFreqScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      float64 frequency = request->frequency();
      float64 duty_cycle = request->duty_cycle();
      auto reserved = nullptr;
      auto status = library_->WriteCtrFreqScalar(task, auto_start, timeout, frequency, duty_cycle, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTicks(::grpc::ServerContext* context, const WriteCtrTicksRequest* request, WriteCtrTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteCtrTicksRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteCtrTicksRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteCtrTicksRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto high_ticks = reinterpret_cast<const uInt32*>(request->high_ticks().data());
      auto low_ticks = reinterpret_cast<const uInt32*>(request->low_ticks().data());
      auto reserved = nullptr;
      int32 num_samps_per_chan_written {};
      auto status = library_->WriteCtrTicks(task, num_samps_per_chan, auto_start, timeout, data_layout, high_ticks, low_ticks, &num_samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_num_samps_per_chan_written(num_samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTicksScalar(::grpc::ServerContext* context, const WriteCtrTicksScalarRequest* request, WriteCtrTicksScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      uInt32 high_ticks = request->high_ticks();
      uInt32 low_ticks = request->low_ticks();
      auto reserved = nullptr;
      auto status = library_->WriteCtrTicksScalar(task, auto_start, timeout, high_ticks, low_ticks, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTime(::grpc::ServerContext* context, const WriteCtrTimeRequest* request, WriteCtrTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteCtrTimeRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteCtrTimeRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteCtrTimeRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto high_time = const_cast<const float64*>(request->high_time().data());
      auto low_time = const_cast<const float64*>(request->low_time().data());
      auto reserved = nullptr;
      int32 num_samps_per_chan_written {};
      auto status = library_->WriteCtrTime(task, num_samps_per_chan, auto_start, timeout, data_layout, high_time, low_time, &num_samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_num_samps_per_chan_written(num_samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTimeScalar(::grpc::ServerContext* context, const WriteCtrTimeScalarRequest* request, WriteCtrTimeScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      float64 high_time = request->high_time();
      float64 low_time = request->low_time();
      auto reserved = nullptr;
      auto status = library_->WriteCtrTimeScalar(task, auto_start, timeout, high_time, low_time, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalLines(::grpc::ServerContext* context, const WriteDigitalLinesRequest* request, WriteDigitalLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalLinesRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalLinesRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalLinesRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      const uInt8* write_array = (const uInt8*)request->write_array().c_str();
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalLines(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalScalarU32(::grpc::ServerContext* context, const WriteDigitalScalarU32Request* request, WriteDigitalScalarU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      uInt32 value = request->value();
      auto reserved = nullptr;
      auto status = library_->WriteDigitalScalarU32(task, auto_start, timeout, value, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU16(::grpc::ServerContext* context, const WriteDigitalU16Request* request, WriteDigitalU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array_raw = request->write_array();
      auto write_array = std::vector<uInt16>();
      write_array.reserve(write_array_raw.size());
      std::transform(
        write_array_raw.begin(),
        write_array_raw.end(),
        std::back_inserter(write_array),
        [](auto x) { 
              if (x < std::numeric_limits<uInt16>::min() || x > std::numeric_limits<uInt16>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("uInt16");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<uInt16>(x);
        });

      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU16(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array.data(), &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU32(::grpc::ServerContext* context, const WriteDigitalU32Request* request, WriteDigitalU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU32Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU32Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU32Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = reinterpret_cast<const uInt32*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU32(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU8(::grpc::ServerContext* context, const WriteDigitalU8Request* request, WriteDigitalU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      const uInt8* write_array = (const uInt8*)request->write_array().c_str();
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU8(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteRaw(::grpc::ServerContext* context, const WriteRawRequest* request, WriteRawResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps = request->num_samps();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      const uInt8* write_array = (const uInt8*)request->write_array().c_str();
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteRaw(task, num_samps, auto_start, timeout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteToTEDSFromArray(::grpc::ServerContext* context, const WriteToTEDSFromArrayRequest* request, WriteToTEDSFromArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      const uInt8* bit_stream = (const uInt8*)request->bit_stream().c_str();
      uInt32 array_size = request->array_size();
      int32 basic_teds_options;
      switch (request->basic_teds_options_enum_case()) {
        case nidaqmx_grpc::WriteToTEDSFromArrayRequest::BasicTedsOptionsEnumCase::kBasicTedsOptions: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromArrayRequest::BasicTedsOptionsEnumCase::kBasicTedsOptionsRaw: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options_raw());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromArrayRequest::BasicTedsOptionsEnumCase::BASIC_TEDS_OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for basic_teds_options was not specified or out of range");
          break;
        }
      }

      auto status = library_->WriteToTEDSFromArray(physical_channel, bit_stream, array_size, basic_teds_options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteToTEDSFromFile(::grpc::ServerContext* context, const WriteToTEDSFromFileRequest* request, WriteToTEDSFromFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      auto file_path = request->file_path().c_str();
      int32 basic_teds_options;
      switch (request->basic_teds_options_enum_case()) {
        case nidaqmx_grpc::WriteToTEDSFromFileRequest::BasicTedsOptionsEnumCase::kBasicTedsOptions: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromFileRequest::BasicTedsOptionsEnumCase::kBasicTedsOptionsRaw: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options_raw());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromFileRequest::BasicTedsOptionsEnumCase::BASIC_TEDS_OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for basic_teds_options was not specified or out of range");
          break;
        }
      }

      auto status = library_->WriteToTEDSFromFile(physical_channel, file_path, basic_teds_options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

} // namespace nidaqmx_grpc

