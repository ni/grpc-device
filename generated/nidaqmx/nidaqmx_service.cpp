
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-DAQMX Metadata
//---------------------------------------------------------------------
#include "nidaqmx_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/nidaqmx_conversions.h"
#include <server/callback_router.h>
#include <server/server_reactor.h>
#include "nidaqmx_library.h"

namespace nidaqmx_grpc {

  NiDAQmxService::NiDAQmxService(NiDAQmxLibraryInterface* library, ResourceRepositorySharedPtr session_repository)
      : library_(library), session_repository_(session_repository)
  {
  }

  NiDAQmxService::~NiDAQmxService()
  {
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AddCDAQSyncConnection(::grpc::ServerContext* context, const AddCDAQSyncConnectionRequest* request, AddCDAQSyncConnectionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto port_list = request->port_list().c_str();
      auto status = library_->AddCDAQSyncConnection(port_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AddGlobalChansToTask(::grpc::ServerContext* context, const AddGlobalChansToTaskRequest* request, AddGlobalChansToTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto status = library_->AddGlobalChansToTask(task, channel_names);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AddNetworkDevice(::grpc::ServerContext* context, const AddNetworkDeviceRequest* request, AddNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto ip_address = request->ip_address().c_str();
      auto device_name = request->device_name().c_str();
      bool32 attempt_reservation = request->attempt_reservation();
      float64 timeout = request->timeout();
      uInt32 device_name_out_buffer_size = request->device_name_out_buffer_size();
      std::string device_name_out;
      if (device_name_out_buffer_size > 0) {
          device_name_out.resize(device_name_out_buffer_size-1);
      }
      auto status = library_->AddNetworkDevice(ip_address, device_name, attempt_reservation, timeout, (char*)device_name_out.data(), device_name_out_buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_device_name_out(device_name_out);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AreConfiguredCDAQSyncPortsDisconnected(::grpc::ServerContext* context, const AreConfiguredCDAQSyncPortsDisconnectedRequest* request, AreConfiguredCDAQSyncPortsDisconnectedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto chassis_devices_ports = request->chassis_devices_ports().c_str();
      float64 timeout = request->timeout();
      bool32 disconnected_ports_exist {};
      auto status = library_->AreConfiguredCDAQSyncPortsDisconnected(chassis_devices_ports, timeout, &disconnected_ports_exist);
      response->set_status(status);
      if (status == 0) {
        response->set_disconnected_ports_exist(disconnected_ports_exist);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AutoConfigureCDAQSyncConnections(::grpc::ServerContext* context, const AutoConfigureCDAQSyncConnectionsRequest* request, AutoConfigureCDAQSyncConnectionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto chassis_devices_ports = request->chassis_devices_ports().c_str();
      float64 timeout = request->timeout();
      auto status = library_->AutoConfigureCDAQSyncConnections(chassis_devices_ports, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CalculateReversePolyCoeff(::grpc::ServerContext* context, const CalculateReversePolyCoeffRequest* request, CalculateReversePolyCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs_in = request->num_forward_coeffs_in();
      float64 min_val_x = request->min_val_x();
      float64 max_val_x = request->max_val_x();
      int32 num_points_to_compute = request->num_points_to_compute();
      int32 reverse_poly_order = request->reverse_poly_order();
      response->mutable_reverse_coeffs()->Resize((reverse_poly_order < 0) ? num_forward_coeffs_in : reverse_poly_order + 1, 0);
      float64* reverse_coeffs = response->mutable_reverse_coeffs()->mutable_data();
      auto status = library_->CalculateReversePolyCoeff(forward_coeffs, num_forward_coeffs_in, min_val_x, max_val_x, num_points_to_compute, reverse_poly_order, reverse_coeffs);
      response->set_status(status);
      if (status == 0) {
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgEdgeRefTrig(::grpc::ServerContext* context, const CfgAnlgEdgeRefTrigRequest* request, CfgAnlgEdgeRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_slope;
      switch (request->trigger_slope_enum_case()) {
        case nidaqmx_grpc::CfgAnlgEdgeRefTrigRequest::TriggerSlopeEnumCase::kTriggerSlope: {
          trigger_slope = static_cast<int32>(request->trigger_slope());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeRefTrigRequest::TriggerSlopeEnumCase::kTriggerSlopeRaw: {
          trigger_slope = static_cast<int32>(request->trigger_slope_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeRefTrigRequest::TriggerSlopeEnumCase::TRIGGER_SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_slope was not specified or out of range");
          break;
        }
      }

      float64 trigger_level = request->trigger_level();
      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgAnlgEdgeRefTrig(task, trigger_source, trigger_slope, trigger_level, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgEdgeStartTrig(::grpc::ServerContext* context, const CfgAnlgEdgeStartTrigRequest* request, CfgAnlgEdgeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_slope;
      switch (request->trigger_slope_enum_case()) {
        case nidaqmx_grpc::CfgAnlgEdgeStartTrigRequest::TriggerSlopeEnumCase::kTriggerSlope: {
          trigger_slope = static_cast<int32>(request->trigger_slope());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeStartTrigRequest::TriggerSlopeEnumCase::kTriggerSlopeRaw: {
          trigger_slope = static_cast<int32>(request->trigger_slope_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeStartTrigRequest::TriggerSlopeEnumCase::TRIGGER_SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_slope was not specified or out of range");
          break;
        }
      }

      float64 trigger_level = request->trigger_level();
      auto status = library_->CfgAnlgEdgeStartTrig(task, trigger_source, trigger_slope, trigger_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgMultiEdgeRefTrig(::grpc::ServerContext* context, const CfgAnlgMultiEdgeRefTrigRequest* request, CfgAnlgMultiEdgeRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_sources = request->trigger_sources().c_str();
      auto trigger_slope_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->trigger_slope_array().data()));
      auto trigger_level_array = const_cast<const float64*>(request->trigger_level_array().data());
      uInt32 pretrigger_samples = request->pretrigger_samples();
      uInt32 array_size = request->array_size();
      auto status = library_->CfgAnlgMultiEdgeRefTrig(task, trigger_sources, trigger_slope_array, trigger_level_array, pretrigger_samples, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgMultiEdgeStartTrig(::grpc::ServerContext* context, const CfgAnlgMultiEdgeStartTrigRequest* request, CfgAnlgMultiEdgeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_sources = request->trigger_sources().c_str();
      auto trigger_slope_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->trigger_slope_array().data()));
      auto trigger_level_array = const_cast<const float64*>(request->trigger_level_array().data());
      uInt32 array_size = request->array_size();
      auto status = library_->CfgAnlgMultiEdgeStartTrig(task, trigger_sources, trigger_slope_array, trigger_level_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgWindowRefTrig(::grpc::ServerContext* context, const CfgAnlgWindowRefTrigRequest* request, CfgAnlgWindowRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgAnlgWindowRefTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowRefTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowRefTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      float64 window_top = request->window_top();
      float64 window_bottom = request->window_bottom();
      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgAnlgWindowRefTrig(task, trigger_source, trigger_when, window_top, window_bottom, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgWindowStartTrig(::grpc::ServerContext* context, const CfgAnlgWindowStartTrigRequest* request, CfgAnlgWindowStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgAnlgWindowStartTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowStartTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowStartTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      float64 window_top = request->window_top();
      float64 window_bottom = request->window_bottom();
      auto status = library_->CfgAnlgWindowStartTrig(task, trigger_source, trigger_when, window_top, window_bottom);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgBurstHandshakingTimingExportClock(::grpc::ServerContext* context, const CfgBurstHandshakingTimingExportClockRequest* request, CfgBurstHandshakingTimingExportClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      float64 sample_clk_rate = request->sample_clk_rate();
      auto sample_clk_outp_term = request->sample_clk_outp_term().c_str();
      int32 sample_clk_pulse_polarity;
      switch (request->sample_clk_pulse_polarity_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleClkPulsePolarityEnumCase::kSampleClkPulsePolarity: {
          sample_clk_pulse_polarity = static_cast<int32>(request->sample_clk_pulse_polarity());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleClkPulsePolarityEnumCase::kSampleClkPulsePolarityRaw: {
          sample_clk_pulse_polarity = static_cast<int32>(request->sample_clk_pulse_polarity_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleClkPulsePolarityEnumCase::SAMPLE_CLK_PULSE_POLARITY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_clk_pulse_polarity was not specified or out of range");
          break;
        }
      }

      int32 pause_when;
      switch (request->pause_when_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::PauseWhenEnumCase::kPauseWhen: {
          pause_when = static_cast<int32>(request->pause_when());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::PauseWhenEnumCase::kPauseWhenRaw: {
          pause_when = static_cast<int32>(request->pause_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::PauseWhenEnumCase::PAUSE_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pause_when was not specified or out of range");
          break;
        }
      }

      int32 ready_event_active_level;
      switch (request->ready_event_active_level_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevel: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevelRaw: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::ReadyEventActiveLevelEnumCase::READY_EVENT_ACTIVE_LEVEL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ready_event_active_level was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgBurstHandshakingTimingExportClock(task, sample_mode, samps_per_chan, sample_clk_rate, sample_clk_outp_term, sample_clk_pulse_polarity, pause_when, ready_event_active_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgBurstHandshakingTimingImportClock(::grpc::ServerContext* context, const CfgBurstHandshakingTimingImportClockRequest* request, CfgBurstHandshakingTimingImportClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      float64 sample_clk_rate = request->sample_clk_rate();
      auto sample_clk_src = request->sample_clk_src().c_str();
      int32 sample_clk_active_edge;
      switch (request->sample_clk_active_edge_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleClkActiveEdgeEnumCase::kSampleClkActiveEdge: {
          sample_clk_active_edge = static_cast<int32>(request->sample_clk_active_edge());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleClkActiveEdgeEnumCase::kSampleClkActiveEdgeRaw: {
          sample_clk_active_edge = static_cast<int32>(request->sample_clk_active_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleClkActiveEdgeEnumCase::SAMPLE_CLK_ACTIVE_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_clk_active_edge was not specified or out of range");
          break;
        }
      }

      int32 pause_when;
      switch (request->pause_when_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::PauseWhenEnumCase::kPauseWhen: {
          pause_when = static_cast<int32>(request->pause_when());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::PauseWhenEnumCase::kPauseWhenRaw: {
          pause_when = static_cast<int32>(request->pause_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::PauseWhenEnumCase::PAUSE_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pause_when was not specified or out of range");
          break;
        }
      }

      int32 ready_event_active_level;
      switch (request->ready_event_active_level_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevel: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevelRaw: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::ReadyEventActiveLevelEnumCase::READY_EVENT_ACTIVE_LEVEL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ready_event_active_level was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgBurstHandshakingTimingImportClock(task, sample_mode, samps_per_chan, sample_clk_rate, sample_clk_src, sample_clk_active_edge, pause_when, ready_event_active_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgChangeDetectionTiming(::grpc::ServerContext* context, const CfgChangeDetectionTimingRequest* request, CfgChangeDetectionTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto rising_edge_chan = request->rising_edge_chan().c_str();
      auto falling_edge_chan = request->falling_edge_chan().c_str();
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgChangeDetectionTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgChangeDetectionTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgChangeDetectionTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgChangeDetectionTiming(task, rising_edge_chan, falling_edge_chan, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigEdgeRefTrig(::grpc::ServerContext* context, const CfgDigEdgeRefTrigRequest* request, CfgDigEdgeRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_edge;
      switch (request->trigger_edge_enum_case()) {
        case nidaqmx_grpc::CfgDigEdgeRefTrigRequest::TriggerEdgeEnumCase::kTriggerEdge: {
          trigger_edge = static_cast<int32>(request->trigger_edge());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeRefTrigRequest::TriggerEdgeEnumCase::kTriggerEdgeRaw: {
          trigger_edge = static_cast<int32>(request->trigger_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeRefTrigRequest::TriggerEdgeEnumCase::TRIGGER_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_edge was not specified or out of range");
          break;
        }
      }

      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgDigEdgeRefTrig(task, trigger_source, trigger_edge, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigEdgeStartTrig(::grpc::ServerContext* context, const CfgDigEdgeStartTrigRequest* request, CfgDigEdgeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_edge;
      switch (request->trigger_edge_enum_case()) {
        case nidaqmx_grpc::CfgDigEdgeStartTrigRequest::TriggerEdgeEnumCase::kTriggerEdge: {
          trigger_edge = static_cast<int32>(request->trigger_edge());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeStartTrigRequest::TriggerEdgeEnumCase::kTriggerEdgeRaw: {
          trigger_edge = static_cast<int32>(request->trigger_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeStartTrigRequest::TriggerEdgeEnumCase::TRIGGER_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgDigEdgeStartTrig(task, trigger_source, trigger_edge);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigPatternRefTrig(::grpc::ServerContext* context, const CfgDigPatternRefTrigRequest* request, CfgDigPatternRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      auto trigger_pattern = request->trigger_pattern().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgDigPatternRefTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternRefTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternRefTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgDigPatternRefTrig(task, trigger_source, trigger_pattern, trigger_when, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigPatternStartTrig(::grpc::ServerContext* context, const CfgDigPatternStartTrigRequest* request, CfgDigPatternStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      auto trigger_pattern = request->trigger_pattern().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgDigPatternStartTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternStartTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternStartTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgDigPatternStartTrig(task, trigger_source, trigger_pattern, trigger_when);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgHandshakingTiming(::grpc::ServerContext* context, const CfgHandshakingTimingRequest* request, CfgHandshakingTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgHandshakingTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgHandshakingTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgHandshakingTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgHandshakingTiming(task, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgImplicitTiming(::grpc::ServerContext* context, const CfgImplicitTimingRequest* request, CfgImplicitTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgImplicitTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgImplicitTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgImplicitTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgImplicitTiming(task, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgInputBuffer(::grpc::ServerContext* context, const CfgInputBufferRequest* request, CfgInputBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 num_samps_per_chan = request->num_samps_per_chan();
      auto status = library_->CfgInputBuffer(task, num_samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgOutputBuffer(::grpc::ServerContext* context, const CfgOutputBufferRequest* request, CfgOutputBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 num_samps_per_chan = request->num_samps_per_chan();
      auto status = library_->CfgOutputBuffer(task, num_samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgPipelinedSampClkTiming(::grpc::ServerContext* context, const CfgPipelinedSampClkTimingRequest* request, CfgPipelinedSampClkTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto source = request->source().c_str();
      float64 rate = request->rate();
      int32 active_edge;
      switch (request->active_edge_enum_case()) {
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdge: {
          active_edge = static_cast<int32>(request->active_edge());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdgeRaw: {
          active_edge = static_cast<int32>(request->active_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::ActiveEdgeEnumCase::ACTIVE_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for active_edge was not specified or out of range");
          break;
        }
      }

      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgPipelinedSampClkTiming(task, source, rate, active_edge, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgSampClkTiming(::grpc::ServerContext* context, const CfgSampClkTimingRequest* request, CfgSampClkTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto source = request->source().c_str();
      float64 rate = request->rate();
      int32 active_edge;
      switch (request->active_edge_enum_case()) {
        case nidaqmx_grpc::CfgSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdge: {
          active_edge = static_cast<int32>(request->active_edge());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdgeRaw: {
          active_edge = static_cast<int32>(request->active_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::ActiveEdgeEnumCase::ACTIVE_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for active_edge was not specified or out of range");
          break;
        }
      }

      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgSampClkTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgSampClkTiming(task, source, rate, active_edge, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgTimeStartTrig(::grpc::ServerContext* context, const CfgTimeStartTrigRequest* request, CfgTimeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime when = convert_from_grpc<CVIAbsoluteTime>(request->when());
      int32 timescale;
      switch (request->timescale_enum_case()) {
        case nidaqmx_grpc::CfgTimeStartTrigRequest::TimescaleEnumCase::kTimescale: {
          timescale = static_cast<int32>(request->timescale());
          break;
        }
        case nidaqmx_grpc::CfgTimeStartTrigRequest::TimescaleEnumCase::kTimescaleRaw: {
          timescale = static_cast<int32>(request->timescale_raw());
          break;
        }
        case nidaqmx_grpc::CfgTimeStartTrigRequest::TimescaleEnumCase::TIMESCALE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timescale was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgTimeStartTrig(task, when, timescale);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgWatchdogAOExpirStates(::grpc::ServerContext* context, const CfgWatchdogAOExpirStatesRequest* request, CfgWatchdogAOExpirStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto expir_state_array = const_cast<const float64*>(request->expir_state_array().data());
      auto output_type_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->output_type_array().data()));
      uInt32 array_size = request->array_size();
      auto status = library_->CfgWatchdogAOExpirStates(task, channel_names, expir_state_array, output_type_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgWatchdogCOExpirStates(::grpc::ServerContext* context, const CfgWatchdogCOExpirStatesRequest* request, CfgWatchdogCOExpirStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto expir_state_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->expir_state_array().data()));
      uInt32 array_size = request->array_size();
      auto status = library_->CfgWatchdogCOExpirStates(task, channel_names, expir_state_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgWatchdogDOExpirStates(::grpc::ServerContext* context, const CfgWatchdogDOExpirStatesRequest* request, CfgWatchdogDOExpirStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto expir_state_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->expir_state_array().data()));
      uInt32 array_size = request->array_size();
      auto status = library_->CfgWatchdogDOExpirStates(task, channel_names, expir_state_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ClearTEDS(::grpc::ServerContext* context, const ClearTEDSRequest* request, ClearTEDSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      auto status = library_->ClearTEDS(physical_channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ClearTask(::grpc::ServerContext* context, const ClearTaskRequest* request, ClearTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      session_repository_->remove_session(task);
      auto status = library_->ClearTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ConfigureLogging(::grpc::ServerContext* context, const ConfigureLoggingRequest* request, ConfigureLoggingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto file_path = request->file_path().c_str();
      int32 logging_mode;
      switch (request->logging_mode_enum_case()) {
        case nidaqmx_grpc::ConfigureLoggingRequest::LoggingModeEnumCase::kLoggingMode: {
          logging_mode = static_cast<int32>(request->logging_mode());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::LoggingModeEnumCase::kLoggingModeRaw: {
          logging_mode = static_cast<int32>(request->logging_mode_raw());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::LoggingModeEnumCase::LOGGING_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for logging_mode was not specified or out of range");
          break;
        }
      }

      auto group_name = request->group_name().c_str();
      int32 operation;
      switch (request->operation_enum_case()) {
        case nidaqmx_grpc::ConfigureLoggingRequest::OperationEnumCase::kOperation: {
          operation = static_cast<int32>(request->operation());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::OperationEnumCase::kOperationRaw: {
          operation = static_cast<int32>(request->operation_raw());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::OperationEnumCase::OPERATION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for operation was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureLogging(task, file_path, logging_mode, group_name, operation);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ConfigureTEDS(::grpc::ServerContext* context, const ConfigureTEDSRequest* request, ConfigureTEDSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      auto file_path = request->file_path().c_str();
      auto status = library_->ConfigureTEDS(physical_channel, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ConnectTerms(::grpc::ServerContext* context, const ConnectTermsRequest* request, ConnectTermsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto source_terminal = request->source_terminal().c_str();
      auto destination_terminal = request->destination_terminal().c_str();
      int32 signal_modifiers;
      switch (request->signal_modifiers_enum_case()) {
        case nidaqmx_grpc::ConnectTermsRequest::SignalModifiersEnumCase::kSignalModifiers: {
          signal_modifiers = static_cast<int32>(request->signal_modifiers());
          break;
        }
        case nidaqmx_grpc::ConnectTermsRequest::SignalModifiersEnumCase::kSignalModifiersRaw: {
          signal_modifiers = static_cast<int32>(request->signal_modifiers_raw());
          break;
        }
        case nidaqmx_grpc::ConnectTermsRequest::SignalModifiersEnumCase::SIGNAL_MODIFIERS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_modifiers was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConnectTerms(source_terminal, destination_terminal, signal_modifiers);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ControlWatchdogTask(::grpc::ServerContext* context, const ControlWatchdogTaskRequest* request, ControlWatchdogTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 action;
      switch (request->action_enum_case()) {
        case nidaqmx_grpc::ControlWatchdogTaskRequest::ActionEnumCase::kAction: {
          action = static_cast<int32>(request->action());
          break;
        }
        case nidaqmx_grpc::ControlWatchdogTaskRequest::ActionEnumCase::kActionRaw: {
          action = static_cast<int32>(request->action_raw());
          break;
        }
        case nidaqmx_grpc::ControlWatchdogTaskRequest::ActionEnumCase::ACTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for action was not specified or out of range");
          break;
        }
      }

      auto status = library_->ControlWatchdogTask(task, action);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccel4WireDCVoltageChan(::grpc::ServerContext* context, const CreateAIAccel4WireDCVoltageChanRequest* request, CreateAIAccel4WireDCVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      bool32 use_excit_for_scaling = request->use_excit_for_scaling();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccel4WireDCVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, use_excit_for_scaling, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccelChan(::grpc::ServerContext* context, const CreateAIAccelChanRequest* request, CreateAIAccelChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccelChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccelChargeChan(::grpc::ServerContext* context, const CreateAIAccelChargeChanRequest* request, CreateAIAccelChargeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccelChargeChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIBridgeChan(::grpc::ServerContext* context, const CreateAIBridgeChanRequest* request, CreateAIBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIChargeChan(::grpc::ServerContext* context, const CreateAIChargeChanRequest* request, CreateAIChargeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIChargeChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAICurrentChan(::grpc::ServerContext* context, const CreateAICurrentChanRequest* request, CreateAICurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAICurrentChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAICurrentRMSChan(::grpc::ServerContext* context, const CreateAICurrentRMSChanRequest* request, CreateAICurrentRMSChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAICurrentRMSChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceBridgePolynomialChan(::grpc::ServerContext* context, const CreateAIForceBridgePolynomialChanRequest* request, CreateAIForceBridgePolynomialChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs = request->num_forward_coeffs();
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs = request->num_reverse_coeffs();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceBridgePolynomialChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, num_forward_coeffs, reverse_coeffs, num_reverse_coeffs, electrical_units, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceBridgeTableChan(::grpc::ServerContext* context, const CreateAIForceBridgeTableChanRequest* request, CreateAIForceBridgeTableChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto electrical_vals = const_cast<const float64*>(request->electrical_vals().data());
      uInt32 num_electrical_vals = request->num_electrical_vals();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      auto physical_vals = const_cast<const float64*>(request->physical_vals().data());
      uInt32 num_physical_vals = request->num_physical_vals();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceBridgeTableChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, num_electrical_vals, electrical_units, physical_vals, num_physical_vals, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceBridgeTwoPointLinChan(::grpc::ServerContext* context, const CreateAIForceBridgeTwoPointLinChanRequest* request, CreateAIForceBridgeTwoPointLinChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      float64 first_electrical_val = request->first_electrical_val();
      float64 second_electrical_val = request->second_electrical_val();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      float64 first_physical_val = request->first_physical_val();
      float64 second_physical_val = request->second_physical_val();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceBridgeTwoPointLinChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceIEPEChan(::grpc::ServerContext* context, const CreateAIForceIEPEChanRequest* request, CreateAIForceIEPEChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceIEPEChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIFreqVoltageChan(::grpc::ServerContext* context, const CreateAIFreqVoltageChanRequest* request, CreateAIFreqVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 threshold_level = request->threshold_level();
      float64 hysteresis = request->hysteresis();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIFreqVoltageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, threshold_level, hysteresis, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIMicrophoneChan(::grpc::ServerContext* context, const CreateAIMicrophoneChanRequest* request, CreateAIMicrophoneChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 mic_sensitivity = request->mic_sensitivity();
      float64 max_snd_press_level = request->max_snd_press_level();
      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIMicrophoneChan(task, physical_channel, name_to_assign_to_channel, terminal_config, units, mic_sensitivity, max_snd_press_level, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosEddyCurrProxProbeChan(::grpc::ServerContext* context, const CreateAIPosEddyCurrProxProbeChanRequest* request, CreateAIPosEddyCurrProxProbeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosEddyCurrProxProbeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosLVDTChan(::grpc::ServerContext* context, const CreateAIPosLVDTChanRequest* request, CreateAIPosLVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosLVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosRVDTChan(::grpc::ServerContext* context, const CreateAIPosRVDTChanRequest* request, CreateAIPosRVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosRVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPressureBridgePolynomialChan(::grpc::ServerContext* context, const CreateAIPressureBridgePolynomialChanRequest* request, CreateAIPressureBridgePolynomialChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs = request->num_forward_coeffs();
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs = request->num_reverse_coeffs();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPressureBridgePolynomialChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, num_forward_coeffs, reverse_coeffs, num_reverse_coeffs, electrical_units, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPressureBridgeTableChan(::grpc::ServerContext* context, const CreateAIPressureBridgeTableChanRequest* request, CreateAIPressureBridgeTableChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto electrical_vals = const_cast<const float64*>(request->electrical_vals().data());
      uInt32 num_electrical_vals = request->num_electrical_vals();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      auto physical_vals = const_cast<const float64*>(request->physical_vals().data());
      uInt32 num_physical_vals = request->num_physical_vals();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPressureBridgeTableChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, num_electrical_vals, electrical_units, physical_vals, num_physical_vals, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPressureBridgeTwoPointLinChan(::grpc::ServerContext* context, const CreateAIPressureBridgeTwoPointLinChanRequest* request, CreateAIPressureBridgeTwoPointLinChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      float64 first_electrical_val = request->first_electrical_val();
      float64 second_electrical_val = request->second_electrical_val();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      float64 first_physical_val = request->first_physical_val();
      float64 second_physical_val = request->second_physical_val();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPressureBridgeTwoPointLinChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIRTDChan(::grpc::ServerContext* context, const CreateAIRTDChanRequest* request, CreateAIRTDChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 rtd_type;
      switch (request->rtd_type_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::RtdTypeEnumCase::kRtdType: {
          rtd_type = static_cast<int32>(request->rtd_type());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::RtdTypeEnumCase::kRtdTypeRaw: {
          rtd_type = static_cast<int32>(request->rtd_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::RtdTypeEnumCase::RTD_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rtd_type was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      float64 r0 = request->r0();
      auto status = library_->CreateAIRTDChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, rtd_type, resistance_config, current_excit_source, current_excit_val, r0);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIResistanceChan(::grpc::ServerContext* context, const CreateAIResistanceChanRequest* request, CreateAIResistanceChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIResistanceChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIRosetteStrainGageChan(::grpc::ServerContext* context, const CreateAIRosetteStrainGageChanRequest* request, CreateAIRosetteStrainGageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 rosette_type;
      switch (request->rosette_type_enum_case()) {
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::RosetteTypeEnumCase::kRosetteType: {
          rosette_type = static_cast<int32>(request->rosette_type());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::RosetteTypeEnumCase::kRosetteTypeRaw: {
          rosette_type = static_cast<int32>(request->rosette_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::RosetteTypeEnumCase::ROSETTE_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rosette_type was not specified or out of range");
          break;
        }
      }

      float64 gage_orientation = request->gage_orientation();
      auto rosette_meas_types = const_cast<int32*>(reinterpret_cast<const int32*>(request->rosette_meas_types().data()));
      uInt32 num_rosette_meas_types = request->num_rosette_meas_types();
      int32 strain_config;
      switch (request->strain_config_enum_case()) {
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::StrainConfigEnumCase::kStrainConfig: {
          strain_config = static_cast<int32>(request->strain_config());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::StrainConfigEnumCase::kStrainConfigRaw: {
          strain_config = static_cast<int32>(request->strain_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::StrainConfigEnumCase::STRAIN_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for strain_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 gage_factor = request->gage_factor();
      float64 nominal_gage_resistance = request->nominal_gage_resistance();
      float64 poisson_ratio = request->poisson_ratio();
      float64 lead_wire_resistance = request->lead_wire_resistance();
      auto status = library_->CreateAIRosetteStrainGageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, rosette_type, gage_orientation, rosette_meas_types, num_rosette_meas_types, strain_config, voltage_excit_source, voltage_excit_val, gage_factor, nominal_gage_resistance, poisson_ratio, lead_wire_resistance);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIStrainGageChan(::grpc::ServerContext* context, const CreateAIStrainGageChanRequest* request, CreateAIStrainGageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 strain_config;
      switch (request->strain_config_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::kStrainConfig: {
          strain_config = static_cast<int32>(request->strain_config());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::kStrainConfigRaw: {
          strain_config = static_cast<int32>(request->strain_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::STRAIN_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for strain_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 gage_factor = request->gage_factor();
      float64 initial_bridge_voltage = request->initial_bridge_voltage();
      float64 nominal_gage_resistance = request->nominal_gage_resistance();
      float64 poisson_ratio = request->poisson_ratio();
      float64 lead_wire_resistance = request->lead_wire_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIStrainGageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, strain_config, voltage_excit_source, voltage_excit_val, gage_factor, initial_bridge_voltage, nominal_gage_resistance, poisson_ratio, lead_wire_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITempBuiltInSensorChan(::grpc::ServerContext* context, const CreateAITempBuiltInSensorChanRequest* request, CreateAITempBuiltInSensorChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITempBuiltInSensorChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITempBuiltInSensorChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITempBuiltInSensorChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateAITempBuiltInSensorChan(task, physical_channel, name_to_assign_to_channel, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIThrmcplChan(::grpc::ServerContext* context, const CreateAIThrmcplChanRequest* request, CreateAIThrmcplChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 thermocouple_type;
      switch (request->thermocouple_type_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::ThermocoupleTypeEnumCase::kThermocoupleType: {
          thermocouple_type = static_cast<int32>(request->thermocouple_type());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::ThermocoupleTypeEnumCase::kThermocoupleTypeRaw: {
          thermocouple_type = static_cast<int32>(request->thermocouple_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::ThermocoupleTypeEnumCase::THERMOCOUPLE_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for thermocouple_type was not specified or out of range");
          break;
        }
      }

      int32 cjc_source;
      switch (request->cjc_source_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSource: {
          cjc_source = static_cast<int32>(request->cjc_source());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSourceRaw: {
          cjc_source = static_cast<int32>(request->cjc_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::CjcSourceEnumCase::CJC_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for cjc_source was not specified or out of range");
          break;
        }
      }

      float64 cjc_val = request->cjc_val();
      auto cjc_channel = request->cjc_channel().c_str();
      auto status = library_->CreateAIThrmcplChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, thermocouple_type, cjc_source, cjc_val, cjc_channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIThrmstrChanIex(::grpc::ServerContext* context, const CreateAIThrmstrChanIexRequest* request, CreateAIThrmstrChanIexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      float64 a = request->a();
      float64 b = request->b();
      float64 c = request->c();
      auto status = library_->CreateAIThrmstrChanIex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, a, b, c);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIThrmstrChanVex(::grpc::ServerContext* context, const CreateAIThrmstrChanVexRequest* request, CreateAIThrmstrChanVexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 a = request->a();
      float64 b = request->b();
      float64 c = request->c();
      float64 r1 = request->r1();
      auto status = library_->CreateAIThrmstrChanVex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, voltage_excit_source, voltage_excit_val, a, b, c, r1);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITorqueBridgePolynomialChan(::grpc::ServerContext* context, const CreateAITorqueBridgePolynomialChanRequest* request, CreateAITorqueBridgePolynomialChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs = request->num_forward_coeffs();
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs = request->num_reverse_coeffs();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAITorqueBridgePolynomialChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, num_forward_coeffs, reverse_coeffs, num_reverse_coeffs, electrical_units, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITorqueBridgeTableChan(::grpc::ServerContext* context, const CreateAITorqueBridgeTableChanRequest* request, CreateAITorqueBridgeTableChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto electrical_vals = const_cast<const float64*>(request->electrical_vals().data());
      uInt32 num_electrical_vals = request->num_electrical_vals();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      auto physical_vals = const_cast<const float64*>(request->physical_vals().data());
      uInt32 num_physical_vals = request->num_physical_vals();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAITorqueBridgeTableChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, num_electrical_vals, electrical_units, physical_vals, num_physical_vals, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITorqueBridgeTwoPointLinChan(::grpc::ServerContext* context, const CreateAITorqueBridgeTwoPointLinChanRequest* request, CreateAITorqueBridgeTwoPointLinChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      float64 first_electrical_val = request->first_electrical_val();
      float64 second_electrical_val = request->second_electrical_val();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      float64 first_physical_val = request->first_physical_val();
      float64 second_physical_val = request->second_physical_val();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAITorqueBridgeTwoPointLinChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVelocityIEPEChan(::grpc::ServerContext* context, const CreateAIVelocityIEPEChanRequest* request, CreateAIVelocityIEPEChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVelocityIEPEChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageChan(::grpc::ServerContext* context, const CreateAIVoltageChanRequest* request, CreateAIVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageChanWithExcit(::grpc::ServerContext* context, const CreateAIVoltageChanWithExcitRequest* request, CreateAIVoltageChanWithExcitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      bool32 use_excit_for_scaling = request->use_excit_for_scaling();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageChanWithExcit(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, use_excit_for_scaling, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageRMSChan(::grpc::ServerContext* context, const CreateAIVoltageRMSChanRequest* request, CreateAIVoltageRMSChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageRMSChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOCurrentChan(::grpc::ServerContext* context, const CreateAOCurrentChanRequest* request, CreateAOCurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAOCurrentChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOFuncGenChan(::grpc::ServerContext* context, const CreateAOFuncGenChanRequest* request, CreateAOFuncGenChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 type;
      switch (request->type_enum_case()) {
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::kType: {
          type = static_cast<int32>(request->type());
          break;
        }
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::kTypeRaw: {
          type = static_cast<int32>(request->type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for type was not specified or out of range");
          break;
        }
      }

      float64 freq = request->freq();
      float64 amplitude = request->amplitude();
      float64 offset = request->offset();
      auto status = library_->CreateAOFuncGenChan(task, physical_channel, name_to_assign_to_channel, type, freq, amplitude, offset);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOVoltageChan(::grpc::ServerContext* context, const CreateAOVoltageChanRequest* request, CreateAOVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAOVoltageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIAngEncoderChan(::grpc::ServerContext* context, const CreateCIAngEncoderChanRequest* request, CreateCIAngEncoderChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      bool32 zidx_enable = request->zidx_enable();
      float64 zidx_val = request->zidx_val();
      int32 zidx_phase;
      switch (request->zidx_phase_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhase: {
          zidx_phase = static_cast<int32>(request->zidx_phase());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhaseRaw: {
          zidx_phase = static_cast<int32>(request->zidx_phase_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::ZIDX_PHASE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for zidx_phase was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      uInt32 pulses_per_rev = request->pulses_per_rev();
      float64 initial_angle = request->initial_angle();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIAngEncoderChan(task, counter, name_to_assign_to_channel, decoding_type, zidx_enable, zidx_val, zidx_phase, units, pulses_per_rev, initial_angle, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIAngVelocityChan(::grpc::ServerContext* context, const CreateCIAngVelocityChanRequest* request, CreateCIAngVelocityChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      uInt32 pulses_per_rev = request->pulses_per_rev();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIAngVelocityChan(task, counter, name_to_assign_to_channel, min_val, max_val, decoding_type, units, pulses_per_rev, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCICountEdgesChan(::grpc::ServerContext* context, const CreateCICountEdgesChanRequest* request, CreateCICountEdgesChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      uInt32 initial_count = request->initial_count();
      int32 count_direction;
      switch (request->count_direction_enum_case()) {
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::kCountDirection: {
          count_direction = static_cast<int32>(request->count_direction());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::kCountDirectionRaw: {
          count_direction = static_cast<int32>(request->count_direction_raw());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::COUNT_DIRECTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for count_direction was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCICountEdgesChan(task, counter, name_to_assign_to_channel, edge, initial_count, count_direction);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIDutyCycleChan(::grpc::ServerContext* context, const CreateCIDutyCycleChanRequest* request, CreateCIDutyCycleChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_freq = request->min_freq();
      float64 max_freq = request->max_freq();
      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIDutyCycleChan(task, counter, name_to_assign_to_channel, min_freq, max_freq, edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIFreqChan(::grpc::ServerContext* context, const CreateCIFreqChanRequest* request, CreateCIFreqChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      int32 meas_method;
      switch (request->meas_method_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::kMeasMethod: {
          meas_method = static_cast<int32>(request->meas_method());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::kMeasMethodRaw: {
          meas_method = static_cast<int32>(request->meas_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::MEAS_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for meas_method was not specified or out of range");
          break;
        }
      }

      float64 meas_time = request->meas_time();
      uInt32 divisor = request->divisor();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIFreqChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, edge, meas_method, meas_time, divisor, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIGPSTimestampChan(::grpc::ServerContext* context, const CreateCIGPSTimestampChanRequest* request, CreateCIGPSTimestampChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 sync_method;
      switch (request->sync_method_enum_case()) {
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::kSyncMethod: {
          sync_method = static_cast<int32>(request->sync_method());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::kSyncMethodRaw: {
          sync_method = static_cast<int32>(request->sync_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::SYNC_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sync_method was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIGPSTimestampChan(task, counter, name_to_assign_to_channel, units, sync_method, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCILinEncoderChan(::grpc::ServerContext* context, const CreateCILinEncoderChanRequest* request, CreateCILinEncoderChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      bool32 zidx_enable = request->zidx_enable();
      float64 zidx_val = request->zidx_val();
      int32 zidx_phase;
      switch (request->zidx_phase_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhase: {
          zidx_phase = static_cast<int32>(request->zidx_phase());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhaseRaw: {
          zidx_phase = static_cast<int32>(request->zidx_phase_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::ZIDX_PHASE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for zidx_phase was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 dist_per_pulse = request->dist_per_pulse();
      float64 initial_pos = request->initial_pos();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCILinEncoderChan(task, counter, name_to_assign_to_channel, decoding_type, zidx_enable, zidx_val, zidx_phase, units, dist_per_pulse, initial_pos, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCILinVelocityChan(::grpc::ServerContext* context, const CreateCILinVelocityChanRequest* request, CreateCILinVelocityChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 dist_per_pulse = request->dist_per_pulse();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCILinVelocityChan(task, counter, name_to_assign_to_channel, min_val, max_val, decoding_type, units, dist_per_pulse, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPeriodChan(::grpc::ServerContext* context, const CreateCIPeriodChanRequest* request, CreateCIPeriodChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      int32 meas_method;
      switch (request->meas_method_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::kMeasMethod: {
          meas_method = static_cast<int32>(request->meas_method());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::kMeasMethodRaw: {
          meas_method = static_cast<int32>(request->meas_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::MEAS_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for meas_method was not specified or out of range");
          break;
        }
      }

      float64 meas_time = request->meas_time();
      uInt32 divisor = request->divisor();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIPeriodChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, edge, meas_method, meas_time, divisor, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanFreq(::grpc::ServerContext* context, const CreateCIPulseChanFreqRequest* request, CreateCIPulseChanFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCIPulseChanFreq(task, counter, name_to_assign_to_channel, min_val, max_val, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanTicks(::grpc::ServerContext* context, const CreateCIPulseChanTicksRequest* request, CreateCIPulseChanTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      auto source_terminal = request->source_terminal().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      auto status = library_->CreateCIPulseChanTicks(task, counter, name_to_assign_to_channel, source_terminal, min_val, max_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanTime(::grpc::ServerContext* context, const CreateCIPulseChanTimeRequest* request, CreateCIPulseChanTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCIPulseChanTime(task, counter, name_to_assign_to_channel, min_val, max_val, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseWidthChan(::grpc::ServerContext* context, const CreateCIPulseWidthChanRequest* request, CreateCIPulseWidthChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 starting_edge;
      switch (request->starting_edge_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::kStartingEdge: {
          starting_edge = static_cast<int32>(request->starting_edge());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::kStartingEdgeRaw: {
          starting_edge = static_cast<int32>(request->starting_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::STARTING_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for starting_edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIPulseWidthChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, starting_edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCISemiPeriodChan(::grpc::ServerContext* context, const CreateCISemiPeriodChanRequest* request, CreateCISemiPeriodChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCISemiPeriodChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCITwoEdgeSepChan(::grpc::ServerContext* context, const CreateCITwoEdgeSepChanRequest* request, CreateCITwoEdgeSepChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 first_edge;
      switch (request->first_edge_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::kFirstEdge: {
          first_edge = static_cast<int32>(request->first_edge());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::kFirstEdgeRaw: {
          first_edge = static_cast<int32>(request->first_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::FIRST_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for first_edge was not specified or out of range");
          break;
        }
      }

      int32 second_edge;
      switch (request->second_edge_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::kSecondEdge: {
          second_edge = static_cast<int32>(request->second_edge());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::kSecondEdgeRaw: {
          second_edge = static_cast<int32>(request->second_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::SECOND_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for second_edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCITwoEdgeSepChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, first_edge, second_edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanFreq(::grpc::ServerContext* context, const CreateCOPulseChanFreqRequest* request, CreateCOPulseChanFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      float64 initial_delay = request->initial_delay();
      float64 freq = request->freq();
      float64 duty_cycle = request->duty_cycle();
      auto status = library_->CreateCOPulseChanFreq(task, counter, name_to_assign_to_channel, units, idle_state, initial_delay, freq, duty_cycle);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanTicks(::grpc::ServerContext* context, const CreateCOPulseChanTicksRequest* request, CreateCOPulseChanTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      auto source_terminal = request->source_terminal().c_str();
      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      int32 initial_delay = request->initial_delay();
      int32 low_ticks = request->low_ticks();
      int32 high_ticks = request->high_ticks();
      auto status = library_->CreateCOPulseChanTicks(task, counter, name_to_assign_to_channel, source_terminal, idle_state, initial_delay, low_ticks, high_ticks);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanTime(::grpc::ServerContext* context, const CreateCOPulseChanTimeRequest* request, CreateCOPulseChanTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      float64 initial_delay = request->initial_delay();
      float64 low_time = request->low_time();
      float64 high_time = request->high_time();
      auto status = library_->CreateCOPulseChanTime(task, counter, name_to_assign_to_channel, units, idle_state, initial_delay, low_time, high_time);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateDIChan(::grpc::ServerContext* context, const CreateDIChanRequest* request, CreateDIChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      auto name_to_assign_to_lines = request->name_to_assign_to_lines().c_str();
      int32 line_grouping;
      switch (request->line_grouping_enum_case()) {
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::kLineGrouping: {
          line_grouping = static_cast<int32>(request->line_grouping());
          break;
        }
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::kLineGroupingRaw: {
          line_grouping = static_cast<int32>(request->line_grouping_raw());
          break;
        }
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::LINE_GROUPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for line_grouping was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateDIChan(task, lines, name_to_assign_to_lines, line_grouping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateDOChan(::grpc::ServerContext* context, const CreateDOChanRequest* request, CreateDOChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      auto name_to_assign_to_lines = request->name_to_assign_to_lines().c_str();
      int32 line_grouping;
      switch (request->line_grouping_enum_case()) {
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::kLineGrouping: {
          line_grouping = static_cast<int32>(request->line_grouping());
          break;
        }
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::kLineGroupingRaw: {
          line_grouping = static_cast<int32>(request->line_grouping_raw());
          break;
        }
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::LINE_GROUPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for line_grouping was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateDOChan(task, lines, name_to_assign_to_lines, line_grouping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateLinScale(::grpc::ServerContext* context, const CreateLinScaleRequest* request, CreateLinScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      float64 slope = request->slope();
      float64 y_intercept = request->y_intercept();
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreateLinScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreateLinScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateLinScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreateLinScale(name, slope, y_intercept, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateMapScale(::grpc::ServerContext* context, const CreateMapScaleRequest* request, CreateMapScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      float64 prescaled_min = request->prescaled_min();
      float64 prescaled_max = request->prescaled_max();
      float64 scaled_min = request->scaled_min();
      float64 scaled_max = request->scaled_max();
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreateMapScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreateMapScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateMapScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreateMapScale(name, prescaled_min, prescaled_max, scaled_min, scaled_max, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreatePolynomialScale(::grpc::ServerContext* context, const CreatePolynomialScaleRequest* request, CreatePolynomialScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs_in = request->num_forward_coeffs_in();
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs_in = request->num_reverse_coeffs_in();
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreatePolynomialScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreatePolynomialScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreatePolynomialScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreatePolynomialScale(name, forward_coeffs, num_forward_coeffs_in, reverse_coeffs, num_reverse_coeffs_in, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIAccelChan(::grpc::ServerContext* context, const CreateTEDSAIAccelChanRequest* request, CreateTEDSAIAccelChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIAccelChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIBridgeChan(::grpc::ServerContext* context, const CreateTEDSAIBridgeChanRequest* request, CreateTEDSAIBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAICurrentChan(::grpc::ServerContext* context, const CreateTEDSAICurrentChanRequest* request, CreateTEDSAICurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAICurrentChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIForceBridgeChan(::grpc::ServerContext* context, const CreateTEDSAIForceBridgeChanRequest* request, CreateTEDSAIForceBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIForceBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIForceIEPEChan(::grpc::ServerContext* context, const CreateTEDSAIForceIEPEChanRequest* request, CreateTEDSAIForceIEPEChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIForceIEPEChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIMicrophoneChan(::grpc::ServerContext* context, const CreateTEDSAIMicrophoneChanRequest* request, CreateTEDSAIMicrophoneChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 max_snd_press_level = request->max_snd_press_level();
      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIMicrophoneChan(task, physical_channel, name_to_assign_to_channel, terminal_config, units, max_snd_press_level, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPosLVDTChan(::grpc::ServerContext* context, const CreateTEDSAIPosLVDTChanRequest* request, CreateTEDSAIPosLVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPosLVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPosRVDTChan(::grpc::ServerContext* context, const CreateTEDSAIPosRVDTChanRequest* request, CreateTEDSAIPosRVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPosRVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPressureBridgeChan(::grpc::ServerContext* context, const CreateTEDSAIPressureBridgeChanRequest* request, CreateTEDSAIPressureBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPressureBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIRTDChan(::grpc::ServerContext* context, const CreateTEDSAIRTDChanRequest* request, CreateTEDSAIRTDChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto status = library_->CreateTEDSAIRTDChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIResistanceChan(::grpc::ServerContext* context, const CreateTEDSAIResistanceChanRequest* request, CreateTEDSAIResistanceChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIResistanceChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIStrainGageChan(::grpc::ServerContext* context, const CreateTEDSAIStrainGageChanRequest* request, CreateTEDSAIStrainGageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 initial_bridge_voltage = request->initial_bridge_voltage();
      float64 lead_wire_resistance = request->lead_wire_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIStrainGageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, initial_bridge_voltage, lead_wire_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIThrmcplChan(::grpc::ServerContext* context, const CreateTEDSAIThrmcplChanRequest* request, CreateTEDSAIThrmcplChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 cjc_source;
      switch (request->cjc_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSource: {
          cjc_source = static_cast<int32>(request->cjc_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSourceRaw: {
          cjc_source = static_cast<int32>(request->cjc_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::CjcSourceEnumCase::CJC_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for cjc_source was not specified or out of range");
          break;
        }
      }

      float64 cjc_val = request->cjc_val();
      auto cjc_channel = request->cjc_channel().c_str();
      auto status = library_->CreateTEDSAIThrmcplChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, cjc_source, cjc_val, cjc_channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIThrmstrChanIex(::grpc::ServerContext* context, const CreateTEDSAIThrmstrChanIexRequest* request, CreateTEDSAIThrmstrChanIexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto status = library_->CreateTEDSAIThrmstrChanIex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIThrmstrChanVex(::grpc::ServerContext* context, const CreateTEDSAIThrmstrChanVexRequest* request, CreateTEDSAIThrmstrChanVexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 r1 = request->r1();
      auto status = library_->CreateTEDSAIThrmstrChanVex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, voltage_excit_source, voltage_excit_val, r1);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAITorqueBridgeChan(::grpc::ServerContext* context, const CreateTEDSAITorqueBridgeChanRequest* request, CreateTEDSAITorqueBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAITorqueBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIVoltageChan(::grpc::ServerContext* context, const CreateTEDSAIVoltageChanRequest* request, CreateTEDSAIVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIVoltageChanWithExcit(::grpc::ServerContext* context, const CreateTEDSAIVoltageChanWithExcitRequest* request, CreateTEDSAIVoltageChanWithExcitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIVoltageChanWithExcit(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTableScale(::grpc::ServerContext* context, const CreateTableScaleRequest* request, CreateTableScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      auto prescaled_vals = const_cast<const float64*>(request->prescaled_vals().data());
      uInt32 num_prescaled_vals_in = request->num_prescaled_vals_in();
      auto scaled_vals = const_cast<const float64*>(request->scaled_vals().data());
      uInt32 num_scaled_vals_in = request->num_scaled_vals_in();
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreateTableScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreateTableScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTableScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreateTableScale(name, prescaled_vals, num_prescaled_vals_in, scaled_vals, num_scaled_vals_in, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTask(::grpc::ServerContext* context, const CreateTaskRequest* request, CreateTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_name = request->session_name().c_str();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->CreateTask(session_name, &task);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateWatchdogTimerTask(::grpc::ServerContext* context, const CreateWatchdogTimerTaskRequest* request, CreateWatchdogTimerTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto session_name = request->session_name().c_str();
      float64 timeout = request->timeout();
      auto lines = request->lines().c_str();
      int32 exp_state;
      switch (request->exp_state_enum_case()) {
        case nidaqmx_grpc::CreateWatchdogTimerTaskRequest::ExpStateEnumCase::kExpState: {
          exp_state = static_cast<int32>(request->exp_state());
          break;
        }
        case nidaqmx_grpc::CreateWatchdogTimerTaskRequest::ExpStateEnumCase::kExpStateRaw: {
          exp_state = static_cast<int32>(request->exp_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateWatchdogTimerTaskRequest::ExpStateEnumCase::EXP_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for exp_state was not specified or out of range");
          break;
        }
      }


      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->CreateWatchdogTimerTask(device_name, session_name, &task, timeout, lines, exp_state);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateWatchdogTimerTaskEx(::grpc::ServerContext* context, const CreateWatchdogTimerTaskExRequest* request, CreateWatchdogTimerTaskExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto session_name = request->session_name().c_str();
      float64 timeout = request->timeout();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->CreateWatchdogTimerTaskEx(device_name, session_name, &task, timeout);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteNetworkDevice(::grpc::ServerContext* context, const DeleteNetworkDeviceRequest* request, DeleteNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->DeleteNetworkDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteSavedGlobalChan(::grpc::ServerContext* context, const DeleteSavedGlobalChanRequest* request, DeleteSavedGlobalChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto channel_name = request->channel_name().c_str();
      auto status = library_->DeleteSavedGlobalChan(channel_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteSavedScale(::grpc::ServerContext* context, const DeleteSavedScaleRequest* request, DeleteSavedScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      auto status = library_->DeleteSavedScale(scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteSavedTask(::grpc::ServerContext* context, const DeleteSavedTaskRequest* request, DeleteSavedTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_name = request->task_name().c_str();
      auto status = library_->DeleteSavedTask(task_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeviceSupportsCal(::grpc::ServerContext* context, const DeviceSupportsCalRequest* request, DeviceSupportsCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      bool32 cal_supported {};
      auto status = library_->DeviceSupportsCal(device_name, &cal_supported);
      response->set_status(status);
      if (status == 0) {
        response->set_cal_supported(cal_supported);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DisableRefTrig(::grpc::ServerContext* context, const DisableRefTrigRequest* request, DisableRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->DisableRefTrig(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DisableStartTrig(::grpc::ServerContext* context, const DisableStartTrigRequest* request, DisableStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->DisableStartTrig(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DisconnectTerms(::grpc::ServerContext* context, const DisconnectTermsRequest* request, DisconnectTermsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto source_terminal = request->source_terminal().c_str();
      auto destination_terminal = request->destination_terminal().c_str();
      auto status = library_->DisconnectTerms(source_terminal, destination_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ExportSignal(::grpc::ServerContext* context, const ExportSignalRequest* request, ExportSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 signal_id;
      switch (request->signal_id_enum_case()) {
        case nidaqmx_grpc::ExportSignalRequest::SignalIdEnumCase::kSignalId: {
          signal_id = static_cast<int32>(request->signal_id());
          break;
        }
        case nidaqmx_grpc::ExportSignalRequest::SignalIdEnumCase::kSignalIdRaw: {
          signal_id = static_cast<int32>(request->signal_id_raw());
          break;
        }
        case nidaqmx_grpc::ExportSignalRequest::SignalIdEnumCase::SIGNAL_ID_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_id was not specified or out of range");
          break;
        }
      }

      auto output_terminal = request->output_terminal().c_str();
      auto status = library_->ExportSignal(task, signal_id, output_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalCalDate(::grpc::ServerContext* context, const GetAIChanCalCalDateRequest* request, GetAIChanCalCalDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetAIChanCalCalDate(task, channel_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status == 0) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalExpDate(::grpc::ServerContext* context, const GetAIChanCalExpDateRequest* request, GetAIChanCalExpDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetAIChanCalExpDate(task, channel_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status == 0) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetArmStartTrigTimestampVal(::grpc::ServerContext* context, const GetArmStartTrigTimestampValRequest* request, GetArmStartTrigTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetArmStartTrigTimestampVal(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetArmStartTrigTrigWhen(::grpc::ServerContext* context, const GetArmStartTrigTrigWhenRequest* request, GetArmStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetArmStartTrigTrigWhen(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAutoConfiguredCDAQSyncConnections(::grpc::ServerContext* context, const GetAutoConfiguredCDAQSyncConnectionsRequest* request, GetAutoConfiguredCDAQSyncConnectionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      uInt32 port_list_size = request->port_list_size();
      std::string port_list;
      if (port_list_size > 0) {
          port_list.resize(port_list_size-1);
      }
      auto status = library_->GetAutoConfiguredCDAQSyncConnections((char*)port_list.data(), port_list_size);
      response->set_status(status);
      if (status == 0) {
        response->set_port_list(port_list);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDigitalLogicFamilyPowerUpState(::grpc::ServerContext* context, const GetDigitalLogicFamilyPowerUpStateRequest* request, GetDigitalLogicFamilyPowerUpStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 logic_family {};
      auto status = library_->GetDigitalLogicFamilyPowerUpState(device_name, &logic_family);
      response->set_status(status);
      if (status == 0) {
        response->set_logic_family(logic_family);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDisconnectedCDAQSyncPorts(::grpc::ServerContext* context, const GetDisconnectedCDAQSyncPortsRequest* request, GetDisconnectedCDAQSyncPortsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      uInt32 port_list_size = request->port_list_size();
      std::string port_list;
      if (port_list_size > 0) {
          port_list.resize(port_list_size-1);
      }
      auto status = library_->GetDisconnectedCDAQSyncPorts((char*)port_list.data(), port_list_size);
      response->set_status(status);
      if (status == 0) {
        response->set_port_list(port_list);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetErrorString(::grpc::ServerContext* context, const GetErrorStringRequest* request, GetErrorStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      int32 error_code = request->error_code();
      uInt32 buffer_size = request->buffer_size();
      std::string error_string;
      if (buffer_size > 0) {
          error_string.resize(buffer_size-1);
      }
      auto status = library_->GetErrorString(error_code, (char*)error_string.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_error_string(error_string);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExtendedErrorInfo(::grpc::ServerContext* context, const GetExtendedErrorInfoRequest* request, GetExtendedErrorInfoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      uInt32 buffer_size = request->buffer_size();
      std::string error_string;
      if (buffer_size > 0) {
          error_string.resize(buffer_size-1);
      }
      auto status = library_->GetExtendedErrorInfo((char*)error_string.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_error_string(error_string);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetFirstSampClkWhen(::grpc::ServerContext* context, const GetFirstSampClkWhenRequest* request, GetFirstSampClkWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetFirstSampClkWhen(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetFirstSampTimestampVal(::grpc::ServerContext* context, const GetFirstSampTimestampValRequest* request, GetFirstSampTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetFirstSampTimestampVal(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskChannel(::grpc::ServerContext* context, const GetNthTaskChannelRequest* request, GetNthTaskChannelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();
      int32 buffer_size = request->buffer_size();
      std::string buffer;
      if (buffer_size > 0) {
          buffer.resize(buffer_size-1);
      }
      auto status = library_->GetNthTaskChannel(task, index, (char*)buffer.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_buffer(buffer);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskDevice(::grpc::ServerContext* context, const GetNthTaskDeviceRequest* request, GetNthTaskDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();
      int32 buffer_size = request->buffer_size();
      std::string buffer;
      if (buffer_size > 0) {
          buffer.resize(buffer_size-1);
      }
      auto status = library_->GetNthTaskDevice(task, index, (char*)buffer.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_buffer(buffer);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskReadChannel(::grpc::ServerContext* context, const GetNthTaskReadChannelRequest* request, GetNthTaskReadChannelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();
      int32 buffer_size = request->buffer_size();
      std::string buffer;
      if (buffer_size > 0) {
          buffer.resize(buffer_size-1);
      }
      auto status = library_->GetNthTaskReadChannel(task, index, (char*)buffer.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_buffer(buffer);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetRefTrigTimestampVal(::grpc::ServerContext* context, const GetRefTrigTimestampValRequest* request, GetRefTrigTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetRefTrigTimestampVal(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetScaleAttributeDouble(::grpc::ServerContext* context, const GetScaleAttributeDoubleRequest* request, GetScaleAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute = request->attribute();
      float64 value {};
      auto status = library_->GetScaleAttributeDouble(scale_name, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetScaleAttributeInt32(::grpc::ServerContext* context, const GetScaleAttributeInt32Request* request, GetScaleAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute = request->attribute();
      int32 value {};
      auto status = library_->GetScaleAttributeInt32(scale_name, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetSelfCalLastDateAndTime(::grpc::ServerContext* context, const GetSelfCalLastDateAndTimeRequest* request, GetSelfCalLastDateAndTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetSelfCalLastDateAndTime(device_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status == 0) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetStartTrigTimestampVal(::grpc::ServerContext* context, const GetStartTrigTimestampValRequest* request, GetStartTrigTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetStartTrigTimestampVal(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetStartTrigTrigWhen(::grpc::ServerContext* context, const GetStartTrigTrigWhenRequest* request, GetStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetStartTrigTrigWhen(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetSyncPulseTimeWhen(::grpc::ServerContext* context, const GetSyncPulseTimeWhenRequest* request, GetSyncPulseTimeWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetSyncPulseTimeWhen(task, &data);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::IsTaskDone(::grpc::ServerContext* context, const IsTaskDoneRequest* request, IsTaskDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 is_task_done {};
      auto status = library_->IsTaskDone(task, &is_task_done);
      response->set_status(status);
      if (status == 0) {
        response->set_is_task_done(is_task_done);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::LoadTask(::grpc::ServerContext* context, const LoadTaskRequest* request, LoadTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_name = request->session_name().c_str();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->LoadTask(session_name, &task);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadAnalogF64(::grpc::ServerContext* context, const ReadAnalogF64Request* request, ReadAnalogF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadAnalogF64(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadAnalogScalarF64(::grpc::ServerContext* context, const ReadAnalogScalarF64Request* request, ReadAnalogScalarF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 value {};
      auto status = library_->ReadAnalogScalarF64(task, timeout, &value, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryI16(::grpc::ServerContext* context, const ReadBinaryI16Request* request, ReadBinaryI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryI16Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI16Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI16Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::vector<int16> read_array(array_size_in_samps);
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryI16(task, num_samps_per_chan, timeout, fill_mode, read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->mutable_read_array()->Clear();
        response->mutable_read_array()->Reserve(array_size_in_samps);
        std::transform(
          read_array.begin(),
          read_array.end(),
          google::protobuf::RepeatedFieldBackInserter(response->mutable_read_array()),
          [](auto x) { 
              return x;
          });
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryI32(::grpc::ServerContext* context, const ReadBinaryI32Request* request, ReadBinaryI32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryI32Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI32Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI32Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      int32* read_array = reinterpret_cast<int32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryI32(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryU16(::grpc::ServerContext* context, const ReadBinaryU16Request* request, ReadBinaryU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryU16Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU16Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU16Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::vector<uInt16> read_array(array_size_in_samps);
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryU16(task, num_samps_per_chan, timeout, fill_mode, read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->mutable_read_array()->Clear();
        response->mutable_read_array()->Reserve(array_size_in_samps);
        std::transform(
          read_array.begin(),
          read_array.end(),
          google::protobuf::RepeatedFieldBackInserter(response->mutable_read_array()),
          [](auto x) { 
              return x;
          });
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryU32(::grpc::ServerContext* context, const ReadBinaryU32Request* request, ReadBinaryU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryU32Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU32Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU32Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryU32(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterF64(::grpc::ServerContext* context, const ReadCounterF64Request* request, ReadCounterF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterF64(task, num_samps_per_chan, timeout, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterF64Ex(::grpc::ServerContext* context, const ReadCounterF64ExRequest* request, ReadCounterF64ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadCounterF64ExRequest::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadCounterF64ExRequest::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadCounterF64ExRequest::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterF64Ex(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterScalarF64(::grpc::ServerContext* context, const ReadCounterScalarF64Request* request, ReadCounterScalarF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 value {};
      auto status = library_->ReadCounterScalarF64(task, timeout, &value, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterScalarU32(::grpc::ServerContext* context, const ReadCounterScalarU32Request* request, ReadCounterScalarU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      uInt32 value {};
      auto status = library_->ReadCounterScalarU32(task, timeout, &value, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterU32(::grpc::ServerContext* context, const ReadCounterU32Request* request, ReadCounterU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterU32(task, num_samps_per_chan, timeout, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterU32Ex(::grpc::ServerContext* context, const ReadCounterU32ExRequest* request, ReadCounterU32ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadCounterU32ExRequest::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadCounterU32ExRequest::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadCounterU32ExRequest::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterU32Ex(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrFreq(::grpc::ServerContext* context, const ReadCtrFreqRequest* request, ReadCtrFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 interleaved;
      switch (request->interleaved_enum_case()) {
        case nidaqmx_grpc::ReadCtrFreqRequest::InterleavedEnumCase::kInterleaved: {
          interleaved = static_cast<int32>(request->interleaved());
          break;
        }
        case nidaqmx_grpc::ReadCtrFreqRequest::InterleavedEnumCase::kInterleavedRaw: {
          interleaved = static_cast<int32>(request->interleaved_raw());
          break;
        }
        case nidaqmx_grpc::ReadCtrFreqRequest::InterleavedEnumCase::INTERLEAVED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for interleaved was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array_frequency()->Resize(array_size_in_samps, 0);
      float64* read_array_frequency = response->mutable_read_array_frequency()->mutable_data();
      response->mutable_read_array_duty_cycle()->Resize(array_size_in_samps, 0);
      float64* read_array_duty_cycle = response->mutable_read_array_duty_cycle()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCtrFreq(task, num_samps_per_chan, timeout, interleaved, read_array_frequency, read_array_duty_cycle, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrFreqScalar(::grpc::ServerContext* context, const ReadCtrFreqScalarRequest* request, ReadCtrFreqScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 frequency {};
      float64 duty_cycle {};
      auto status = library_->ReadCtrFreqScalar(task, timeout, &frequency, &duty_cycle, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_frequency(frequency);
        response->set_duty_cycle(duty_cycle);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTicks(::grpc::ServerContext* context, const ReadCtrTicksRequest* request, ReadCtrTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 interleaved;
      switch (request->interleaved_enum_case()) {
        case nidaqmx_grpc::ReadCtrTicksRequest::InterleavedEnumCase::kInterleaved: {
          interleaved = static_cast<int32>(request->interleaved());
          break;
        }
        case nidaqmx_grpc::ReadCtrTicksRequest::InterleavedEnumCase::kInterleavedRaw: {
          interleaved = static_cast<int32>(request->interleaved_raw());
          break;
        }
        case nidaqmx_grpc::ReadCtrTicksRequest::InterleavedEnumCase::INTERLEAVED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for interleaved was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array_high_ticks()->Resize(array_size_in_samps, 0);
      uInt32* read_array_high_ticks = reinterpret_cast<uInt32*>(response->mutable_read_array_high_ticks()->mutable_data());
      response->mutable_read_array_low_ticks()->Resize(array_size_in_samps, 0);
      uInt32* read_array_low_ticks = reinterpret_cast<uInt32*>(response->mutable_read_array_low_ticks()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadCtrTicks(task, num_samps_per_chan, timeout, interleaved, read_array_high_ticks, read_array_low_ticks, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTicksScalar(::grpc::ServerContext* context, const ReadCtrTicksScalarRequest* request, ReadCtrTicksScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      uInt32 high_ticks {};
      uInt32 low_ticks {};
      auto status = library_->ReadCtrTicksScalar(task, timeout, &high_ticks, &low_ticks, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_high_ticks(high_ticks);
        response->set_low_ticks(low_ticks);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTime(::grpc::ServerContext* context, const ReadCtrTimeRequest* request, ReadCtrTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 interleaved;
      switch (request->interleaved_enum_case()) {
        case nidaqmx_grpc::ReadCtrTimeRequest::InterleavedEnumCase::kInterleaved: {
          interleaved = static_cast<int32>(request->interleaved());
          break;
        }
        case nidaqmx_grpc::ReadCtrTimeRequest::InterleavedEnumCase::kInterleavedRaw: {
          interleaved = static_cast<int32>(request->interleaved_raw());
          break;
        }
        case nidaqmx_grpc::ReadCtrTimeRequest::InterleavedEnumCase::INTERLEAVED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for interleaved was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array_high_time()->Resize(array_size_in_samps, 0);
      float64* read_array_high_time = response->mutable_read_array_high_time()->mutable_data();
      response->mutable_read_array_low_time()->Resize(array_size_in_samps, 0);
      float64* read_array_low_time = response->mutable_read_array_low_time()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCtrTime(task, num_samps_per_chan, timeout, interleaved, read_array_high_time, read_array_low_time, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTimeScalar(::grpc::ServerContext* context, const ReadCtrTimeScalarRequest* request, ReadCtrTimeScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 high_time {};
      float64 low_time {};
      auto status = library_->ReadCtrTimeScalar(task, timeout, &high_time, &low_time, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_high_time(high_time);
        response->set_low_time(low_time);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalLines(::grpc::ServerContext* context, const ReadDigitalLinesRequest* request, ReadDigitalLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalLinesRequest::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalLinesRequest::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalLinesRequest::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_bytes = request->array_size_in_bytes();
      auto reserved = nullptr;
      std::string read_array(array_size_in_bytes, '\0');
      int32 samps_per_chan_read {};
      int32 num_bytes_per_samp {};
      auto status = library_->ReadDigitalLines(task, num_samps_per_chan, timeout, fill_mode, (uInt8*)read_array.data(), array_size_in_bytes, &samps_per_chan_read, &num_bytes_per_samp, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_read_array(read_array);
        response->set_samps_per_chan_read(samps_per_chan_read);
        response->set_num_bytes_per_samp(num_bytes_per_samp);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalScalarU32(::grpc::ServerContext* context, const ReadDigitalScalarU32Request* request, ReadDigitalScalarU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      uInt32 value {};
      auto status = library_->ReadDigitalScalarU32(task, timeout, &value, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU16(::grpc::ServerContext* context, const ReadDigitalU16Request* request, ReadDigitalU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::vector<uInt16> read_array(array_size_in_samps);
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU16(task, num_samps_per_chan, timeout, fill_mode, read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->mutable_read_array()->Clear();
        response->mutable_read_array()->Reserve(array_size_in_samps);
        std::transform(
          read_array.begin(),
          read_array.end(),
          google::protobuf::RepeatedFieldBackInserter(response->mutable_read_array()),
          [](auto x) { 
              return x;
          });
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU32(::grpc::ServerContext* context, const ReadDigitalU32Request* request, ReadDigitalU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU32Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU32Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU32Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU32(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU8(::grpc::ServerContext* context, const ReadDigitalU8Request* request, ReadDigitalU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::string read_array(array_size_in_samps, '\0');
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU8(task, num_samps_per_chan, timeout, fill_mode, (uInt8*)read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_read_array(read_array);
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadRaw(::grpc::ServerContext* context, const ReadRawRequest* request, ReadRawResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      uInt32 array_size_in_bytes = request->array_size_in_bytes();
      auto reserved = nullptr;
      std::string read_array(array_size_in_bytes, '\0');
      int32 samps_read {};
      int32 num_bytes_per_samp {};
      auto status = library_->ReadRaw(task, num_samps_per_chan, timeout, (uInt8*)read_array.data(), array_size_in_bytes, &samps_read, &num_bytes_per_samp, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_read_array(read_array);
        response->set_samps_read(samps_read);
        response->set_num_bytes_per_samp(num_bytes_per_samp);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::ServerWriteReactor<RegisterDoneEventResponse>*
  NiDAQmxService::RegisterDoneEvent(::grpc::CallbackServerContext* context, const RegisterDoneEventRequest* request)
  {
    using CallbackRouter = nidevice_grpc::CallbackRouter<int32, TaskHandle, int32>;
    class RegisterDoneEventReactor : public nidevice_grpc::ServerWriterReactor<RegisterDoneEventResponse, nidevice_grpc::CallbackRegistration> {
    public:
    RegisterDoneEventReactor(const RegisterDoneEventRequest& request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository)
    {
      auto status = start(&request, library, session_repository);
      if (!status.ok()) {
        this->Finish(status);
      }
    }

    ::grpc::Status start(const RegisterDoneEventRequest* request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository_)
    {
      try {
        auto handler = CallbackRouter::register_handler(
          [this](TaskHandle task, int32 status) {
            RegisterDoneEventResponse callback_response;
            auto response = &callback_response;
            response->set_status(status);
            queue_write(callback_response);
            return 0;
        });

        auto task_grpc_session = request->task();
        TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
        uInt32 options = request->options();

        auto status = library->RegisterDoneEvent(task, options, CallbackRouter::handle_callback, handler->token());

        // SendInitialMetadata after the driver call so that WaitForInitialMetadata can be used to ensure that calls are serialized.
        StartSendInitialMetadata();

        if (status) {
          RegisterDoneEventResponse failed_to_register_response;
          failed_to_register_response.set_status(status);
          queue_write(failed_to_register_response);
        }

        this->set_producer(std::move(handler));
      }
      catch (nidevice_grpc::LibraryLoadException& ex) {
         return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
      }

      return ::grpc::Status::OK;
    }
    };

    return new RegisterDoneEventReactor(*request, library_, session_repository_);
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::ServerWriteReactor<RegisterEveryNSamplesEventResponse>*
  NiDAQmxService::RegisterEveryNSamplesEvent(::grpc::CallbackServerContext* context, const RegisterEveryNSamplesEventRequest* request)
  {
    using CallbackRouter = nidevice_grpc::CallbackRouter<int32, TaskHandle, int32, uInt32>;
    class RegisterEveryNSamplesEventReactor : public nidevice_grpc::ServerWriterReactor<RegisterEveryNSamplesEventResponse, nidevice_grpc::CallbackRegistration> {
    public:
    RegisterEveryNSamplesEventReactor(const RegisterEveryNSamplesEventRequest& request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository)
    {
      auto status = start(&request, library, session_repository);
      if (!status.ok()) {
        this->Finish(status);
      }
    }

    ::grpc::Status start(const RegisterEveryNSamplesEventRequest* request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository_)
    {
      try {
        auto handler = CallbackRouter::register_handler(
          [this](TaskHandle task, int32 every_n_samples_event_type, uInt32 n_samples) {
            RegisterEveryNSamplesEventResponse callback_response;
            auto response = &callback_response;
            response->set_every_n_samples_event_type(static_cast<nidaqmx_grpc::EveryNSamplesEventType>(every_n_samples_event_type));
            response->set_every_n_samples_event_type_raw(every_n_samples_event_type);
            response->set_n_samples(n_samples);
            queue_write(callback_response);
            return 0;
        });

        auto task_grpc_session = request->task();
        TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
        int32 every_n_samples_event_type;
        switch (request->every_n_samples_event_type_enum_case()) {
          case nidaqmx_grpc::RegisterEveryNSamplesEventRequest::EveryNSamplesEventTypeEnumCase::kEveryNSamplesEventType: {
            every_n_samples_event_type = static_cast<int32>(request->every_n_samples_event_type());
            break;
          }
          case nidaqmx_grpc::RegisterEveryNSamplesEventRequest::EveryNSamplesEventTypeEnumCase::kEveryNSamplesEventTypeRaw: {
            every_n_samples_event_type = static_cast<int32>(request->every_n_samples_event_type_raw());
            break;
          }
          case nidaqmx_grpc::RegisterEveryNSamplesEventRequest::EveryNSamplesEventTypeEnumCase::EVERY_N_SAMPLES_EVENT_TYPE_ENUM_NOT_SET: {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for every_n_samples_event_type was not specified or out of range");
            break;
          }
        }
  
        uInt32 n_samples = request->n_samples();
        uInt32 options = request->options();

        auto status = library->RegisterEveryNSamplesEvent(task, every_n_samples_event_type, n_samples, options, CallbackRouter::handle_callback, handler->token());

        // SendInitialMetadata after the driver call so that WaitForInitialMetadata can be used to ensure that calls are serialized.
        StartSendInitialMetadata();

        if (status) {
          RegisterEveryNSamplesEventResponse failed_to_register_response;
          failed_to_register_response.set_status(status);
          queue_write(failed_to_register_response);
        }

        this->set_producer(std::move(handler));
      }
      catch (nidevice_grpc::LibraryLoadException& ex) {
         return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
      }

      return ::grpc::Status::OK;
    }
    };

    return new RegisterEveryNSamplesEventReactor(*request, library_, session_repository_);
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::ServerWriteReactor<RegisterSignalEventResponse>*
  NiDAQmxService::RegisterSignalEvent(::grpc::CallbackServerContext* context, const RegisterSignalEventRequest* request)
  {
    using CallbackRouter = nidevice_grpc::CallbackRouter<int32, TaskHandle, int32>;
    class RegisterSignalEventReactor : public nidevice_grpc::ServerWriterReactor<RegisterSignalEventResponse, nidevice_grpc::CallbackRegistration> {
    public:
    RegisterSignalEventReactor(const RegisterSignalEventRequest& request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository)
    {
      auto status = start(&request, library, session_repository);
      if (!status.ok()) {
        this->Finish(status);
      }
    }

    ::grpc::Status start(const RegisterSignalEventRequest* request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository_)
    {
      try {
        auto handler = CallbackRouter::register_handler(
          [this](TaskHandle task, int32 signal_id) {
            RegisterSignalEventResponse callback_response;
            auto response = &callback_response;
            response->set_signal_id(signal_id);
            queue_write(callback_response);
            return 0;
        });

        auto task_grpc_session = request->task();
        TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
        int32 signal_id;
        switch (request->signal_id_enum_case()) {
          case nidaqmx_grpc::RegisterSignalEventRequest::SignalIdEnumCase::kSignalId: {
            signal_id = static_cast<int32>(request->signal_id());
            break;
          }
          case nidaqmx_grpc::RegisterSignalEventRequest::SignalIdEnumCase::kSignalIdRaw: {
            signal_id = static_cast<int32>(request->signal_id_raw());
            break;
          }
          case nidaqmx_grpc::RegisterSignalEventRequest::SignalIdEnumCase::SIGNAL_ID_ENUM_NOT_SET: {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_id was not specified or out of range");
            break;
          }
        }
  
        uInt32 options = request->options();

        auto status = library->RegisterSignalEvent(task, signal_id, options, CallbackRouter::handle_callback, handler->token());

        // SendInitialMetadata after the driver call so that WaitForInitialMetadata can be used to ensure that calls are serialized.
        StartSendInitialMetadata();

        if (status) {
          RegisterSignalEventResponse failed_to_register_response;
          failed_to_register_response.set_status(status);
          queue_write(failed_to_register_response);
        }

        this->set_producer(std::move(handler));
      }
      catch (nidevice_grpc::LibraryLoadException& ex) {
         return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
      }

      return ::grpc::Status::OK;
    }
    };

    return new RegisterSignalEventReactor(*request, library_, session_repository_);
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::RemoveCDAQSyncConnection(::grpc::ServerContext* context, const RemoveCDAQSyncConnectionRequest* request, RemoveCDAQSyncConnectionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto port_list = request->port_list().c_str();
      auto status = library_->RemoveCDAQSyncConnection(port_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReserveNetworkDevice(::grpc::ServerContext* context, const ReserveNetworkDeviceRequest* request, ReserveNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      bool32 override_reservation = request->override_reservation();
      auto status = library_->ReserveNetworkDevice(device_name, override_reservation);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDevice(::grpc::ServerContext* context, const ResetDeviceRequest* request, ResetDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->ResetDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SaveGlobalChan(::grpc::ServerContext* context, const SaveGlobalChanRequest* request, SaveGlobalChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      auto save_as = request->save_as().c_str();
      auto author = request->author().c_str();
      uInt32 options;
      switch (request->options_enum_case()) {
        case nidaqmx_grpc::SaveGlobalChanRequest::OptionsEnumCase::kOptions: {
          options = static_cast<uInt32>(request->options());
          break;
        }
        case nidaqmx_grpc::SaveGlobalChanRequest::OptionsEnumCase::kOptionsRaw: {
          options = static_cast<uInt32>(request->options_raw());
          break;
        }
        case nidaqmx_grpc::SaveGlobalChanRequest::OptionsEnumCase::OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for options was not specified or out of range");
          break;
        }
      }

      auto status = library_->SaveGlobalChan(task, channel_name, save_as, author, options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SaveScale(::grpc::ServerContext* context, const SaveScaleRequest* request, SaveScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      auto save_as = request->save_as().c_str();
      auto author = request->author().c_str();
      uInt32 options;
      switch (request->options_enum_case()) {
        case nidaqmx_grpc::SaveScaleRequest::OptionsEnumCase::kOptions: {
          options = static_cast<uInt32>(request->options());
          break;
        }
        case nidaqmx_grpc::SaveScaleRequest::OptionsEnumCase::kOptionsRaw: {
          options = static_cast<uInt32>(request->options_raw());
          break;
        }
        case nidaqmx_grpc::SaveScaleRequest::OptionsEnumCase::OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for options was not specified or out of range");
          break;
        }
      }

      auto status = library_->SaveScale(scale_name, save_as, author, options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SaveTask(::grpc::ServerContext* context, const SaveTaskRequest* request, SaveTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto save_as = request->save_as().c_str();
      auto author = request->author().c_str();
      uInt32 options;
      switch (request->options_enum_case()) {
        case nidaqmx_grpc::SaveTaskRequest::OptionsEnumCase::kOptions: {
          options = static_cast<uInt32>(request->options());
          break;
        }
        case nidaqmx_grpc::SaveTaskRequest::OptionsEnumCase::kOptionsRaw: {
          options = static_cast<uInt32>(request->options_raw());
          break;
        }
        case nidaqmx_grpc::SaveTaskRequest::OptionsEnumCase::OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for options was not specified or out of range");
          break;
        }
      }

      auto status = library_->SaveTask(task, save_as, author, options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SelfCal(::grpc::ServerContext* context, const SelfCalRequest* request, SelfCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->SelfCal(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SelfTestDevice(::grpc::ServerContext* context, const SelfTestDeviceRequest* request, SelfTestDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->SelfTestDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalCalDate(::grpc::ServerContext* context, const SetAIChanCalCalDateRequest* request, SetAIChanCalCalDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year = request->year();
      uInt32 month = request->month();
      uInt32 day = request->day();
      uInt32 hour = request->hour();
      uInt32 minute = request->minute();
      auto status = library_->SetAIChanCalCalDate(task, channel_name, year, month, day, hour, minute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalExpDate(::grpc::ServerContext* context, const SetAIChanCalExpDateRequest* request, SetAIChanCalExpDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year = request->year();
      uInt32 month = request->month();
      uInt32 day = request->day();
      uInt32 hour = request->hour();
      uInt32 minute = request->minute();
      auto status = library_->SetAIChanCalExpDate(task, channel_name, year, month, day, hour, minute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAnalogPowerUpStates(::grpc::ServerContext* context, const SetAnalogPowerUpStatesRequest* request, SetAnalogPowerUpStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto power_up_states = request->power_up_states();
      if (power_up_states.size() == 0) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "No values for powerUpStates were specified");
      }
      if (power_up_states.size() > 96) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "More than 96 values for powerUpStates were specified");
      }
      auto get_channelNames_if = [](const google::protobuf::RepeatedPtrField<AnalogPowerUpState>& vector, int n) -> const char* {
            if (vector.size() > n) {
                  return vector[n].channelnames().c_str();
            }
            return nullptr;
      };
      auto get_state_if = [](const google::protobuf::RepeatedPtrField<AnalogPowerUpState>& vector, int n) -> double {
            if (vector.size() > n) {
                  return vector[n].state();
            }
            return 0;
      };
      auto get_channelType_if = [](const google::protobuf::RepeatedPtrField<AnalogPowerUpState>& vector, int n) -> int32 {
            if (vector.size() > n) {
                  return vector[n].channeltype();
            }
            return 0;
      };

      auto status = ((NiDAQmxLibrary*)library_)->SetAnalogPowerUpStates(device_name, get_channelNames_if(power_up_states, 0), get_state_if(power_up_states, 0), get_channelType_if(power_up_states, 0), get_channelNames_if(power_up_states, 1), get_state_if(power_up_states, 1), get_channelType_if(power_up_states, 1), get_channelNames_if(power_up_states, 2), get_state_if(power_up_states, 2), get_channelType_if(power_up_states, 2), get_channelNames_if(power_up_states, 3), get_state_if(power_up_states, 3), get_channelType_if(power_up_states, 3), get_channelNames_if(power_up_states, 4), get_state_if(power_up_states, 4), get_channelType_if(power_up_states, 4), get_channelNames_if(power_up_states, 5), get_state_if(power_up_states, 5), get_channelType_if(power_up_states, 5), get_channelNames_if(power_up_states, 6), get_state_if(power_up_states, 6), get_channelType_if(power_up_states, 6), get_channelNames_if(power_up_states, 7), get_state_if(power_up_states, 7), get_channelType_if(power_up_states, 7), get_channelNames_if(power_up_states, 8), get_state_if(power_up_states, 8), get_channelType_if(power_up_states, 8), get_channelNames_if(power_up_states, 9), get_state_if(power_up_states, 9), get_channelType_if(power_up_states, 9), get_channelNames_if(power_up_states, 10), get_state_if(power_up_states, 10), get_channelType_if(power_up_states, 10), get_channelNames_if(power_up_states, 11), get_state_if(power_up_states, 11), get_channelType_if(power_up_states, 11), get_channelNames_if(power_up_states, 12), get_state_if(power_up_states, 12), get_channelType_if(power_up_states, 12), get_channelNames_if(power_up_states, 13), get_state_if(power_up_states, 13), get_channelType_if(power_up_states, 13), get_channelNames_if(power_up_states, 14), get_state_if(power_up_states, 14), get_channelType_if(power_up_states, 14), get_channelNames_if(power_up_states, 15), get_state_if(power_up_states, 15), get_channelType_if(power_up_states, 15), get_channelNames_if(power_up_states, 16), get_state_if(power_up_states, 16), get_channelType_if(power_up_states, 16), get_channelNames_if(power_up_states, 17), get_state_if(power_up_states, 17), get_channelType_if(power_up_states, 17), get_channelNames_if(power_up_states, 18), get_state_if(power_up_states, 18), get_channelType_if(power_up_states, 18), get_channelNames_if(power_up_states, 19), get_state_if(power_up_states, 19), get_channelType_if(power_up_states, 19), get_channelNames_if(power_up_states, 20), get_state_if(power_up_states, 20), get_channelType_if(power_up_states, 20), get_channelNames_if(power_up_states, 21), get_state_if(power_up_states, 21), get_channelType_if(power_up_states, 21), get_channelNames_if(power_up_states, 22), get_state_if(power_up_states, 22), get_channelType_if(power_up_states, 22), get_channelNames_if(power_up_states, 23), get_state_if(power_up_states, 23), get_channelType_if(power_up_states, 23), get_channelNames_if(power_up_states, 24), get_state_if(power_up_states, 24), get_channelType_if(power_up_states, 24), get_channelNames_if(power_up_states, 25), get_state_if(power_up_states, 25), get_channelType_if(power_up_states, 25), get_channelNames_if(power_up_states, 26), get_state_if(power_up_states, 26), get_channelType_if(power_up_states, 26), get_channelNames_if(power_up_states, 27), get_state_if(power_up_states, 27), get_channelType_if(power_up_states, 27), get_channelNames_if(power_up_states, 28), get_state_if(power_up_states, 28), get_channelType_if(power_up_states, 28), get_channelNames_if(power_up_states, 29), get_state_if(power_up_states, 29), get_channelType_if(power_up_states, 29), get_channelNames_if(power_up_states, 30), get_state_if(power_up_states, 30), get_channelType_if(power_up_states, 30), get_channelNames_if(power_up_states, 31), get_state_if(power_up_states, 31), get_channelType_if(power_up_states, 31), get_channelNames_if(power_up_states, 32), get_state_if(power_up_states, 32), get_channelType_if(power_up_states, 32), get_channelNames_if(power_up_states, 33), get_state_if(power_up_states, 33), get_channelType_if(power_up_states, 33), get_channelNames_if(power_up_states, 34), get_state_if(power_up_states, 34), get_channelType_if(power_up_states, 34), get_channelNames_if(power_up_states, 35), get_state_if(power_up_states, 35), get_channelType_if(power_up_states, 35), get_channelNames_if(power_up_states, 36), get_state_if(power_up_states, 36), get_channelType_if(power_up_states, 36), get_channelNames_if(power_up_states, 37), get_state_if(power_up_states, 37), get_channelType_if(power_up_states, 37), get_channelNames_if(power_up_states, 38), get_state_if(power_up_states, 38), get_channelType_if(power_up_states, 38), get_channelNames_if(power_up_states, 39), get_state_if(power_up_states, 39), get_channelType_if(power_up_states, 39), get_channelNames_if(power_up_states, 40), get_state_if(power_up_states, 40), get_channelType_if(power_up_states, 40), get_channelNames_if(power_up_states, 41), get_state_if(power_up_states, 41), get_channelType_if(power_up_states, 41), get_channelNames_if(power_up_states, 42), get_state_if(power_up_states, 42), get_channelType_if(power_up_states, 42), get_channelNames_if(power_up_states, 43), get_state_if(power_up_states, 43), get_channelType_if(power_up_states, 43), get_channelNames_if(power_up_states, 44), get_state_if(power_up_states, 44), get_channelType_if(power_up_states, 44), get_channelNames_if(power_up_states, 45), get_state_if(power_up_states, 45), get_channelType_if(power_up_states, 45), get_channelNames_if(power_up_states, 46), get_state_if(power_up_states, 46), get_channelType_if(power_up_states, 46), get_channelNames_if(power_up_states, 47), get_state_if(power_up_states, 47), get_channelType_if(power_up_states, 47), get_channelNames_if(power_up_states, 48), get_state_if(power_up_states, 48), get_channelType_if(power_up_states, 48), get_channelNames_if(power_up_states, 49), get_state_if(power_up_states, 49), get_channelType_if(power_up_states, 49), get_channelNames_if(power_up_states, 50), get_state_if(power_up_states, 50), get_channelType_if(power_up_states, 50), get_channelNames_if(power_up_states, 51), get_state_if(power_up_states, 51), get_channelType_if(power_up_states, 51), get_channelNames_if(power_up_states, 52), get_state_if(power_up_states, 52), get_channelType_if(power_up_states, 52), get_channelNames_if(power_up_states, 53), get_state_if(power_up_states, 53), get_channelType_if(power_up_states, 53), get_channelNames_if(power_up_states, 54), get_state_if(power_up_states, 54), get_channelType_if(power_up_states, 54), get_channelNames_if(power_up_states, 55), get_state_if(power_up_states, 55), get_channelType_if(power_up_states, 55), get_channelNames_if(power_up_states, 56), get_state_if(power_up_states, 56), get_channelType_if(power_up_states, 56), get_channelNames_if(power_up_states, 57), get_state_if(power_up_states, 57), get_channelType_if(power_up_states, 57), get_channelNames_if(power_up_states, 58), get_state_if(power_up_states, 58), get_channelType_if(power_up_states, 58), get_channelNames_if(power_up_states, 59), get_state_if(power_up_states, 59), get_channelType_if(power_up_states, 59), get_channelNames_if(power_up_states, 60), get_state_if(power_up_states, 60), get_channelType_if(power_up_states, 60), get_channelNames_if(power_up_states, 61), get_state_if(power_up_states, 61), get_channelType_if(power_up_states, 61), get_channelNames_if(power_up_states, 62), get_state_if(power_up_states, 62), get_channelType_if(power_up_states, 62), get_channelNames_if(power_up_states, 63), get_state_if(power_up_states, 63), get_channelType_if(power_up_states, 63), get_channelNames_if(power_up_states, 64), get_state_if(power_up_states, 64), get_channelType_if(power_up_states, 64), get_channelNames_if(power_up_states, 65), get_state_if(power_up_states, 65), get_channelType_if(power_up_states, 65), get_channelNames_if(power_up_states, 66), get_state_if(power_up_states, 66), get_channelType_if(power_up_states, 66), get_channelNames_if(power_up_states, 67), get_state_if(power_up_states, 67), get_channelType_if(power_up_states, 67), get_channelNames_if(power_up_states, 68), get_state_if(power_up_states, 68), get_channelType_if(power_up_states, 68), get_channelNames_if(power_up_states, 69), get_state_if(power_up_states, 69), get_channelType_if(power_up_states, 69), get_channelNames_if(power_up_states, 70), get_state_if(power_up_states, 70), get_channelType_if(power_up_states, 70), get_channelNames_if(power_up_states, 71), get_state_if(power_up_states, 71), get_channelType_if(power_up_states, 71), get_channelNames_if(power_up_states, 72), get_state_if(power_up_states, 72), get_channelType_if(power_up_states, 72), get_channelNames_if(power_up_states, 73), get_state_if(power_up_states, 73), get_channelType_if(power_up_states, 73), get_channelNames_if(power_up_states, 74), get_state_if(power_up_states, 74), get_channelType_if(power_up_states, 74), get_channelNames_if(power_up_states, 75), get_state_if(power_up_states, 75), get_channelType_if(power_up_states, 75), get_channelNames_if(power_up_states, 76), get_state_if(power_up_states, 76), get_channelType_if(power_up_states, 76), get_channelNames_if(power_up_states, 77), get_state_if(power_up_states, 77), get_channelType_if(power_up_states, 77), get_channelNames_if(power_up_states, 78), get_state_if(power_up_states, 78), get_channelType_if(power_up_states, 78), get_channelNames_if(power_up_states, 79), get_state_if(power_up_states, 79), get_channelType_if(power_up_states, 79), get_channelNames_if(power_up_states, 80), get_state_if(power_up_states, 80), get_channelType_if(power_up_states, 80), get_channelNames_if(power_up_states, 81), get_state_if(power_up_states, 81), get_channelType_if(power_up_states, 81), get_channelNames_if(power_up_states, 82), get_state_if(power_up_states, 82), get_channelType_if(power_up_states, 82), get_channelNames_if(power_up_states, 83), get_state_if(power_up_states, 83), get_channelType_if(power_up_states, 83), get_channelNames_if(power_up_states, 84), get_state_if(power_up_states, 84), get_channelType_if(power_up_states, 84), get_channelNames_if(power_up_states, 85), get_state_if(power_up_states, 85), get_channelType_if(power_up_states, 85), get_channelNames_if(power_up_states, 86), get_state_if(power_up_states, 86), get_channelType_if(power_up_states, 86), get_channelNames_if(power_up_states, 87), get_state_if(power_up_states, 87), get_channelType_if(power_up_states, 87), get_channelNames_if(power_up_states, 88), get_state_if(power_up_states, 88), get_channelType_if(power_up_states, 88), get_channelNames_if(power_up_states, 89), get_state_if(power_up_states, 89), get_channelType_if(power_up_states, 89), get_channelNames_if(power_up_states, 90), get_state_if(power_up_states, 90), get_channelType_if(power_up_states, 90), get_channelNames_if(power_up_states, 91), get_state_if(power_up_states, 91), get_channelType_if(power_up_states, 91), get_channelNames_if(power_up_states, 92), get_state_if(power_up_states, 92), get_channelType_if(power_up_states, 92), get_channelNames_if(power_up_states, 93), get_state_if(power_up_states, 93), get_channelType_if(power_up_states, 93), get_channelNames_if(power_up_states, 94), get_state_if(power_up_states, 94), get_channelType_if(power_up_states, 94), get_channelNames_if(power_up_states, 95), get_state_if(power_up_states, 95), get_channelType_if(power_up_states, 95));
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetArmStartTrigTrigWhen(::grpc::ServerContext* context, const SetArmStartTrigTrigWhenRequest* request, SetArmStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetArmStartTrigTrigWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDigitalLogicFamilyPowerUpState(::grpc::ServerContext* context, const SetDigitalLogicFamilyPowerUpStateRequest* request, SetDigitalLogicFamilyPowerUpStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 logic_family;
      switch (request->logic_family_enum_case()) {
        case nidaqmx_grpc::SetDigitalLogicFamilyPowerUpStateRequest::LogicFamilyEnumCase::kLogicFamily: {
          logic_family = static_cast<int32>(request->logic_family());
          break;
        }
        case nidaqmx_grpc::SetDigitalLogicFamilyPowerUpStateRequest::LogicFamilyEnumCase::kLogicFamilyRaw: {
          logic_family = static_cast<int32>(request->logic_family_raw());
          break;
        }
        case nidaqmx_grpc::SetDigitalLogicFamilyPowerUpStateRequest::LogicFamilyEnumCase::LOGIC_FAMILY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for logic_family was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDigitalLogicFamilyPowerUpState(device_name, logic_family);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetFirstSampClkWhen(::grpc::ServerContext* context, const SetFirstSampClkWhenRequest* request, SetFirstSampClkWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetFirstSampClkWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetScaleAttributeDouble(::grpc::ServerContext* context, const SetScaleAttributeDoubleRequest* request, SetScaleAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute = request->attribute();
      float64 value = request->value();
      auto status = library_->SetScaleAttributeDouble(scale_name, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetScaleAttributeInt32(::grpc::ServerContext* context, const SetScaleAttributeInt32Request* request, SetScaleAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute = request->attribute();
      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetScaleAttributeInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetScaleAttributeInt32(scale_name, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetStartTrigTrigWhen(::grpc::ServerContext* context, const SetStartTrigTrigWhenRequest* request, SetStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetStartTrigTrigWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetSyncPulseTimeWhen(::grpc::ServerContext* context, const SetSyncPulseTimeWhenRequest* request, SetSyncPulseTimeWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetSyncPulseTimeWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StartNewFile(::grpc::ServerContext* context, const StartNewFileRequest* request, StartNewFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->StartNewFile(task, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StartTask(::grpc::ServerContext* context, const StartTaskRequest* request, StartTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->StartTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StopTask(::grpc::ServerContext* context, const StopTaskRequest* request, StopTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->StopTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::TaskControl(::grpc::ServerContext* context, const TaskControlRequest* request, TaskControlResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 action;
      switch (request->action_enum_case()) {
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::kAction: {
          action = static_cast<int32>(request->action());
          break;
        }
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::kActionRaw: {
          action = static_cast<int32>(request->action_raw());
          break;
        }
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::ACTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for action was not specified or out of range");
          break;
        }
      }

      auto status = library_->TaskControl(task, action);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::TristateOutputTerm(::grpc::ServerContext* context, const TristateOutputTermRequest* request, TristateOutputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto output_terminal = request->output_terminal().c_str();
      auto status = library_->TristateOutputTerm(output_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::UnreserveNetworkDevice(::grpc::ServerContext* context, const UnreserveNetworkDeviceRequest* request, UnreserveNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->UnreserveNetworkDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WaitForNextSampleClock(::grpc::ServerContext* context, const WaitForNextSampleClockRequest* request, WaitForNextSampleClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      bool32 is_late {};
      auto status = library_->WaitForNextSampleClock(task, timeout, &is_late);
      response->set_status(status);
      if (status == 0) {
        response->set_is_late(is_late);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WaitForValidTimestamp(::grpc::ServerContext* context, const WaitForValidTimestampRequest* request, WaitForValidTimestampResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 timestamp_event;
      switch (request->timestamp_event_enum_case()) {
        case nidaqmx_grpc::WaitForValidTimestampRequest::TimestampEventEnumCase::kTimestampEvent: {
          timestamp_event = static_cast<int32>(request->timestamp_event());
          break;
        }
        case nidaqmx_grpc::WaitForValidTimestampRequest::TimestampEventEnumCase::kTimestampEventRaw: {
          timestamp_event = static_cast<int32>(request->timestamp_event_raw());
          break;
        }
        case nidaqmx_grpc::WaitForValidTimestampRequest::TimestampEventEnumCase::TIMESTAMP_EVENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timestamp_event was not specified or out of range");
          break;
        }
      }

      float64 timeout = request->timeout();
      CVIAbsoluteTime timestamp {};
      auto status = library_->WaitForValidTimestamp(task, timestamp_event, timeout, &timestamp);
      response->set_status(status);
      if (status == 0) {
        convert_to_grpc(timestamp, response->mutable_timestamp());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WaitUntilTaskDone(::grpc::ServerContext* context, const WaitUntilTaskDoneRequest* request, WaitUntilTaskDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 time_to_wait = request->time_to_wait();
      auto status = library_->WaitUntilTaskDone(task, time_to_wait);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteAnalogF64(::grpc::ServerContext* context, const WriteAnalogF64Request* request, WriteAnalogF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = const_cast<const float64*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteAnalogF64(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteAnalogScalarF64(::grpc::ServerContext* context, const WriteAnalogScalarF64Request* request, WriteAnalogScalarF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      float64 value = request->value();
      auto reserved = nullptr;
      auto status = library_->WriteAnalogScalarF64(task, auto_start, timeout, value, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryI16(::grpc::ServerContext* context, const WriteBinaryI16Request* request, WriteBinaryI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryI16Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI16Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI16Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array_raw = request->write_array();
      auto write_array = std::vector<int16>();
      write_array.reserve(write_array_raw.size());
      std::transform(
        write_array_raw.begin(),
        write_array_raw.end(),
        std::back_inserter(write_array),
        [](auto x) { 
              if (x < std::numeric_limits<int16>::min() || x > std::numeric_limits<int16>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("int16");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<int16>(x);
        });

      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryI16(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array.data(), &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryI32(::grpc::ServerContext* context, const WriteBinaryI32Request* request, WriteBinaryI32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryI32Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI32Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI32Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = const_cast<int32*>(reinterpret_cast<const int32*>(request->write_array().data()));
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryI32(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryU16(::grpc::ServerContext* context, const WriteBinaryU16Request* request, WriteBinaryU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryU16Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU16Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU16Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array_raw = request->write_array();
      auto write_array = std::vector<uInt16>();
      write_array.reserve(write_array_raw.size());
      std::transform(
        write_array_raw.begin(),
        write_array_raw.end(),
        std::back_inserter(write_array),
        [](auto x) { 
              if (x < std::numeric_limits<uInt16>::min() || x > std::numeric_limits<uInt16>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("uInt16");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<uInt16>(x);
        });

      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryU16(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array.data(), &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryU32(::grpc::ServerContext* context, const WriteBinaryU32Request* request, WriteBinaryU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryU32Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU32Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU32Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = reinterpret_cast<const uInt32*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryU32(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrFreq(::grpc::ServerContext* context, const WriteCtrFreqRequest* request, WriteCtrFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteCtrFreqRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteCtrFreqRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteCtrFreqRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto frequency = const_cast<const float64*>(request->frequency().data());
      auto duty_cycle = const_cast<const float64*>(request->duty_cycle().data());
      auto reserved = nullptr;
      int32 num_samps_per_chan_written {};
      auto status = library_->WriteCtrFreq(task, num_samps_per_chan, auto_start, timeout, data_layout, frequency, duty_cycle, &num_samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_num_samps_per_chan_written(num_samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrFreqScalar(::grpc::ServerContext* context, const WriteCtrFreqScalarRequest* request, WriteCtrFreqScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      float64 frequency = request->frequency();
      float64 duty_cycle = request->duty_cycle();
      auto reserved = nullptr;
      auto status = library_->WriteCtrFreqScalar(task, auto_start, timeout, frequency, duty_cycle, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTicks(::grpc::ServerContext* context, const WriteCtrTicksRequest* request, WriteCtrTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteCtrTicksRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteCtrTicksRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteCtrTicksRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto high_ticks = reinterpret_cast<const uInt32*>(request->high_ticks().data());
      auto low_ticks = reinterpret_cast<const uInt32*>(request->low_ticks().data());
      auto reserved = nullptr;
      int32 num_samps_per_chan_written {};
      auto status = library_->WriteCtrTicks(task, num_samps_per_chan, auto_start, timeout, data_layout, high_ticks, low_ticks, &num_samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_num_samps_per_chan_written(num_samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTicksScalar(::grpc::ServerContext* context, const WriteCtrTicksScalarRequest* request, WriteCtrTicksScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      uInt32 high_ticks = request->high_ticks();
      uInt32 low_ticks = request->low_ticks();
      auto reserved = nullptr;
      auto status = library_->WriteCtrTicksScalar(task, auto_start, timeout, high_ticks, low_ticks, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTime(::grpc::ServerContext* context, const WriteCtrTimeRequest* request, WriteCtrTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteCtrTimeRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteCtrTimeRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteCtrTimeRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto high_time = const_cast<const float64*>(request->high_time().data());
      auto low_time = const_cast<const float64*>(request->low_time().data());
      auto reserved = nullptr;
      int32 num_samps_per_chan_written {};
      auto status = library_->WriteCtrTime(task, num_samps_per_chan, auto_start, timeout, data_layout, high_time, low_time, &num_samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_num_samps_per_chan_written(num_samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTimeScalar(::grpc::ServerContext* context, const WriteCtrTimeScalarRequest* request, WriteCtrTimeScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      float64 high_time = request->high_time();
      float64 low_time = request->low_time();
      auto reserved = nullptr;
      auto status = library_->WriteCtrTimeScalar(task, auto_start, timeout, high_time, low_time, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalLines(::grpc::ServerContext* context, const WriteDigitalLinesRequest* request, WriteDigitalLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalLinesRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalLinesRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalLinesRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      const uInt8* write_array = (const uInt8*)request->write_array().c_str();
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalLines(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalScalarU32(::grpc::ServerContext* context, const WriteDigitalScalarU32Request* request, WriteDigitalScalarU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      uInt32 value = request->value();
      auto reserved = nullptr;
      auto status = library_->WriteDigitalScalarU32(task, auto_start, timeout, value, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU16(::grpc::ServerContext* context, const WriteDigitalU16Request* request, WriteDigitalU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array_raw = request->write_array();
      auto write_array = std::vector<uInt16>();
      write_array.reserve(write_array_raw.size());
      std::transform(
        write_array_raw.begin(),
        write_array_raw.end(),
        std::back_inserter(write_array),
        [](auto x) { 
              if (x < std::numeric_limits<uInt16>::min() || x > std::numeric_limits<uInt16>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("uInt16");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<uInt16>(x);
        });

      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU16(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array.data(), &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU32(::grpc::ServerContext* context, const WriteDigitalU32Request* request, WriteDigitalU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU32Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU32Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU32Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = reinterpret_cast<const uInt32*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU32(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU8(::grpc::ServerContext* context, const WriteDigitalU8Request* request, WriteDigitalU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      const uInt8* write_array = (const uInt8*)request->write_array().c_str();
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU8(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteRaw(::grpc::ServerContext* context, const WriteRawRequest* request, WriteRawResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps = request->num_samps();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      const uInt8* write_array = (const uInt8*)request->write_array().c_str();
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteRaw(task, num_samps, auto_start, timeout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteToTEDSFromArray(::grpc::ServerContext* context, const WriteToTEDSFromArrayRequest* request, WriteToTEDSFromArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      const uInt8* bit_stream = (const uInt8*)request->bit_stream().c_str();
      uInt32 array_size = request->array_size();
      int32 basic_teds_options;
      switch (request->basic_teds_options_enum_case()) {
        case nidaqmx_grpc::WriteToTEDSFromArrayRequest::BasicTedsOptionsEnumCase::kBasicTedsOptions: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromArrayRequest::BasicTedsOptionsEnumCase::kBasicTedsOptionsRaw: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options_raw());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromArrayRequest::BasicTedsOptionsEnumCase::BASIC_TEDS_OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for basic_teds_options was not specified or out of range");
          break;
        }
      }

      auto status = library_->WriteToTEDSFromArray(physical_channel, bit_stream, array_size, basic_teds_options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteToTEDSFromFile(::grpc::ServerContext* context, const WriteToTEDSFromFileRequest* request, WriteToTEDSFromFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      auto file_path = request->file_path().c_str();
      int32 basic_teds_options;
      switch (request->basic_teds_options_enum_case()) {
        case nidaqmx_grpc::WriteToTEDSFromFileRequest::BasicTedsOptionsEnumCase::kBasicTedsOptions: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromFileRequest::BasicTedsOptionsEnumCase::kBasicTedsOptionsRaw: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options_raw());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromFileRequest::BasicTedsOptionsEnumCase::BASIC_TEDS_OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for basic_teds_options was not specified or out of range");
          break;
        }
      }

      auto status = library_->WriteToTEDSFromFile(physical_channel, file_path, basic_teds_options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

} // namespace nidaqmx_grpc

