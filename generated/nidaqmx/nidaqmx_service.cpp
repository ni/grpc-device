
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-DAQMX Metadata
//---------------------------------------------------------------------
#include "nidaqmx_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>

namespace nidaqmx_grpc {

  NiDAQmxService::NiDAQmxService(NiDAQmxLibraryInterface* library, ResourceRepositorySharedPtr session_repository)
      : library_(library), session_repository_(session_repository)
  {
  }

  NiDAQmxService::~NiDAQmxService()
  {
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AddGlobalChansToTask(::grpc::ServerContext* context, const AddGlobalChansToTaskRequest* request, AddGlobalChansToTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto status = library_->AddGlobalChansToTask(task, channel_names);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ClearTask(::grpc::ServerContext* context, const ClearTaskRequest* request, ClearTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      session_repository_->remove_session(task);
      auto status = library_->ClearTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccel4WireDCVoltageChan(::grpc::ServerContext* context, const CreateAIAccel4WireDCVoltageChanRequest* request, CreateAIAccel4WireDCVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      bool32 use_excit_for_scaling = request->use_excit_for_scaling();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccel4WireDCVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, use_excit_for_scaling, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccelChan(::grpc::ServerContext* context, const CreateAIAccelChanRequest* request, CreateAIAccelChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccelChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccelChargeChan(::grpc::ServerContext* context, const CreateAIAccelChargeChanRequest* request, CreateAIAccelChargeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccelChargeChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIBridgeChan(::grpc::ServerContext* context, const CreateAIBridgeChanRequest* request, CreateAIBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIChargeChan(::grpc::ServerContext* context, const CreateAIChargeChanRequest* request, CreateAIChargeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIChargeChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAICurrentChan(::grpc::ServerContext* context, const CreateAICurrentChanRequest* request, CreateAICurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAICurrentChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAICurrentRMSChan(::grpc::ServerContext* context, const CreateAICurrentRMSChanRequest* request, CreateAICurrentRMSChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAICurrentRMSChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIFreqVoltageChan(::grpc::ServerContext* context, const CreateAIFreqVoltageChanRequest* request, CreateAIFreqVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 threshold_level = request->threshold_level();
      float64 hysteresis = request->hysteresis();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIFreqVoltageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, threshold_level, hysteresis, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIMicrophoneChan(::grpc::ServerContext* context, const CreateAIMicrophoneChanRequest* request, CreateAIMicrophoneChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 mic_sensitivity = request->mic_sensitivity();
      float64 max_snd_press_level = request->max_snd_press_level();
      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIMicrophoneChan(task, physical_channel, name_to_assign_to_channel, terminal_config, units, mic_sensitivity, max_snd_press_level, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosLVDTChan(::grpc::ServerContext* context, const CreateAIPosLVDTChanRequest* request, CreateAIPosLVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosLVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosRVDTChan(::grpc::ServerContext* context, const CreateAIPosRVDTChanRequest* request, CreateAIPosRVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosRVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIResistanceChan(::grpc::ServerContext* context, const CreateAIResistanceChanRequest* request, CreateAIResistanceChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIResistanceChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIStrainGageChan(::grpc::ServerContext* context, const CreateAIStrainGageChanRequest* request, CreateAIStrainGageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 strain_config;
      switch (request->strain_config_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::kStrainConfig: {
          strain_config = static_cast<int32>(request->strain_config());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::kStrainConfigRaw: {
          strain_config = static_cast<int32>(request->strain_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::STRAIN_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for strain_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 gage_factor = request->gage_factor();
      float64 initial_bridge_voltage = request->initial_bridge_voltage();
      float64 nominal_gage_resistance = request->nominal_gage_resistance();
      float64 poisson_ratio = request->poisson_ratio();
      float64 lead_wire_resistance = request->lead_wire_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIStrainGageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, strain_config, voltage_excit_source, voltage_excit_val, gage_factor, initial_bridge_voltage, nominal_gage_resistance, poisson_ratio, lead_wire_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVelocityIEPEChan(::grpc::ServerContext* context, const CreateAIVelocityIEPEChanRequest* request, CreateAIVelocityIEPEChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVelocityIEPEChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageChan(::grpc::ServerContext* context, const CreateAIVoltageChanRequest* request, CreateAIVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageRMSChan(::grpc::ServerContext* context, const CreateAIVoltageRMSChanRequest* request, CreateAIVoltageRMSChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageRMSChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOCurrentChan(::grpc::ServerContext* context, const CreateAOCurrentChanRequest* request, CreateAOCurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAOCurrentChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOFuncGenChan(::grpc::ServerContext* context, const CreateAOFuncGenChanRequest* request, CreateAOFuncGenChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 type;
      switch (request->type_enum_case()) {
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::kType: {
          type = static_cast<int32>(request->type());
          break;
        }
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::kTypeRaw: {
          type = static_cast<int32>(request->type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for type was not specified or out of range");
          break;
        }
      }

      float64 freq = request->freq();
      float64 amplitude = request->amplitude();
      float64 offset = request->offset();
      auto status = library_->CreateAOFuncGenChan(task, physical_channel, name_to_assign_to_channel, type, freq, amplitude, offset);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOVoltageChan(::grpc::ServerContext* context, const CreateAOVoltageChanRequest* request, CreateAOVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAOVoltageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIAngEncoderChan(::grpc::ServerContext* context, const CreateCIAngEncoderChanRequest* request, CreateCIAngEncoderChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      bool32 zidx_enable = request->zidx_enable();
      float64 zidx_val = request->zidx_val();
      int32 zidx_phase;
      switch (request->zidx_phase_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhase: {
          zidx_phase = static_cast<int32>(request->zidx_phase());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhaseRaw: {
          zidx_phase = static_cast<int32>(request->zidx_phase_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::ZIDX_PHASE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for zidx_phase was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      uInt32 pulses_per_rev = request->pulses_per_rev();
      float64 initial_angle = request->initial_angle();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIAngEncoderChan(task, counter, name_to_assign_to_channel, decoding_type, zidx_enable, zidx_val, zidx_phase, units, pulses_per_rev, initial_angle, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIAngVelocityChan(::grpc::ServerContext* context, const CreateCIAngVelocityChanRequest* request, CreateCIAngVelocityChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      uInt32 pulses_per_rev = request->pulses_per_rev();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIAngVelocityChan(task, counter, name_to_assign_to_channel, min_val, max_val, decoding_type, units, pulses_per_rev, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCICountEdgesChan(::grpc::ServerContext* context, const CreateCICountEdgesChanRequest* request, CreateCICountEdgesChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      uInt32 initial_count = request->initial_count();
      int32 count_direction;
      switch (request->count_direction_enum_case()) {
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::kCountDirection: {
          count_direction = static_cast<int32>(request->count_direction());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::kCountDirectionRaw: {
          count_direction = static_cast<int32>(request->count_direction_raw());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::COUNT_DIRECTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for count_direction was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCICountEdgesChan(task, counter, name_to_assign_to_channel, edge, initial_count, count_direction);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIDutyCycleChan(::grpc::ServerContext* context, const CreateCIDutyCycleChanRequest* request, CreateCIDutyCycleChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_freq = request->min_freq();
      float64 max_freq = request->max_freq();
      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIDutyCycleChan(task, counter, name_to_assign_to_channel, min_freq, max_freq, edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIFreqChan(::grpc::ServerContext* context, const CreateCIFreqChanRequest* request, CreateCIFreqChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      int32 meas_method;
      switch (request->meas_method_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::kMeasMethod: {
          meas_method = static_cast<int32>(request->meas_method());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::kMeasMethodRaw: {
          meas_method = static_cast<int32>(request->meas_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::MEAS_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for meas_method was not specified or out of range");
          break;
        }
      }

      float64 meas_time = request->meas_time();
      uInt32 divisor = request->divisor();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIFreqChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, edge, meas_method, meas_time, divisor, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIGPSTimestampChan(::grpc::ServerContext* context, const CreateCIGPSTimestampChanRequest* request, CreateCIGPSTimestampChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 sync_method;
      switch (request->sync_method_enum_case()) {
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::kSyncMethod: {
          sync_method = static_cast<int32>(request->sync_method());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::kSyncMethodRaw: {
          sync_method = static_cast<int32>(request->sync_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::SYNC_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sync_method was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIGPSTimestampChan(task, counter, name_to_assign_to_channel, units, sync_method, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCILinEncoderChan(::grpc::ServerContext* context, const CreateCILinEncoderChanRequest* request, CreateCILinEncoderChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      bool32 zidx_enable = request->zidx_enable();
      float64 zidx_val = request->zidx_val();
      int32 zidx_phase;
      switch (request->zidx_phase_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhase: {
          zidx_phase = static_cast<int32>(request->zidx_phase());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhaseRaw: {
          zidx_phase = static_cast<int32>(request->zidx_phase_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::ZIDX_PHASE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for zidx_phase was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 dist_per_pulse = request->dist_per_pulse();
      float64 initial_pos = request->initial_pos();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCILinEncoderChan(task, counter, name_to_assign_to_channel, decoding_type, zidx_enable, zidx_val, zidx_phase, units, dist_per_pulse, initial_pos, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCILinVelocityChan(::grpc::ServerContext* context, const CreateCILinVelocityChanRequest* request, CreateCILinVelocityChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 dist_per_pulse = request->dist_per_pulse();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCILinVelocityChan(task, counter, name_to_assign_to_channel, min_val, max_val, decoding_type, units, dist_per_pulse, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPeriodChan(::grpc::ServerContext* context, const CreateCIPeriodChanRequest* request, CreateCIPeriodChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      int32 meas_method;
      switch (request->meas_method_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::kMeasMethod: {
          meas_method = static_cast<int32>(request->meas_method());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::kMeasMethodRaw: {
          meas_method = static_cast<int32>(request->meas_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::MEAS_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for meas_method was not specified or out of range");
          break;
        }
      }

      float64 meas_time = request->meas_time();
      uInt32 divisor = request->divisor();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIPeriodChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, edge, meas_method, meas_time, divisor, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanFreq(::grpc::ServerContext* context, const CreateCIPulseChanFreqRequest* request, CreateCIPulseChanFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCIPulseChanFreq(task, counter, name_to_assign_to_channel, min_val, max_val, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanTicks(::grpc::ServerContext* context, const CreateCIPulseChanTicksRequest* request, CreateCIPulseChanTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      auto source_terminal = request->source_terminal().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      auto status = library_->CreateCIPulseChanTicks(task, counter, name_to_assign_to_channel, source_terminal, min_val, max_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanTime(::grpc::ServerContext* context, const CreateCIPulseChanTimeRequest* request, CreateCIPulseChanTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCIPulseChanTime(task, counter, name_to_assign_to_channel, min_val, max_val, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseWidthChan(::grpc::ServerContext* context, const CreateCIPulseWidthChanRequest* request, CreateCIPulseWidthChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 starting_edge;
      switch (request->starting_edge_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::kStartingEdge: {
          starting_edge = static_cast<int32>(request->starting_edge());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::kStartingEdgeRaw: {
          starting_edge = static_cast<int32>(request->starting_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::STARTING_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for starting_edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIPulseWidthChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, starting_edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCISemiPeriodChan(::grpc::ServerContext* context, const CreateCISemiPeriodChanRequest* request, CreateCISemiPeriodChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCISemiPeriodChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCITwoEdgeSepChan(::grpc::ServerContext* context, const CreateCITwoEdgeSepChanRequest* request, CreateCITwoEdgeSepChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 first_edge;
      switch (request->first_edge_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::kFirstEdge: {
          first_edge = static_cast<int32>(request->first_edge());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::kFirstEdgeRaw: {
          first_edge = static_cast<int32>(request->first_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::FIRST_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for first_edge was not specified or out of range");
          break;
        }
      }

      int32 second_edge;
      switch (request->second_edge_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::kSecondEdge: {
          second_edge = static_cast<int32>(request->second_edge());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::kSecondEdgeRaw: {
          second_edge = static_cast<int32>(request->second_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::SECOND_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for second_edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCITwoEdgeSepChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, first_edge, second_edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanFreq(::grpc::ServerContext* context, const CreateCOPulseChanFreqRequest* request, CreateCOPulseChanFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      float64 initial_delay = request->initial_delay();
      float64 freq = request->freq();
      float64 duty_cycle = request->duty_cycle();
      auto status = library_->CreateCOPulseChanFreq(task, counter, name_to_assign_to_channel, units, idle_state, initial_delay, freq, duty_cycle);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanTicks(::grpc::ServerContext* context, const CreateCOPulseChanTicksRequest* request, CreateCOPulseChanTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      auto source_terminal = request->source_terminal().c_str();
      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      int32 initial_delay = request->initial_delay();
      int32 low_ticks = request->low_ticks();
      int32 high_ticks = request->high_ticks();
      auto status = library_->CreateCOPulseChanTicks(task, counter, name_to_assign_to_channel, source_terminal, idle_state, initial_delay, low_ticks, high_ticks);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanTime(::grpc::ServerContext* context, const CreateCOPulseChanTimeRequest* request, CreateCOPulseChanTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      float64 initial_delay = request->initial_delay();
      float64 low_time = request->low_time();
      float64 high_time = request->high_time();
      auto status = library_->CreateCOPulseChanTime(task, counter, name_to_assign_to_channel, units, idle_state, initial_delay, low_time, high_time);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateDIChan(::grpc::ServerContext* context, const CreateDIChanRequest* request, CreateDIChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      auto name_to_assign_to_lines = request->name_to_assign_to_lines().c_str();
      int32 line_grouping;
      switch (request->line_grouping_enum_case()) {
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::kLineGrouping: {
          line_grouping = static_cast<int32>(request->line_grouping());
          break;
        }
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::kLineGroupingRaw: {
          line_grouping = static_cast<int32>(request->line_grouping_raw());
          break;
        }
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::LINE_GROUPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for line_grouping was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateDIChan(task, lines, name_to_assign_to_lines, line_grouping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateDOChan(::grpc::ServerContext* context, const CreateDOChanRequest* request, CreateDOChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      auto name_to_assign_to_lines = request->name_to_assign_to_lines().c_str();
      int32 line_grouping;
      switch (request->line_grouping_enum_case()) {
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::kLineGrouping: {
          line_grouping = static_cast<int32>(request->line_grouping());
          break;
        }
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::kLineGroupingRaw: {
          line_grouping = static_cast<int32>(request->line_grouping_raw());
          break;
        }
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::LINE_GROUPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for line_grouping was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateDOChan(task, lines, name_to_assign_to_lines, line_grouping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIAccelChan(::grpc::ServerContext* context, const CreateTEDSAIAccelChanRequest* request, CreateTEDSAIAccelChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIAccelChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIBridgeChan(::grpc::ServerContext* context, const CreateTEDSAIBridgeChanRequest* request, CreateTEDSAIBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAICurrentChan(::grpc::ServerContext* context, const CreateTEDSAICurrentChanRequest* request, CreateTEDSAICurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAICurrentChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPosLVDTChan(::grpc::ServerContext* context, const CreateTEDSAIPosLVDTChanRequest* request, CreateTEDSAIPosLVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPosLVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPosRVDTChan(::grpc::ServerContext* context, const CreateTEDSAIPosRVDTChanRequest* request, CreateTEDSAIPosRVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPosRVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIVoltageChan(::grpc::ServerContext* context, const CreateTEDSAIVoltageChanRequest* request, CreateTEDSAIVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTask(::grpc::ServerContext* context, const CreateTaskRequest* request, CreateTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_name = request->session_name().c_str();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->CreateTask(session_name, &task);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalCalDate(::grpc::ServerContext* context, const GetAIChanCalCalDateRequest* request, GetAIChanCalCalDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetAIChanCalCalDate(task, channel_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status == 0) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalExpDate(::grpc::ServerContext* context, const GetAIChanCalExpDateRequest* request, GetAIChanCalExpDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetAIChanCalExpDate(task, channel_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status == 0) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetErrorString(::grpc::ServerContext* context, const GetErrorStringRequest* request, GetErrorStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      int32 error_code = request->error_code();
      uInt32 buffer_size = request->buffer_size();
      std::string error_string;
      if (buffer_size > 0) {
          error_string.resize(buffer_size-1);
      }
      auto status = library_->GetErrorString(error_code, (char*)error_string.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_error_string(error_string);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskChannel(::grpc::ServerContext* context, const GetNthTaskChannelRequest* request, GetNthTaskChannelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();
      int32 buffer_size = request->buffer_size();
      std::string buffer;
      if (buffer_size > 0) {
          buffer.resize(buffer_size-1);
      }
      auto status = library_->GetNthTaskChannel(task, index, (char*)buffer.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_buffer(buffer);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskDevice(::grpc::ServerContext* context, const GetNthTaskDeviceRequest* request, GetNthTaskDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();
      int32 buffer_size = request->buffer_size();
      std::string buffer;
      if (buffer_size > 0) {
          buffer.resize(buffer_size-1);
      }
      auto status = library_->GetNthTaskDevice(task, index, (char*)buffer.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_buffer(buffer);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::IsTaskDone(::grpc::ServerContext* context, const IsTaskDoneRequest* request, IsTaskDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 is_task_done {};
      auto status = library_->IsTaskDone(task, &is_task_done);
      response->set_status(status);
      if (status == 0) {
        response->set_is_task_done(is_task_done);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadAnalogF64(::grpc::ServerContext* context, const ReadAnalogF64Request* request, ReadAnalogF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadAnalogF64(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU16(::grpc::ServerContext* context, const ReadDigitalU16Request* request, ReadDigitalU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::vector<uInt16> read_array(array_size_in_samps);
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU16(task, num_samps_per_chan, timeout, fill_mode, read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->mutable_read_array()->Clear();
        response->mutable_read_array()->Reserve(array_size_in_samps);
        std::transform(
          read_array.begin(),
          read_array.end(),
          google::protobuf::RepeatedFieldBackInserter(response->mutable_read_array()),
          [](auto x) { 
              return x;
          });
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU8(::grpc::ServerContext* context, const ReadDigitalU8Request* request, ReadDigitalU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::string read_array(array_size_in_samps, '\0');
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU8(task, num_samps_per_chan, timeout, fill_mode, (uInt8*)read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_read_array(read_array);
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalCalDate(::grpc::ServerContext* context, const SetAIChanCalCalDateRequest* request, SetAIChanCalCalDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year = request->year();
      uInt32 month = request->month();
      uInt32 day = request->day();
      uInt32 hour = request->hour();
      uInt32 minute = request->minute();
      auto status = library_->SetAIChanCalCalDate(task, channel_name, year, month, day, hour, minute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalExpDate(::grpc::ServerContext* context, const SetAIChanCalExpDateRequest* request, SetAIChanCalExpDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year = request->year();
      uInt32 month = request->month();
      uInt32 day = request->day();
      uInt32 hour = request->hour();
      uInt32 minute = request->minute();
      auto status = library_->SetAIChanCalExpDate(task, channel_name, year, month, day, hour, minute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StartTask(::grpc::ServerContext* context, const StartTaskRequest* request, StartTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->StartTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StopTask(::grpc::ServerContext* context, const StopTaskRequest* request, StopTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->StopTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::TaskControl(::grpc::ServerContext* context, const TaskControlRequest* request, TaskControlResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 action;
      switch (request->action_enum_case()) {
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::kAction: {
          action = static_cast<int32>(request->action());
          break;
        }
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::kActionRaw: {
          action = static_cast<int32>(request->action_raw());
          break;
        }
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::ACTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for action was not specified or out of range");
          break;
        }
      }

      auto status = library_->TaskControl(task, action);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WaitUntilTaskDone(::grpc::ServerContext* context, const WaitUntilTaskDoneRequest* request, WaitUntilTaskDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 time_to_wait = request->time_to_wait();
      auto status = library_->WaitUntilTaskDone(task, time_to_wait);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteAnalogF64(::grpc::ServerContext* context, const WriteAnalogF64Request* request, WriteAnalogF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = const_cast<const float64*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteAnalogF64(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU16(::grpc::ServerContext* context, const WriteDigitalU16Request* request, WriteDigitalU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array_raw = request->write_array();
      auto write_array = std::vector<uInt16>();
      write_array.reserve(write_array_raw.size());
      std::transform(
        write_array_raw.begin(),
        write_array_raw.end(),
        std::back_inserter(write_array),
        [](auto x) { 
              if (x < std::numeric_limits<uInt16>::min() || x > std::numeric_limits<uInt16>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("uInt16");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<uInt16>(x);
        });

      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU16(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array.data(), &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU8(::grpc::ServerContext* context, const WriteDigitalU8Request* request, WriteDigitalU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      const uInt8* write_array = (const uInt8*)request->write_array().c_str();
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU8(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

} // namespace nidaqmx_grpc

