
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-DAQMX Metadata
//---------------------------------------------------------------------
#include "nidaqmx_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>
#include <server/callback_router.h>
#include <server/server_reactor.h>
#include "nidaqmx_library.h"

namespace nidaqmx_grpc {

  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiDAQmxService::NiDAQmxService(
      NiDAQmxLibraryInterface* library,
      ResourceRepositorySharedPtr session_repository, 
      const NiDAQmxFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(session_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiDAQmxService::~NiDAQmxService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AddCDAQSyncConnection(::grpc::ServerContext* context, const AddCDAQSyncConnectionRequest* request, AddCDAQSyncConnectionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto port_list = request->port_list().c_str();
      auto status = library_->AddCDAQSyncConnection(port_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AddGlobalChansToTask(::grpc::ServerContext* context, const AddGlobalChansToTaskRequest* request, AddGlobalChansToTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto status = library_->AddGlobalChansToTask(task, channel_names);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AddNetworkDevice(::grpc::ServerContext* context, const AddNetworkDeviceRequest* request, AddNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto ip_address = request->ip_address().c_str();
      auto device_name = request->device_name().c_str();
      bool32 attempt_reservation = request->attempt_reservation();
      float64 timeout = request->timeout();

      while (true) {
        auto status = library_->AddNetworkDevice(ip_address, device_name, attempt_reservation, timeout, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 device_name_out_buffer_size = status;
      
        std::string device_name_out;
        if (device_name_out_buffer_size > 0) {
            device_name_out.resize(device_name_out_buffer_size - 1);
        }
        status = library_->AddNetworkDevice(ip_address, device_name, attempt_reservation, timeout, (char*)device_name_out.data(), device_name_out_buffer_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(device_name_out_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_device_name_out(device_name_out);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_device_name_out()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AreConfiguredCDAQSyncPortsDisconnected(::grpc::ServerContext* context, const AreConfiguredCDAQSyncPortsDisconnectedRequest* request, AreConfiguredCDAQSyncPortsDisconnectedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto chassis_devices_ports = request->chassis_devices_ports().c_str();
      float64 timeout = request->timeout();
      bool32 disconnected_ports_exist {};
      auto status = library_->AreConfiguredCDAQSyncPortsDisconnected(chassis_devices_ports, timeout, &disconnected_ports_exist);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_disconnected_ports_exist(disconnected_ports_exist);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::AutoConfigureCDAQSyncConnections(::grpc::ServerContext* context, const AutoConfigureCDAQSyncConnectionsRequest* request, AutoConfigureCDAQSyncConnectionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto chassis_devices_ports = request->chassis_devices_ports().c_str();
      float64 timeout = request->timeout();
      auto status = library_->AutoConfigureCDAQSyncConnections(chassis_devices_ports, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CalculateReversePolyCoeff(::grpc::ServerContext* context, const CalculateReversePolyCoeffRequest* request, CalculateReversePolyCoeffResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs_in = static_cast<uInt32>(request->forward_coeffs().size());
      float64 min_val_x = request->min_val_x();
      float64 max_val_x = request->max_val_x();
      int32 num_points_to_compute = request->num_points_to_compute();
      int32 reverse_poly_order = request->reverse_poly_order();
      response->mutable_reverse_coeffs()->Resize((reverse_poly_order < 0) ? num_forward_coeffs_in : reverse_poly_order + 1, 0);
      float64* reverse_coeffs = response->mutable_reverse_coeffs()->mutable_data();
      auto status = library_->CalculateReversePolyCoeff(forward_coeffs, num_forward_coeffs_in, min_val_x, max_val_x, num_points_to_compute, reverse_poly_order, reverse_coeffs);
      response->set_status(status);
      if (status_ok(status)) {
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgEdgeRefTrig(::grpc::ServerContext* context, const CfgAnlgEdgeRefTrigRequest* request, CfgAnlgEdgeRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_slope;
      switch (request->trigger_slope_enum_case()) {
        case nidaqmx_grpc::CfgAnlgEdgeRefTrigRequest::TriggerSlopeEnumCase::kTriggerSlope: {
          trigger_slope = static_cast<int32>(request->trigger_slope());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeRefTrigRequest::TriggerSlopeEnumCase::kTriggerSlopeRaw: {
          trigger_slope = static_cast<int32>(request->trigger_slope_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeRefTrigRequest::TriggerSlopeEnumCase::TRIGGER_SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_slope was not specified or out of range");
          break;
        }
      }

      float64 trigger_level = request->trigger_level();
      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgAnlgEdgeRefTrig(task, trigger_source, trigger_slope, trigger_level, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgEdgeStartTrig(::grpc::ServerContext* context, const CfgAnlgEdgeStartTrigRequest* request, CfgAnlgEdgeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_slope;
      switch (request->trigger_slope_enum_case()) {
        case nidaqmx_grpc::CfgAnlgEdgeStartTrigRequest::TriggerSlopeEnumCase::kTriggerSlope: {
          trigger_slope = static_cast<int32>(request->trigger_slope());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeStartTrigRequest::TriggerSlopeEnumCase::kTriggerSlopeRaw: {
          trigger_slope = static_cast<int32>(request->trigger_slope_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgEdgeStartTrigRequest::TriggerSlopeEnumCase::TRIGGER_SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_slope was not specified or out of range");
          break;
        }
      }

      float64 trigger_level = request->trigger_level();
      auto status = library_->CfgAnlgEdgeStartTrig(task, trigger_source, trigger_slope, trigger_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgMultiEdgeRefTrig(::grpc::ServerContext* context, const CfgAnlgMultiEdgeRefTrigRequest* request, CfgAnlgMultiEdgeRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_sources = request->trigger_sources().c_str();
      auto trigger_slope_array = reinterpret_cast<const int32*>(request->trigger_slope_array().data());
      auto trigger_level_array = const_cast<const float64*>(request->trigger_level_array().data());
      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->trigger_slope_array_size(),
        request->trigger_level_array_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, false);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [triggerSlopeArray, triggerLevelArray] do not match");
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->CfgAnlgMultiEdgeRefTrig(task, trigger_sources, trigger_slope_array, trigger_level_array, pretrigger_samples, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgMultiEdgeStartTrig(::grpc::ServerContext* context, const CfgAnlgMultiEdgeStartTrigRequest* request, CfgAnlgMultiEdgeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_sources = request->trigger_sources().c_str();
      auto trigger_slope_array = reinterpret_cast<const int32*>(request->trigger_slope_array().data());
      auto trigger_level_array = const_cast<const float64*>(request->trigger_level_array().data());
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->trigger_slope_array_size(),
        request->trigger_level_array_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, false);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [triggerSlopeArray, triggerLevelArray] do not match");
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->CfgAnlgMultiEdgeStartTrig(task, trigger_sources, trigger_slope_array, trigger_level_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgWindowRefTrig(::grpc::ServerContext* context, const CfgAnlgWindowRefTrigRequest* request, CfgAnlgWindowRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgAnlgWindowRefTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowRefTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowRefTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      float64 window_top = request->window_top();
      float64 window_bottom = request->window_bottom();
      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgAnlgWindowRefTrig(task, trigger_source, trigger_when, window_top, window_bottom, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgAnlgWindowStartTrig(::grpc::ServerContext* context, const CfgAnlgWindowStartTrigRequest* request, CfgAnlgWindowStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgAnlgWindowStartTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowStartTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgAnlgWindowStartTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      float64 window_top = request->window_top();
      float64 window_bottom = request->window_bottom();
      auto status = library_->CfgAnlgWindowStartTrig(task, trigger_source, trigger_when, window_top, window_bottom);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgBurstHandshakingTimingExportClock(::grpc::ServerContext* context, const CfgBurstHandshakingTimingExportClockRequest* request, CfgBurstHandshakingTimingExportClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      float64 sample_clk_rate = request->sample_clk_rate();
      auto sample_clk_outp_term = request->sample_clk_outp_term().c_str();
      int32 sample_clk_pulse_polarity;
      switch (request->sample_clk_pulse_polarity_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleClkPulsePolarityEnumCase::kSampleClkPulsePolarity: {
          sample_clk_pulse_polarity = static_cast<int32>(request->sample_clk_pulse_polarity());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleClkPulsePolarityEnumCase::kSampleClkPulsePolarityRaw: {
          sample_clk_pulse_polarity = static_cast<int32>(request->sample_clk_pulse_polarity_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::SampleClkPulsePolarityEnumCase::SAMPLE_CLK_PULSE_POLARITY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_clk_pulse_polarity was not specified or out of range");
          break;
        }
      }

      int32 pause_when;
      switch (request->pause_when_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::PauseWhenEnumCase::kPauseWhen: {
          pause_when = static_cast<int32>(request->pause_when());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::PauseWhenEnumCase::kPauseWhenRaw: {
          pause_when = static_cast<int32>(request->pause_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::PauseWhenEnumCase::PAUSE_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pause_when was not specified or out of range");
          break;
        }
      }

      int32 ready_event_active_level;
      switch (request->ready_event_active_level_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevel: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevelRaw: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingExportClockRequest::ReadyEventActiveLevelEnumCase::READY_EVENT_ACTIVE_LEVEL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ready_event_active_level was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgBurstHandshakingTimingExportClock(task, sample_mode, samps_per_chan, sample_clk_rate, sample_clk_outp_term, sample_clk_pulse_polarity, pause_when, ready_event_active_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgBurstHandshakingTimingImportClock(::grpc::ServerContext* context, const CfgBurstHandshakingTimingImportClockRequest* request, CfgBurstHandshakingTimingImportClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      float64 sample_clk_rate = request->sample_clk_rate();
      auto sample_clk_src = request->sample_clk_src().c_str();
      int32 sample_clk_active_edge;
      switch (request->sample_clk_active_edge_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleClkActiveEdgeEnumCase::kSampleClkActiveEdge: {
          sample_clk_active_edge = static_cast<int32>(request->sample_clk_active_edge());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleClkActiveEdgeEnumCase::kSampleClkActiveEdgeRaw: {
          sample_clk_active_edge = static_cast<int32>(request->sample_clk_active_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::SampleClkActiveEdgeEnumCase::SAMPLE_CLK_ACTIVE_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_clk_active_edge was not specified or out of range");
          break;
        }
      }

      int32 pause_when;
      switch (request->pause_when_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::PauseWhenEnumCase::kPauseWhen: {
          pause_when = static_cast<int32>(request->pause_when());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::PauseWhenEnumCase::kPauseWhenRaw: {
          pause_when = static_cast<int32>(request->pause_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::PauseWhenEnumCase::PAUSE_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pause_when was not specified or out of range");
          break;
        }
      }

      int32 ready_event_active_level;
      switch (request->ready_event_active_level_enum_case()) {
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevel: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::ReadyEventActiveLevelEnumCase::kReadyEventActiveLevelRaw: {
          ready_event_active_level = static_cast<int32>(request->ready_event_active_level_raw());
          break;
        }
        case nidaqmx_grpc::CfgBurstHandshakingTimingImportClockRequest::ReadyEventActiveLevelEnumCase::READY_EVENT_ACTIVE_LEVEL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ready_event_active_level was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgBurstHandshakingTimingImportClock(task, sample_mode, samps_per_chan, sample_clk_rate, sample_clk_src, sample_clk_active_edge, pause_when, ready_event_active_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgChangeDetectionTiming(::grpc::ServerContext* context, const CfgChangeDetectionTimingRequest* request, CfgChangeDetectionTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto rising_edge_chan = request->rising_edge_chan().c_str();
      auto falling_edge_chan = request->falling_edge_chan().c_str();
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgChangeDetectionTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgChangeDetectionTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgChangeDetectionTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgChangeDetectionTiming(task, rising_edge_chan, falling_edge_chan, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigEdgeRefTrig(::grpc::ServerContext* context, const CfgDigEdgeRefTrigRequest* request, CfgDigEdgeRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_edge;
      switch (request->trigger_edge_enum_case()) {
        case nidaqmx_grpc::CfgDigEdgeRefTrigRequest::TriggerEdgeEnumCase::kTriggerEdge: {
          trigger_edge = static_cast<int32>(request->trigger_edge());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeRefTrigRequest::TriggerEdgeEnumCase::kTriggerEdgeRaw: {
          trigger_edge = static_cast<int32>(request->trigger_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeRefTrigRequest::TriggerEdgeEnumCase::TRIGGER_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_edge was not specified or out of range");
          break;
        }
      }

      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgDigEdgeRefTrig(task, trigger_source, trigger_edge, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigEdgeStartTrig(::grpc::ServerContext* context, const CfgDigEdgeStartTrigRequest* request, CfgDigEdgeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      int32 trigger_edge;
      switch (request->trigger_edge_enum_case()) {
        case nidaqmx_grpc::CfgDigEdgeStartTrigRequest::TriggerEdgeEnumCase::kTriggerEdge: {
          trigger_edge = static_cast<int32>(request->trigger_edge());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeStartTrigRequest::TriggerEdgeEnumCase::kTriggerEdgeRaw: {
          trigger_edge = static_cast<int32>(request->trigger_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigEdgeStartTrigRequest::TriggerEdgeEnumCase::TRIGGER_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgDigEdgeStartTrig(task, trigger_source, trigger_edge);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigPatternRefTrig(::grpc::ServerContext* context, const CfgDigPatternRefTrigRequest* request, CfgDigPatternRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      auto trigger_pattern = request->trigger_pattern().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgDigPatternRefTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternRefTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternRefTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      uInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->CfgDigPatternRefTrig(task, trigger_source, trigger_pattern, trigger_when, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigPatternStartTrig(::grpc::ServerContext* context, const CfgDigPatternStartTrigRequest* request, CfgDigPatternStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      auto trigger_pattern = request->trigger_pattern().c_str();
      int32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nidaqmx_grpc::CfgDigPatternStartTrigRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<int32>(request->trigger_when());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternStartTrigRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<int32>(request->trigger_when_raw());
          break;
        }
        case nidaqmx_grpc::CfgDigPatternStartTrigRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgDigPatternStartTrig(task, trigger_source, trigger_pattern, trigger_when);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgHandshakingTiming(::grpc::ServerContext* context, const CfgHandshakingTimingRequest* request, CfgHandshakingTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgHandshakingTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgHandshakingTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgHandshakingTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgHandshakingTiming(task, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgImplicitTiming(::grpc::ServerContext* context, const CfgImplicitTimingRequest* request, CfgImplicitTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgImplicitTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgImplicitTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgImplicitTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgImplicitTiming(task, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgInputBuffer(::grpc::ServerContext* context, const CfgInputBufferRequest* request, CfgInputBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 num_samps_per_chan = request->num_samps_per_chan();
      auto status = library_->CfgInputBuffer(task, num_samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgOutputBuffer(::grpc::ServerContext* context, const CfgOutputBufferRequest* request, CfgOutputBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 num_samps_per_chan = request->num_samps_per_chan();
      auto status = library_->CfgOutputBuffer(task, num_samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgPipelinedSampClkTiming(::grpc::ServerContext* context, const CfgPipelinedSampClkTimingRequest* request, CfgPipelinedSampClkTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto source = request->source().c_str();
      float64 rate = request->rate();
      int32 active_edge;
      switch (request->active_edge_enum_case()) {
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdge: {
          active_edge = static_cast<int32>(request->active_edge());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdgeRaw: {
          active_edge = static_cast<int32>(request->active_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::ActiveEdgeEnumCase::ACTIVE_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for active_edge was not specified or out of range");
          break;
        }
      }

      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgPipelinedSampClkTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgPipelinedSampClkTiming(task, source, rate, active_edge, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgSampClkTiming(::grpc::ServerContext* context, const CfgSampClkTimingRequest* request, CfgSampClkTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto source = request->source().c_str();
      float64 rate = request->rate();
      int32 active_edge;
      switch (request->active_edge_enum_case()) {
        case nidaqmx_grpc::CfgSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdge: {
          active_edge = static_cast<int32>(request->active_edge());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::ActiveEdgeEnumCase::kActiveEdgeRaw: {
          active_edge = static_cast<int32>(request->active_edge_raw());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::ActiveEdgeEnumCase::ACTIVE_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for active_edge was not specified or out of range");
          break;
        }
      }

      int32 sample_mode;
      switch (request->sample_mode_enum_case()) {
        case nidaqmx_grpc::CfgSampClkTimingRequest::SampleModeEnumCase::kSampleMode: {
          sample_mode = static_cast<int32>(request->sample_mode());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::SampleModeEnumCase::kSampleModeRaw: {
          sample_mode = static_cast<int32>(request->sample_mode_raw());
          break;
        }
        case nidaqmx_grpc::CfgSampClkTimingRequest::SampleModeEnumCase::SAMPLE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_mode was not specified or out of range");
          break;
        }
      }

      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgSampClkTiming(task, source, rate, active_edge, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgTimeStartTrig(::grpc::ServerContext* context, const CfgTimeStartTrigRequest* request, CfgTimeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto when = convert_from_grpc<CVIAbsoluteTime>(request->when());
      int32 timescale;
      switch (request->timescale_enum_case()) {
        case nidaqmx_grpc::CfgTimeStartTrigRequest::TimescaleEnumCase::kTimescale: {
          timescale = static_cast<int32>(request->timescale());
          break;
        }
        case nidaqmx_grpc::CfgTimeStartTrigRequest::TimescaleEnumCase::kTimescaleRaw: {
          timescale = static_cast<int32>(request->timescale_raw());
          break;
        }
        case nidaqmx_grpc::CfgTimeStartTrigRequest::TimescaleEnumCase::TIMESCALE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timescale was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgTimeStartTrig(task, when, timescale);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgWatchdogAOExpirStates(::grpc::ServerContext* context, const CfgWatchdogAOExpirStatesRequest* request, CfgWatchdogAOExpirStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto expir_state_array = const_cast<const float64*>(request->expir_state_array().data());
      auto output_type_array_vector = std::vector<int32>();
      output_type_array_vector.reserve(request->output_type_array().size());
      std::transform(
        request->output_type_array().begin(),
        request->output_type_array().end(),
        std::back_inserter(output_type_array_vector),
        [](auto x) { return x; });
      auto output_type_array = output_type_array_vector.data();

      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->expir_state_array_size(),
        request->output_type_array_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, false);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [expirStateArray, outputTypeArray] do not match");
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->CfgWatchdogAOExpirStates(task, channel_names, expir_state_array, output_type_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgWatchdogCOExpirStates(::grpc::ServerContext* context, const CfgWatchdogCOExpirStatesRequest* request, CfgWatchdogCOExpirStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto expir_state_array_vector = std::vector<int32>();
      expir_state_array_vector.reserve(request->expir_state_array().size());
      std::transform(
        request->expir_state_array().begin(),
        request->expir_state_array().end(),
        std::back_inserter(expir_state_array_vector),
        [](auto x) { return x; });
      auto expir_state_array = expir_state_array_vector.data();

      uInt32 array_size = static_cast<uInt32>(request->expir_state_array().size());
      auto status = library_->CfgWatchdogCOExpirStates(task, channel_names, expir_state_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgWatchdogDOExpirStates(::grpc::ServerContext* context, const CfgWatchdogDOExpirStatesRequest* request, CfgWatchdogDOExpirStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_names = request->channel_names().c_str();
      auto expir_state_array_vector = std::vector<int32>();
      expir_state_array_vector.reserve(request->expir_state_array().size());
      std::transform(
        request->expir_state_array().begin(),
        request->expir_state_array().end(),
        std::back_inserter(expir_state_array_vector),
        [](auto x) { return x; });
      auto expir_state_array = expir_state_array_vector.data();

      uInt32 array_size = static_cast<uInt32>(request->expir_state_array().size());
      auto status = library_->CfgWatchdogDOExpirStates(task, channel_names, expir_state_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ClearTEDS(::grpc::ServerContext* context, const ClearTEDSRequest* request, ClearTEDSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      auto status = library_->ClearTEDS(physical_channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ClearTask(::grpc::ServerContext* context, const ClearTaskRequest* request, ClearTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      session_repository_->remove_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->ClearTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ConfigureLogging(::grpc::ServerContext* context, const ConfigureLoggingRequest* request, ConfigureLoggingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto file_path = request->file_path().c_str();
      int32 logging_mode;
      switch (request->logging_mode_enum_case()) {
        case nidaqmx_grpc::ConfigureLoggingRequest::LoggingModeEnumCase::kLoggingMode: {
          logging_mode = static_cast<int32>(request->logging_mode());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::LoggingModeEnumCase::kLoggingModeRaw: {
          logging_mode = static_cast<int32>(request->logging_mode_raw());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::LoggingModeEnumCase::LOGGING_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for logging_mode was not specified or out of range");
          break;
        }
      }

      auto group_name = request->group_name().c_str();
      int32 operation;
      switch (request->operation_enum_case()) {
        case nidaqmx_grpc::ConfigureLoggingRequest::OperationEnumCase::kOperation: {
          operation = static_cast<int32>(request->operation());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::OperationEnumCase::kOperationRaw: {
          operation = static_cast<int32>(request->operation_raw());
          break;
        }
        case nidaqmx_grpc::ConfigureLoggingRequest::OperationEnumCase::OPERATION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for operation was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureLogging(task, file_path, logging_mode, group_name, operation);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ConfigureTEDS(::grpc::ServerContext* context, const ConfigureTEDSRequest* request, ConfigureTEDSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      auto file_path = request->file_path().c_str();
      auto status = library_->ConfigureTEDS(physical_channel, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ConnectTerms(::grpc::ServerContext* context, const ConnectTermsRequest* request, ConnectTermsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto source_terminal = request->source_terminal().c_str();
      auto destination_terminal = request->destination_terminal().c_str();
      int32 signal_modifiers;
      switch (request->signal_modifiers_enum_case()) {
        case nidaqmx_grpc::ConnectTermsRequest::SignalModifiersEnumCase::kSignalModifiers: {
          signal_modifiers = static_cast<int32>(request->signal_modifiers());
          break;
        }
        case nidaqmx_grpc::ConnectTermsRequest::SignalModifiersEnumCase::kSignalModifiersRaw: {
          signal_modifiers = static_cast<int32>(request->signal_modifiers_raw());
          break;
        }
        case nidaqmx_grpc::ConnectTermsRequest::SignalModifiersEnumCase::SIGNAL_MODIFIERS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_modifiers was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConnectTerms(source_terminal, destination_terminal, signal_modifiers);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ControlWatchdogTask(::grpc::ServerContext* context, const ControlWatchdogTaskRequest* request, ControlWatchdogTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 action;
      switch (request->action_enum_case()) {
        case nidaqmx_grpc::ControlWatchdogTaskRequest::ActionEnumCase::kAction: {
          action = static_cast<int32>(request->action());
          break;
        }
        case nidaqmx_grpc::ControlWatchdogTaskRequest::ActionEnumCase::kActionRaw: {
          action = static_cast<int32>(request->action_raw());
          break;
        }
        case nidaqmx_grpc::ControlWatchdogTaskRequest::ActionEnumCase::ACTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for action was not specified or out of range");
          break;
        }
      }

      auto status = library_->ControlWatchdogTask(task, action);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccel4WireDCVoltageChan(::grpc::ServerContext* context, const CreateAIAccel4WireDCVoltageChanRequest* request, CreateAIAccel4WireDCVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccel4WireDCVoltageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      bool32 use_excit_for_scaling = request->use_excit_for_scaling();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccel4WireDCVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, use_excit_for_scaling, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccelChan(::grpc::ServerContext* context, const CreateAIAccelChanRequest* request, CreateAIAccelChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccelChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIAccelChargeChan(::grpc::ServerContext* context, const CreateAIAccelChargeChanRequest* request, CreateAIAccelChargeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIAccelChargeChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIAccelChargeChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIBridgeChan(::grpc::ServerContext* context, const CreateAIBridgeChanRequest* request, CreateAIBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIChargeChan(::grpc::ServerContext* context, const CreateAIChargeChanRequest* request, CreateAIChargeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIChargeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIChargeChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAICurrentChan(::grpc::ServerContext* context, const CreateAICurrentChanRequest* request, CreateAICurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAICurrentChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAICurrentRMSChan(::grpc::ServerContext* context, const CreateAICurrentRMSChanRequest* request, CreateAICurrentRMSChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateAICurrentRMSChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAICurrentRMSChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceBridgePolynomialChan(::grpc::ServerContext* context, const CreateAIForceBridgePolynomialChanRequest* request, CreateAIForceBridgePolynomialChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs = static_cast<uInt32>(request->forward_coeffs().size());
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs = static_cast<uInt32>(request->reverse_coeffs().size());
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgePolynomialChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceBridgePolynomialChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, num_forward_coeffs, reverse_coeffs, num_reverse_coeffs, electrical_units, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceBridgeTableChan(::grpc::ServerContext* context, const CreateAIForceBridgeTableChanRequest* request, CreateAIForceBridgeTableChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto electrical_vals = const_cast<const float64*>(request->electrical_vals().data());
      uInt32 num_electrical_vals = static_cast<uInt32>(request->electrical_vals().size());
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      auto physical_vals = const_cast<const float64*>(request->physical_vals().data());
      uInt32 num_physical_vals = static_cast<uInt32>(request->physical_vals().size());
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTableChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceBridgeTableChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, num_electrical_vals, electrical_units, physical_vals, num_physical_vals, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceBridgeTwoPointLinChan(::grpc::ServerContext* context, const CreateAIForceBridgeTwoPointLinChanRequest* request, CreateAIForceBridgeTwoPointLinChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      float64 first_electrical_val = request->first_electrical_val();
      float64 second_electrical_val = request->second_electrical_val();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      float64 first_physical_val = request->first_physical_val();
      float64 second_physical_val = request->second_physical_val();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceBridgeTwoPointLinChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIForceIEPEChan(::grpc::ServerContext* context, const CreateAIForceIEPEChanRequest* request, CreateAIForceIEPEChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIForceIEPEChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIFreqVoltageChan(::grpc::ServerContext* context, const CreateAIFreqVoltageChanRequest* request, CreateAIFreqVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIFreqVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 threshold_level = request->threshold_level();
      float64 hysteresis = request->hysteresis();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIFreqVoltageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, threshold_level, hysteresis, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIMicrophoneChan(::grpc::ServerContext* context, const CreateAIMicrophoneChanRequest* request, CreateAIMicrophoneChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 mic_sensitivity = request->mic_sensitivity();
      float64 max_snd_press_level = request->max_snd_press_level();
      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIMicrophoneChan(task, physical_channel, name_to_assign_to_channel, terminal_config, units, mic_sensitivity, max_snd_press_level, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosEddyCurrProxProbeChan(::grpc::ServerContext* context, const CreateAIPosEddyCurrProxProbeChanRequest* request, CreateAIPosEddyCurrProxProbeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosEddyCurrProxProbeChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosEddyCurrProxProbeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosLVDTChan(::grpc::ServerContext* context, const CreateAIPosLVDTChanRequest* request, CreateAIPosLVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosLVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosLVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPosRVDTChan(::grpc::ServerContext* context, const CreateAIPosRVDTChanRequest* request, CreateAIPosRVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPosRVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPosRVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPressureBridgePolynomialChan(::grpc::ServerContext* context, const CreateAIPressureBridgePolynomialChanRequest* request, CreateAIPressureBridgePolynomialChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs = static_cast<uInt32>(request->forward_coeffs().size());
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs = static_cast<uInt32>(request->reverse_coeffs().size());
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgePolynomialChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPressureBridgePolynomialChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, num_forward_coeffs, reverse_coeffs, num_reverse_coeffs, electrical_units, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPressureBridgeTableChan(::grpc::ServerContext* context, const CreateAIPressureBridgeTableChanRequest* request, CreateAIPressureBridgeTableChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto electrical_vals = const_cast<const float64*>(request->electrical_vals().data());
      uInt32 num_electrical_vals = static_cast<uInt32>(request->electrical_vals().size());
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      auto physical_vals = const_cast<const float64*>(request->physical_vals().data());
      uInt32 num_physical_vals = static_cast<uInt32>(request->physical_vals().size());
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTableChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPressureBridgeTableChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, num_electrical_vals, electrical_units, physical_vals, num_physical_vals, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIPressureBridgeTwoPointLinChan(::grpc::ServerContext* context, const CreateAIPressureBridgeTwoPointLinChanRequest* request, CreateAIPressureBridgeTwoPointLinChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      float64 first_electrical_val = request->first_electrical_val();
      float64 second_electrical_val = request->second_electrical_val();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      float64 first_physical_val = request->first_physical_val();
      float64 second_physical_val = request->second_physical_val();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIPressureBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIPressureBridgeTwoPointLinChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIRTDChan(::grpc::ServerContext* context, const CreateAIRTDChanRequest* request, CreateAIRTDChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 rtd_type;
      switch (request->rtd_type_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::RtdTypeEnumCase::kRtdType: {
          rtd_type = static_cast<int32>(request->rtd_type());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::RtdTypeEnumCase::kRtdTypeRaw: {
          rtd_type = static_cast<int32>(request->rtd_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::RtdTypeEnumCase::RTD_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rtd_type was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRTDChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      float64 r0 = request->r0();
      auto status = library_->CreateAIRTDChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, rtd_type, resistance_config, current_excit_source, current_excit_val, r0);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIResistanceChan(::grpc::ServerContext* context, const CreateAIResistanceChanRequest* request, CreateAIResistanceChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIResistanceChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIResistanceChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIRosetteStrainGageChan(::grpc::ServerContext* context, const CreateAIRosetteStrainGageChanRequest* request, CreateAIRosetteStrainGageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 rosette_type;
      switch (request->rosette_type_enum_case()) {
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::RosetteTypeEnumCase::kRosetteType: {
          rosette_type = static_cast<int32>(request->rosette_type());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::RosetteTypeEnumCase::kRosetteTypeRaw: {
          rosette_type = static_cast<int32>(request->rosette_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::RosetteTypeEnumCase::ROSETTE_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rosette_type was not specified or out of range");
          break;
        }
      }

      float64 gage_orientation = request->gage_orientation();
      auto rosette_meas_types = reinterpret_cast<const int32*>(request->rosette_meas_types().data());
      uInt32 num_rosette_meas_types = static_cast<uInt32>(request->rosette_meas_types().size());
      int32 strain_config;
      switch (request->strain_config_enum_case()) {
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::StrainConfigEnumCase::kStrainConfig: {
          strain_config = static_cast<int32>(request->strain_config());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::StrainConfigEnumCase::kStrainConfigRaw: {
          strain_config = static_cast<int32>(request->strain_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::StrainConfigEnumCase::STRAIN_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for strain_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIRosetteStrainGageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 gage_factor = request->gage_factor();
      float64 nominal_gage_resistance = request->nominal_gage_resistance();
      float64 poisson_ratio = request->poisson_ratio();
      float64 lead_wire_resistance = request->lead_wire_resistance();
      auto status = library_->CreateAIRosetteStrainGageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, rosette_type, gage_orientation, rosette_meas_types, num_rosette_meas_types, strain_config, voltage_excit_source, voltage_excit_val, gage_factor, nominal_gage_resistance, poisson_ratio, lead_wire_resistance);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIStrainGageChan(::grpc::ServerContext* context, const CreateAIStrainGageChanRequest* request, CreateAIStrainGageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 strain_config;
      switch (request->strain_config_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::kStrainConfig: {
          strain_config = static_cast<int32>(request->strain_config());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::kStrainConfigRaw: {
          strain_config = static_cast<int32>(request->strain_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::StrainConfigEnumCase::STRAIN_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for strain_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIStrainGageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 gage_factor = request->gage_factor();
      float64 initial_bridge_voltage = request->initial_bridge_voltage();
      float64 nominal_gage_resistance = request->nominal_gage_resistance();
      float64 poisson_ratio = request->poisson_ratio();
      float64 lead_wire_resistance = request->lead_wire_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIStrainGageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, strain_config, voltage_excit_source, voltage_excit_val, gage_factor, initial_bridge_voltage, nominal_gage_resistance, poisson_ratio, lead_wire_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITempBuiltInSensorChan(::grpc::ServerContext* context, const CreateAITempBuiltInSensorChanRequest* request, CreateAITempBuiltInSensorChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITempBuiltInSensorChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITempBuiltInSensorChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITempBuiltInSensorChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateAITempBuiltInSensorChan(task, physical_channel, name_to_assign_to_channel, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIThrmcplChan(::grpc::ServerContext* context, const CreateAIThrmcplChanRequest* request, CreateAIThrmcplChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 thermocouple_type;
      switch (request->thermocouple_type_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::ThermocoupleTypeEnumCase::kThermocoupleType: {
          thermocouple_type = static_cast<int32>(request->thermocouple_type());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::ThermocoupleTypeEnumCase::kThermocoupleTypeRaw: {
          thermocouple_type = static_cast<int32>(request->thermocouple_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::ThermocoupleTypeEnumCase::THERMOCOUPLE_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for thermocouple_type was not specified or out of range");
          break;
        }
      }

      int32 cjc_source;
      switch (request->cjc_source_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSource: {
          cjc_source = static_cast<int32>(request->cjc_source());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSourceRaw: {
          cjc_source = static_cast<int32>(request->cjc_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmcplChanRequest::CjcSourceEnumCase::CJC_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for cjc_source was not specified or out of range");
          break;
        }
      }

      float64 cjc_val = request->cjc_val();
      auto cjc_channel = request->cjc_channel().c_str();
      auto status = library_->CreateAIThrmcplChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, thermocouple_type, cjc_source, cjc_val, cjc_channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIThrmstrChanIex(::grpc::ServerContext* context, const CreateAIThrmstrChanIexRequest* request, CreateAIThrmstrChanIexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      float64 a = request->a();
      float64 b = request->b();
      float64 c = request->c();
      auto status = library_->CreateAIThrmstrChanIex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, a, b, c);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIThrmstrChanVex(::grpc::ServerContext* context, const CreateAIThrmstrChanVexRequest* request, CreateAIThrmstrChanVexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 a = request->a();
      float64 b = request->b();
      float64 c = request->c();
      float64 r1 = request->r1();
      auto status = library_->CreateAIThrmstrChanVex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, voltage_excit_source, voltage_excit_val, a, b, c, r1);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITorqueBridgePolynomialChan(::grpc::ServerContext* context, const CreateAITorqueBridgePolynomialChanRequest* request, CreateAITorqueBridgePolynomialChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs = static_cast<uInt32>(request->forward_coeffs().size());
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs = static_cast<uInt32>(request->reverse_coeffs().size());
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgePolynomialChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAITorqueBridgePolynomialChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, num_forward_coeffs, reverse_coeffs, num_reverse_coeffs, electrical_units, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITorqueBridgeTableChan(::grpc::ServerContext* context, const CreateAITorqueBridgeTableChanRequest* request, CreateAITorqueBridgeTableChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      auto electrical_vals = const_cast<const float64*>(request->electrical_vals().data());
      uInt32 num_electrical_vals = static_cast<uInt32>(request->electrical_vals().size());
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      auto physical_vals = const_cast<const float64*>(request->physical_vals().data());
      uInt32 num_physical_vals = static_cast<uInt32>(request->physical_vals().size());
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTableChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAITorqueBridgeTableChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, num_electrical_vals, electrical_units, physical_vals, num_physical_vals, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAITorqueBridgeTwoPointLinChan(::grpc::ServerContext* context, const CreateAITorqueBridgeTwoPointLinChanRequest* request, CreateAITorqueBridgeTwoPointLinChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 nominal_bridge_resistance = request->nominal_bridge_resistance();
      float64 first_electrical_val = request->first_electrical_val();
      float64 second_electrical_val = request->second_electrical_val();
      int32 electrical_units;
      switch (request->electrical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnits: {
          electrical_units = static_cast<int32>(request->electrical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::kElectricalUnitsRaw: {
          electrical_units = static_cast<int32>(request->electrical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::ElectricalUnitsEnumCase::ELECTRICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for electrical_units was not specified or out of range");
          break;
        }
      }

      float64 first_physical_val = request->first_physical_val();
      float64 second_physical_val = request->second_physical_val();
      int32 physical_units;
      switch (request->physical_units_enum_case()) {
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnits: {
          physical_units = static_cast<int32>(request->physical_units());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::kPhysicalUnitsRaw: {
          physical_units = static_cast<int32>(request->physical_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAITorqueBridgeTwoPointLinChanRequest::PhysicalUnitsEnumCase::PHYSICAL_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for physical_units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAITorqueBridgeTwoPointLinChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVelocityIEPEChan(::grpc::ServerContext* context, const CreateAIVelocityIEPEChanRequest* request, CreateAIVelocityIEPEChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 sensitivity = request->sensitivity();
      int32 sensitivity_units;
      switch (request->sensitivity_units_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnits: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::kSensitivityUnitsRaw: {
          sensitivity_units = static_cast<int32>(request->sensitivity_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::SensitivityUnitsEnumCase::SENSITIVITY_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sensitivity_units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVelocityIEPEChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVelocityIEPEChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageChan(::grpc::ServerContext* context, const CreateAIVoltageChanRequest* request, CreateAIVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageChanWithExcit(::grpc::ServerContext* context, const CreateAIVoltageChanWithExcitRequest* request, CreateAIVoltageChanWithExcitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 bridge_config;
      switch (request->bridge_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::BridgeConfigEnumCase::kBridgeConfig: {
          bridge_config = static_cast<int32>(request->bridge_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::BridgeConfigEnumCase::kBridgeConfigRaw: {
          bridge_config = static_cast<int32>(request->bridge_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::BridgeConfigEnumCase::BRIDGE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bridge_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      bool32 use_excit_for_scaling = request->use_excit_for_scaling();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageChanWithExcit(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, use_excit_for_scaling, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageRMSChan(::grpc::ServerContext* context, const CreateAIVoltageRMSChanRequest* request, CreateAIVoltageRMSChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAIVoltageRMSChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageRMSChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOCurrentChan(::grpc::ServerContext* context, const CreateAOCurrentChanRequest* request, CreateAOCurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOCurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAOCurrentChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOFuncGenChan(::grpc::ServerContext* context, const CreateAOFuncGenChanRequest* request, CreateAOFuncGenChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 type;
      switch (request->type_enum_case()) {
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::kType: {
          type = static_cast<int32>(request->type());
          break;
        }
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::kTypeRaw: {
          type = static_cast<int32>(request->type_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOFuncGenChanRequest::TypeEnumCase::TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for type was not specified or out of range");
          break;
        }
      }

      float64 freq = request->freq();
      float64 amplitude = request->amplitude();
      float64 offset = request->offset();
      auto status = library_->CreateAOFuncGenChan(task, physical_channel, name_to_assign_to_channel, type, freq, amplitude, offset);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOVoltageChan(::grpc::ServerContext* context, const CreateAOVoltageChanRequest* request, CreateAOVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateAOVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAOVoltageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIAngEncoderChan(::grpc::ServerContext* context, const CreateCIAngEncoderChanRequest* request, CreateCIAngEncoderChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      bool32 zidx_enable = request->zidx_enable();
      float64 zidx_val = request->zidx_val();
      int32 zidx_phase;
      switch (request->zidx_phase_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhase: {
          zidx_phase = static_cast<int32>(request->zidx_phase());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhaseRaw: {
          zidx_phase = static_cast<int32>(request->zidx_phase_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::ZidxPhaseEnumCase::ZIDX_PHASE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for zidx_phase was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngEncoderChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      uInt32 pulses_per_rev = request->pulses_per_rev();
      float64 initial_angle = request->initial_angle();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIAngEncoderChan(task, counter, name_to_assign_to_channel, decoding_type, zidx_enable, zidx_val, zidx_phase, units, pulses_per_rev, initial_angle, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIAngVelocityChan(::grpc::ServerContext* context, const CreateCIAngVelocityChanRequest* request, CreateCIAngVelocityChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIAngVelocityChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      uInt32 pulses_per_rev = request->pulses_per_rev();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIAngVelocityChan(task, counter, name_to_assign_to_channel, min_val, max_val, decoding_type, units, pulses_per_rev, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCICountEdgesChan(::grpc::ServerContext* context, const CreateCICountEdgesChanRequest* request, CreateCICountEdgesChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      uInt32 initial_count = request->initial_count();
      int32 count_direction;
      switch (request->count_direction_enum_case()) {
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::kCountDirection: {
          count_direction = static_cast<int32>(request->count_direction());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::kCountDirectionRaw: {
          count_direction = static_cast<int32>(request->count_direction_raw());
          break;
        }
        case nidaqmx_grpc::CreateCICountEdgesChanRequest::CountDirectionEnumCase::COUNT_DIRECTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for count_direction was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCICountEdgesChan(task, counter, name_to_assign_to_channel, edge, initial_count, count_direction);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIDutyCycleChan(::grpc::ServerContext* context, const CreateCIDutyCycleChanRequest* request, CreateCIDutyCycleChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_freq = request->min_freq();
      float64 max_freq = request->max_freq();
      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIDutyCycleChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIDutyCycleChan(task, counter, name_to_assign_to_channel, min_freq, max_freq, edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIFreqChan(::grpc::ServerContext* context, const CreateCIFreqChanRequest* request, CreateCIFreqChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      int32 meas_method;
      switch (request->meas_method_enum_case()) {
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::kMeasMethod: {
          meas_method = static_cast<int32>(request->meas_method());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::kMeasMethodRaw: {
          meas_method = static_cast<int32>(request->meas_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIFreqChanRequest::MeasMethodEnumCase::MEAS_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for meas_method was not specified or out of range");
          break;
        }
      }

      float64 meas_time = request->meas_time();
      uInt32 divisor = request->divisor();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIFreqChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, edge, meas_method, meas_time, divisor, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIGPSTimestampChan(::grpc::ServerContext* context, const CreateCIGPSTimestampChanRequest* request, CreateCIGPSTimestampChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 sync_method;
      switch (request->sync_method_enum_case()) {
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::kSyncMethod: {
          sync_method = static_cast<int32>(request->sync_method());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::kSyncMethodRaw: {
          sync_method = static_cast<int32>(request->sync_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIGPSTimestampChanRequest::SyncMethodEnumCase::SYNC_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sync_method was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIGPSTimestampChan(task, counter, name_to_assign_to_channel, units, sync_method, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCILinEncoderChan(::grpc::ServerContext* context, const CreateCILinEncoderChanRequest* request, CreateCILinEncoderChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      bool32 zidx_enable = request->zidx_enable();
      float64 zidx_val = request->zidx_val();
      int32 zidx_phase;
      switch (request->zidx_phase_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhase: {
          zidx_phase = static_cast<int32>(request->zidx_phase());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::kZidxPhaseRaw: {
          zidx_phase = static_cast<int32>(request->zidx_phase_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::ZidxPhaseEnumCase::ZIDX_PHASE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for zidx_phase was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinEncoderChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 dist_per_pulse = request->dist_per_pulse();
      float64 initial_pos = request->initial_pos();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCILinEncoderChan(task, counter, name_to_assign_to_channel, decoding_type, zidx_enable, zidx_val, zidx_phase, units, dist_per_pulse, initial_pos, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCILinVelocityChan(::grpc::ServerContext* context, const CreateCILinVelocityChanRequest* request, CreateCILinVelocityChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 decoding_type;
      switch (request->decoding_type_enum_case()) {
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::kDecodingType: {
          decoding_type = static_cast<int32>(request->decoding_type());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::kDecodingTypeRaw: {
          decoding_type = static_cast<int32>(request->decoding_type_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::DecodingTypeEnumCase::DECODING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for decoding_type was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCILinVelocityChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 dist_per_pulse = request->dist_per_pulse();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCILinVelocityChan(task, counter, name_to_assign_to_channel, min_val, max_val, decoding_type, units, dist_per_pulse, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPeriodChan(::grpc::ServerContext* context, const CreateCIPeriodChanRequest* request, CreateCIPeriodChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 edge;
      switch (request->edge_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<int32>(request->edge());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<int32>(request->edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      int32 meas_method;
      switch (request->meas_method_enum_case()) {
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::kMeasMethod: {
          meas_method = static_cast<int32>(request->meas_method());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::kMeasMethodRaw: {
          meas_method = static_cast<int32>(request->meas_method_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPeriodChanRequest::MeasMethodEnumCase::MEAS_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for meas_method was not specified or out of range");
          break;
        }
      }

      float64 meas_time = request->meas_time();
      uInt32 divisor = request->divisor();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIPeriodChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, edge, meas_method, meas_time, divisor, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanFreq(::grpc::ServerContext* context, const CreateCIPulseChanFreqRequest* request, CreateCIPulseChanFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanFreqRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCIPulseChanFreq(task, counter, name_to_assign_to_channel, min_val, max_val, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanTicks(::grpc::ServerContext* context, const CreateCIPulseChanTicksRequest* request, CreateCIPulseChanTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      auto source_terminal = request->source_terminal().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      auto status = library_->CreateCIPulseChanTicks(task, counter, name_to_assign_to_channel, source_terminal, min_val, max_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanTime(::grpc::ServerContext* context, const CreateCIPulseChanTimeRequest* request, CreateCIPulseChanTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseChanTimeRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCIPulseChanTime(task, counter, name_to_assign_to_channel, min_val, max_val, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseWidthChan(::grpc::ServerContext* context, const CreateCIPulseWidthChanRequest* request, CreateCIPulseWidthChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 starting_edge;
      switch (request->starting_edge_enum_case()) {
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::kStartingEdge: {
          starting_edge = static_cast<int32>(request->starting_edge());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::kStartingEdgeRaw: {
          starting_edge = static_cast<int32>(request->starting_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCIPulseWidthChanRequest::StartingEdgeEnumCase::STARTING_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for starting_edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCIPulseWidthChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, starting_edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCISemiPeriodChan(::grpc::ServerContext* context, const CreateCISemiPeriodChanRequest* request, CreateCISemiPeriodChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCISemiPeriodChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCISemiPeriodChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCITwoEdgeSepChan(::grpc::ServerContext* context, const CreateCITwoEdgeSepChanRequest* request, CreateCITwoEdgeSepChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 first_edge;
      switch (request->first_edge_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::kFirstEdge: {
          first_edge = static_cast<int32>(request->first_edge());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::kFirstEdgeRaw: {
          first_edge = static_cast<int32>(request->first_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::FirstEdgeEnumCase::FIRST_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for first_edge was not specified or out of range");
          break;
        }
      }

      int32 second_edge;
      switch (request->second_edge_enum_case()) {
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::kSecondEdge: {
          second_edge = static_cast<int32>(request->second_edge());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::kSecondEdgeRaw: {
          second_edge = static_cast<int32>(request->second_edge_raw());
          break;
        }
        case nidaqmx_grpc::CreateCITwoEdgeSepChanRequest::SecondEdgeEnumCase::SECOND_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for second_edge was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateCITwoEdgeSepChan(task, counter, name_to_assign_to_channel, min_val, max_val, units, first_edge, second_edge, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanFreq(::grpc::ServerContext* context, const CreateCOPulseChanFreqRequest* request, CreateCOPulseChanFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanFreqRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      float64 initial_delay = request->initial_delay();
      float64 freq = request->freq();
      float64 duty_cycle = request->duty_cycle();
      auto status = library_->CreateCOPulseChanFreq(task, counter, name_to_assign_to_channel, units, idle_state, initial_delay, freq, duty_cycle);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanTicks(::grpc::ServerContext* context, const CreateCOPulseChanTicksRequest* request, CreateCOPulseChanTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      auto source_terminal = request->source_terminal().c_str();
      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTicksRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      int32 initial_delay = request->initial_delay();
      int32 low_ticks = request->low_ticks();
      int32 high_ticks = request->high_ticks();
      auto status = library_->CreateCOPulseChanTicks(task, counter, name_to_assign_to_channel, source_terminal, idle_state, initial_delay, low_ticks, high_ticks);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCOPulseChanTime(::grpc::ServerContext* context, const CreateCOPulseChanTimeRequest* request, CreateCOPulseChanTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto counter = request->counter().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 idle_state;
      switch (request->idle_state_enum_case()) {
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::kIdleState: {
          idle_state = static_cast<int32>(request->idle_state());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::kIdleStateRaw: {
          idle_state = static_cast<int32>(request->idle_state_raw());
          break;
        }
        case nidaqmx_grpc::CreateCOPulseChanTimeRequest::IdleStateEnumCase::IDLE_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_state was not specified or out of range");
          break;
        }
      }

      float64 initial_delay = request->initial_delay();
      float64 low_time = request->low_time();
      float64 high_time = request->high_time();
      auto status = library_->CreateCOPulseChanTime(task, counter, name_to_assign_to_channel, units, idle_state, initial_delay, low_time, high_time);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateDIChan(::grpc::ServerContext* context, const CreateDIChanRequest* request, CreateDIChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      auto name_to_assign_to_lines = request->name_to_assign_to_lines().c_str();
      int32 line_grouping;
      switch (request->line_grouping_enum_case()) {
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::kLineGrouping: {
          line_grouping = static_cast<int32>(request->line_grouping());
          break;
        }
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::kLineGroupingRaw: {
          line_grouping = static_cast<int32>(request->line_grouping_raw());
          break;
        }
        case nidaqmx_grpc::CreateDIChanRequest::LineGroupingEnumCase::LINE_GROUPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for line_grouping was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateDIChan(task, lines, name_to_assign_to_lines, line_grouping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateDOChan(::grpc::ServerContext* context, const CreateDOChanRequest* request, CreateDOChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      auto name_to_assign_to_lines = request->name_to_assign_to_lines().c_str();
      int32 line_grouping;
      switch (request->line_grouping_enum_case()) {
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::kLineGrouping: {
          line_grouping = static_cast<int32>(request->line_grouping());
          break;
        }
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::kLineGroupingRaw: {
          line_grouping = static_cast<int32>(request->line_grouping_raw());
          break;
        }
        case nidaqmx_grpc::CreateDOChanRequest::LineGroupingEnumCase::LINE_GROUPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for line_grouping was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateDOChan(task, lines, name_to_assign_to_lines, line_grouping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateLinScale(::grpc::ServerContext* context, const CreateLinScaleRequest* request, CreateLinScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      float64 slope = request->slope();
      float64 y_intercept = request->y_intercept();
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreateLinScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreateLinScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateLinScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreateLinScale(name, slope, y_intercept, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateMapScale(::grpc::ServerContext* context, const CreateMapScaleRequest* request, CreateMapScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      float64 prescaled_min = request->prescaled_min();
      float64 prescaled_max = request->prescaled_max();
      float64 scaled_min = request->scaled_min();
      float64 scaled_max = request->scaled_max();
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreateMapScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreateMapScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateMapScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreateMapScale(name, prescaled_min, prescaled_max, scaled_min, scaled_max, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreatePolynomialScale(::grpc::ServerContext* context, const CreatePolynomialScaleRequest* request, CreatePolynomialScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      auto forward_coeffs = const_cast<const float64*>(request->forward_coeffs().data());
      uInt32 num_forward_coeffs_in = static_cast<uInt32>(request->forward_coeffs().size());
      auto reverse_coeffs = const_cast<const float64*>(request->reverse_coeffs().data());
      uInt32 num_reverse_coeffs_in = static_cast<uInt32>(request->reverse_coeffs().size());
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreatePolynomialScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreatePolynomialScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreatePolynomialScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreatePolynomialScale(name, forward_coeffs, num_forward_coeffs_in, reverse_coeffs, num_reverse_coeffs_in, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIAccelChan(::grpc::ServerContext* context, const CreateTEDSAIAccelChanRequest* request, CreateTEDSAIAccelChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIAccelChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIAccelChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIBridgeChan(::grpc::ServerContext* context, const CreateTEDSAIBridgeChanRequest* request, CreateTEDSAIBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAICurrentChan(::grpc::ServerContext* context, const CreateTEDSAICurrentChanRequest* request, CreateTEDSAICurrentChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 shunt_resistor_loc;
      switch (request->shunt_resistor_loc_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLoc: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::kShuntResistorLocRaw: {
          shunt_resistor_loc = static_cast<int32>(request->shunt_resistor_loc_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAICurrentChanRequest::ShuntResistorLocEnumCase::SHUNT_RESISTOR_LOC_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for shunt_resistor_loc was not specified or out of range");
          break;
        }
      }

      float64 ext_shunt_resistor_val = request->ext_shunt_resistor_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAICurrentChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIForceBridgeChan(::grpc::ServerContext* context, const CreateTEDSAIForceBridgeChanRequest* request, CreateTEDSAIForceBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIForceBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIForceIEPEChan(::grpc::ServerContext* context, const CreateTEDSAIForceIEPEChanRequest* request, CreateTEDSAIForceIEPEChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIForceIEPEChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIForceIEPEChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIMicrophoneChan(::grpc::ServerContext* context, const CreateTEDSAIMicrophoneChanRequest* request, CreateTEDSAIMicrophoneChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      float64 max_snd_press_level = request->max_snd_press_level();
      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIMicrophoneChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIMicrophoneChan(task, physical_channel, name_to_assign_to_channel, terminal_config, units, max_snd_press_level, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPosLVDTChan(::grpc::ServerContext* context, const CreateTEDSAIPosLVDTChanRequest* request, CreateTEDSAIPosLVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosLVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPosLVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPosRVDTChan(::grpc::ServerContext* context, const CreateTEDSAIPosRVDTChanRequest* request, CreateTEDSAIPosRVDTChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 voltage_excit_freq = request->voltage_excit_freq();
      int32 ac_excit_wire_mode;
      switch (request->ac_excit_wire_mode_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireMode: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::kAcExcitWireModeRaw: {
          ac_excit_wire_mode = static_cast<int32>(request->ac_excit_wire_mode_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPosRVDTChanRequest::AcExcitWireModeEnumCase::AC_EXCIT_WIRE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for ac_excit_wire_mode was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPosRVDTChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIPressureBridgeChan(::grpc::ServerContext* context, const CreateTEDSAIPressureBridgeChanRequest* request, CreateTEDSAIPressureBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIPressureBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIPressureBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIRTDChan(::grpc::ServerContext* context, const CreateTEDSAIRTDChanRequest* request, CreateTEDSAIRTDChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIRTDChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto status = library_->CreateTEDSAIRTDChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIResistanceChan(::grpc::ServerContext* context, const CreateTEDSAIResistanceChanRequest* request, CreateTEDSAIResistanceChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIResistanceChanRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIResistanceChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIStrainGageChan(::grpc::ServerContext* context, const CreateTEDSAIStrainGageChanRequest* request, CreateTEDSAIStrainGageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIStrainGageChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 initial_bridge_voltage = request->initial_bridge_voltage();
      float64 lead_wire_resistance = request->lead_wire_resistance();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIStrainGageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, initial_bridge_voltage, lead_wire_resistance, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIThrmcplChan(::grpc::ServerContext* context, const CreateTEDSAIThrmcplChanRequest* request, CreateTEDSAIThrmcplChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 cjc_source;
      switch (request->cjc_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSource: {
          cjc_source = static_cast<int32>(request->cjc_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::CjcSourceEnumCase::kCjcSourceRaw: {
          cjc_source = static_cast<int32>(request->cjc_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmcplChanRequest::CjcSourceEnumCase::CJC_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for cjc_source was not specified or out of range");
          break;
        }
      }

      float64 cjc_val = request->cjc_val();
      auto cjc_channel = request->cjc_channel().c_str();
      auto status = library_->CreateTEDSAIThrmcplChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, cjc_source, cjc_val, cjc_channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIThrmstrChanIex(::grpc::ServerContext* context, const CreateTEDSAIThrmstrChanIexRequest* request, CreateTEDSAIThrmstrChanIexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 current_excit_source;
      switch (request->current_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSource: {
          current_excit_source = static_cast<int32>(request->current_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::kCurrentExcitSourceRaw: {
          current_excit_source = static_cast<int32>(request->current_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanIexRequest::CurrentExcitSourceEnumCase::CURRENT_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for current_excit_source was not specified or out of range");
          break;
        }
      }

      float64 current_excit_val = request->current_excit_val();
      auto status = library_->CreateTEDSAIThrmstrChanIex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIThrmstrChanVex(::grpc::ServerContext* context, const CreateTEDSAIThrmstrChanVexRequest* request, CreateTEDSAIThrmstrChanVexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 resistance_config;
      switch (request->resistance_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfig: {
          resistance_config = static_cast<int32>(request->resistance_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::ResistanceConfigEnumCase::kResistanceConfigRaw: {
          resistance_config = static_cast<int32>(request->resistance_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::ResistanceConfigEnumCase::RESISTANCE_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for resistance_config was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIThrmstrChanVexRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      float64 r1 = request->r1();
      auto status = library_->CreateTEDSAIThrmstrChanVex(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, voltage_excit_source, voltage_excit_val, r1);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAITorqueBridgeChan(::grpc::ServerContext* context, const CreateTEDSAITorqueBridgeChanRequest* request, CreateTEDSAITorqueBridgeChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAITorqueBridgeChanRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAITorqueBridgeChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIVoltageChan(::grpc::ServerContext* context, const CreateTEDSAIVoltageChanRequest* request, CreateTEDSAIVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTEDSAIVoltageChanWithExcit(::grpc::ServerContext* context, const CreateTEDSAIVoltageChanWithExcitRequest* request, CreateTEDSAIVoltageChanWithExcitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto physical_channel = request->physical_channel().c_str();
      auto name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config;
      switch (request->terminal_config_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfig: {
          terminal_config = static_cast<int32>(request->terminal_config());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::kTerminalConfigRaw: {
          terminal_config = static_cast<int32>(request->terminal_config_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::TerminalConfigEnumCase::TERMINAL_CONFIG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for terminal_config was not specified or out of range");
          break;
        }
      }

      float64 min_val = request->min_val();
      float64 max_val = request->max_val();
      int32 units;
      switch (request->units_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnits: {
          units = static_cast<int32>(request->units());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<int32>(request->units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      int32 voltage_excit_source;
      switch (request->voltage_excit_source_enum_case()) {
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSource: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::kVoltageExcitSourceRaw: {
          voltage_excit_source = static_cast<int32>(request->voltage_excit_source_raw());
          break;
        }
        case nidaqmx_grpc::CreateTEDSAIVoltageChanWithExcitRequest::VoltageExcitSourceEnumCase::VOLTAGE_EXCIT_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for voltage_excit_source was not specified or out of range");
          break;
        }
      }

      float64 voltage_excit_val = request->voltage_excit_val();
      auto custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateTEDSAIVoltageChanWithExcit(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTableScale(::grpc::ServerContext* context, const CreateTableScaleRequest* request, CreateTableScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto name = request->name().c_str();
      auto prescaled_vals = const_cast<const float64*>(request->prescaled_vals().data());
      uInt32 num_prescaled_vals_in = static_cast<uInt32>(request->prescaled_vals().size());
      auto scaled_vals = const_cast<const float64*>(request->scaled_vals().data());
      uInt32 num_scaled_vals_in = static_cast<uInt32>(request->scaled_vals().size());
      int32 pre_scaled_units;
      switch (request->pre_scaled_units_enum_case()) {
        case nidaqmx_grpc::CreateTableScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnits: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units());
          break;
        }
        case nidaqmx_grpc::CreateTableScaleRequest::PreScaledUnitsEnumCase::kPreScaledUnitsRaw: {
          pre_scaled_units = static_cast<int32>(request->pre_scaled_units_raw());
          break;
        }
        case nidaqmx_grpc::CreateTableScaleRequest::PreScaledUnitsEnumCase::PRE_SCALED_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for pre_scaled_units was not specified or out of range");
          break;
        }
      }

      auto scaled_units = request->scaled_units().c_str();
      auto status = library_->CreateTableScale(name, prescaled_vals, num_prescaled_vals_in, scaled_vals, num_scaled_vals_in, pre_scaled_units, scaled_units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTask(::grpc::ServerContext* context, const CreateTaskRequest* request, CreateTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_name = request->session_name().c_str();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->CreateTask(session_name, &task);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateWatchdogTimerTask(::grpc::ServerContext* context, const CreateWatchdogTimerTaskRequest* request, CreateWatchdogTimerTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto session_name = request->session_name().c_str();
      float64 timeout = request->timeout();
      auto get_lines_if = [](const google::protobuf::RepeatedPtrField<WatchdogExpChannelsAndState>& vector, int n) -> const char* {
            if (vector.size() > n) {
                  return vector[n].lines().c_str();
            }
            return nullptr;
      };
      auto get_expState_if = [](const google::protobuf::RepeatedPtrField<WatchdogExpChannelsAndState>& vector, int n) -> int32 {
            if (vector.size() > n) {
                  return vector[n].exp_state();
            }
            return 0;
      };
      auto exp_states = request->exp_states();
      if (exp_states.size() == 0) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "No values for expStates were specified");
      }
      if (exp_states.size() > 96) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "More than 96 values for expStates were specified");
      }


      auto init_lambda = [&] () {
        TaskHandle task;
        int status = ((NiDAQmxLibrary*)library_)->CreateWatchdogTimerTask(device_name, session_name, &task, timeout, get_lines_if(exp_states, 0), get_expState_if(exp_states, 0), get_lines_if(exp_states, 1), get_expState_if(exp_states, 1), get_lines_if(exp_states, 2), get_expState_if(exp_states, 2), get_lines_if(exp_states, 3), get_expState_if(exp_states, 3), get_lines_if(exp_states, 4), get_expState_if(exp_states, 4), get_lines_if(exp_states, 5), get_expState_if(exp_states, 5), get_lines_if(exp_states, 6), get_expState_if(exp_states, 6), get_lines_if(exp_states, 7), get_expState_if(exp_states, 7), get_lines_if(exp_states, 8), get_expState_if(exp_states, 8), get_lines_if(exp_states, 9), get_expState_if(exp_states, 9), get_lines_if(exp_states, 10), get_expState_if(exp_states, 10), get_lines_if(exp_states, 11), get_expState_if(exp_states, 11), get_lines_if(exp_states, 12), get_expState_if(exp_states, 12), get_lines_if(exp_states, 13), get_expState_if(exp_states, 13), get_lines_if(exp_states, 14), get_expState_if(exp_states, 14), get_lines_if(exp_states, 15), get_expState_if(exp_states, 15), get_lines_if(exp_states, 16), get_expState_if(exp_states, 16), get_lines_if(exp_states, 17), get_expState_if(exp_states, 17), get_lines_if(exp_states, 18), get_expState_if(exp_states, 18), get_lines_if(exp_states, 19), get_expState_if(exp_states, 19), get_lines_if(exp_states, 20), get_expState_if(exp_states, 20), get_lines_if(exp_states, 21), get_expState_if(exp_states, 21), get_lines_if(exp_states, 22), get_expState_if(exp_states, 22), get_lines_if(exp_states, 23), get_expState_if(exp_states, 23), get_lines_if(exp_states, 24), get_expState_if(exp_states, 24), get_lines_if(exp_states, 25), get_expState_if(exp_states, 25), get_lines_if(exp_states, 26), get_expState_if(exp_states, 26), get_lines_if(exp_states, 27), get_expState_if(exp_states, 27), get_lines_if(exp_states, 28), get_expState_if(exp_states, 28), get_lines_if(exp_states, 29), get_expState_if(exp_states, 29), get_lines_if(exp_states, 30), get_expState_if(exp_states, 30), get_lines_if(exp_states, 31), get_expState_if(exp_states, 31), get_lines_if(exp_states, 32), get_expState_if(exp_states, 32), get_lines_if(exp_states, 33), get_expState_if(exp_states, 33), get_lines_if(exp_states, 34), get_expState_if(exp_states, 34), get_lines_if(exp_states, 35), get_expState_if(exp_states, 35), get_lines_if(exp_states, 36), get_expState_if(exp_states, 36), get_lines_if(exp_states, 37), get_expState_if(exp_states, 37), get_lines_if(exp_states, 38), get_expState_if(exp_states, 38), get_lines_if(exp_states, 39), get_expState_if(exp_states, 39), get_lines_if(exp_states, 40), get_expState_if(exp_states, 40), get_lines_if(exp_states, 41), get_expState_if(exp_states, 41), get_lines_if(exp_states, 42), get_expState_if(exp_states, 42), get_lines_if(exp_states, 43), get_expState_if(exp_states, 43), get_lines_if(exp_states, 44), get_expState_if(exp_states, 44), get_lines_if(exp_states, 45), get_expState_if(exp_states, 45), get_lines_if(exp_states, 46), get_expState_if(exp_states, 46), get_lines_if(exp_states, 47), get_expState_if(exp_states, 47), get_lines_if(exp_states, 48), get_expState_if(exp_states, 48), get_lines_if(exp_states, 49), get_expState_if(exp_states, 49), get_lines_if(exp_states, 50), get_expState_if(exp_states, 50), get_lines_if(exp_states, 51), get_expState_if(exp_states, 51), get_lines_if(exp_states, 52), get_expState_if(exp_states, 52), get_lines_if(exp_states, 53), get_expState_if(exp_states, 53), get_lines_if(exp_states, 54), get_expState_if(exp_states, 54), get_lines_if(exp_states, 55), get_expState_if(exp_states, 55), get_lines_if(exp_states, 56), get_expState_if(exp_states, 56), get_lines_if(exp_states, 57), get_expState_if(exp_states, 57), get_lines_if(exp_states, 58), get_expState_if(exp_states, 58), get_lines_if(exp_states, 59), get_expState_if(exp_states, 59), get_lines_if(exp_states, 60), get_expState_if(exp_states, 60), get_lines_if(exp_states, 61), get_expState_if(exp_states, 61), get_lines_if(exp_states, 62), get_expState_if(exp_states, 62), get_lines_if(exp_states, 63), get_expState_if(exp_states, 63), get_lines_if(exp_states, 64), get_expState_if(exp_states, 64), get_lines_if(exp_states, 65), get_expState_if(exp_states, 65), get_lines_if(exp_states, 66), get_expState_if(exp_states, 66), get_lines_if(exp_states, 67), get_expState_if(exp_states, 67), get_lines_if(exp_states, 68), get_expState_if(exp_states, 68), get_lines_if(exp_states, 69), get_expState_if(exp_states, 69), get_lines_if(exp_states, 70), get_expState_if(exp_states, 70), get_lines_if(exp_states, 71), get_expState_if(exp_states, 71), get_lines_if(exp_states, 72), get_expState_if(exp_states, 72), get_lines_if(exp_states, 73), get_expState_if(exp_states, 73), get_lines_if(exp_states, 74), get_expState_if(exp_states, 74), get_lines_if(exp_states, 75), get_expState_if(exp_states, 75), get_lines_if(exp_states, 76), get_expState_if(exp_states, 76), get_lines_if(exp_states, 77), get_expState_if(exp_states, 77), get_lines_if(exp_states, 78), get_expState_if(exp_states, 78), get_lines_if(exp_states, 79), get_expState_if(exp_states, 79), get_lines_if(exp_states, 80), get_expState_if(exp_states, 80), get_lines_if(exp_states, 81), get_expState_if(exp_states, 81), get_lines_if(exp_states, 82), get_expState_if(exp_states, 82), get_lines_if(exp_states, 83), get_expState_if(exp_states, 83), get_lines_if(exp_states, 84), get_expState_if(exp_states, 84), get_lines_if(exp_states, 85), get_expState_if(exp_states, 85), get_lines_if(exp_states, 86), get_expState_if(exp_states, 86), get_lines_if(exp_states, 87), get_expState_if(exp_states, 87), get_lines_if(exp_states, 88), get_expState_if(exp_states, 88), get_lines_if(exp_states, 89), get_expState_if(exp_states, 89), get_lines_if(exp_states, 90), get_expState_if(exp_states, 90), get_lines_if(exp_states, 91), get_expState_if(exp_states, 91), get_lines_if(exp_states, 92), get_expState_if(exp_states, 92), get_lines_if(exp_states, 93), get_expState_if(exp_states, 93), get_lines_if(exp_states, 94), get_expState_if(exp_states, 94), get_lines_if(exp_states, 95), get_expState_if(exp_states, 95), get_lines_if(exp_states, 96), get_expState_if(exp_states, 96));
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateWatchdogTimerTaskEx(::grpc::ServerContext* context, const CreateWatchdogTimerTaskExRequest* request, CreateWatchdogTimerTaskExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto session_name = request->session_name().c_str();
      float64 timeout = request->timeout();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->CreateWatchdogTimerTaskEx(device_name, session_name, &task, timeout);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteNetworkDevice(::grpc::ServerContext* context, const DeleteNetworkDeviceRequest* request, DeleteNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->DeleteNetworkDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteSavedGlobalChan(::grpc::ServerContext* context, const DeleteSavedGlobalChanRequest* request, DeleteSavedGlobalChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto channel_name = request->channel_name().c_str();
      auto status = library_->DeleteSavedGlobalChan(channel_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteSavedScale(::grpc::ServerContext* context, const DeleteSavedScaleRequest* request, DeleteSavedScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      auto status = library_->DeleteSavedScale(scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeleteSavedTask(::grpc::ServerContext* context, const DeleteSavedTaskRequest* request, DeleteSavedTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_name = request->task_name().c_str();
      auto status = library_->DeleteSavedTask(task_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DeviceSupportsCal(::grpc::ServerContext* context, const DeviceSupportsCalRequest* request, DeviceSupportsCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      bool32 cal_supported {};
      auto status = library_->DeviceSupportsCal(device_name, &cal_supported);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_cal_supported(cal_supported);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DisableRefTrig(::grpc::ServerContext* context, const DisableRefTrigRequest* request, DisableRefTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->DisableRefTrig(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DisableStartTrig(::grpc::ServerContext* context, const DisableStartTrigRequest* request, DisableStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->DisableStartTrig(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DisconnectTerms(::grpc::ServerContext* context, const DisconnectTermsRequest* request, DisconnectTermsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto source_terminal = request->source_terminal().c_str();
      auto destination_terminal = request->destination_terminal().c_str();
      auto status = library_->DisconnectTerms(source_terminal, destination_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ExportSignal(::grpc::ServerContext* context, const ExportSignalRequest* request, ExportSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 signal_id;
      switch (request->signal_id_enum_case()) {
        case nidaqmx_grpc::ExportSignalRequest::SignalIdEnumCase::kSignalId: {
          signal_id = static_cast<int32>(request->signal_id());
          break;
        }
        case nidaqmx_grpc::ExportSignalRequest::SignalIdEnumCase::kSignalIdRaw: {
          signal_id = static_cast<int32>(request->signal_id_raw());
          break;
        }
        case nidaqmx_grpc::ExportSignalRequest::SignalIdEnumCase::SIGNAL_ID_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_id was not specified or out of range");
          break;
        }
      }

      auto output_terminal = request->output_terminal().c_str();
      auto status = library_->ExportSignal(task, signal_id, output_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalCalDate(::grpc::ServerContext* context, const GetAIChanCalCalDateRequest* request, GetAIChanCalCalDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetAIChanCalCalDate(task, channel_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAIChanCalExpDate(::grpc::ServerContext* context, const GetAIChanCalExpDateRequest* request, GetAIChanCalExpDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetAIChanCalExpDate(task, channel_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAnalogPowerUpStates(::grpc::ServerContext* context, const GetAnalogPowerUpStatesRequest* request, GetAnalogPowerUpStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto get_channelName_if = [](const google::protobuf::RepeatedPtrField<AnalogPowerUpChannelAndType>& vector, int n) -> const char* {
            if (vector.size() > n) {
                  return vector[n].channel_name().c_str();
            }
            return nullptr;
      };
      auto get_channelType_if = [](const google::protobuf::RepeatedPtrField<AnalogPowerUpChannelAndType>& vector, int n) -> int32 {
            if (vector.size() > n) {
                  return vector[n].channel_type();
            }
            return 0;
      };
      auto channels = request->channels();
      if (channels.size() == 0) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "No values for channels were specified");
      }
      if (channels.size() > 96) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "More than 96 values for channels were specified");
      }

      auto get_state_if = [](std::vector<float64>& vector, int n) -> float64* {
            if (vector.size() > n) {
                  return &(vector[n]);
            }
            return nullptr;
      };
      std::vector<float64> stateVector;
      stateVector.resize(channels.size());
      auto status = ((NiDAQmxLibrary*)library_)->GetAnalogPowerUpStates(device_name, get_channelName_if(channels, 0), get_state_if(stateVector, 0), get_channelType_if(channels, 0), get_channelName_if(channels, 1), get_state_if(stateVector, 1), get_channelType_if(channels, 1), get_channelName_if(channels, 2), get_state_if(stateVector, 2), get_channelType_if(channels, 2), get_channelName_if(channels, 3), get_state_if(stateVector, 3), get_channelType_if(channels, 3), get_channelName_if(channels, 4), get_state_if(stateVector, 4), get_channelType_if(channels, 4), get_channelName_if(channels, 5), get_state_if(stateVector, 5), get_channelType_if(channels, 5), get_channelName_if(channels, 6), get_state_if(stateVector, 6), get_channelType_if(channels, 6), get_channelName_if(channels, 7), get_state_if(stateVector, 7), get_channelType_if(channels, 7), get_channelName_if(channels, 8), get_state_if(stateVector, 8), get_channelType_if(channels, 8), get_channelName_if(channels, 9), get_state_if(stateVector, 9), get_channelType_if(channels, 9), get_channelName_if(channels, 10), get_state_if(stateVector, 10), get_channelType_if(channels, 10), get_channelName_if(channels, 11), get_state_if(stateVector, 11), get_channelType_if(channels, 11), get_channelName_if(channels, 12), get_state_if(stateVector, 12), get_channelType_if(channels, 12), get_channelName_if(channels, 13), get_state_if(stateVector, 13), get_channelType_if(channels, 13), get_channelName_if(channels, 14), get_state_if(stateVector, 14), get_channelType_if(channels, 14), get_channelName_if(channels, 15), get_state_if(stateVector, 15), get_channelType_if(channels, 15), get_channelName_if(channels, 16), get_state_if(stateVector, 16), get_channelType_if(channels, 16), get_channelName_if(channels, 17), get_state_if(stateVector, 17), get_channelType_if(channels, 17), get_channelName_if(channels, 18), get_state_if(stateVector, 18), get_channelType_if(channels, 18), get_channelName_if(channels, 19), get_state_if(stateVector, 19), get_channelType_if(channels, 19), get_channelName_if(channels, 20), get_state_if(stateVector, 20), get_channelType_if(channels, 20), get_channelName_if(channels, 21), get_state_if(stateVector, 21), get_channelType_if(channels, 21), get_channelName_if(channels, 22), get_state_if(stateVector, 22), get_channelType_if(channels, 22), get_channelName_if(channels, 23), get_state_if(stateVector, 23), get_channelType_if(channels, 23), get_channelName_if(channels, 24), get_state_if(stateVector, 24), get_channelType_if(channels, 24), get_channelName_if(channels, 25), get_state_if(stateVector, 25), get_channelType_if(channels, 25), get_channelName_if(channels, 26), get_state_if(stateVector, 26), get_channelType_if(channels, 26), get_channelName_if(channels, 27), get_state_if(stateVector, 27), get_channelType_if(channels, 27), get_channelName_if(channels, 28), get_state_if(stateVector, 28), get_channelType_if(channels, 28), get_channelName_if(channels, 29), get_state_if(stateVector, 29), get_channelType_if(channels, 29), get_channelName_if(channels, 30), get_state_if(stateVector, 30), get_channelType_if(channels, 30), get_channelName_if(channels, 31), get_state_if(stateVector, 31), get_channelType_if(channels, 31), get_channelName_if(channels, 32), get_state_if(stateVector, 32), get_channelType_if(channels, 32), get_channelName_if(channels, 33), get_state_if(stateVector, 33), get_channelType_if(channels, 33), get_channelName_if(channels, 34), get_state_if(stateVector, 34), get_channelType_if(channels, 34), get_channelName_if(channels, 35), get_state_if(stateVector, 35), get_channelType_if(channels, 35), get_channelName_if(channels, 36), get_state_if(stateVector, 36), get_channelType_if(channels, 36), get_channelName_if(channels, 37), get_state_if(stateVector, 37), get_channelType_if(channels, 37), get_channelName_if(channels, 38), get_state_if(stateVector, 38), get_channelType_if(channels, 38), get_channelName_if(channels, 39), get_state_if(stateVector, 39), get_channelType_if(channels, 39), get_channelName_if(channels, 40), get_state_if(stateVector, 40), get_channelType_if(channels, 40), get_channelName_if(channels, 41), get_state_if(stateVector, 41), get_channelType_if(channels, 41), get_channelName_if(channels, 42), get_state_if(stateVector, 42), get_channelType_if(channels, 42), get_channelName_if(channels, 43), get_state_if(stateVector, 43), get_channelType_if(channels, 43), get_channelName_if(channels, 44), get_state_if(stateVector, 44), get_channelType_if(channels, 44), get_channelName_if(channels, 45), get_state_if(stateVector, 45), get_channelType_if(channels, 45), get_channelName_if(channels, 46), get_state_if(stateVector, 46), get_channelType_if(channels, 46), get_channelName_if(channels, 47), get_state_if(stateVector, 47), get_channelType_if(channels, 47), get_channelName_if(channels, 48), get_state_if(stateVector, 48), get_channelType_if(channels, 48), get_channelName_if(channels, 49), get_state_if(stateVector, 49), get_channelType_if(channels, 49), get_channelName_if(channels, 50), get_state_if(stateVector, 50), get_channelType_if(channels, 50), get_channelName_if(channels, 51), get_state_if(stateVector, 51), get_channelType_if(channels, 51), get_channelName_if(channels, 52), get_state_if(stateVector, 52), get_channelType_if(channels, 52), get_channelName_if(channels, 53), get_state_if(stateVector, 53), get_channelType_if(channels, 53), get_channelName_if(channels, 54), get_state_if(stateVector, 54), get_channelType_if(channels, 54), get_channelName_if(channels, 55), get_state_if(stateVector, 55), get_channelType_if(channels, 55), get_channelName_if(channels, 56), get_state_if(stateVector, 56), get_channelType_if(channels, 56), get_channelName_if(channels, 57), get_state_if(stateVector, 57), get_channelType_if(channels, 57), get_channelName_if(channels, 58), get_state_if(stateVector, 58), get_channelType_if(channels, 58), get_channelName_if(channels, 59), get_state_if(stateVector, 59), get_channelType_if(channels, 59), get_channelName_if(channels, 60), get_state_if(stateVector, 60), get_channelType_if(channels, 60), get_channelName_if(channels, 61), get_state_if(stateVector, 61), get_channelType_if(channels, 61), get_channelName_if(channels, 62), get_state_if(stateVector, 62), get_channelType_if(channels, 62), get_channelName_if(channels, 63), get_state_if(stateVector, 63), get_channelType_if(channels, 63), get_channelName_if(channels, 64), get_state_if(stateVector, 64), get_channelType_if(channels, 64), get_channelName_if(channels, 65), get_state_if(stateVector, 65), get_channelType_if(channels, 65), get_channelName_if(channels, 66), get_state_if(stateVector, 66), get_channelType_if(channels, 66), get_channelName_if(channels, 67), get_state_if(stateVector, 67), get_channelType_if(channels, 67), get_channelName_if(channels, 68), get_state_if(stateVector, 68), get_channelType_if(channels, 68), get_channelName_if(channels, 69), get_state_if(stateVector, 69), get_channelType_if(channels, 69), get_channelName_if(channels, 70), get_state_if(stateVector, 70), get_channelType_if(channels, 70), get_channelName_if(channels, 71), get_state_if(stateVector, 71), get_channelType_if(channels, 71), get_channelName_if(channels, 72), get_state_if(stateVector, 72), get_channelType_if(channels, 72), get_channelName_if(channels, 73), get_state_if(stateVector, 73), get_channelType_if(channels, 73), get_channelName_if(channels, 74), get_state_if(stateVector, 74), get_channelType_if(channels, 74), get_channelName_if(channels, 75), get_state_if(stateVector, 75), get_channelType_if(channels, 75), get_channelName_if(channels, 76), get_state_if(stateVector, 76), get_channelType_if(channels, 76), get_channelName_if(channels, 77), get_state_if(stateVector, 77), get_channelType_if(channels, 77), get_channelName_if(channels, 78), get_state_if(stateVector, 78), get_channelType_if(channels, 78), get_channelName_if(channels, 79), get_state_if(stateVector, 79), get_channelType_if(channels, 79), get_channelName_if(channels, 80), get_state_if(stateVector, 80), get_channelType_if(channels, 80), get_channelName_if(channels, 81), get_state_if(stateVector, 81), get_channelType_if(channels, 81), get_channelName_if(channels, 82), get_state_if(stateVector, 82), get_channelType_if(channels, 82), get_channelName_if(channels, 83), get_state_if(stateVector, 83), get_channelType_if(channels, 83), get_channelName_if(channels, 84), get_state_if(stateVector, 84), get_channelType_if(channels, 84), get_channelName_if(channels, 85), get_state_if(stateVector, 85), get_channelType_if(channels, 85), get_channelName_if(channels, 86), get_state_if(stateVector, 86), get_channelType_if(channels, 86), get_channelName_if(channels, 87), get_state_if(stateVector, 87), get_channelType_if(channels, 87), get_channelName_if(channels, 88), get_state_if(stateVector, 88), get_channelType_if(channels, 88), get_channelName_if(channels, 89), get_state_if(stateVector, 89), get_channelType_if(channels, 89), get_channelName_if(channels, 90), get_state_if(stateVector, 90), get_channelType_if(channels, 90), get_channelName_if(channels, 91), get_state_if(stateVector, 91), get_channelType_if(channels, 91), get_channelName_if(channels, 92), get_state_if(stateVector, 92), get_channelType_if(channels, 92), get_channelName_if(channels, 93), get_state_if(stateVector, 93), get_channelType_if(channels, 93), get_channelName_if(channels, 94), get_state_if(stateVector, 94), get_channelType_if(channels, 94), get_channelName_if(channels, 95), get_state_if(stateVector, 95), get_channelType_if(channels, 95), get_channelName_if(channels, 96), get_state_if(stateVector, 96), get_channelType_if(channels, 96));
      response->set_status(status);
      if (status_ok(status)) {
        for (int i = 0; i < stateVector.size(); ++i) {
          response->add_power_up_states(stateVector[i]);
        }
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAnalogPowerUpStatesWithOutputType(::grpc::ServerContext* context, const GetAnalogPowerUpStatesWithOutputTypeRequest* request, GetAnalogPowerUpStatesWithOutputTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto channel_names = request->channel_names().c_str();
      uInt32 array_size_copy = request->array_size();
      response->mutable_state_array()->Resize(array_size_copy, 0);
      float64* state_array = response->mutable_state_array()->mutable_data();
      response->mutable_channel_type_array_raw()->Resize(array_size_copy, 0);
      int32* channel_type_array = reinterpret_cast<int32*>(response->mutable_channel_type_array_raw()->mutable_data());
      auto status = library_->GetAnalogPowerUpStatesWithOutputType(channel_names, state_array, channel_type_array, &array_size_copy);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_state_array()->Resize(array_size_copy, 0);
        response->mutable_channel_type_array()->Clear();
        response->mutable_channel_type_array()->Reserve(array_size_copy);
        std::transform(
          response->channel_type_array_raw().begin(),
          response->channel_type_array_raw().begin() + array_size_copy,
          google::protobuf::RepeatedFieldBackInserter(response->mutable_channel_type_array()),
          [&](auto x) { 
              return static_cast<nidaqmx_grpc::PowerUpChannelType>(x);
          });
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetArmStartTrigTimestampVal(::grpc::ServerContext* context, const GetArmStartTrigTimestampValRequest* request, GetArmStartTrigTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetArmStartTrigTimestampVal(task, &data);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetArmStartTrigTrigWhen(::grpc::ServerContext* context, const GetArmStartTrigTrigWhenRequest* request, GetArmStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetArmStartTrigTrigWhen(task, &data);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetAutoConfiguredCDAQSyncConnections(::grpc::ServerContext* context, const GetAutoConfiguredCDAQSyncConnectionsRequest* request, GetAutoConfiguredCDAQSyncConnectionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {

      while (true) {
        auto status = library_->GetAutoConfiguredCDAQSyncConnections(nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 port_list_size = status;
      
        std::string port_list;
        if (port_list_size > 0) {
            port_list.resize(port_list_size - 1);
        }
        status = library_->GetAutoConfiguredCDAQSyncConnections((char*)port_list.data(), port_list_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(port_list_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_port_list(port_list);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_port_list()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetBufferAttributeUInt32(::grpc::ServerContext* context, const GetBufferAttributeUInt32Request* request, GetBufferAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetBufferAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::BufferUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetBufferAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::BufferUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetBufferAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value {};
      auto status = library_->GetBufferAttributeUInt32(task, attribute, &value);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCalInfoAttributeBool(::grpc::ServerContext* context, const GetCalInfoAttributeBoolRequest* request, GetCalInfoAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetCalInfoAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::CalibrationInfoBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetCalInfoAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::CalibrationInfoBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetCalInfoAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetCalInfoAttributeBool(device_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCalInfoAttributeDouble(::grpc::ServerContext* context, const GetCalInfoAttributeDoubleRequest* request, GetCalInfoAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetCalInfoAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::CalibrationInfoDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetCalInfoAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::CalibrationInfoDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetCalInfoAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetCalInfoAttributeDouble(device_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCalInfoAttributeString(::grpc::ServerContext* context, const GetCalInfoAttributeStringRequest* request, GetCalInfoAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetCalInfoAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::CalibrationInfoStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetCalInfoAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::CalibrationInfoStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetCalInfoAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetCalInfoAttributeString(device_name, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetCalInfoAttributeString(device_name, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetCalInfoAttributeUInt32(::grpc::ServerContext* context, const GetCalInfoAttributeUInt32Request* request, GetCalInfoAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetCalInfoAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::CalibrationInfoUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetCalInfoAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::CalibrationInfoUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetCalInfoAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetCalInfoAttributeUInt32(device_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanAttributeBool(::grpc::ServerContext* context, const GetChanAttributeBoolRequest* request, GetChanAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetChanAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetChanAttributeBool(task, channel, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanAttributeDouble(::grpc::ServerContext* context, const GetChanAttributeDoubleRequest* request, GetChanAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetChanAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetChanAttributeDouble(task, channel, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanAttributeDoubleArray(::grpc::ServerContext* context, const GetChanAttributeDoubleArrayRequest* request, GetChanAttributeDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetChanAttributeDoubleArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelDoubleArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeDoubleArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelDoubleArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeDoubleArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetChanAttributeDoubleArray(task, channel, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        response->mutable_value()->Resize(size, 0);
        float64* value = response->mutable_value()->mutable_data();
        status = library_->GetChanAttributeDoubleArray(task, channel, attribute, value, size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanAttributeInt32(::grpc::ServerContext* context, const GetChanAttributeInt32Request* request, GetChanAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetChanAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetChanAttributeInt32(task, channel, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::ChannelInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::ChannelInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanAttributeString(::grpc::ServerContext* context, const GetChanAttributeStringRequest* request, GetChanAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetChanAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetChanAttributeString(task, channel, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetChanAttributeString(task, channel, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanAttributeUInt32(::grpc::ServerContext* context, const GetChanAttributeUInt32Request* request, GetChanAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetChanAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetChanAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetChanAttributeUInt32(task, channel, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDeviceAttributeBool(::grpc::ServerContext* context, const GetDeviceAttributeBoolRequest* request, GetDeviceAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetDeviceAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::DeviceBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::DeviceBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetDeviceAttributeBool(device_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDeviceAttributeDouble(::grpc::ServerContext* context, const GetDeviceAttributeDoubleRequest* request, GetDeviceAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetDeviceAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::DeviceDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::DeviceDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetDeviceAttributeDouble(device_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDeviceAttributeDoubleArray(::grpc::ServerContext* context, const GetDeviceAttributeDoubleArrayRequest* request, GetDeviceAttributeDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetDeviceAttributeDoubleArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::DeviceDoubleArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeDoubleArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::DeviceDoubleArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeDoubleArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetDeviceAttributeDoubleArray(device_name, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        response->mutable_value()->Resize(size, 0);
        float64* value = response->mutable_value()->mutable_data();
        status = library_->GetDeviceAttributeDoubleArray(device_name, attribute, value, size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDeviceAttributeInt32(::grpc::ServerContext* context, const GetDeviceAttributeInt32Request* request, GetDeviceAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetDeviceAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::DeviceInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::DeviceInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetDeviceAttributeInt32(device_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::DeviceInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::DeviceInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDeviceAttributeInt32Array(::grpc::ServerContext* context, const GetDeviceAttributeInt32ArrayRequest* request, GetDeviceAttributeInt32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetDeviceAttributeInt32ArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::DeviceInt32ArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeInt32ArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::DeviceInt32ArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeInt32ArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetDeviceAttributeInt32Array(device_name, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        response->mutable_value_raw()->Resize(size, 0);
        int32* value = reinterpret_cast<int32*>(response->mutable_value_raw()->mutable_data());
        status = library_->GetDeviceAttributeInt32Array(device_name, attribute, value, size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          auto checked_convert_value = [](auto raw_value) {
            bool raw_value_is_valid = nidaqmx_grpc::DeviceInt32AttributeValues_IsValid(raw_value);
            auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
            return static_cast<nidaqmx_grpc::DeviceInt32AttributeValues>(valid_enum_value);
          };
          response->mutable_value()->Clear();
          response->mutable_value()->Reserve(size);
          std::transform(
            response->value_raw().begin(),
            response->value_raw().begin() + size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_value()),
            [&](auto x) { 
                return checked_convert_value(x);
            });
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDeviceAttributeString(::grpc::ServerContext* context, const GetDeviceAttributeStringRequest* request, GetDeviceAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetDeviceAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::DeviceStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::DeviceStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetDeviceAttributeString(device_name, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetDeviceAttributeString(device_name, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDeviceAttributeUInt32(::grpc::ServerContext* context, const GetDeviceAttributeUInt32Request* request, GetDeviceAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetDeviceAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::DeviceUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::DeviceUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetDeviceAttributeUInt32(device_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDeviceAttributeUInt32Array(::grpc::ServerContext* context, const GetDeviceAttributeUInt32ArrayRequest* request, GetDeviceAttributeUInt32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetDeviceAttributeUInt32ArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::DeviceUInt32ArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeUInt32ArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::DeviceUInt32ArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetDeviceAttributeUInt32ArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetDeviceAttributeUInt32Array(device_name, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        response->mutable_value()->Resize(size, 0);
        uInt32* value = reinterpret_cast<uInt32*>(response->mutable_value()->mutable_data());
        status = library_->GetDeviceAttributeUInt32Array(device_name, attribute, value, size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDigitalLogicFamilyPowerUpState(::grpc::ServerContext* context, const GetDigitalLogicFamilyPowerUpStateRequest* request, GetDigitalLogicFamilyPowerUpStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 logic_family {};
      auto status = library_->GetDigitalLogicFamilyPowerUpState(device_name, &logic_family);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_logic_family(logic_family);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDigitalPowerUpStates(::grpc::ServerContext* context, const GetDigitalPowerUpStatesRequest* request, GetDigitalPowerUpStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto get_channelName_if = [](const google::protobuf::RepeatedPtrField<std::string>& vector, int n) -> const char* {
            if (vector.size() > n) {
                  return vector[n].c_str();
            }
            return nullptr;
      };
      auto channel_name = request->channel_name();
      if (channel_name.size() == 0) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "No values for channelName were specified");
      }
      if (channel_name.size() > 96) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "More than 96 values for channelName were specified");
      }

      auto get_state_if = [](std::vector<int32>& vector, int n) -> int32* {
            if (vector.size() > n) {
                  return &(vector[n]);
            }
            return nullptr;
      };
      std::vector<int32> stateVector;
      stateVector.resize(channel_name.size());
      auto status = ((NiDAQmxLibrary*)library_)->GetDigitalPowerUpStates(device_name, get_channelName_if(channel_name, 0), get_state_if(stateVector, 0), get_channelName_if(channel_name, 1), get_state_if(stateVector, 1), get_channelName_if(channel_name, 2), get_state_if(stateVector, 2), get_channelName_if(channel_name, 3), get_state_if(stateVector, 3), get_channelName_if(channel_name, 4), get_state_if(stateVector, 4), get_channelName_if(channel_name, 5), get_state_if(stateVector, 5), get_channelName_if(channel_name, 6), get_state_if(stateVector, 6), get_channelName_if(channel_name, 7), get_state_if(stateVector, 7), get_channelName_if(channel_name, 8), get_state_if(stateVector, 8), get_channelName_if(channel_name, 9), get_state_if(stateVector, 9), get_channelName_if(channel_name, 10), get_state_if(stateVector, 10), get_channelName_if(channel_name, 11), get_state_if(stateVector, 11), get_channelName_if(channel_name, 12), get_state_if(stateVector, 12), get_channelName_if(channel_name, 13), get_state_if(stateVector, 13), get_channelName_if(channel_name, 14), get_state_if(stateVector, 14), get_channelName_if(channel_name, 15), get_state_if(stateVector, 15), get_channelName_if(channel_name, 16), get_state_if(stateVector, 16), get_channelName_if(channel_name, 17), get_state_if(stateVector, 17), get_channelName_if(channel_name, 18), get_state_if(stateVector, 18), get_channelName_if(channel_name, 19), get_state_if(stateVector, 19), get_channelName_if(channel_name, 20), get_state_if(stateVector, 20), get_channelName_if(channel_name, 21), get_state_if(stateVector, 21), get_channelName_if(channel_name, 22), get_state_if(stateVector, 22), get_channelName_if(channel_name, 23), get_state_if(stateVector, 23), get_channelName_if(channel_name, 24), get_state_if(stateVector, 24), get_channelName_if(channel_name, 25), get_state_if(stateVector, 25), get_channelName_if(channel_name, 26), get_state_if(stateVector, 26), get_channelName_if(channel_name, 27), get_state_if(stateVector, 27), get_channelName_if(channel_name, 28), get_state_if(stateVector, 28), get_channelName_if(channel_name, 29), get_state_if(stateVector, 29), get_channelName_if(channel_name, 30), get_state_if(stateVector, 30), get_channelName_if(channel_name, 31), get_state_if(stateVector, 31), get_channelName_if(channel_name, 32), get_state_if(stateVector, 32), get_channelName_if(channel_name, 33), get_state_if(stateVector, 33), get_channelName_if(channel_name, 34), get_state_if(stateVector, 34), get_channelName_if(channel_name, 35), get_state_if(stateVector, 35), get_channelName_if(channel_name, 36), get_state_if(stateVector, 36), get_channelName_if(channel_name, 37), get_state_if(stateVector, 37), get_channelName_if(channel_name, 38), get_state_if(stateVector, 38), get_channelName_if(channel_name, 39), get_state_if(stateVector, 39), get_channelName_if(channel_name, 40), get_state_if(stateVector, 40), get_channelName_if(channel_name, 41), get_state_if(stateVector, 41), get_channelName_if(channel_name, 42), get_state_if(stateVector, 42), get_channelName_if(channel_name, 43), get_state_if(stateVector, 43), get_channelName_if(channel_name, 44), get_state_if(stateVector, 44), get_channelName_if(channel_name, 45), get_state_if(stateVector, 45), get_channelName_if(channel_name, 46), get_state_if(stateVector, 46), get_channelName_if(channel_name, 47), get_state_if(stateVector, 47), get_channelName_if(channel_name, 48), get_state_if(stateVector, 48), get_channelName_if(channel_name, 49), get_state_if(stateVector, 49), get_channelName_if(channel_name, 50), get_state_if(stateVector, 50), get_channelName_if(channel_name, 51), get_state_if(stateVector, 51), get_channelName_if(channel_name, 52), get_state_if(stateVector, 52), get_channelName_if(channel_name, 53), get_state_if(stateVector, 53), get_channelName_if(channel_name, 54), get_state_if(stateVector, 54), get_channelName_if(channel_name, 55), get_state_if(stateVector, 55), get_channelName_if(channel_name, 56), get_state_if(stateVector, 56), get_channelName_if(channel_name, 57), get_state_if(stateVector, 57), get_channelName_if(channel_name, 58), get_state_if(stateVector, 58), get_channelName_if(channel_name, 59), get_state_if(stateVector, 59), get_channelName_if(channel_name, 60), get_state_if(stateVector, 60), get_channelName_if(channel_name, 61), get_state_if(stateVector, 61), get_channelName_if(channel_name, 62), get_state_if(stateVector, 62), get_channelName_if(channel_name, 63), get_state_if(stateVector, 63), get_channelName_if(channel_name, 64), get_state_if(stateVector, 64), get_channelName_if(channel_name, 65), get_state_if(stateVector, 65), get_channelName_if(channel_name, 66), get_state_if(stateVector, 66), get_channelName_if(channel_name, 67), get_state_if(stateVector, 67), get_channelName_if(channel_name, 68), get_state_if(stateVector, 68), get_channelName_if(channel_name, 69), get_state_if(stateVector, 69), get_channelName_if(channel_name, 70), get_state_if(stateVector, 70), get_channelName_if(channel_name, 71), get_state_if(stateVector, 71), get_channelName_if(channel_name, 72), get_state_if(stateVector, 72), get_channelName_if(channel_name, 73), get_state_if(stateVector, 73), get_channelName_if(channel_name, 74), get_state_if(stateVector, 74), get_channelName_if(channel_name, 75), get_state_if(stateVector, 75), get_channelName_if(channel_name, 76), get_state_if(stateVector, 76), get_channelName_if(channel_name, 77), get_state_if(stateVector, 77), get_channelName_if(channel_name, 78), get_state_if(stateVector, 78), get_channelName_if(channel_name, 79), get_state_if(stateVector, 79), get_channelName_if(channel_name, 80), get_state_if(stateVector, 80), get_channelName_if(channel_name, 81), get_state_if(stateVector, 81), get_channelName_if(channel_name, 82), get_state_if(stateVector, 82), get_channelName_if(channel_name, 83), get_state_if(stateVector, 83), get_channelName_if(channel_name, 84), get_state_if(stateVector, 84), get_channelName_if(channel_name, 85), get_state_if(stateVector, 85), get_channelName_if(channel_name, 86), get_state_if(stateVector, 86), get_channelName_if(channel_name, 87), get_state_if(stateVector, 87), get_channelName_if(channel_name, 88), get_state_if(stateVector, 88), get_channelName_if(channel_name, 89), get_state_if(stateVector, 89), get_channelName_if(channel_name, 90), get_state_if(stateVector, 90), get_channelName_if(channel_name, 91), get_state_if(stateVector, 91), get_channelName_if(channel_name, 92), get_state_if(stateVector, 92), get_channelName_if(channel_name, 93), get_state_if(stateVector, 93), get_channelName_if(channel_name, 94), get_state_if(stateVector, 94), get_channelName_if(channel_name, 95), get_state_if(stateVector, 95), get_channelName_if(channel_name, 96), get_state_if(stateVector, 96));
      response->set_status(status);
      if (status_ok(status)) {
        for (int i = 0; i < stateVector.size(); ++i) {
          response->add_power_up_states(static_cast<PowerUpStates>(stateVector[i]));
        }
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDigitalPullUpPullDownStates(::grpc::ServerContext* context, const GetDigitalPullUpPullDownStatesRequest* request, GetDigitalPullUpPullDownStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto get_channelName_if = [](const google::protobuf::RepeatedPtrField<std::string>& vector, int n) -> const char* {
            if (vector.size() > n) {
                  return vector[n].c_str();
            }
            return nullptr;
      };
      auto channel_name = request->channel_name();
      if (channel_name.size() == 0) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "No values for channelName were specified");
      }
      if (channel_name.size() > 96) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "More than 96 values for channelName were specified");
      }

      auto get_state_if = [](std::vector<int32>& vector, int n) -> int32* {
            if (vector.size() > n) {
                  return &(vector[n]);
            }
            return nullptr;
      };
      std::vector<int32> stateVector;
      stateVector.resize(channel_name.size());
      auto status = ((NiDAQmxLibrary*)library_)->GetDigitalPullUpPullDownStates(device_name, get_channelName_if(channel_name, 0), get_state_if(stateVector, 0), get_channelName_if(channel_name, 1), get_state_if(stateVector, 1), get_channelName_if(channel_name, 2), get_state_if(stateVector, 2), get_channelName_if(channel_name, 3), get_state_if(stateVector, 3), get_channelName_if(channel_name, 4), get_state_if(stateVector, 4), get_channelName_if(channel_name, 5), get_state_if(stateVector, 5), get_channelName_if(channel_name, 6), get_state_if(stateVector, 6), get_channelName_if(channel_name, 7), get_state_if(stateVector, 7), get_channelName_if(channel_name, 8), get_state_if(stateVector, 8), get_channelName_if(channel_name, 9), get_state_if(stateVector, 9), get_channelName_if(channel_name, 10), get_state_if(stateVector, 10), get_channelName_if(channel_name, 11), get_state_if(stateVector, 11), get_channelName_if(channel_name, 12), get_state_if(stateVector, 12), get_channelName_if(channel_name, 13), get_state_if(stateVector, 13), get_channelName_if(channel_name, 14), get_state_if(stateVector, 14), get_channelName_if(channel_name, 15), get_state_if(stateVector, 15), get_channelName_if(channel_name, 16), get_state_if(stateVector, 16), get_channelName_if(channel_name, 17), get_state_if(stateVector, 17), get_channelName_if(channel_name, 18), get_state_if(stateVector, 18), get_channelName_if(channel_name, 19), get_state_if(stateVector, 19), get_channelName_if(channel_name, 20), get_state_if(stateVector, 20), get_channelName_if(channel_name, 21), get_state_if(stateVector, 21), get_channelName_if(channel_name, 22), get_state_if(stateVector, 22), get_channelName_if(channel_name, 23), get_state_if(stateVector, 23), get_channelName_if(channel_name, 24), get_state_if(stateVector, 24), get_channelName_if(channel_name, 25), get_state_if(stateVector, 25), get_channelName_if(channel_name, 26), get_state_if(stateVector, 26), get_channelName_if(channel_name, 27), get_state_if(stateVector, 27), get_channelName_if(channel_name, 28), get_state_if(stateVector, 28), get_channelName_if(channel_name, 29), get_state_if(stateVector, 29), get_channelName_if(channel_name, 30), get_state_if(stateVector, 30), get_channelName_if(channel_name, 31), get_state_if(stateVector, 31), get_channelName_if(channel_name, 32), get_state_if(stateVector, 32), get_channelName_if(channel_name, 33), get_state_if(stateVector, 33), get_channelName_if(channel_name, 34), get_state_if(stateVector, 34), get_channelName_if(channel_name, 35), get_state_if(stateVector, 35), get_channelName_if(channel_name, 36), get_state_if(stateVector, 36), get_channelName_if(channel_name, 37), get_state_if(stateVector, 37), get_channelName_if(channel_name, 38), get_state_if(stateVector, 38), get_channelName_if(channel_name, 39), get_state_if(stateVector, 39), get_channelName_if(channel_name, 40), get_state_if(stateVector, 40), get_channelName_if(channel_name, 41), get_state_if(stateVector, 41), get_channelName_if(channel_name, 42), get_state_if(stateVector, 42), get_channelName_if(channel_name, 43), get_state_if(stateVector, 43), get_channelName_if(channel_name, 44), get_state_if(stateVector, 44), get_channelName_if(channel_name, 45), get_state_if(stateVector, 45), get_channelName_if(channel_name, 46), get_state_if(stateVector, 46), get_channelName_if(channel_name, 47), get_state_if(stateVector, 47), get_channelName_if(channel_name, 48), get_state_if(stateVector, 48), get_channelName_if(channel_name, 49), get_state_if(stateVector, 49), get_channelName_if(channel_name, 50), get_state_if(stateVector, 50), get_channelName_if(channel_name, 51), get_state_if(stateVector, 51), get_channelName_if(channel_name, 52), get_state_if(stateVector, 52), get_channelName_if(channel_name, 53), get_state_if(stateVector, 53), get_channelName_if(channel_name, 54), get_state_if(stateVector, 54), get_channelName_if(channel_name, 55), get_state_if(stateVector, 55), get_channelName_if(channel_name, 56), get_state_if(stateVector, 56), get_channelName_if(channel_name, 57), get_state_if(stateVector, 57), get_channelName_if(channel_name, 58), get_state_if(stateVector, 58), get_channelName_if(channel_name, 59), get_state_if(stateVector, 59), get_channelName_if(channel_name, 60), get_state_if(stateVector, 60), get_channelName_if(channel_name, 61), get_state_if(stateVector, 61), get_channelName_if(channel_name, 62), get_state_if(stateVector, 62), get_channelName_if(channel_name, 63), get_state_if(stateVector, 63), get_channelName_if(channel_name, 64), get_state_if(stateVector, 64), get_channelName_if(channel_name, 65), get_state_if(stateVector, 65), get_channelName_if(channel_name, 66), get_state_if(stateVector, 66), get_channelName_if(channel_name, 67), get_state_if(stateVector, 67), get_channelName_if(channel_name, 68), get_state_if(stateVector, 68), get_channelName_if(channel_name, 69), get_state_if(stateVector, 69), get_channelName_if(channel_name, 70), get_state_if(stateVector, 70), get_channelName_if(channel_name, 71), get_state_if(stateVector, 71), get_channelName_if(channel_name, 72), get_state_if(stateVector, 72), get_channelName_if(channel_name, 73), get_state_if(stateVector, 73), get_channelName_if(channel_name, 74), get_state_if(stateVector, 74), get_channelName_if(channel_name, 75), get_state_if(stateVector, 75), get_channelName_if(channel_name, 76), get_state_if(stateVector, 76), get_channelName_if(channel_name, 77), get_state_if(stateVector, 77), get_channelName_if(channel_name, 78), get_state_if(stateVector, 78), get_channelName_if(channel_name, 79), get_state_if(stateVector, 79), get_channelName_if(channel_name, 80), get_state_if(stateVector, 80), get_channelName_if(channel_name, 81), get_state_if(stateVector, 81), get_channelName_if(channel_name, 82), get_state_if(stateVector, 82), get_channelName_if(channel_name, 83), get_state_if(stateVector, 83), get_channelName_if(channel_name, 84), get_state_if(stateVector, 84), get_channelName_if(channel_name, 85), get_state_if(stateVector, 85), get_channelName_if(channel_name, 86), get_state_if(stateVector, 86), get_channelName_if(channel_name, 87), get_state_if(stateVector, 87), get_channelName_if(channel_name, 88), get_state_if(stateVector, 88), get_channelName_if(channel_name, 89), get_state_if(stateVector, 89), get_channelName_if(channel_name, 90), get_state_if(stateVector, 90), get_channelName_if(channel_name, 91), get_state_if(stateVector, 91), get_channelName_if(channel_name, 92), get_state_if(stateVector, 92), get_channelName_if(channel_name, 93), get_state_if(stateVector, 93), get_channelName_if(channel_name, 94), get_state_if(stateVector, 94), get_channelName_if(channel_name, 95), get_state_if(stateVector, 95), get_channelName_if(channel_name, 96), get_state_if(stateVector, 96));
      response->set_status(status);
      if (status_ok(status)) {
        for (int i = 0; i < stateVector.size(); ++i) {
          response->add_pull_up_pull_down_states(static_cast<ResistorState>(stateVector[i]));
        }
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetDisconnectedCDAQSyncPorts(::grpc::ServerContext* context, const GetDisconnectedCDAQSyncPortsRequest* request, GetDisconnectedCDAQSyncPortsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {

      while (true) {
        auto status = library_->GetDisconnectedCDAQSyncPorts(nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 port_list_size = status;
      
        std::string port_list;
        if (port_list_size > 0) {
            port_list.resize(port_list_size - 1);
        }
        status = library_->GetDisconnectedCDAQSyncPorts((char*)port_list.data(), port_list_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(port_list_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_port_list(port_list);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_port_list()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetErrorString(::grpc::ServerContext* context, const GetErrorStringRequest* request, GetErrorStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      int32 error_code = request->error_code();

      while (true) {
        auto status = library_->GetErrorString(error_code, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 buffer_size = status;
      
        std::string error_string;
        if (buffer_size > 0) {
            error_string.resize(buffer_size - 1);
        }
        status = library_->GetErrorString(error_code, (char*)error_string.data(), buffer_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_error_string(error_string);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_string()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExportedSignalAttributeBool(::grpc::ServerContext* context, const GetExportedSignalAttributeBoolRequest* request, GetExportedSignalAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetExportedSignalAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetExportedSignalAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetExportedSignalAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetExportedSignalAttributeBool(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExportedSignalAttributeDouble(::grpc::ServerContext* context, const GetExportedSignalAttributeDoubleRequest* request, GetExportedSignalAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetExportedSignalAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetExportedSignalAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetExportedSignalAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetExportedSignalAttributeDouble(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExportedSignalAttributeInt32(::grpc::ServerContext* context, const GetExportedSignalAttributeInt32Request* request, GetExportedSignalAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetExportedSignalAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetExportedSignalAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetExportedSignalAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetExportedSignalAttributeInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::ExportSignalInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::ExportSignalInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExportedSignalAttributeString(::grpc::ServerContext* context, const GetExportedSignalAttributeStringRequest* request, GetExportedSignalAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetExportedSignalAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetExportedSignalAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetExportedSignalAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetExportedSignalAttributeString(task, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetExportedSignalAttributeString(task, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExportedSignalAttributeUInt32(::grpc::ServerContext* context, const GetExportedSignalAttributeUInt32Request* request, GetExportedSignalAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetExportedSignalAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetExportedSignalAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetExportedSignalAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetExportedSignalAttributeUInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExtendedErrorInfo(::grpc::ServerContext* context, const GetExtendedErrorInfoRequest* request, GetExtendedErrorInfoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {

      while (true) {
        auto status = library_->GetExtendedErrorInfo(nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 buffer_size = status;
      
        std::string error_string;
        if (buffer_size > 0) {
            error_string.resize(buffer_size - 1);
        }
        status = library_->GetExtendedErrorInfo((char*)error_string.data(), buffer_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_error_string(error_string);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_string()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetFirstSampClkWhen(::grpc::ServerContext* context, const GetFirstSampClkWhenRequest* request, GetFirstSampClkWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetFirstSampClkWhen(task, &data);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetFirstSampTimestampVal(::grpc::ServerContext* context, const GetFirstSampTimestampValRequest* request, GetFirstSampTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetFirstSampTimestampVal(task, &data);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskChannel(::grpc::ServerContext* context, const GetNthTaskChannelRequest* request, GetNthTaskChannelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();

      while (true) {
        auto status = library_->GetNthTaskChannel(task, index, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        int32 buffer_size = status;
      
        std::string buffer;
        if (buffer_size > 0) {
            buffer.resize(buffer_size - 1);
        }
        status = library_->GetNthTaskChannel(task, index, (char*)buffer.data(), buffer_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_buffer(buffer);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_buffer()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskDevice(::grpc::ServerContext* context, const GetNthTaskDeviceRequest* request, GetNthTaskDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();

      while (true) {
        auto status = library_->GetNthTaskDevice(task, index, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        int32 buffer_size = status;
      
        std::string buffer;
        if (buffer_size > 0) {
            buffer.resize(buffer_size - 1);
        }
        status = library_->GetNthTaskDevice(task, index, (char*)buffer.data(), buffer_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_buffer(buffer);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_buffer()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetNthTaskReadChannel(::grpc::ServerContext* context, const GetNthTaskReadChannelRequest* request, GetNthTaskReadChannelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      uInt32 index = request->index();

      while (true) {
        auto status = library_->GetNthTaskReadChannel(task, index, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        int32 buffer_size = status;
      
        std::string buffer;
        if (buffer_size > 0) {
            buffer.resize(buffer_size - 1);
        }
        status = library_->GetNthTaskReadChannel(task, index, (char*)buffer.data(), buffer_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_buffer(buffer);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_buffer()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPersistedChanAttributeBool(::grpc::ServerContext* context, const GetPersistedChanAttributeBoolRequest* request, GetPersistedChanAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPersistedChanAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PersistedChannelBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedChanAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PersistedChannelBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedChanAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetPersistedChanAttributeBool(channel, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPersistedChanAttributeString(::grpc::ServerContext* context, const GetPersistedChanAttributeStringRequest* request, GetPersistedChanAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPersistedChanAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PersistedChannelStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedChanAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PersistedChannelStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedChanAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetPersistedChanAttributeString(channel, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetPersistedChanAttributeString(channel, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPersistedScaleAttributeBool(::grpc::ServerContext* context, const GetPersistedScaleAttributeBoolRequest* request, GetPersistedScaleAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPersistedScaleAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PersistedScaleBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedScaleAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PersistedScaleBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedScaleAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetPersistedScaleAttributeBool(scale_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPersistedScaleAttributeString(::grpc::ServerContext* context, const GetPersistedScaleAttributeStringRequest* request, GetPersistedScaleAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPersistedScaleAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PersistedScaleStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedScaleAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PersistedScaleStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedScaleAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetPersistedScaleAttributeString(scale_name, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetPersistedScaleAttributeString(scale_name, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPersistedTaskAttributeBool(::grpc::ServerContext* context, const GetPersistedTaskAttributeBoolRequest* request, GetPersistedTaskAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_name = request->task_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPersistedTaskAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PersistedTaskBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedTaskAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PersistedTaskBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedTaskAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetPersistedTaskAttributeBool(task_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPersistedTaskAttributeString(::grpc::ServerContext* context, const GetPersistedTaskAttributeStringRequest* request, GetPersistedTaskAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_name = request->task_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPersistedTaskAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PersistedTaskStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedTaskAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PersistedTaskStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPersistedTaskAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetPersistedTaskAttributeString(task_name, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetPersistedTaskAttributeString(task_name, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPhysicalChanAttributeBool(::grpc::ServerContext* context, const GetPhysicalChanAttributeBoolRequest* request, GetPhysicalChanAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPhysicalChanAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PhysicalChannelBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PhysicalChannelBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetPhysicalChanAttributeBool(physical_channel, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPhysicalChanAttributeBytes(::grpc::ServerContext* context, const GetPhysicalChanAttributeBytesRequest* request, GetPhysicalChanAttributeBytesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPhysicalChanAttributeBytesRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PhysicalChannelBytesAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeBytesRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PhysicalChannelBytesAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeBytesRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetPhysicalChanAttributeBytes(physical_channel, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value(size, '\0');
        status = library_->GetPhysicalChanAttributeBytes(physical_channel, attribute, (uInt8*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPhysicalChanAttributeDouble(::grpc::ServerContext* context, const GetPhysicalChanAttributeDoubleRequest* request, GetPhysicalChanAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPhysicalChanAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PhysicalChannelDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PhysicalChannelDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetPhysicalChanAttributeDouble(physical_channel, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPhysicalChanAttributeDoubleArray(::grpc::ServerContext* context, const GetPhysicalChanAttributeDoubleArrayRequest* request, GetPhysicalChanAttributeDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPhysicalChanAttributeDoubleArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PhysicalChannelDoubleArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeDoubleArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PhysicalChannelDoubleArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeDoubleArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetPhysicalChanAttributeDoubleArray(physical_channel, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        response->mutable_value()->Resize(size, 0);
        float64* value = response->mutable_value()->mutable_data();
        status = library_->GetPhysicalChanAttributeDoubleArray(physical_channel, attribute, value, size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPhysicalChanAttributeInt32(::grpc::ServerContext* context, const GetPhysicalChanAttributeInt32Request* request, GetPhysicalChanAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPhysicalChanAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PhysicalChannelInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PhysicalChannelInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetPhysicalChanAttributeInt32(physical_channel, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::PhysicalChannelInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::PhysicalChannelInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPhysicalChanAttributeInt32Array(::grpc::ServerContext* context, const GetPhysicalChanAttributeInt32ArrayRequest* request, GetPhysicalChanAttributeInt32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPhysicalChanAttributeInt32ArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PhysicalChannelInt32ArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeInt32ArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PhysicalChannelInt32ArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeInt32ArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetPhysicalChanAttributeInt32Array(physical_channel, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        response->mutable_value_raw()->Resize(size, 0);
        int32* value = reinterpret_cast<int32*>(response->mutable_value_raw()->mutable_data());
        status = library_->GetPhysicalChanAttributeInt32Array(physical_channel, attribute, value, size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          auto checked_convert_value = [](auto raw_value) {
            bool raw_value_is_valid = nidaqmx_grpc::PhysicalChannelInt32AttributeValues_IsValid(raw_value);
            auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
            return static_cast<nidaqmx_grpc::PhysicalChannelInt32AttributeValues>(valid_enum_value);
          };
          response->mutable_value()->Clear();
          response->mutable_value()->Reserve(size);
          std::transform(
            response->value_raw().begin(),
            response->value_raw().begin() + size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_value()),
            [&](auto x) { 
                return checked_convert_value(x);
            });
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPhysicalChanAttributeString(::grpc::ServerContext* context, const GetPhysicalChanAttributeStringRequest* request, GetPhysicalChanAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPhysicalChanAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PhysicalChannelStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PhysicalChannelStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetPhysicalChanAttributeString(physical_channel, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetPhysicalChanAttributeString(physical_channel, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPhysicalChanAttributeUInt32(::grpc::ServerContext* context, const GetPhysicalChanAttributeUInt32Request* request, GetPhysicalChanAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPhysicalChanAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PhysicalChannelUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PhysicalChannelUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetPhysicalChanAttributeUInt32(physical_channel, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetPhysicalChanAttributeUInt32Array(::grpc::ServerContext* context, const GetPhysicalChanAttributeUInt32ArrayRequest* request, GetPhysicalChanAttributeUInt32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetPhysicalChanAttributeUInt32ArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::PhysicalChannelUInt32ArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeUInt32ArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::PhysicalChannelUInt32ArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetPhysicalChanAttributeUInt32ArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetPhysicalChanAttributeUInt32Array(physical_channel, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        response->mutable_value()->Resize(size, 0);
        uInt32* value = reinterpret_cast<uInt32*>(response->mutable_value()->mutable_data());
        status = library_->GetPhysicalChanAttributeUInt32Array(physical_channel, attribute, value, size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetReadAttributeBool(::grpc::ServerContext* context, const GetReadAttributeBoolRequest* request, GetReadAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetReadAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetReadAttributeBool(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetReadAttributeDouble(::grpc::ServerContext* context, const GetReadAttributeDoubleRequest* request, GetReadAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetReadAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetReadAttributeDouble(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetReadAttributeInt32(::grpc::ServerContext* context, const GetReadAttributeInt32Request* request, GetReadAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetReadAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetReadAttributeInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::ReadInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::ReadInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetReadAttributeString(::grpc::ServerContext* context, const GetReadAttributeStringRequest* request, GetReadAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetReadAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetReadAttributeString(task, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetReadAttributeString(task, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetReadAttributeUInt32(::grpc::ServerContext* context, const GetReadAttributeUInt32Request* request, GetReadAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetReadAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetReadAttributeUInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetReadAttributeUInt64(::grpc::ServerContext* context, const GetReadAttributeUInt64Request* request, GetReadAttributeUInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetReadAttributeUInt64Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadUInt64Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeUInt64Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadUInt64Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetReadAttributeUInt64Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt64 value {};
      auto status = library_->GetReadAttributeUInt64(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetRealTimeAttributeBool(::grpc::ServerContext* context, const GetRealTimeAttributeBoolRequest* request, GetRealTimeAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetRealTimeAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::RealTimeBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::RealTimeBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetRealTimeAttributeBool(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetRealTimeAttributeInt32(::grpc::ServerContext* context, const GetRealTimeAttributeInt32Request* request, GetRealTimeAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetRealTimeAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::RealTimeInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::RealTimeInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetRealTimeAttributeInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::RealTimeInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::RealTimeInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetRealTimeAttributeUInt32(::grpc::ServerContext* context, const GetRealTimeAttributeUInt32Request* request, GetRealTimeAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetRealTimeAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::RealTimeUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::RealTimeUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetRealTimeAttributeUInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetRefTrigTimestampVal(::grpc::ServerContext* context, const GetRefTrigTimestampValRequest* request, GetRefTrigTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetRefTrigTimestampVal(task, &data);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetScaleAttributeDouble(::grpc::ServerContext* context, const GetScaleAttributeDoubleRequest* request, GetScaleAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetScaleAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ScaleDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetScaleAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ScaleDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetScaleAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetScaleAttributeDouble(scale_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetScaleAttributeDoubleArray(::grpc::ServerContext* context, const GetScaleAttributeDoubleArrayRequest* request, GetScaleAttributeDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetScaleAttributeDoubleArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ScaleDoubleArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetScaleAttributeDoubleArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ScaleDoubleArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetScaleAttributeDoubleArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetScaleAttributeDoubleArray(scale_name, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        response->mutable_value()->Resize(size, 0);
        float64* value = response->mutable_value()->mutable_data();
        status = library_->GetScaleAttributeDoubleArray(scale_name, attribute, value, size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetScaleAttributeInt32(::grpc::ServerContext* context, const GetScaleAttributeInt32Request* request, GetScaleAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetScaleAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ScaleInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetScaleAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ScaleInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetScaleAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetScaleAttributeInt32(scale_name, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::ScaleInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::ScaleInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetScaleAttributeString(::grpc::ServerContext* context, const GetScaleAttributeStringRequest* request, GetScaleAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetScaleAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ScaleStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetScaleAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ScaleStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetScaleAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetScaleAttributeString(scale_name, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetScaleAttributeString(scale_name, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetSelfCalLastDateAndTime(::grpc::ServerContext* context, const GetSelfCalLastDateAndTimeRequest* request, GetSelfCalLastDateAndTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      uInt32 year {};
      uInt32 month {};
      uInt32 day {};
      uInt32 hour {};
      uInt32 minute {};
      auto status = library_->GetSelfCalLastDateAndTime(device_name, &year, &month, &day, &hour, &minute);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_year(year);
        response->set_month(month);
        response->set_day(day);
        response->set_hour(hour);
        response->set_minute(minute);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetStartTrigTimestampVal(::grpc::ServerContext* context, const GetStartTrigTimestampValRequest* request, GetStartTrigTimestampValResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetStartTrigTimestampVal(task, &data);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetStartTrigTrigWhen(::grpc::ServerContext* context, const GetStartTrigTrigWhenRequest* request, GetStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetStartTrigTrigWhen(task, &data);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetSyncPulseTimeWhen(::grpc::ServerContext* context, const GetSyncPulseTimeWhenRequest* request, GetSyncPulseTimeWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      CVIAbsoluteTime data {};
      auto status = library_->GetSyncPulseTimeWhen(task, &data);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(data, response->mutable_data());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetSystemInfoAttributeString(::grpc::ServerContext* context, const GetSystemInfoAttributeStringRequest* request, GetSystemInfoAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetSystemInfoAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::SystemStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetSystemInfoAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::SystemStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetSystemInfoAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetSystemInfoAttributeString(attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetSystemInfoAttributeString(attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetSystemInfoAttributeUInt32(::grpc::ServerContext* context, const GetSystemInfoAttributeUInt32Request* request, GetSystemInfoAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetSystemInfoAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::SystemUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetSystemInfoAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::SystemUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetSystemInfoAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetSystemInfoAttributeUInt32(attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTaskAttributeBool(::grpc::ServerContext* context, const GetTaskAttributeBoolRequest* request, GetTaskAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTaskAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TaskBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTaskAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TaskBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTaskAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetTaskAttributeBool(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTaskAttributeString(::grpc::ServerContext* context, const GetTaskAttributeStringRequest* request, GetTaskAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTaskAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TaskStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTaskAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TaskStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTaskAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetTaskAttributeString(task, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetTaskAttributeString(task, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTaskAttributeUInt32(::grpc::ServerContext* context, const GetTaskAttributeUInt32Request* request, GetTaskAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTaskAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TaskUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTaskAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TaskUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTaskAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetTaskAttributeUInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeBool(::grpc::ServerContext* context, const GetTimingAttributeBoolRequest* request, GetTimingAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetTimingAttributeBool(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeDouble(::grpc::ServerContext* context, const GetTimingAttributeDoubleRequest* request, GetTimingAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetTimingAttributeDouble(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeExBool(::grpc::ServerContext* context, const GetTimingAttributeExBoolRequest* request, GetTimingAttributeExBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeExBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetTimingAttributeExBool(task, device_names, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeExDouble(::grpc::ServerContext* context, const GetTimingAttributeExDoubleRequest* request, GetTimingAttributeExDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeExDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetTimingAttributeExDouble(task, device_names, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeExInt32(::grpc::ServerContext* context, const GetTimingAttributeExInt32Request* request, GetTimingAttributeExInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeExInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetTimingAttributeExInt32(task, device_names, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::TimingInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::TimingInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeExString(::grpc::ServerContext* context, const GetTimingAttributeExStringRequest* request, GetTimingAttributeExStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeExStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetTimingAttributeExString(task, device_names, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetTimingAttributeExString(task, device_names, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeExTimestamp(::grpc::ServerContext* context, const GetTimingAttributeExTimestampRequest* request, GetTimingAttributeExTimestampResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeExTimestampRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingTimestampAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExTimestampRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingTimestampAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExTimestampRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      CVIAbsoluteTime value {};
      auto status = library_->GetTimingAttributeExTimestamp(task, device_names, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(value, response->mutable_value());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeExUInt32(::grpc::ServerContext* context, const GetTimingAttributeExUInt32Request* request, GetTimingAttributeExUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeExUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetTimingAttributeExUInt32(task, device_names, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeExUInt64(::grpc::ServerContext* context, const GetTimingAttributeExUInt64Request* request, GetTimingAttributeExUInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeExUInt64Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingUInt64Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExUInt64Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingUInt64Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeExUInt64Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt64 value {};
      auto status = library_->GetTimingAttributeExUInt64(task, device_names, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeInt32(::grpc::ServerContext* context, const GetTimingAttributeInt32Request* request, GetTimingAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetTimingAttributeInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::TimingInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::TimingInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeString(::grpc::ServerContext* context, const GetTimingAttributeStringRequest* request, GetTimingAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetTimingAttributeString(task, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetTimingAttributeString(task, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeTimestamp(::grpc::ServerContext* context, const GetTimingAttributeTimestampRequest* request, GetTimingAttributeTimestampResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeTimestampRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingTimestampAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeTimestampRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingTimestampAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeTimestampRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      CVIAbsoluteTime value {};
      auto status = library_->GetTimingAttributeTimestamp(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(value, response->mutable_value());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeUInt32(::grpc::ServerContext* context, const GetTimingAttributeUInt32Request* request, GetTimingAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetTimingAttributeUInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeUInt64(::grpc::ServerContext* context, const GetTimingAttributeUInt64Request* request, GetTimingAttributeUInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeUInt64Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingUInt64Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeUInt64Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingUInt64Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeUInt64Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt64 value {};
      auto status = library_->GetTimingAttributeUInt64(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTrigAttributeBool(::grpc::ServerContext* context, const GetTrigAttributeBoolRequest* request, GetTrigAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTrigAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetTrigAttributeBool(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTrigAttributeDouble(::grpc::ServerContext* context, const GetTrigAttributeDoubleRequest* request, GetTrigAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTrigAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetTrigAttributeDouble(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTrigAttributeDoubleArray(::grpc::ServerContext* context, const GetTrigAttributeDoubleArrayRequest* request, GetTrigAttributeDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTrigAttributeDoubleArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerDoubleArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeDoubleArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerDoubleArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeDoubleArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetTrigAttributeDoubleArray(task, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        response->mutable_value()->Resize(size, 0);
        float64* value = response->mutable_value()->mutable_data();
        status = library_->GetTrigAttributeDoubleArray(task, attribute, value, size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTrigAttributeInt32(::grpc::ServerContext* context, const GetTrigAttributeInt32Request* request, GetTrigAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTrigAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetTrigAttributeInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::TriggerInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::TriggerInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTrigAttributeInt32Array(::grpc::ServerContext* context, const GetTrigAttributeInt32ArrayRequest* request, GetTrigAttributeInt32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTrigAttributeInt32ArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerInt32ArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeInt32ArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerInt32ArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeInt32ArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetTrigAttributeInt32Array(task, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        response->mutable_value_raw()->Resize(size, 0);
        int32* value = reinterpret_cast<int32*>(response->mutable_value_raw()->mutable_data());
        status = library_->GetTrigAttributeInt32Array(task, attribute, value, size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          auto checked_convert_value = [](auto raw_value) {
            bool raw_value_is_valid = nidaqmx_grpc::TriggerInt32AttributeValues_IsValid(raw_value);
            auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
            return static_cast<nidaqmx_grpc::TriggerInt32AttributeValues>(valid_enum_value);
          };
          response->mutable_value()->Clear();
          response->mutable_value()->Reserve(size);
          std::transform(
            response->value_raw().begin(),
            response->value_raw().begin() + size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_value()),
            [&](auto x) { 
                return checked_convert_value(x);
            });
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTrigAttributeString(::grpc::ServerContext* context, const GetTrigAttributeStringRequest* request, GetTrigAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTrigAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetTrigAttributeString(task, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetTrigAttributeString(task, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTrigAttributeTimestamp(::grpc::ServerContext* context, const GetTrigAttributeTimestampRequest* request, GetTrigAttributeTimestampResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTrigAttributeTimestampRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerTimestampAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeTimestampRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerTimestampAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeTimestampRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      CVIAbsoluteTime value {};
      auto status = library_->GetTrigAttributeTimestamp(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(value, response->mutable_value());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTrigAttributeUInt32(::grpc::ServerContext* context, const GetTrigAttributeUInt32Request* request, GetTrigAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTrigAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetTrigAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetTrigAttributeUInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetWatchdogAttributeBool(::grpc::ServerContext* context, const GetWatchdogAttributeBoolRequest* request, GetWatchdogAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetWatchdogAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WatchdogBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWatchdogAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WatchdogBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWatchdogAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetWatchdogAttributeBool(task, lines, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetWatchdogAttributeDouble(::grpc::ServerContext* context, const GetWatchdogAttributeDoubleRequest* request, GetWatchdogAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetWatchdogAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WatchdogDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWatchdogAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WatchdogDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWatchdogAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetWatchdogAttributeDouble(task, lines, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetWatchdogAttributeInt32(::grpc::ServerContext* context, const GetWatchdogAttributeInt32Request* request, GetWatchdogAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetWatchdogAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WatchdogInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWatchdogAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WatchdogInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWatchdogAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetWatchdogAttributeInt32(task, lines, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::WatchdogInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::WatchdogInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetWatchdogAttributeString(::grpc::ServerContext* context, const GetWatchdogAttributeStringRequest* request, GetWatchdogAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetWatchdogAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WatchdogStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWatchdogAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WatchdogStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWatchdogAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetWatchdogAttributeString(task, lines, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetWatchdogAttributeString(task, lines, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetWriteAttributeBool(::grpc::ServerContext* context, const GetWriteAttributeBoolRequest* request, GetWriteAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetWriteAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      bool32 value {};
      auto status = library_->GetWriteAttributeBool(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetWriteAttributeDouble(::grpc::ServerContext* context, const GetWriteAttributeDoubleRequest* request, GetWriteAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetWriteAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      float64 value {};
      auto status = library_->GetWriteAttributeDouble(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetWriteAttributeInt32(::grpc::ServerContext* context, const GetWriteAttributeInt32Request* request, GetWriteAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetWriteAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      int32 value {};
      auto status = library_->GetWriteAttributeInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_value = [](auto raw_value) {
          bool raw_value_is_valid = nidaqmx_grpc::WriteInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nidaqmx_grpc::WriteInt32AttributeValues>(valid_enum_value);
        };
        response->set_value(checked_convert_value(value));
        response->set_value_raw(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetWriteAttributeString(::grpc::ServerContext* context, const GetWriteAttributeStringRequest* request, GetWriteAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetWriteAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }


      while (true) {
        auto status = library_->GetWriteAttributeString(task, attribute, nullptr, 0);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        uInt32 size = status;
      
        std::string value;
        if (size > 0) {
            value.resize(size - 1);
        }
        status = library_->GetWriteAttributeString(task, attribute, (char*)value.data(), size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetWriteAttributeUInt32(::grpc::ServerContext* context, const GetWriteAttributeUInt32Request* request, GetWriteAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetWriteAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt32 value {};
      auto status = library_->GetWriteAttributeUInt32(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetWriteAttributeUInt64(::grpc::ServerContext* context, const GetWriteAttributeUInt64Request* request, GetWriteAttributeUInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetWriteAttributeUInt64Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteUInt64Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeUInt64Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteUInt64Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::GetWriteAttributeUInt64Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      uInt64 value {};
      auto status = library_->GetWriteAttributeUInt64(task, attribute, &value, size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::IsTaskDone(::grpc::ServerContext* context, const IsTaskDoneRequest* request, IsTaskDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 is_task_done {};
      auto status = library_->IsTaskDone(task, &is_task_done);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_is_task_done(is_task_done);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::LoadTask(::grpc::ServerContext* context, const LoadTaskRequest* request, LoadTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_name = request->session_name().c_str();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->LoadTask(session_name, &task);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadAnalogF64(::grpc::ServerContext* context, const ReadAnalogF64Request* request, ReadAnalogF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadAnalogF64Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadAnalogF64(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadAnalogScalarF64(::grpc::ServerContext* context, const ReadAnalogScalarF64Request* request, ReadAnalogScalarF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 value {};
      auto status = library_->ReadAnalogScalarF64(task, timeout, &value, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryI16(::grpc::ServerContext* context, const ReadBinaryI16Request* request, ReadBinaryI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryI16Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI16Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI16Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::vector<int16> read_array(array_size_in_samps);
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryI16(task, num_samps_per_chan, timeout, fill_mode, read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_read_array()->Clear();
        response->mutable_read_array()->Reserve(array_size_in_samps);
        std::transform(
          read_array.begin(),
          read_array.begin() + array_size_in_samps,
          google::protobuf::RepeatedFieldBackInserter(response->mutable_read_array()),
          [&](auto x) { 
              return x;
          });
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryI32(::grpc::ServerContext* context, const ReadBinaryI32Request* request, ReadBinaryI32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryI32Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI32Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryI32Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      int32* read_array = reinterpret_cast<int32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryI32(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryU16(::grpc::ServerContext* context, const ReadBinaryU16Request* request, ReadBinaryU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryU16Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU16Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU16Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::vector<uInt16> read_array(array_size_in_samps);
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryU16(task, num_samps_per_chan, timeout, fill_mode, read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_read_array()->Clear();
        response->mutable_read_array()->Reserve(array_size_in_samps);
        std::transform(
          read_array.begin(),
          read_array.begin() + array_size_in_samps,
          google::protobuf::RepeatedFieldBackInserter(response->mutable_read_array()),
          [&](auto x) { 
              return x;
          });
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadBinaryU32(::grpc::ServerContext* context, const ReadBinaryU32Request* request, ReadBinaryU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadBinaryU32Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU32Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadBinaryU32Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadBinaryU32(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterF64(::grpc::ServerContext* context, const ReadCounterF64Request* request, ReadCounterF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterF64(task, num_samps_per_chan, timeout, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterF64Ex(::grpc::ServerContext* context, const ReadCounterF64ExRequest* request, ReadCounterF64ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadCounterF64ExRequest::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadCounterF64ExRequest::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadCounterF64ExRequest::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterF64Ex(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterScalarF64(::grpc::ServerContext* context, const ReadCounterScalarF64Request* request, ReadCounterScalarF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 value {};
      auto status = library_->ReadCounterScalarF64(task, timeout, &value, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterScalarU32(::grpc::ServerContext* context, const ReadCounterScalarU32Request* request, ReadCounterScalarU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      uInt32 value {};
      auto status = library_->ReadCounterScalarU32(task, timeout, &value, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterU32(::grpc::ServerContext* context, const ReadCounterU32Request* request, ReadCounterU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterU32(task, num_samps_per_chan, timeout, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCounterU32Ex(::grpc::ServerContext* context, const ReadCounterU32ExRequest* request, ReadCounterU32ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadCounterU32ExRequest::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadCounterU32ExRequest::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadCounterU32ExRequest::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadCounterU32Ex(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrFreq(::grpc::ServerContext* context, const ReadCtrFreqRequest* request, ReadCtrFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 interleaved;
      switch (request->interleaved_enum_case()) {
        case nidaqmx_grpc::ReadCtrFreqRequest::InterleavedEnumCase::kInterleaved: {
          interleaved = static_cast<int32>(request->interleaved());
          break;
        }
        case nidaqmx_grpc::ReadCtrFreqRequest::InterleavedEnumCase::kInterleavedRaw: {
          interleaved = static_cast<int32>(request->interleaved_raw());
          break;
        }
        case nidaqmx_grpc::ReadCtrFreqRequest::InterleavedEnumCase::INTERLEAVED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for interleaved was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array_frequency()->Resize(array_size_in_samps, 0);
      float64* read_array_frequency = response->mutable_read_array_frequency()->mutable_data();
      response->mutable_read_array_duty_cycle()->Resize(array_size_in_samps, 0);
      float64* read_array_duty_cycle = response->mutable_read_array_duty_cycle()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCtrFreq(task, num_samps_per_chan, timeout, interleaved, read_array_frequency, read_array_duty_cycle, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrFreqScalar(::grpc::ServerContext* context, const ReadCtrFreqScalarRequest* request, ReadCtrFreqScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 frequency {};
      float64 duty_cycle {};
      auto status = library_->ReadCtrFreqScalar(task, timeout, &frequency, &duty_cycle, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_frequency(frequency);
        response->set_duty_cycle(duty_cycle);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTicks(::grpc::ServerContext* context, const ReadCtrTicksRequest* request, ReadCtrTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 interleaved;
      switch (request->interleaved_enum_case()) {
        case nidaqmx_grpc::ReadCtrTicksRequest::InterleavedEnumCase::kInterleaved: {
          interleaved = static_cast<int32>(request->interleaved());
          break;
        }
        case nidaqmx_grpc::ReadCtrTicksRequest::InterleavedEnumCase::kInterleavedRaw: {
          interleaved = static_cast<int32>(request->interleaved_raw());
          break;
        }
        case nidaqmx_grpc::ReadCtrTicksRequest::InterleavedEnumCase::INTERLEAVED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for interleaved was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array_high_ticks()->Resize(array_size_in_samps, 0);
      uInt32* read_array_high_ticks = reinterpret_cast<uInt32*>(response->mutable_read_array_high_ticks()->mutable_data());
      response->mutable_read_array_low_ticks()->Resize(array_size_in_samps, 0);
      uInt32* read_array_low_ticks = reinterpret_cast<uInt32*>(response->mutable_read_array_low_ticks()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadCtrTicks(task, num_samps_per_chan, timeout, interleaved, read_array_high_ticks, read_array_low_ticks, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTicksScalar(::grpc::ServerContext* context, const ReadCtrTicksScalarRequest* request, ReadCtrTicksScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      uInt32 high_ticks {};
      uInt32 low_ticks {};
      auto status = library_->ReadCtrTicksScalar(task, timeout, &high_ticks, &low_ticks, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_high_ticks(high_ticks);
        response->set_low_ticks(low_ticks);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTime(::grpc::ServerContext* context, const ReadCtrTimeRequest* request, ReadCtrTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 interleaved;
      switch (request->interleaved_enum_case()) {
        case nidaqmx_grpc::ReadCtrTimeRequest::InterleavedEnumCase::kInterleaved: {
          interleaved = static_cast<int32>(request->interleaved());
          break;
        }
        case nidaqmx_grpc::ReadCtrTimeRequest::InterleavedEnumCase::kInterleavedRaw: {
          interleaved = static_cast<int32>(request->interleaved_raw());
          break;
        }
        case nidaqmx_grpc::ReadCtrTimeRequest::InterleavedEnumCase::INTERLEAVED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for interleaved was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array_high_time()->Resize(array_size_in_samps, 0);
      float64* read_array_high_time = response->mutable_read_array_high_time()->mutable_data();
      response->mutable_read_array_low_time()->Resize(array_size_in_samps, 0);
      float64* read_array_low_time = response->mutable_read_array_low_time()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCtrTime(task, num_samps_per_chan, timeout, interleaved, read_array_high_time, read_array_low_time, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrTimeScalar(::grpc::ServerContext* context, const ReadCtrTimeScalarRequest* request, ReadCtrTimeScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      float64 high_time {};
      float64 low_time {};
      auto status = library_->ReadCtrTimeScalar(task, timeout, &high_time, &low_time, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_high_time(high_time);
        response->set_low_time(low_time);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalLines(::grpc::ServerContext* context, const ReadDigitalLinesRequest* request, ReadDigitalLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalLinesRequest::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalLinesRequest::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalLinesRequest::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_bytes = request->array_size_in_bytes();
      auto reserved = nullptr;
      std::string read_array(array_size_in_bytes, '\0');
      int32 samps_per_chan_read {};
      int32 num_bytes_per_samp {};
      auto status = library_->ReadDigitalLines(task, num_samps_per_chan, timeout, fill_mode, (uInt8*)read_array.data(), array_size_in_bytes, &samps_per_chan_read, &num_bytes_per_samp, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_read_array(read_array);
        response->set_samps_per_chan_read(samps_per_chan_read);
        response->set_num_bytes_per_samp(num_bytes_per_samp);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalScalarU32(::grpc::ServerContext* context, const ReadDigitalScalarU32Request* request, ReadDigitalScalarU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      auto reserved = nullptr;
      uInt32 value {};
      auto status = library_->ReadDigitalScalarU32(task, timeout, &value, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU16(::grpc::ServerContext* context, const ReadDigitalU16Request* request, ReadDigitalU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU16Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::vector<uInt16> read_array(array_size_in_samps);
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU16(task, num_samps_per_chan, timeout, fill_mode, read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_read_array()->Clear();
        response->mutable_read_array()->Reserve(array_size_in_samps);
        std::transform(
          read_array.begin(),
          read_array.begin() + array_size_in_samps,
          google::protobuf::RepeatedFieldBackInserter(response->mutable_read_array()),
          [&](auto x) { 
              return x;
          });
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU32(::grpc::ServerContext* context, const ReadDigitalU32Request* request, ReadDigitalU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU32Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU32Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU32Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU32(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU8(::grpc::ServerContext* context, const ReadDigitalU8Request* request, ReadDigitalU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      int32 fill_mode;
      switch (request->fill_mode_enum_case()) {
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::kFillMode: {
          fill_mode = static_cast<int32>(request->fill_mode());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::kFillModeRaw: {
          fill_mode = static_cast<int32>(request->fill_mode_raw());
          break;
        }
        case nidaqmx_grpc::ReadDigitalU8Request::FillModeEnumCase::FILL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fill_mode was not specified or out of range");
          break;
        }
      }

      uInt32 array_size_in_samps = request->array_size_in_samps();
      auto reserved = nullptr;
      std::string read_array(array_size_in_samps, '\0');
      int32 samps_per_chan_read {};
      auto status = library_->ReadDigitalU8(task, num_samps_per_chan, timeout, fill_mode, (uInt8*)read_array.data(), array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_read_array(read_array);
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadRaw(::grpc::ServerContext* context, const ReadRawRequest* request, ReadRawResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      float64 timeout = request->timeout();
      uInt32 array_size_in_bytes = request->array_size_in_bytes();
      auto reserved = nullptr;
      std::string read_array(array_size_in_bytes, '\0');
      int32 samps_read {};
      int32 num_bytes_per_samp {};
      auto status = library_->ReadRaw(task, num_samps_per_chan, timeout, (uInt8*)read_array.data(), array_size_in_bytes, &samps_read, &num_bytes_per_samp, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_read_array(read_array);
        response->set_samps_read(samps_read);
        response->set_num_bytes_per_samp(num_bytes_per_samp);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::ServerWriteReactor<RegisterDoneEventResponse>*
  NiDAQmxService::RegisterDoneEvent(::grpc::CallbackServerContext* context, const RegisterDoneEventRequest* request)
  {
    using CallbackRouter = nidevice_grpc::CallbackRouter<int32, TaskHandle, int32>;
    class RegisterDoneEventReactor : public nidevice_grpc::ServerWriterReactor<RegisterDoneEventResponse, nidevice_grpc::CallbackRegistration> {
    public:
    RegisterDoneEventReactor(const RegisterDoneEventRequest& request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository)
    {
      auto status = start(&request, library, session_repository);
      if (!status.ok()) {
        this->Finish(status);
      }
    }

    ::grpc::Status start(const RegisterDoneEventRequest* request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository_)
    {
      try {
        auto handler = CallbackRouter::register_handler(
          [this](TaskHandle task, int32 status) {
            RegisterDoneEventResponse callback_response;
            auto response = &callback_response;
            response->set_status(status);
            queue_write(callback_response);
            return 0;
        });

        auto task_grpc_session = request->task();
        TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
        auto options = 0U;

        auto status = library->RegisterDoneEvent(task, options, CallbackRouter::handle_callback, handler->token());

        // SendInitialMetadata after the driver call so that WaitForInitialMetadata can be used to ensure that calls are serialized.
        StartSendInitialMetadata();

        if (status) {
          RegisterDoneEventResponse failed_to_register_response;
          failed_to_register_response.set_status(status);
          queue_write(failed_to_register_response);
        }

        this->set_producer(std::move(handler));
      }
      catch (nidevice_grpc::LibraryLoadException& ex) {
         return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
      }

      return ::grpc::Status::OK;
    }
    };

    return new RegisterDoneEventReactor(*request, library_, session_repository_);
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::ServerWriteReactor<RegisterEveryNSamplesEventResponse>*
  NiDAQmxService::RegisterEveryNSamplesEvent(::grpc::CallbackServerContext* context, const RegisterEveryNSamplesEventRequest* request)
  {
    using CallbackRouter = nidevice_grpc::CallbackRouter<int32, TaskHandle, int32, uInt32>;
    class RegisterEveryNSamplesEventReactor : public nidevice_grpc::ServerWriterReactor<RegisterEveryNSamplesEventResponse, nidevice_grpc::CallbackRegistration> {
    public:
    RegisterEveryNSamplesEventReactor(const RegisterEveryNSamplesEventRequest& request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository)
    {
      auto status = start(&request, library, session_repository);
      if (!status.ok()) {
        this->Finish(status);
      }
    }

    ::grpc::Status start(const RegisterEveryNSamplesEventRequest* request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository_)
    {
      try {
        auto handler = CallbackRouter::register_handler(
          [this](TaskHandle task, int32 every_n_samples_event_type, uInt32 n_samples) {
            RegisterEveryNSamplesEventResponse callback_response;
            auto response = &callback_response;
            response->set_every_n_samples_event_type(static_cast<nidaqmx_grpc::EveryNSamplesEventType>(every_n_samples_event_type));
            response->set_every_n_samples_event_type_raw(every_n_samples_event_type);
            response->set_n_samples(n_samples);
            queue_write(callback_response);
            return 0;
        });

        auto task_grpc_session = request->task();
        TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
        int32 every_n_samples_event_type;
        switch (request->every_n_samples_event_type_enum_case()) {
          case nidaqmx_grpc::RegisterEveryNSamplesEventRequest::EveryNSamplesEventTypeEnumCase::kEveryNSamplesEventType: {
            every_n_samples_event_type = static_cast<int32>(request->every_n_samples_event_type());
            break;
          }
          case nidaqmx_grpc::RegisterEveryNSamplesEventRequest::EveryNSamplesEventTypeEnumCase::kEveryNSamplesEventTypeRaw: {
            every_n_samples_event_type = static_cast<int32>(request->every_n_samples_event_type_raw());
            break;
          }
          case nidaqmx_grpc::RegisterEveryNSamplesEventRequest::EveryNSamplesEventTypeEnumCase::EVERY_N_SAMPLES_EVENT_TYPE_ENUM_NOT_SET: {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for every_n_samples_event_type was not specified or out of range");
            break;
          }
        }
  
        uInt32 n_samples = request->n_samples();
        auto options = 0U;

        auto status = library->RegisterEveryNSamplesEvent(task, every_n_samples_event_type, n_samples, options, CallbackRouter::handle_callback, handler->token());

        // SendInitialMetadata after the driver call so that WaitForInitialMetadata can be used to ensure that calls are serialized.
        StartSendInitialMetadata();

        if (status) {
          RegisterEveryNSamplesEventResponse failed_to_register_response;
          failed_to_register_response.set_status(status);
          queue_write(failed_to_register_response);
        }

        this->set_producer(std::move(handler));
      }
      catch (nidevice_grpc::LibraryLoadException& ex) {
         return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
      }

      return ::grpc::Status::OK;
    }
    };

    return new RegisterEveryNSamplesEventReactor(*request, library_, session_repository_);
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::ServerWriteReactor<RegisterSignalEventResponse>*
  NiDAQmxService::RegisterSignalEvent(::grpc::CallbackServerContext* context, const RegisterSignalEventRequest* request)
  {
    using CallbackRouter = nidevice_grpc::CallbackRouter<int32, TaskHandle, int32>;
    class RegisterSignalEventReactor : public nidevice_grpc::ServerWriterReactor<RegisterSignalEventResponse, nidevice_grpc::CallbackRegistration> {
    public:
    RegisterSignalEventReactor(const RegisterSignalEventRequest& request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository)
    {
      auto status = start(&request, library, session_repository);
      if (!status.ok()) {
        this->Finish(status);
      }
    }

    ::grpc::Status start(const RegisterSignalEventRequest* request, NiDAQmxLibraryInterface* library, const ResourceRepositorySharedPtr& session_repository_)
    {
      try {
        auto handler = CallbackRouter::register_handler(
          [this](TaskHandle task, int32 signal_id) {
            RegisterSignalEventResponse callback_response;
            auto response = &callback_response;
            response->set_signal_id(signal_id);
            queue_write(callback_response);
            return 0;
        });

        auto task_grpc_session = request->task();
        TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
        int32 signal_id;
        switch (request->signal_id_enum_case()) {
          case nidaqmx_grpc::RegisterSignalEventRequest::SignalIdEnumCase::kSignalId: {
            signal_id = static_cast<int32>(request->signal_id());
            break;
          }
          case nidaqmx_grpc::RegisterSignalEventRequest::SignalIdEnumCase::kSignalIdRaw: {
            signal_id = static_cast<int32>(request->signal_id_raw());
            break;
          }
          case nidaqmx_grpc::RegisterSignalEventRequest::SignalIdEnumCase::SIGNAL_ID_ENUM_NOT_SET: {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_id was not specified or out of range");
            break;
          }
        }
  
        auto options = 0U;

        auto status = library->RegisterSignalEvent(task, signal_id, options, CallbackRouter::handle_callback, handler->token());

        // SendInitialMetadata after the driver call so that WaitForInitialMetadata can be used to ensure that calls are serialized.
        StartSendInitialMetadata();

        if (status) {
          RegisterSignalEventResponse failed_to_register_response;
          failed_to_register_response.set_status(status);
          queue_write(failed_to_register_response);
        }

        this->set_producer(std::move(handler));
      }
      catch (nidevice_grpc::LibraryLoadException& ex) {
         return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
      }

      return ::grpc::Status::OK;
    }
    };

    return new RegisterSignalEventReactor(*request, library_, session_repository_);
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::RemoveCDAQSyncConnection(::grpc::ServerContext* context, const RemoveCDAQSyncConnectionRequest* request, RemoveCDAQSyncConnectionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto port_list = request->port_list().c_str();
      auto status = library_->RemoveCDAQSyncConnection(port_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReserveNetworkDevice(::grpc::ServerContext* context, const ReserveNetworkDeviceRequest* request, ReserveNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      bool32 override_reservation = request->override_reservation();
      auto status = library_->ReserveNetworkDevice(device_name, override_reservation);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetBufferAttribute(::grpc::ServerContext* context, const ResetBufferAttributeRequest* request, ResetBufferAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::ResetBufferAttributeRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::BufferResetAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetBufferAttributeRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::BufferResetAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetBufferAttributeRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto status = library_->ResetBufferAttribute(task, attribute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetChanAttribute(::grpc::ServerContext* context, const ResetChanAttributeRequest* request, ResetChanAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::ResetChanAttributeRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelResetAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetChanAttributeRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelResetAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetChanAttributeRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto status = library_->ResetChanAttribute(task, channel, attribute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetDevice(::grpc::ServerContext* context, const ResetDeviceRequest* request, ResetDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->ResetDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetExportedSignalAttribute(::grpc::ServerContext* context, const ResetExportedSignalAttributeRequest* request, ResetExportedSignalAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::ResetExportedSignalAttributeRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalResetAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetExportedSignalAttributeRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalResetAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetExportedSignalAttributeRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto status = library_->ResetExportedSignalAttribute(task, attribute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetReadAttribute(::grpc::ServerContext* context, const ResetReadAttributeRequest* request, ResetReadAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::ResetReadAttributeRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadResetAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetReadAttributeRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadResetAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetReadAttributeRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto status = library_->ResetReadAttribute(task, attribute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetRealTimeAttribute(::grpc::ServerContext* context, const ResetRealTimeAttributeRequest* request, ResetRealTimeAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::ResetRealTimeAttributeRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::RealTimeResetAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetRealTimeAttributeRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::RealTimeResetAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetRealTimeAttributeRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto status = library_->ResetRealTimeAttribute(task, attribute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetTimingAttribute(::grpc::ServerContext* context, const ResetTimingAttributeRequest* request, ResetTimingAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::ResetTimingAttributeRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingResetAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetTimingAttributeRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingResetAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetTimingAttributeRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto status = library_->ResetTimingAttribute(task, attribute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetTimingAttributeEx(::grpc::ServerContext* context, const ResetTimingAttributeExRequest* request, ResetTimingAttributeExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::ResetTimingAttributeExRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingResetAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetTimingAttributeExRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingResetAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetTimingAttributeExRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto status = library_->ResetTimingAttributeEx(task, device_names, attribute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetTrigAttribute(::grpc::ServerContext* context, const ResetTrigAttributeRequest* request, ResetTrigAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::ResetTrigAttributeRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerResetAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetTrigAttributeRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerResetAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetTrigAttributeRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto status = library_->ResetTrigAttribute(task, attribute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetWatchdogAttribute(::grpc::ServerContext* context, const ResetWatchdogAttributeRequest* request, ResetWatchdogAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::ResetWatchdogAttributeRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WatchdogResetAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetWatchdogAttributeRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WatchdogResetAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetWatchdogAttributeRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto status = library_->ResetWatchdogAttribute(task, lines, attribute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ResetWriteAttribute(::grpc::ServerContext* context, const ResetWriteAttributeRequest* request, ResetWriteAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::ResetWriteAttributeRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteResetAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetWriteAttributeRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteResetAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::ResetWriteAttributeRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto status = library_->ResetWriteAttribute(task, attribute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SaveGlobalChan(::grpc::ServerContext* context, const SaveGlobalChanRequest* request, SaveGlobalChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      auto save_as = request->save_as().c_str();
      auto author = request->author().c_str();
      uInt32 options;
      switch (request->options_enum_case()) {
        case nidaqmx_grpc::SaveGlobalChanRequest::OptionsEnumCase::kOptions: {
          options = static_cast<uInt32>(request->options());
          break;
        }
        case nidaqmx_grpc::SaveGlobalChanRequest::OptionsEnumCase::kOptionsRaw: {
          options = static_cast<uInt32>(request->options_raw());
          break;
        }
        case nidaqmx_grpc::SaveGlobalChanRequest::OptionsEnumCase::OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for options was not specified or out of range");
          break;
        }
      }

      auto status = library_->SaveGlobalChan(task, channel_name, save_as, author, options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SaveScale(::grpc::ServerContext* context, const SaveScaleRequest* request, SaveScaleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      auto save_as = request->save_as().c_str();
      auto author = request->author().c_str();
      uInt32 options;
      switch (request->options_enum_case()) {
        case nidaqmx_grpc::SaveScaleRequest::OptionsEnumCase::kOptions: {
          options = static_cast<uInt32>(request->options());
          break;
        }
        case nidaqmx_grpc::SaveScaleRequest::OptionsEnumCase::kOptionsRaw: {
          options = static_cast<uInt32>(request->options_raw());
          break;
        }
        case nidaqmx_grpc::SaveScaleRequest::OptionsEnumCase::OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for options was not specified or out of range");
          break;
        }
      }

      auto status = library_->SaveScale(scale_name, save_as, author, options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SaveTask(::grpc::ServerContext* context, const SaveTaskRequest* request, SaveTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto save_as = request->save_as().c_str();
      auto author = request->author().c_str();
      uInt32 options;
      switch (request->options_enum_case()) {
        case nidaqmx_grpc::SaveTaskRequest::OptionsEnumCase::kOptions: {
          options = static_cast<uInt32>(request->options());
          break;
        }
        case nidaqmx_grpc::SaveTaskRequest::OptionsEnumCase::kOptionsRaw: {
          options = static_cast<uInt32>(request->options_raw());
          break;
        }
        case nidaqmx_grpc::SaveTaskRequest::OptionsEnumCase::OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for options was not specified or out of range");
          break;
        }
      }

      auto status = library_->SaveTask(task, save_as, author, options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SelfCal(::grpc::ServerContext* context, const SelfCalRequest* request, SelfCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->SelfCal(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SelfTestDevice(::grpc::ServerContext* context, const SelfTestDeviceRequest* request, SelfTestDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->SelfTestDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalCalDate(::grpc::ServerContext* context, const SetAIChanCalCalDateRequest* request, SetAIChanCalCalDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year = request->year();
      uInt32 month = request->month();
      uInt32 day = request->day();
      uInt32 hour = request->hour();
      uInt32 minute = request->minute();
      auto status = library_->SetAIChanCalCalDate(task, channel_name, year, month, day, hour, minute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAIChanCalExpDate(::grpc::ServerContext* context, const SetAIChanCalExpDateRequest* request, SetAIChanCalExpDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      uInt32 year = request->year();
      uInt32 month = request->month();
      uInt32 day = request->day();
      uInt32 hour = request->hour();
      uInt32 minute = request->minute();
      auto status = library_->SetAIChanCalExpDate(task, channel_name, year, month, day, hour, minute);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAnalogPowerUpStates(::grpc::ServerContext* context, const SetAnalogPowerUpStatesRequest* request, SetAnalogPowerUpStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto get_channelNames_if = [](const google::protobuf::RepeatedPtrField<AnalogPowerUpChannelsAndState>& vector, int n) -> const char* {
            if (vector.size() > n) {
                  return vector[n].channel_names().c_str();
            }
            return nullptr;
      };
      auto get_state_if = [](const google::protobuf::RepeatedPtrField<AnalogPowerUpChannelsAndState>& vector, int n) -> float64 {
            if (vector.size() > n) {
                  return vector[n].state();
            }
            return 0;
      };
      auto get_channelType_if = [](const google::protobuf::RepeatedPtrField<AnalogPowerUpChannelsAndState>& vector, int n) -> int32 {
            if (vector.size() > n) {
                  return vector[n].channel_type();
            }
            return 0;
      };
      auto power_up_states = request->power_up_states();
      if (power_up_states.size() == 0) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "No values for powerUpStates were specified");
      }
      if (power_up_states.size() > 96) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "More than 96 values for powerUpStates were specified");
      }

      auto status = ((NiDAQmxLibrary*)library_)->SetAnalogPowerUpStates(device_name, get_channelNames_if(power_up_states, 0), get_state_if(power_up_states, 0), get_channelType_if(power_up_states, 0), get_channelNames_if(power_up_states, 1), get_state_if(power_up_states, 1), get_channelType_if(power_up_states, 1), get_channelNames_if(power_up_states, 2), get_state_if(power_up_states, 2), get_channelType_if(power_up_states, 2), get_channelNames_if(power_up_states, 3), get_state_if(power_up_states, 3), get_channelType_if(power_up_states, 3), get_channelNames_if(power_up_states, 4), get_state_if(power_up_states, 4), get_channelType_if(power_up_states, 4), get_channelNames_if(power_up_states, 5), get_state_if(power_up_states, 5), get_channelType_if(power_up_states, 5), get_channelNames_if(power_up_states, 6), get_state_if(power_up_states, 6), get_channelType_if(power_up_states, 6), get_channelNames_if(power_up_states, 7), get_state_if(power_up_states, 7), get_channelType_if(power_up_states, 7), get_channelNames_if(power_up_states, 8), get_state_if(power_up_states, 8), get_channelType_if(power_up_states, 8), get_channelNames_if(power_up_states, 9), get_state_if(power_up_states, 9), get_channelType_if(power_up_states, 9), get_channelNames_if(power_up_states, 10), get_state_if(power_up_states, 10), get_channelType_if(power_up_states, 10), get_channelNames_if(power_up_states, 11), get_state_if(power_up_states, 11), get_channelType_if(power_up_states, 11), get_channelNames_if(power_up_states, 12), get_state_if(power_up_states, 12), get_channelType_if(power_up_states, 12), get_channelNames_if(power_up_states, 13), get_state_if(power_up_states, 13), get_channelType_if(power_up_states, 13), get_channelNames_if(power_up_states, 14), get_state_if(power_up_states, 14), get_channelType_if(power_up_states, 14), get_channelNames_if(power_up_states, 15), get_state_if(power_up_states, 15), get_channelType_if(power_up_states, 15), get_channelNames_if(power_up_states, 16), get_state_if(power_up_states, 16), get_channelType_if(power_up_states, 16), get_channelNames_if(power_up_states, 17), get_state_if(power_up_states, 17), get_channelType_if(power_up_states, 17), get_channelNames_if(power_up_states, 18), get_state_if(power_up_states, 18), get_channelType_if(power_up_states, 18), get_channelNames_if(power_up_states, 19), get_state_if(power_up_states, 19), get_channelType_if(power_up_states, 19), get_channelNames_if(power_up_states, 20), get_state_if(power_up_states, 20), get_channelType_if(power_up_states, 20), get_channelNames_if(power_up_states, 21), get_state_if(power_up_states, 21), get_channelType_if(power_up_states, 21), get_channelNames_if(power_up_states, 22), get_state_if(power_up_states, 22), get_channelType_if(power_up_states, 22), get_channelNames_if(power_up_states, 23), get_state_if(power_up_states, 23), get_channelType_if(power_up_states, 23), get_channelNames_if(power_up_states, 24), get_state_if(power_up_states, 24), get_channelType_if(power_up_states, 24), get_channelNames_if(power_up_states, 25), get_state_if(power_up_states, 25), get_channelType_if(power_up_states, 25), get_channelNames_if(power_up_states, 26), get_state_if(power_up_states, 26), get_channelType_if(power_up_states, 26), get_channelNames_if(power_up_states, 27), get_state_if(power_up_states, 27), get_channelType_if(power_up_states, 27), get_channelNames_if(power_up_states, 28), get_state_if(power_up_states, 28), get_channelType_if(power_up_states, 28), get_channelNames_if(power_up_states, 29), get_state_if(power_up_states, 29), get_channelType_if(power_up_states, 29), get_channelNames_if(power_up_states, 30), get_state_if(power_up_states, 30), get_channelType_if(power_up_states, 30), get_channelNames_if(power_up_states, 31), get_state_if(power_up_states, 31), get_channelType_if(power_up_states, 31), get_channelNames_if(power_up_states, 32), get_state_if(power_up_states, 32), get_channelType_if(power_up_states, 32), get_channelNames_if(power_up_states, 33), get_state_if(power_up_states, 33), get_channelType_if(power_up_states, 33), get_channelNames_if(power_up_states, 34), get_state_if(power_up_states, 34), get_channelType_if(power_up_states, 34), get_channelNames_if(power_up_states, 35), get_state_if(power_up_states, 35), get_channelType_if(power_up_states, 35), get_channelNames_if(power_up_states, 36), get_state_if(power_up_states, 36), get_channelType_if(power_up_states, 36), get_channelNames_if(power_up_states, 37), get_state_if(power_up_states, 37), get_channelType_if(power_up_states, 37), get_channelNames_if(power_up_states, 38), get_state_if(power_up_states, 38), get_channelType_if(power_up_states, 38), get_channelNames_if(power_up_states, 39), get_state_if(power_up_states, 39), get_channelType_if(power_up_states, 39), get_channelNames_if(power_up_states, 40), get_state_if(power_up_states, 40), get_channelType_if(power_up_states, 40), get_channelNames_if(power_up_states, 41), get_state_if(power_up_states, 41), get_channelType_if(power_up_states, 41), get_channelNames_if(power_up_states, 42), get_state_if(power_up_states, 42), get_channelType_if(power_up_states, 42), get_channelNames_if(power_up_states, 43), get_state_if(power_up_states, 43), get_channelType_if(power_up_states, 43), get_channelNames_if(power_up_states, 44), get_state_if(power_up_states, 44), get_channelType_if(power_up_states, 44), get_channelNames_if(power_up_states, 45), get_state_if(power_up_states, 45), get_channelType_if(power_up_states, 45), get_channelNames_if(power_up_states, 46), get_state_if(power_up_states, 46), get_channelType_if(power_up_states, 46), get_channelNames_if(power_up_states, 47), get_state_if(power_up_states, 47), get_channelType_if(power_up_states, 47), get_channelNames_if(power_up_states, 48), get_state_if(power_up_states, 48), get_channelType_if(power_up_states, 48), get_channelNames_if(power_up_states, 49), get_state_if(power_up_states, 49), get_channelType_if(power_up_states, 49), get_channelNames_if(power_up_states, 50), get_state_if(power_up_states, 50), get_channelType_if(power_up_states, 50), get_channelNames_if(power_up_states, 51), get_state_if(power_up_states, 51), get_channelType_if(power_up_states, 51), get_channelNames_if(power_up_states, 52), get_state_if(power_up_states, 52), get_channelType_if(power_up_states, 52), get_channelNames_if(power_up_states, 53), get_state_if(power_up_states, 53), get_channelType_if(power_up_states, 53), get_channelNames_if(power_up_states, 54), get_state_if(power_up_states, 54), get_channelType_if(power_up_states, 54), get_channelNames_if(power_up_states, 55), get_state_if(power_up_states, 55), get_channelType_if(power_up_states, 55), get_channelNames_if(power_up_states, 56), get_state_if(power_up_states, 56), get_channelType_if(power_up_states, 56), get_channelNames_if(power_up_states, 57), get_state_if(power_up_states, 57), get_channelType_if(power_up_states, 57), get_channelNames_if(power_up_states, 58), get_state_if(power_up_states, 58), get_channelType_if(power_up_states, 58), get_channelNames_if(power_up_states, 59), get_state_if(power_up_states, 59), get_channelType_if(power_up_states, 59), get_channelNames_if(power_up_states, 60), get_state_if(power_up_states, 60), get_channelType_if(power_up_states, 60), get_channelNames_if(power_up_states, 61), get_state_if(power_up_states, 61), get_channelType_if(power_up_states, 61), get_channelNames_if(power_up_states, 62), get_state_if(power_up_states, 62), get_channelType_if(power_up_states, 62), get_channelNames_if(power_up_states, 63), get_state_if(power_up_states, 63), get_channelType_if(power_up_states, 63), get_channelNames_if(power_up_states, 64), get_state_if(power_up_states, 64), get_channelType_if(power_up_states, 64), get_channelNames_if(power_up_states, 65), get_state_if(power_up_states, 65), get_channelType_if(power_up_states, 65), get_channelNames_if(power_up_states, 66), get_state_if(power_up_states, 66), get_channelType_if(power_up_states, 66), get_channelNames_if(power_up_states, 67), get_state_if(power_up_states, 67), get_channelType_if(power_up_states, 67), get_channelNames_if(power_up_states, 68), get_state_if(power_up_states, 68), get_channelType_if(power_up_states, 68), get_channelNames_if(power_up_states, 69), get_state_if(power_up_states, 69), get_channelType_if(power_up_states, 69), get_channelNames_if(power_up_states, 70), get_state_if(power_up_states, 70), get_channelType_if(power_up_states, 70), get_channelNames_if(power_up_states, 71), get_state_if(power_up_states, 71), get_channelType_if(power_up_states, 71), get_channelNames_if(power_up_states, 72), get_state_if(power_up_states, 72), get_channelType_if(power_up_states, 72), get_channelNames_if(power_up_states, 73), get_state_if(power_up_states, 73), get_channelType_if(power_up_states, 73), get_channelNames_if(power_up_states, 74), get_state_if(power_up_states, 74), get_channelType_if(power_up_states, 74), get_channelNames_if(power_up_states, 75), get_state_if(power_up_states, 75), get_channelType_if(power_up_states, 75), get_channelNames_if(power_up_states, 76), get_state_if(power_up_states, 76), get_channelType_if(power_up_states, 76), get_channelNames_if(power_up_states, 77), get_state_if(power_up_states, 77), get_channelType_if(power_up_states, 77), get_channelNames_if(power_up_states, 78), get_state_if(power_up_states, 78), get_channelType_if(power_up_states, 78), get_channelNames_if(power_up_states, 79), get_state_if(power_up_states, 79), get_channelType_if(power_up_states, 79), get_channelNames_if(power_up_states, 80), get_state_if(power_up_states, 80), get_channelType_if(power_up_states, 80), get_channelNames_if(power_up_states, 81), get_state_if(power_up_states, 81), get_channelType_if(power_up_states, 81), get_channelNames_if(power_up_states, 82), get_state_if(power_up_states, 82), get_channelType_if(power_up_states, 82), get_channelNames_if(power_up_states, 83), get_state_if(power_up_states, 83), get_channelType_if(power_up_states, 83), get_channelNames_if(power_up_states, 84), get_state_if(power_up_states, 84), get_channelType_if(power_up_states, 84), get_channelNames_if(power_up_states, 85), get_state_if(power_up_states, 85), get_channelType_if(power_up_states, 85), get_channelNames_if(power_up_states, 86), get_state_if(power_up_states, 86), get_channelType_if(power_up_states, 86), get_channelNames_if(power_up_states, 87), get_state_if(power_up_states, 87), get_channelType_if(power_up_states, 87), get_channelNames_if(power_up_states, 88), get_state_if(power_up_states, 88), get_channelType_if(power_up_states, 88), get_channelNames_if(power_up_states, 89), get_state_if(power_up_states, 89), get_channelType_if(power_up_states, 89), get_channelNames_if(power_up_states, 90), get_state_if(power_up_states, 90), get_channelType_if(power_up_states, 90), get_channelNames_if(power_up_states, 91), get_state_if(power_up_states, 91), get_channelType_if(power_up_states, 91), get_channelNames_if(power_up_states, 92), get_state_if(power_up_states, 92), get_channelType_if(power_up_states, 92), get_channelNames_if(power_up_states, 93), get_state_if(power_up_states, 93), get_channelType_if(power_up_states, 93), get_channelNames_if(power_up_states, 94), get_state_if(power_up_states, 94), get_channelType_if(power_up_states, 94), get_channelNames_if(power_up_states, 95), get_state_if(power_up_states, 95), get_channelType_if(power_up_states, 95), get_channelNames_if(power_up_states, 96), get_state_if(power_up_states, 96), get_channelType_if(power_up_states, 96));
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetAnalogPowerUpStatesWithOutputType(::grpc::ServerContext* context, const SetAnalogPowerUpStatesWithOutputTypeRequest* request, SetAnalogPowerUpStatesWithOutputTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto channel_names = request->channel_names().c_str();
      auto state_array = const_cast<const float64*>(request->state_array().data());
      auto channel_type_array_vector = std::vector<int32>();
      channel_type_array_vector.reserve(request->channel_type_array().size());
      std::transform(
        request->channel_type_array().begin(),
        request->channel_type_array().end(),
        std::back_inserter(channel_type_array_vector),
        [](auto x) { return x; });
      auto channel_type_array = channel_type_array_vector.data();

      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->state_array_size(),
        request->channel_type_array_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, false);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [stateArray, channelTypeArray] do not match");
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->SetAnalogPowerUpStatesWithOutputType(channel_names, state_array, channel_type_array, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetArmStartTrigTrigWhen(::grpc::ServerContext* context, const SetArmStartTrigTrigWhenRequest* request, SetArmStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetArmStartTrigTrigWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetBufferAttributeUInt32(::grpc::ServerContext* context, const SetBufferAttributeUInt32Request* request, SetBufferAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetBufferAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::BufferUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetBufferAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::BufferUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetBufferAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto status = library_->SetBufferAttributeUInt32(task, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCalInfoAttributeBool(::grpc::ServerContext* context, const SetCalInfoAttributeBoolRequest* request, SetCalInfoAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetCalInfoAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::CalibrationInfoBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetCalInfoAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::CalibrationInfoBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetCalInfoAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      bool32 value = request->value();
      auto size = 0U;
      auto status = library_->SetCalInfoAttributeBool(device_name, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCalInfoAttributeDouble(::grpc::ServerContext* context, const SetCalInfoAttributeDoubleRequest* request, SetCalInfoAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetCalInfoAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::CalibrationInfoDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetCalInfoAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::CalibrationInfoDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetCalInfoAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      float64 value = request->value();
      auto size = 0U;
      auto status = library_->SetCalInfoAttributeDouble(device_name, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCalInfoAttributeString(::grpc::ServerContext* context, const SetCalInfoAttributeStringRequest* request, SetCalInfoAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetCalInfoAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::CalibrationInfoStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetCalInfoAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::CalibrationInfoStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetCalInfoAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = request->value().c_str();
      auto size = 0U;
      auto status = library_->SetCalInfoAttributeString(device_name, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetCalInfoAttributeUInt32(::grpc::ServerContext* context, const SetCalInfoAttributeUInt32Request* request, SetCalInfoAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetCalInfoAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::CalibrationInfoUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetCalInfoAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::CalibrationInfoUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetCalInfoAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto size = 0U;
      auto status = library_->SetCalInfoAttributeUInt32(device_name, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanAttributeBool(::grpc::ServerContext* context, const SetChanAttributeBoolRequest* request, SetChanAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      bool32 value = request->value();
      auto size = 0U;
      auto status = library_->SetChanAttributeBool(task, channel, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanAttributeDouble(::grpc::ServerContext* context, const SetChanAttributeDoubleRequest* request, SetChanAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      float64 value = request->value();
      auto size = 0U;
      auto status = library_->SetChanAttributeDouble(task, channel, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanAttributeDoubleArray(::grpc::ServerContext* context, const SetChanAttributeDoubleArrayRequest* request, SetChanAttributeDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeDoubleArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelDoubleArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeDoubleArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelDoubleArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeDoubleArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = const_cast<const float64*>(request->value().data());
      uInt32 size = static_cast<uInt32>(request->value().size());
      auto status = library_->SetChanAttributeDoubleArray(task, channel, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanAttributeInt32(::grpc::ServerContext* context, const SetChanAttributeInt32Request* request, SetChanAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetChanAttributeInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetChanAttributeInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      auto status = library_->SetChanAttributeInt32(task, channel, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanAttributeString(::grpc::ServerContext* context, const SetChanAttributeStringRequest* request, SetChanAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = request->value().c_str();
      auto size = 0U;
      auto status = library_->SetChanAttributeString(task, channel, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanAttributeUInt32(::grpc::ServerContext* context, const SetChanAttributeUInt32Request* request, SetChanAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ChannelUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ChannelUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetChanAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto size = 0U;
      auto status = library_->SetChanAttributeUInt32(task, channel, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDigitalLogicFamilyPowerUpState(::grpc::ServerContext* context, const SetDigitalLogicFamilyPowerUpStateRequest* request, SetDigitalLogicFamilyPowerUpStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      int32 logic_family;
      switch (request->logic_family_enum_case()) {
        case nidaqmx_grpc::SetDigitalLogicFamilyPowerUpStateRequest::LogicFamilyEnumCase::kLogicFamily: {
          logic_family = static_cast<int32>(request->logic_family());
          break;
        }
        case nidaqmx_grpc::SetDigitalLogicFamilyPowerUpStateRequest::LogicFamilyEnumCase::kLogicFamilyRaw: {
          logic_family = static_cast<int32>(request->logic_family_raw());
          break;
        }
        case nidaqmx_grpc::SetDigitalLogicFamilyPowerUpStateRequest::LogicFamilyEnumCase::LOGIC_FAMILY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for logic_family was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetDigitalLogicFamilyPowerUpState(device_name, logic_family);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDigitalPowerUpStates(::grpc::ServerContext* context, const SetDigitalPowerUpStatesRequest* request, SetDigitalPowerUpStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto get_channelNames_if = [](const google::protobuf::RepeatedPtrField<DigitalPowerUpChannelsAndState>& vector, int n) -> const char* {
            if (vector.size() > n) {
                  return vector[n].channel_names().c_str();
            }
            return nullptr;
      };
      auto get_state_if = [](const google::protobuf::RepeatedPtrField<DigitalPowerUpChannelsAndState>& vector, int n) -> int32 {
            if (vector.size() > n) {
                  return vector[n].state();
            }
            return 0;
      };
      auto power_up_states = request->power_up_states();
      if (power_up_states.size() == 0) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "No values for powerUpStates were specified");
      }
      if (power_up_states.size() > 96) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "More than 96 values for powerUpStates were specified");
      }

      auto status = ((NiDAQmxLibrary*)library_)->SetDigitalPowerUpStates(device_name, get_channelNames_if(power_up_states, 0), get_state_if(power_up_states, 0), get_channelNames_if(power_up_states, 1), get_state_if(power_up_states, 1), get_channelNames_if(power_up_states, 2), get_state_if(power_up_states, 2), get_channelNames_if(power_up_states, 3), get_state_if(power_up_states, 3), get_channelNames_if(power_up_states, 4), get_state_if(power_up_states, 4), get_channelNames_if(power_up_states, 5), get_state_if(power_up_states, 5), get_channelNames_if(power_up_states, 6), get_state_if(power_up_states, 6), get_channelNames_if(power_up_states, 7), get_state_if(power_up_states, 7), get_channelNames_if(power_up_states, 8), get_state_if(power_up_states, 8), get_channelNames_if(power_up_states, 9), get_state_if(power_up_states, 9), get_channelNames_if(power_up_states, 10), get_state_if(power_up_states, 10), get_channelNames_if(power_up_states, 11), get_state_if(power_up_states, 11), get_channelNames_if(power_up_states, 12), get_state_if(power_up_states, 12), get_channelNames_if(power_up_states, 13), get_state_if(power_up_states, 13), get_channelNames_if(power_up_states, 14), get_state_if(power_up_states, 14), get_channelNames_if(power_up_states, 15), get_state_if(power_up_states, 15), get_channelNames_if(power_up_states, 16), get_state_if(power_up_states, 16), get_channelNames_if(power_up_states, 17), get_state_if(power_up_states, 17), get_channelNames_if(power_up_states, 18), get_state_if(power_up_states, 18), get_channelNames_if(power_up_states, 19), get_state_if(power_up_states, 19), get_channelNames_if(power_up_states, 20), get_state_if(power_up_states, 20), get_channelNames_if(power_up_states, 21), get_state_if(power_up_states, 21), get_channelNames_if(power_up_states, 22), get_state_if(power_up_states, 22), get_channelNames_if(power_up_states, 23), get_state_if(power_up_states, 23), get_channelNames_if(power_up_states, 24), get_state_if(power_up_states, 24), get_channelNames_if(power_up_states, 25), get_state_if(power_up_states, 25), get_channelNames_if(power_up_states, 26), get_state_if(power_up_states, 26), get_channelNames_if(power_up_states, 27), get_state_if(power_up_states, 27), get_channelNames_if(power_up_states, 28), get_state_if(power_up_states, 28), get_channelNames_if(power_up_states, 29), get_state_if(power_up_states, 29), get_channelNames_if(power_up_states, 30), get_state_if(power_up_states, 30), get_channelNames_if(power_up_states, 31), get_state_if(power_up_states, 31), get_channelNames_if(power_up_states, 32), get_state_if(power_up_states, 32), get_channelNames_if(power_up_states, 33), get_state_if(power_up_states, 33), get_channelNames_if(power_up_states, 34), get_state_if(power_up_states, 34), get_channelNames_if(power_up_states, 35), get_state_if(power_up_states, 35), get_channelNames_if(power_up_states, 36), get_state_if(power_up_states, 36), get_channelNames_if(power_up_states, 37), get_state_if(power_up_states, 37), get_channelNames_if(power_up_states, 38), get_state_if(power_up_states, 38), get_channelNames_if(power_up_states, 39), get_state_if(power_up_states, 39), get_channelNames_if(power_up_states, 40), get_state_if(power_up_states, 40), get_channelNames_if(power_up_states, 41), get_state_if(power_up_states, 41), get_channelNames_if(power_up_states, 42), get_state_if(power_up_states, 42), get_channelNames_if(power_up_states, 43), get_state_if(power_up_states, 43), get_channelNames_if(power_up_states, 44), get_state_if(power_up_states, 44), get_channelNames_if(power_up_states, 45), get_state_if(power_up_states, 45), get_channelNames_if(power_up_states, 46), get_state_if(power_up_states, 46), get_channelNames_if(power_up_states, 47), get_state_if(power_up_states, 47), get_channelNames_if(power_up_states, 48), get_state_if(power_up_states, 48), get_channelNames_if(power_up_states, 49), get_state_if(power_up_states, 49), get_channelNames_if(power_up_states, 50), get_state_if(power_up_states, 50), get_channelNames_if(power_up_states, 51), get_state_if(power_up_states, 51), get_channelNames_if(power_up_states, 52), get_state_if(power_up_states, 52), get_channelNames_if(power_up_states, 53), get_state_if(power_up_states, 53), get_channelNames_if(power_up_states, 54), get_state_if(power_up_states, 54), get_channelNames_if(power_up_states, 55), get_state_if(power_up_states, 55), get_channelNames_if(power_up_states, 56), get_state_if(power_up_states, 56), get_channelNames_if(power_up_states, 57), get_state_if(power_up_states, 57), get_channelNames_if(power_up_states, 58), get_state_if(power_up_states, 58), get_channelNames_if(power_up_states, 59), get_state_if(power_up_states, 59), get_channelNames_if(power_up_states, 60), get_state_if(power_up_states, 60), get_channelNames_if(power_up_states, 61), get_state_if(power_up_states, 61), get_channelNames_if(power_up_states, 62), get_state_if(power_up_states, 62), get_channelNames_if(power_up_states, 63), get_state_if(power_up_states, 63), get_channelNames_if(power_up_states, 64), get_state_if(power_up_states, 64), get_channelNames_if(power_up_states, 65), get_state_if(power_up_states, 65), get_channelNames_if(power_up_states, 66), get_state_if(power_up_states, 66), get_channelNames_if(power_up_states, 67), get_state_if(power_up_states, 67), get_channelNames_if(power_up_states, 68), get_state_if(power_up_states, 68), get_channelNames_if(power_up_states, 69), get_state_if(power_up_states, 69), get_channelNames_if(power_up_states, 70), get_state_if(power_up_states, 70), get_channelNames_if(power_up_states, 71), get_state_if(power_up_states, 71), get_channelNames_if(power_up_states, 72), get_state_if(power_up_states, 72), get_channelNames_if(power_up_states, 73), get_state_if(power_up_states, 73), get_channelNames_if(power_up_states, 74), get_state_if(power_up_states, 74), get_channelNames_if(power_up_states, 75), get_state_if(power_up_states, 75), get_channelNames_if(power_up_states, 76), get_state_if(power_up_states, 76), get_channelNames_if(power_up_states, 77), get_state_if(power_up_states, 77), get_channelNames_if(power_up_states, 78), get_state_if(power_up_states, 78), get_channelNames_if(power_up_states, 79), get_state_if(power_up_states, 79), get_channelNames_if(power_up_states, 80), get_state_if(power_up_states, 80), get_channelNames_if(power_up_states, 81), get_state_if(power_up_states, 81), get_channelNames_if(power_up_states, 82), get_state_if(power_up_states, 82), get_channelNames_if(power_up_states, 83), get_state_if(power_up_states, 83), get_channelNames_if(power_up_states, 84), get_state_if(power_up_states, 84), get_channelNames_if(power_up_states, 85), get_state_if(power_up_states, 85), get_channelNames_if(power_up_states, 86), get_state_if(power_up_states, 86), get_channelNames_if(power_up_states, 87), get_state_if(power_up_states, 87), get_channelNames_if(power_up_states, 88), get_state_if(power_up_states, 88), get_channelNames_if(power_up_states, 89), get_state_if(power_up_states, 89), get_channelNames_if(power_up_states, 90), get_state_if(power_up_states, 90), get_channelNames_if(power_up_states, 91), get_state_if(power_up_states, 91), get_channelNames_if(power_up_states, 92), get_state_if(power_up_states, 92), get_channelNames_if(power_up_states, 93), get_state_if(power_up_states, 93), get_channelNames_if(power_up_states, 94), get_state_if(power_up_states, 94), get_channelNames_if(power_up_states, 95), get_state_if(power_up_states, 95), get_channelNames_if(power_up_states, 96), get_state_if(power_up_states, 96));
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetDigitalPullUpPullDownStates(::grpc::ServerContext* context, const SetDigitalPullUpPullDownStatesRequest* request, SetDigitalPullUpPullDownStatesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto get_channelNames_if = [](const google::protobuf::RepeatedPtrField<DigitalPullUpPullDownChannelsAndState>& vector, int n) -> const char* {
            if (vector.size() > n) {
                  return vector[n].channel_names().c_str();
            }
            return nullptr;
      };
      auto get_state_if = [](const google::protobuf::RepeatedPtrField<DigitalPullUpPullDownChannelsAndState>& vector, int n) -> int32 {
            if (vector.size() > n) {
                  return vector[n].state();
            }
            return 0;
      };
      auto pull_up_pull_down_states = request->pull_up_pull_down_states();
      if (pull_up_pull_down_states.size() == 0) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "No values for pullUpPullDownStates were specified");
      }
      if (pull_up_pull_down_states.size() > 96) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "More than 96 values for pullUpPullDownStates were specified");
      }

      auto status = ((NiDAQmxLibrary*)library_)->SetDigitalPullUpPullDownStates(device_name, get_channelNames_if(pull_up_pull_down_states, 0), get_state_if(pull_up_pull_down_states, 0), get_channelNames_if(pull_up_pull_down_states, 1), get_state_if(pull_up_pull_down_states, 1), get_channelNames_if(pull_up_pull_down_states, 2), get_state_if(pull_up_pull_down_states, 2), get_channelNames_if(pull_up_pull_down_states, 3), get_state_if(pull_up_pull_down_states, 3), get_channelNames_if(pull_up_pull_down_states, 4), get_state_if(pull_up_pull_down_states, 4), get_channelNames_if(pull_up_pull_down_states, 5), get_state_if(pull_up_pull_down_states, 5), get_channelNames_if(pull_up_pull_down_states, 6), get_state_if(pull_up_pull_down_states, 6), get_channelNames_if(pull_up_pull_down_states, 7), get_state_if(pull_up_pull_down_states, 7), get_channelNames_if(pull_up_pull_down_states, 8), get_state_if(pull_up_pull_down_states, 8), get_channelNames_if(pull_up_pull_down_states, 9), get_state_if(pull_up_pull_down_states, 9), get_channelNames_if(pull_up_pull_down_states, 10), get_state_if(pull_up_pull_down_states, 10), get_channelNames_if(pull_up_pull_down_states, 11), get_state_if(pull_up_pull_down_states, 11), get_channelNames_if(pull_up_pull_down_states, 12), get_state_if(pull_up_pull_down_states, 12), get_channelNames_if(pull_up_pull_down_states, 13), get_state_if(pull_up_pull_down_states, 13), get_channelNames_if(pull_up_pull_down_states, 14), get_state_if(pull_up_pull_down_states, 14), get_channelNames_if(pull_up_pull_down_states, 15), get_state_if(pull_up_pull_down_states, 15), get_channelNames_if(pull_up_pull_down_states, 16), get_state_if(pull_up_pull_down_states, 16), get_channelNames_if(pull_up_pull_down_states, 17), get_state_if(pull_up_pull_down_states, 17), get_channelNames_if(pull_up_pull_down_states, 18), get_state_if(pull_up_pull_down_states, 18), get_channelNames_if(pull_up_pull_down_states, 19), get_state_if(pull_up_pull_down_states, 19), get_channelNames_if(pull_up_pull_down_states, 20), get_state_if(pull_up_pull_down_states, 20), get_channelNames_if(pull_up_pull_down_states, 21), get_state_if(pull_up_pull_down_states, 21), get_channelNames_if(pull_up_pull_down_states, 22), get_state_if(pull_up_pull_down_states, 22), get_channelNames_if(pull_up_pull_down_states, 23), get_state_if(pull_up_pull_down_states, 23), get_channelNames_if(pull_up_pull_down_states, 24), get_state_if(pull_up_pull_down_states, 24), get_channelNames_if(pull_up_pull_down_states, 25), get_state_if(pull_up_pull_down_states, 25), get_channelNames_if(pull_up_pull_down_states, 26), get_state_if(pull_up_pull_down_states, 26), get_channelNames_if(pull_up_pull_down_states, 27), get_state_if(pull_up_pull_down_states, 27), get_channelNames_if(pull_up_pull_down_states, 28), get_state_if(pull_up_pull_down_states, 28), get_channelNames_if(pull_up_pull_down_states, 29), get_state_if(pull_up_pull_down_states, 29), get_channelNames_if(pull_up_pull_down_states, 30), get_state_if(pull_up_pull_down_states, 30), get_channelNames_if(pull_up_pull_down_states, 31), get_state_if(pull_up_pull_down_states, 31), get_channelNames_if(pull_up_pull_down_states, 32), get_state_if(pull_up_pull_down_states, 32), get_channelNames_if(pull_up_pull_down_states, 33), get_state_if(pull_up_pull_down_states, 33), get_channelNames_if(pull_up_pull_down_states, 34), get_state_if(pull_up_pull_down_states, 34), get_channelNames_if(pull_up_pull_down_states, 35), get_state_if(pull_up_pull_down_states, 35), get_channelNames_if(pull_up_pull_down_states, 36), get_state_if(pull_up_pull_down_states, 36), get_channelNames_if(pull_up_pull_down_states, 37), get_state_if(pull_up_pull_down_states, 37), get_channelNames_if(pull_up_pull_down_states, 38), get_state_if(pull_up_pull_down_states, 38), get_channelNames_if(pull_up_pull_down_states, 39), get_state_if(pull_up_pull_down_states, 39), get_channelNames_if(pull_up_pull_down_states, 40), get_state_if(pull_up_pull_down_states, 40), get_channelNames_if(pull_up_pull_down_states, 41), get_state_if(pull_up_pull_down_states, 41), get_channelNames_if(pull_up_pull_down_states, 42), get_state_if(pull_up_pull_down_states, 42), get_channelNames_if(pull_up_pull_down_states, 43), get_state_if(pull_up_pull_down_states, 43), get_channelNames_if(pull_up_pull_down_states, 44), get_state_if(pull_up_pull_down_states, 44), get_channelNames_if(pull_up_pull_down_states, 45), get_state_if(pull_up_pull_down_states, 45), get_channelNames_if(pull_up_pull_down_states, 46), get_state_if(pull_up_pull_down_states, 46), get_channelNames_if(pull_up_pull_down_states, 47), get_state_if(pull_up_pull_down_states, 47), get_channelNames_if(pull_up_pull_down_states, 48), get_state_if(pull_up_pull_down_states, 48), get_channelNames_if(pull_up_pull_down_states, 49), get_state_if(pull_up_pull_down_states, 49), get_channelNames_if(pull_up_pull_down_states, 50), get_state_if(pull_up_pull_down_states, 50), get_channelNames_if(pull_up_pull_down_states, 51), get_state_if(pull_up_pull_down_states, 51), get_channelNames_if(pull_up_pull_down_states, 52), get_state_if(pull_up_pull_down_states, 52), get_channelNames_if(pull_up_pull_down_states, 53), get_state_if(pull_up_pull_down_states, 53), get_channelNames_if(pull_up_pull_down_states, 54), get_state_if(pull_up_pull_down_states, 54), get_channelNames_if(pull_up_pull_down_states, 55), get_state_if(pull_up_pull_down_states, 55), get_channelNames_if(pull_up_pull_down_states, 56), get_state_if(pull_up_pull_down_states, 56), get_channelNames_if(pull_up_pull_down_states, 57), get_state_if(pull_up_pull_down_states, 57), get_channelNames_if(pull_up_pull_down_states, 58), get_state_if(pull_up_pull_down_states, 58), get_channelNames_if(pull_up_pull_down_states, 59), get_state_if(pull_up_pull_down_states, 59), get_channelNames_if(pull_up_pull_down_states, 60), get_state_if(pull_up_pull_down_states, 60), get_channelNames_if(pull_up_pull_down_states, 61), get_state_if(pull_up_pull_down_states, 61), get_channelNames_if(pull_up_pull_down_states, 62), get_state_if(pull_up_pull_down_states, 62), get_channelNames_if(pull_up_pull_down_states, 63), get_state_if(pull_up_pull_down_states, 63), get_channelNames_if(pull_up_pull_down_states, 64), get_state_if(pull_up_pull_down_states, 64), get_channelNames_if(pull_up_pull_down_states, 65), get_state_if(pull_up_pull_down_states, 65), get_channelNames_if(pull_up_pull_down_states, 66), get_state_if(pull_up_pull_down_states, 66), get_channelNames_if(pull_up_pull_down_states, 67), get_state_if(pull_up_pull_down_states, 67), get_channelNames_if(pull_up_pull_down_states, 68), get_state_if(pull_up_pull_down_states, 68), get_channelNames_if(pull_up_pull_down_states, 69), get_state_if(pull_up_pull_down_states, 69), get_channelNames_if(pull_up_pull_down_states, 70), get_state_if(pull_up_pull_down_states, 70), get_channelNames_if(pull_up_pull_down_states, 71), get_state_if(pull_up_pull_down_states, 71), get_channelNames_if(pull_up_pull_down_states, 72), get_state_if(pull_up_pull_down_states, 72), get_channelNames_if(pull_up_pull_down_states, 73), get_state_if(pull_up_pull_down_states, 73), get_channelNames_if(pull_up_pull_down_states, 74), get_state_if(pull_up_pull_down_states, 74), get_channelNames_if(pull_up_pull_down_states, 75), get_state_if(pull_up_pull_down_states, 75), get_channelNames_if(pull_up_pull_down_states, 76), get_state_if(pull_up_pull_down_states, 76), get_channelNames_if(pull_up_pull_down_states, 77), get_state_if(pull_up_pull_down_states, 77), get_channelNames_if(pull_up_pull_down_states, 78), get_state_if(pull_up_pull_down_states, 78), get_channelNames_if(pull_up_pull_down_states, 79), get_state_if(pull_up_pull_down_states, 79), get_channelNames_if(pull_up_pull_down_states, 80), get_state_if(pull_up_pull_down_states, 80), get_channelNames_if(pull_up_pull_down_states, 81), get_state_if(pull_up_pull_down_states, 81), get_channelNames_if(pull_up_pull_down_states, 82), get_state_if(pull_up_pull_down_states, 82), get_channelNames_if(pull_up_pull_down_states, 83), get_state_if(pull_up_pull_down_states, 83), get_channelNames_if(pull_up_pull_down_states, 84), get_state_if(pull_up_pull_down_states, 84), get_channelNames_if(pull_up_pull_down_states, 85), get_state_if(pull_up_pull_down_states, 85), get_channelNames_if(pull_up_pull_down_states, 86), get_state_if(pull_up_pull_down_states, 86), get_channelNames_if(pull_up_pull_down_states, 87), get_state_if(pull_up_pull_down_states, 87), get_channelNames_if(pull_up_pull_down_states, 88), get_state_if(pull_up_pull_down_states, 88), get_channelNames_if(pull_up_pull_down_states, 89), get_state_if(pull_up_pull_down_states, 89), get_channelNames_if(pull_up_pull_down_states, 90), get_state_if(pull_up_pull_down_states, 90), get_channelNames_if(pull_up_pull_down_states, 91), get_state_if(pull_up_pull_down_states, 91), get_channelNames_if(pull_up_pull_down_states, 92), get_state_if(pull_up_pull_down_states, 92), get_channelNames_if(pull_up_pull_down_states, 93), get_state_if(pull_up_pull_down_states, 93), get_channelNames_if(pull_up_pull_down_states, 94), get_state_if(pull_up_pull_down_states, 94), get_channelNames_if(pull_up_pull_down_states, 95), get_state_if(pull_up_pull_down_states, 95), get_channelNames_if(pull_up_pull_down_states, 96), get_state_if(pull_up_pull_down_states, 96));
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetExportedSignalAttributeBool(::grpc::ServerContext* context, const SetExportedSignalAttributeBoolRequest* request, SetExportedSignalAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetExportedSignalAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      bool32 value = request->value();
      auto size = 0U;
      auto status = library_->SetExportedSignalAttributeBool(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetExportedSignalAttributeDouble(::grpc::ServerContext* context, const SetExportedSignalAttributeDoubleRequest* request, SetExportedSignalAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetExportedSignalAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      float64 value = request->value();
      auto size = 0U;
      auto status = library_->SetExportedSignalAttributeDouble(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetExportedSignalAttributeInt32(::grpc::ServerContext* context, const SetExportedSignalAttributeInt32Request* request, SetExportedSignalAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetExportedSignalAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetExportedSignalAttributeInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      auto status = library_->SetExportedSignalAttributeInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetExportedSignalAttributeString(::grpc::ServerContext* context, const SetExportedSignalAttributeStringRequest* request, SetExportedSignalAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetExportedSignalAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = request->value().c_str();
      auto size = 0U;
      auto status = library_->SetExportedSignalAttributeString(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetExportedSignalAttributeUInt32(::grpc::ServerContext* context, const SetExportedSignalAttributeUInt32Request* request, SetExportedSignalAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetExportedSignalAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ExportSignalUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ExportSignalUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetExportedSignalAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto size = 0U;
      auto status = library_->SetExportedSignalAttributeUInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetFirstSampClkWhen(::grpc::ServerContext* context, const SetFirstSampClkWhenRequest* request, SetFirstSampClkWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetFirstSampClkWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetReadAttributeBool(::grpc::ServerContext* context, const SetReadAttributeBoolRequest* request, SetReadAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetReadAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      bool32 value = request->value();
      auto size = 0U;
      auto status = library_->SetReadAttributeBool(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetReadAttributeDouble(::grpc::ServerContext* context, const SetReadAttributeDoubleRequest* request, SetReadAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetReadAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      float64 value = request->value();
      auto size = 0U;
      auto status = library_->SetReadAttributeDouble(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetReadAttributeInt32(::grpc::ServerContext* context, const SetReadAttributeInt32Request* request, SetReadAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetReadAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetReadAttributeInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetReadAttributeInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetReadAttributeInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      auto status = library_->SetReadAttributeInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetReadAttributeString(::grpc::ServerContext* context, const SetReadAttributeStringRequest* request, SetReadAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetReadAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = request->value().c_str();
      auto size = 0U;
      auto status = library_->SetReadAttributeString(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetReadAttributeUInt32(::grpc::ServerContext* context, const SetReadAttributeUInt32Request* request, SetReadAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetReadAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto size = 0U;
      auto status = library_->SetReadAttributeUInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetReadAttributeUInt64(::grpc::ServerContext* context, const SetReadAttributeUInt64Request* request, SetReadAttributeUInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetReadAttributeUInt64Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ReadUInt64Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeUInt64Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ReadUInt64Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetReadAttributeUInt64Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt64 value = request->value();
      auto size = 0U;
      auto status = library_->SetReadAttributeUInt64(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetRealTimeAttributeBool(::grpc::ServerContext* context, const SetRealTimeAttributeBoolRequest* request, SetRealTimeAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetRealTimeAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::RealTimeBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::RealTimeBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      bool32 value = request->value();
      auto size = 0U;
      auto status = library_->SetRealTimeAttributeBool(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetRealTimeAttributeInt32(::grpc::ServerContext* context, const SetRealTimeAttributeInt32Request* request, SetRealTimeAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetRealTimeAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::RealTimeInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::RealTimeInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetRealTimeAttributeInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      auto status = library_->SetRealTimeAttributeInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetRealTimeAttributeUInt32(::grpc::ServerContext* context, const SetRealTimeAttributeUInt32Request* request, SetRealTimeAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetRealTimeAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::RealTimeUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::RealTimeUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto size = 0U;
      auto status = library_->SetRealTimeAttributeUInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetScaleAttributeDouble(::grpc::ServerContext* context, const SetScaleAttributeDoubleRequest* request, SetScaleAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetScaleAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ScaleDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ScaleDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      float64 value = request->value();
      auto size = 0U;
      auto status = library_->SetScaleAttributeDouble(scale_name, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetScaleAttributeDoubleArray(::grpc::ServerContext* context, const SetScaleAttributeDoubleArrayRequest* request, SetScaleAttributeDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetScaleAttributeDoubleArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ScaleDoubleArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeDoubleArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ScaleDoubleArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeDoubleArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = const_cast<const float64*>(request->value().data());
      uInt32 size = static_cast<uInt32>(request->value().size());
      auto status = library_->SetScaleAttributeDoubleArray(scale_name, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetScaleAttributeInt32(::grpc::ServerContext* context, const SetScaleAttributeInt32Request* request, SetScaleAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetScaleAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ScaleInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ScaleInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetScaleAttributeInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      auto status = library_->SetScaleAttributeInt32(scale_name, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetScaleAttributeString(::grpc::ServerContext* context, const SetScaleAttributeStringRequest* request, SetScaleAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto scale_name = request->scale_name().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetScaleAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::ScaleStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::ScaleStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetScaleAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = request->value().c_str();
      auto size = 0U;
      auto status = library_->SetScaleAttributeString(scale_name, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetStartTrigTrigWhen(::grpc::ServerContext* context, const SetStartTrigTrigWhenRequest* request, SetStartTrigTrigWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetStartTrigTrigWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetSyncPulseTimeWhen(::grpc::ServerContext* context, const SetSyncPulseTimeWhenRequest* request, SetSyncPulseTimeWhenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto data = convert_from_grpc<CVIAbsoluteTime>(request->data());
      auto status = library_->SetSyncPulseTimeWhen(task, data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeBool(::grpc::ServerContext* context, const SetTimingAttributeBoolRequest* request, SetTimingAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      bool32 value = request->value();
      auto size = 0U;
      auto status = library_->SetTimingAttributeBool(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeDouble(::grpc::ServerContext* context, const SetTimingAttributeDoubleRequest* request, SetTimingAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      float64 value = request->value();
      auto size = 0U;
      auto status = library_->SetTimingAttributeDouble(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeExBool(::grpc::ServerContext* context, const SetTimingAttributeExBoolRequest* request, SetTimingAttributeExBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeExBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      bool32 value = request->value();
      auto size = 0U;
      auto status = library_->SetTimingAttributeExBool(task, device_names, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeExDouble(::grpc::ServerContext* context, const SetTimingAttributeExDoubleRequest* request, SetTimingAttributeExDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeExDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      float64 value = request->value();
      auto size = 0U;
      auto status = library_->SetTimingAttributeExDouble(task, device_names, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeExInt32(::grpc::ServerContext* context, const SetTimingAttributeExInt32Request* request, SetTimingAttributeExInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeExInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeExInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      auto status = library_->SetTimingAttributeExInt32(task, device_names, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeExString(::grpc::ServerContext* context, const SetTimingAttributeExStringRequest* request, SetTimingAttributeExStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeExStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = request->value().c_str();
      auto size = 0U;
      auto status = library_->SetTimingAttributeExString(task, device_names, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeExTimestamp(::grpc::ServerContext* context, const SetTimingAttributeExTimestampRequest* request, SetTimingAttributeExTimestampResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeExTimestampRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingTimestampAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExTimestampRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingTimestampAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExTimestampRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = convert_from_grpc<CVIAbsoluteTime>(request->value());
      auto size = 0U;
      auto status = library_->SetTimingAttributeExTimestamp(task, device_names, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeExUInt32(::grpc::ServerContext* context, const SetTimingAttributeExUInt32Request* request, SetTimingAttributeExUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeExUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto size = 0U;
      auto status = library_->SetTimingAttributeExUInt32(task, device_names, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeExUInt64(::grpc::ServerContext* context, const SetTimingAttributeExUInt64Request* request, SetTimingAttributeExUInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto device_names = request->device_names().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeExUInt64Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingUInt64Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExUInt64Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingUInt64Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeExUInt64Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt64 value = request->value();
      auto size = 0U;
      auto status = library_->SetTimingAttributeExUInt64(task, device_names, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeInt32(::grpc::ServerContext* context, const SetTimingAttributeInt32Request* request, SetTimingAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      auto status = library_->SetTimingAttributeInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeString(::grpc::ServerContext* context, const SetTimingAttributeStringRequest* request, SetTimingAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = request->value().c_str();
      auto size = 0U;
      auto status = library_->SetTimingAttributeString(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeTimestamp(::grpc::ServerContext* context, const SetTimingAttributeTimestampRequest* request, SetTimingAttributeTimestampResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeTimestampRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingTimestampAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeTimestampRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingTimestampAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeTimestampRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = convert_from_grpc<CVIAbsoluteTime>(request->value());
      auto size = 0U;
      auto status = library_->SetTimingAttributeTimestamp(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeUInt32(::grpc::ServerContext* context, const SetTimingAttributeUInt32Request* request, SetTimingAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto size = 0U;
      auto status = library_->SetTimingAttributeUInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeUInt64(::grpc::ServerContext* context, const SetTimingAttributeUInt64Request* request, SetTimingAttributeUInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeUInt64Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TimingUInt64Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeUInt64Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TimingUInt64Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeUInt64Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt64 value = request->value();
      auto size = 0U;
      auto status = library_->SetTimingAttributeUInt64(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTrigAttributeBool(::grpc::ServerContext* context, const SetTrigAttributeBoolRequest* request, SetTrigAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTrigAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      bool32 value = request->value();
      auto size = 0U;
      auto status = library_->SetTrigAttributeBool(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTrigAttributeDouble(::grpc::ServerContext* context, const SetTrigAttributeDoubleRequest* request, SetTrigAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTrigAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      float64 value = request->value();
      auto size = 0U;
      auto status = library_->SetTrigAttributeDouble(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTrigAttributeDoubleArray(::grpc::ServerContext* context, const SetTrigAttributeDoubleArrayRequest* request, SetTrigAttributeDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTrigAttributeDoubleArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerDoubleArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeDoubleArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerDoubleArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeDoubleArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = const_cast<const float64*>(request->value().data());
      uInt32 size = static_cast<uInt32>(request->value().size());
      auto status = library_->SetTrigAttributeDoubleArray(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTrigAttributeInt32(::grpc::ServerContext* context, const SetTrigAttributeInt32Request* request, SetTrigAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTrigAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetTrigAttributeInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      auto status = library_->SetTrigAttributeInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTrigAttributeInt32Array(::grpc::ServerContext* context, const SetTrigAttributeInt32ArrayRequest* request, SetTrigAttributeInt32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTrigAttributeInt32ArrayRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerInt32ArrayAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeInt32ArrayRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerInt32ArrayAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeInt32ArrayRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = reinterpret_cast<const int32*>(request->value().data());
      uInt32 size = static_cast<uInt32>(request->value().size());
      auto status = library_->SetTrigAttributeInt32Array(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTrigAttributeString(::grpc::ServerContext* context, const SetTrigAttributeStringRequest* request, SetTrigAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTrigAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = request->value().c_str();
      auto size = 0U;
      auto status = library_->SetTrigAttributeString(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTrigAttributeTimestamp(::grpc::ServerContext* context, const SetTrigAttributeTimestampRequest* request, SetTrigAttributeTimestampResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTrigAttributeTimestampRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerTimestampAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeTimestampRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerTimestampAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeTimestampRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = convert_from_grpc<CVIAbsoluteTime>(request->value());
      auto size = 0U;
      auto status = library_->SetTrigAttributeTimestamp(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTrigAttributeUInt32(::grpc::ServerContext* context, const SetTrigAttributeUInt32Request* request, SetTrigAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTrigAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::TriggerUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::TriggerUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetTrigAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto size = 0U;
      auto status = library_->SetTrigAttributeUInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetWatchdogAttributeBool(::grpc::ServerContext* context, const SetWatchdogAttributeBoolRequest* request, SetWatchdogAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetWatchdogAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WatchdogBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWatchdogAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WatchdogBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWatchdogAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      bool32 value = request->value();
      auto size = 0U;
      auto status = library_->SetWatchdogAttributeBool(task, lines, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetWatchdogAttributeDouble(::grpc::ServerContext* context, const SetWatchdogAttributeDoubleRequest* request, SetWatchdogAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetWatchdogAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WatchdogDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWatchdogAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WatchdogDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWatchdogAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      float64 value = request->value();
      auto size = 0U;
      auto status = library_->SetWatchdogAttributeDouble(task, lines, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetWatchdogAttributeInt32(::grpc::ServerContext* context, const SetWatchdogAttributeInt32Request* request, SetWatchdogAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetWatchdogAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WatchdogInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWatchdogAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WatchdogInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWatchdogAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetWatchdogAttributeInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetWatchdogAttributeInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetWatchdogAttributeInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      auto status = library_->SetWatchdogAttributeInt32(task, lines, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetWatchdogAttributeString(::grpc::ServerContext* context, const SetWatchdogAttributeStringRequest* request, SetWatchdogAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto lines = request->lines().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetWatchdogAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WatchdogStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWatchdogAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WatchdogStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWatchdogAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = request->value().c_str();
      auto size = 0U;
      auto status = library_->SetWatchdogAttributeString(task, lines, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetWriteAttributeBool(::grpc::ServerContext* context, const SetWriteAttributeBoolRequest* request, SetWriteAttributeBoolResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetWriteAttributeBoolRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteBoolAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeBoolRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteBoolAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeBoolRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      bool32 value = request->value();
      auto size = 0U;
      auto status = library_->SetWriteAttributeBool(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetWriteAttributeDouble(::grpc::ServerContext* context, const SetWriteAttributeDoubleRequest* request, SetWriteAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetWriteAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteDoubleAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteDoubleAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      float64 value = request->value();
      auto size = 0U;
      auto status = library_->SetWriteAttributeDouble(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetWriteAttributeInt32(::grpc::ServerContext* context, const SetWriteAttributeInt32Request* request, SetWriteAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetWriteAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value;
      switch (request->value_enum_case()) {
        case nidaqmx_grpc::SetWriteAttributeInt32Request::ValueEnumCase::kValue: {
          value = static_cast<int32>(request->value());
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<int32>(request->value_raw());
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto size = 0U;
      auto status = library_->SetWriteAttributeInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetWriteAttributeString(::grpc::ServerContext* context, const SetWriteAttributeStringRequest* request, SetWriteAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetWriteAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteStringAttribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteStringAttribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      auto value = request->value().c_str();
      auto size = 0U;
      auto status = library_->SetWriteAttributeString(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetWriteAttributeUInt32(::grpc::ServerContext* context, const SetWriteAttributeUInt32Request* request, SetWriteAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetWriteAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteUInt32Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteUInt32Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto size = 0U;
      auto status = library_->SetWriteAttributeUInt32(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetWriteAttributeUInt64(::grpc::ServerContext* context, const SetWriteAttributeUInt64Request* request, SetWriteAttributeUInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetWriteAttributeUInt64Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          attribute = nidaqmx_grpc::WriteUInt64Attribute_IsValid(attribute) ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeUInt64Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          auto attribute_is_valid = nidaqmx_grpc::WriteUInt64Attribute_IsValid(attribute) || feature_toggles_.is_allow_undefined_attributes_enabled;
          attribute = attribute_is_valid ? attribute : 0;
          break;
        }
        case nidaqmx_grpc::SetWriteAttributeUInt64Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt64 value = request->value();
      auto size = 0U;
      auto status = library_->SetWriteAttributeUInt64(task, attribute, value, size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StartNewFile(::grpc::ServerContext* context, const StartNewFileRequest* request, StartNewFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->StartNewFile(task, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StartTask(::grpc::ServerContext* context, const StartTaskRequest* request, StartTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->StartTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StopTask(::grpc::ServerContext* context, const StopTaskRequest* request, StopTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->StopTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::TaskControl(::grpc::ServerContext* context, const TaskControlRequest* request, TaskControlResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 action;
      switch (request->action_enum_case()) {
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::kAction: {
          action = static_cast<int32>(request->action());
          break;
        }
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::kActionRaw: {
          action = static_cast<int32>(request->action_raw());
          break;
        }
        case nidaqmx_grpc::TaskControlRequest::ActionEnumCase::ACTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for action was not specified or out of range");
          break;
        }
      }

      auto status = library_->TaskControl(task, action);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::TristateOutputTerm(::grpc::ServerContext* context, const TristateOutputTermRequest* request, TristateOutputTermResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto output_terminal = request->output_terminal().c_str();
      auto status = library_->TristateOutputTerm(output_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::UnreserveNetworkDevice(::grpc::ServerContext* context, const UnreserveNetworkDeviceRequest* request, UnreserveNetworkDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto device_name = request->device_name().c_str();
      auto status = library_->UnreserveNetworkDevice(device_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WaitForNextSampleClock(::grpc::ServerContext* context, const WaitForNextSampleClockRequest* request, WaitForNextSampleClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 timeout = request->timeout();
      bool32 is_late {};
      auto status = library_->WaitForNextSampleClock(task, timeout, &is_late);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_is_late(is_late);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WaitForValidTimestamp(::grpc::ServerContext* context, const WaitForValidTimestampRequest* request, WaitForValidTimestampResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 timestamp_event;
      switch (request->timestamp_event_enum_case()) {
        case nidaqmx_grpc::WaitForValidTimestampRequest::TimestampEventEnumCase::kTimestampEvent: {
          timestamp_event = static_cast<int32>(request->timestamp_event());
          break;
        }
        case nidaqmx_grpc::WaitForValidTimestampRequest::TimestampEventEnumCase::kTimestampEventRaw: {
          timestamp_event = static_cast<int32>(request->timestamp_event_raw());
          break;
        }
        case nidaqmx_grpc::WaitForValidTimestampRequest::TimestampEventEnumCase::TIMESTAMP_EVENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timestamp_event was not specified or out of range");
          break;
        }
      }

      float64 timeout = request->timeout();
      CVIAbsoluteTime timestamp {};
      auto status = library_->WaitForValidTimestamp(task, timestamp_event, timeout, &timestamp);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(timestamp, response->mutable_timestamp());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WaitUntilTaskDone(::grpc::ServerContext* context, const WaitUntilTaskDoneRequest* request, WaitUntilTaskDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      float64 time_to_wait = request->time_to_wait();
      auto status = library_->WaitUntilTaskDone(task, time_to_wait);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteAnalogF64(::grpc::ServerContext* context, const WriteAnalogF64Request* request, WriteAnalogF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteAnalogF64Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = const_cast<const float64*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteAnalogF64(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteAnalogScalarF64(::grpc::ServerContext* context, const WriteAnalogScalarF64Request* request, WriteAnalogScalarF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      float64 value = request->value();
      auto reserved = nullptr;
      auto status = library_->WriteAnalogScalarF64(task, auto_start, timeout, value, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryI16(::grpc::ServerContext* context, const WriteBinaryI16Request* request, WriteBinaryI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryI16Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI16Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI16Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array_raw = request->write_array();
      auto write_array = std::vector<int16>();
      write_array.reserve(write_array_raw.size());
      std::transform(
        write_array_raw.begin(),
        write_array_raw.end(),
        std::back_inserter(write_array),
        [](auto x) { 
              if (x < std::numeric_limits<int16>::min() || x > std::numeric_limits<int16>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("int16");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<int16>(x);
        });

      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryI16(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array.data(), &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryI32(::grpc::ServerContext* context, const WriteBinaryI32Request* request, WriteBinaryI32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryI32Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI32Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryI32Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = reinterpret_cast<const int32*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryI32(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryU16(::grpc::ServerContext* context, const WriteBinaryU16Request* request, WriteBinaryU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryU16Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU16Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU16Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array_raw = request->write_array();
      auto write_array = std::vector<uInt16>();
      write_array.reserve(write_array_raw.size());
      std::transform(
        write_array_raw.begin(),
        write_array_raw.end(),
        std::back_inserter(write_array),
        [](auto x) { 
              if (x < std::numeric_limits<uInt16>::min() || x > std::numeric_limits<uInt16>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("uInt16");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<uInt16>(x);
        });

      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryU16(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array.data(), &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteBinaryU32(::grpc::ServerContext* context, const WriteBinaryU32Request* request, WriteBinaryU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteBinaryU32Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU32Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteBinaryU32Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = reinterpret_cast<const uInt32*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteBinaryU32(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrFreq(::grpc::ServerContext* context, const WriteCtrFreqRequest* request, WriteCtrFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteCtrFreqRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteCtrFreqRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteCtrFreqRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto frequency = const_cast<const float64*>(request->frequency().data());
      auto duty_cycle = const_cast<const float64*>(request->duty_cycle().data());
      auto reserved = nullptr;
      int32 num_samps_per_chan_written {};
      auto status = library_->WriteCtrFreq(task, num_samps_per_chan, auto_start, timeout, data_layout, frequency, duty_cycle, &num_samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_num_samps_per_chan_written(num_samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrFreqScalar(::grpc::ServerContext* context, const WriteCtrFreqScalarRequest* request, WriteCtrFreqScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      float64 frequency = request->frequency();
      float64 duty_cycle = request->duty_cycle();
      auto reserved = nullptr;
      auto status = library_->WriteCtrFreqScalar(task, auto_start, timeout, frequency, duty_cycle, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTicks(::grpc::ServerContext* context, const WriteCtrTicksRequest* request, WriteCtrTicksResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteCtrTicksRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteCtrTicksRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteCtrTicksRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto high_ticks = reinterpret_cast<const uInt32*>(request->high_ticks().data());
      auto low_ticks = reinterpret_cast<const uInt32*>(request->low_ticks().data());
      auto reserved = nullptr;
      int32 num_samps_per_chan_written {};
      auto status = library_->WriteCtrTicks(task, num_samps_per_chan, auto_start, timeout, data_layout, high_ticks, low_ticks, &num_samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_num_samps_per_chan_written(num_samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTicksScalar(::grpc::ServerContext* context, const WriteCtrTicksScalarRequest* request, WriteCtrTicksScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      uInt32 high_ticks = request->high_ticks();
      uInt32 low_ticks = request->low_ticks();
      auto reserved = nullptr;
      auto status = library_->WriteCtrTicksScalar(task, auto_start, timeout, high_ticks, low_ticks, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTime(::grpc::ServerContext* context, const WriteCtrTimeRequest* request, WriteCtrTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteCtrTimeRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteCtrTimeRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteCtrTimeRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto high_time = const_cast<const float64*>(request->high_time().data());
      auto low_time = const_cast<const float64*>(request->low_time().data());
      auto reserved = nullptr;
      int32 num_samps_per_chan_written {};
      auto status = library_->WriteCtrTime(task, num_samps_per_chan, auto_start, timeout, data_layout, high_time, low_time, &num_samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_num_samps_per_chan_written(num_samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteCtrTimeScalar(::grpc::ServerContext* context, const WriteCtrTimeScalarRequest* request, WriteCtrTimeScalarResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      float64 high_time = request->high_time();
      float64 low_time = request->low_time();
      auto reserved = nullptr;
      auto status = library_->WriteCtrTimeScalar(task, auto_start, timeout, high_time, low_time, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalLines(::grpc::ServerContext* context, const WriteDigitalLinesRequest* request, WriteDigitalLinesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalLinesRequest::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalLinesRequest::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalLinesRequest::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      const uInt8* write_array = (const uInt8*)request->write_array().c_str();
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalLines(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalScalarU32(::grpc::ServerContext* context, const WriteDigitalScalarU32Request* request, WriteDigitalScalarU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      uInt32 value = request->value();
      auto reserved = nullptr;
      auto status = library_->WriteDigitalScalarU32(task, auto_start, timeout, value, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU16(::grpc::ServerContext* context, const WriteDigitalU16Request* request, WriteDigitalU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU16Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array_raw = request->write_array();
      auto write_array = std::vector<uInt16>();
      write_array.reserve(write_array_raw.size());
      std::transform(
        write_array_raw.begin(),
        write_array_raw.end(),
        std::back_inserter(write_array),
        [](auto x) { 
              if (x < std::numeric_limits<uInt16>::min() || x > std::numeric_limits<uInt16>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("uInt16");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<uInt16>(x);
        });

      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU16(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array.data(), &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU32(::grpc::ServerContext* context, const WriteDigitalU32Request* request, WriteDigitalU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU32Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU32Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU32Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      auto write_array = reinterpret_cast<const uInt32*>(request->write_array().data());
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU32(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU8(::grpc::ServerContext* context, const WriteDigitalU8Request* request, WriteDigitalU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      int32 data_layout;
      switch (request->data_layout_enum_case()) {
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::kDataLayout: {
          data_layout = static_cast<int32>(request->data_layout());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::kDataLayoutRaw: {
          data_layout = static_cast<int32>(request->data_layout_raw());
          break;
        }
        case nidaqmx_grpc::WriteDigitalU8Request::DataLayoutEnumCase::DATA_LAYOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_layout was not specified or out of range");
          break;
        }
      }

      const uInt8* write_array = (const uInt8*)request->write_array().c_str();
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU8(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteRaw(::grpc::ServerContext* context, const WriteRawRequest* request, WriteRawResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      TaskHandle task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps = request->num_samps();
      bool32 auto_start = request->auto_start();
      float64 timeout = request->timeout();
      const uInt8* write_array = (const uInt8*)request->write_array().c_str();
      auto reserved = nullptr;
      int32 samps_per_chan_written {};
      auto status = library_->WriteRaw(task, num_samps, auto_start, timeout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteToTEDSFromArray(::grpc::ServerContext* context, const WriteToTEDSFromArrayRequest* request, WriteToTEDSFromArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      const uInt8* bit_stream = (const uInt8*)request->bit_stream().c_str();
      uInt32 array_size = static_cast<uInt32>(request->bit_stream().size());
      int32 basic_teds_options;
      switch (request->basic_teds_options_enum_case()) {
        case nidaqmx_grpc::WriteToTEDSFromArrayRequest::BasicTedsOptionsEnumCase::kBasicTedsOptions: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromArrayRequest::BasicTedsOptionsEnumCase::kBasicTedsOptionsRaw: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options_raw());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromArrayRequest::BasicTedsOptionsEnumCase::BASIC_TEDS_OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for basic_teds_options was not specified or out of range");
          break;
        }
      }

      auto status = library_->WriteToTEDSFromArray(physical_channel, bit_stream, array_size, basic_teds_options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteToTEDSFromFile(::grpc::ServerContext* context, const WriteToTEDSFromFileRequest* request, WriteToTEDSFromFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto physical_channel = request->physical_channel().c_str();
      auto file_path = request->file_path().c_str();
      int32 basic_teds_options;
      switch (request->basic_teds_options_enum_case()) {
        case nidaqmx_grpc::WriteToTEDSFromFileRequest::BasicTedsOptionsEnumCase::kBasicTedsOptions: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromFileRequest::BasicTedsOptionsEnumCase::kBasicTedsOptionsRaw: {
          basic_teds_options = static_cast<int32>(request->basic_teds_options_raw());
          break;
        }
        case nidaqmx_grpc::WriteToTEDSFromFileRequest::BasicTedsOptionsEnumCase::BASIC_TEDS_OPTIONS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for basic_teds_options was not specified or out of range");
          break;
        }
      }

      auto status = library_->WriteToTEDSFromFile(physical_channel, file_path, basic_teds_options);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  NiDAQmxFeatureToggles::NiDAQmxFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nidaqmx", CodeReadiness::kRelease)),
      is_allow_undefined_attributes_enabled(
        feature_toggles.is_feature_enabled("nidaqmx.allow_undefined_attributes", CodeReadiness::kPrototype))
  {
  }
} // namespace nidaqmx_grpc

