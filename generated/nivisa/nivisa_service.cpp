
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-VISA Library Metadata
//---------------------------------------------------------------------
#include "nivisa_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>

namespace nivisa_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  NiVISAService::NiVISAService(
      LibrarySharedPtr library,
      ResourceRepositorySharedPtr resource_repository,
      ViObjectResourceRepositorySharedPtr vi_object_resource_repository,
      const NiVISAFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      vi_object_resource_repository_(vi_object_resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiVISAService::~NiVISAService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::AssertIntrSignal(::grpc::ServerContext* context, const AssertIntrSignalRequest* request, AssertIntrSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 mode;
      switch (request->mode_enum_case()) {
        case nivisa_grpc::AssertIntrSignalRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViInt16>(request->mode());
          break;
        }
        case nivisa_grpc::AssertIntrSignalRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViInt16>(request->mode_raw());
          break;
        }
        case nivisa_grpc::AssertIntrSignalRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      ViUInt32 status_id = request->status_id();
      auto status = library_->AssertIntrSignal(vi, mode, status_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::AssertTrigger(::grpc::ServerContext* context, const AssertTriggerRequest* request, AssertTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 protocol;
      switch (request->protocol_enum_case()) {
        case nivisa_grpc::AssertTriggerRequest::ProtocolEnumCase::kProtocol: {
          protocol = static_cast<ViUInt16>(request->protocol());
          break;
        }
        case nivisa_grpc::AssertTriggerRequest::ProtocolEnumCase::kProtocolRaw: {
          protocol = static_cast<ViUInt16>(request->protocol_raw());
          break;
        }
        case nivisa_grpc::AssertTriggerRequest::ProtocolEnumCase::PROTOCOL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for protocol was not specified or out of range");
          break;
        }
      }

      auto status = library_->AssertTrigger(vi, protocol);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::AssertUtilSignal(::grpc::ServerContext* context, const AssertUtilSignalRequest* request, AssertUtilSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mode;
      switch (request->mode_enum_case()) {
        case nivisa_grpc::AssertUtilSignalRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViUInt16>(request->mode());
          break;
        }
        case nivisa_grpc::AssertUtilSignalRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViUInt16>(request->mode_raw());
          break;
        }
        case nivisa_grpc::AssertUtilSignalRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->AssertUtilSignal(vi, mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Clear(::grpc::ServerContext* context, const ClearRequest* request, ClearResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Clear(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViObject object_handle = request->object_handle();
      vi_object_resource_repository_->remove_session(object_handle_grpc_session.name());
      auto status = library_->Close(object_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViObject(context, status, object_handle);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::DisableEvent(::grpc::ServerContext* context, const DisableEventRequest* request, DisableEventResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViEventType event_type;
      switch (request->event_type_enum_case()) {
        case nivisa_grpc::DisableEventRequest::EventTypeEnumCase::kEventType: {
          event_type = static_cast<ViEventType>(request->event_type());
          break;
        }
        case nivisa_grpc::DisableEventRequest::EventTypeEnumCase::kEventTypeRaw: {
          event_type = static_cast<ViEventType>(request->event_type_raw());
          break;
        }
        case nivisa_grpc::DisableEventRequest::EventTypeEnumCase::EVENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_type was not specified or out of range");
          break;
        }
      }

      ViUInt16 event_mechanism;
      switch (request->event_mechanism_enum_case()) {
        case nivisa_grpc::DisableEventRequest::EventMechanismEnumCase::kEventMechanism: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism());
          break;
        }
        case nivisa_grpc::DisableEventRequest::EventMechanismEnumCase::kEventMechanismRaw: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism_raw());
          break;
        }
        case nivisa_grpc::DisableEventRequest::EventMechanismEnumCase::EVENT_MECHANISM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_mechanism was not specified or out of range");
          break;
        }
      }

      auto status = library_->DisableEvent(vi, event_type, event_mechanism);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::DiscardEvents(::grpc::ServerContext* context, const DiscardEventsRequest* request, DiscardEventsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViEventType event_type;
      switch (request->event_type_enum_case()) {
        case nivisa_grpc::DiscardEventsRequest::EventTypeEnumCase::kEventType: {
          event_type = static_cast<ViEventType>(request->event_type());
          break;
        }
        case nivisa_grpc::DiscardEventsRequest::EventTypeEnumCase::kEventTypeRaw: {
          event_type = static_cast<ViEventType>(request->event_type_raw());
          break;
        }
        case nivisa_grpc::DiscardEventsRequest::EventTypeEnumCase::EVENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_type was not specified or out of range");
          break;
        }
      }

      ViUInt16 event_mechanism;
      switch (request->event_mechanism_enum_case()) {
        case nivisa_grpc::DiscardEventsRequest::EventMechanismEnumCase::kEventMechanism: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism());
          break;
        }
        case nivisa_grpc::DiscardEventsRequest::EventMechanismEnumCase::kEventMechanismRaw: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism_raw());
          break;
        }
        case nivisa_grpc::DiscardEventsRequest::EventMechanismEnumCase::EVENT_MECHANISM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_mechanism was not specified or out of range");
          break;
        }
      }

      auto status = library_->DiscardEvents(vi, event_type, event_mechanism);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::EnableEvent(::grpc::ServerContext* context, const EnableEventRequest* request, EnableEventResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViEventType event_type;
      switch (request->event_type_enum_case()) {
        case nivisa_grpc::EnableEventRequest::EventTypeEnumCase::kEventType: {
          event_type = static_cast<ViEventType>(request->event_type());
          break;
        }
        case nivisa_grpc::EnableEventRequest::EventTypeEnumCase::kEventTypeRaw: {
          event_type = static_cast<ViEventType>(request->event_type_raw());
          break;
        }
        case nivisa_grpc::EnableEventRequest::EventTypeEnumCase::EVENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_type was not specified or out of range");
          break;
        }
      }

      ViUInt16 event_mechanism;
      switch (request->event_mechanism_enum_case()) {
        case nivisa_grpc::EnableEventRequest::EventMechanismEnumCase::kEventMechanism: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism());
          break;
        }
        case nivisa_grpc::EnableEventRequest::EventMechanismEnumCase::kEventMechanismRaw: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism_raw());
          break;
        }
        case nivisa_grpc::EnableEventRequest::EventMechanismEnumCase::EVENT_MECHANISM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_mechanism was not specified or out of range");
          break;
        }
      }

      ViEventFilter filter_context = request->filter_context();
      auto status = library_->EnableEvent(vi, event_type, event_mechanism, filter_context);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::FindRsrc(::grpc::ServerContext* context, const FindRsrcRequest* request, FindRsrcResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto rsrc_manager_handle_grpc_session = request->rsrc_manager_handle();
      ViSession rsrc_manager_handle = session_repository_->access_session(rsrc_manager_handle_grpc_session.name());
      auto expression_mbcs = convert_from_grpc<std::string>(request->expression());
      auto expression = expression_mbcs.c_str();
      ViFindList find_handle {};
      ViUInt32 return_count {};
      std::string instrument_descriptor(256 - 1, '\0');
      auto status = library_->FindRsrc(rsrc_manager_handle, expression, &find_handle, &return_count, (ViChar*)instrument_descriptor.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, rsrc_manager_handle);
      }
      response->set_status(status);
      response->set_find_handle(find_handle);
      response->set_return_count(return_count);
      std::string instrument_descriptor_utf8;
      convert_to_grpc(instrument_descriptor, &instrument_descriptor_utf8);
      response->set_instrument_descriptor(instrument_descriptor_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_instrument_descriptor()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Flush(::grpc::ServerContext* context, const FlushRequest* request, FlushResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mask;
      switch (request->mask_enum_case()) {
        case nivisa_grpc::FlushRequest::MaskEnumCase::kMask: {
          mask = static_cast<ViUInt16>(request->mask());
          break;
        }
        case nivisa_grpc::FlushRequest::MaskEnumCase::kMaskRaw: {
          mask = static_cast<ViUInt16>(request->mask_raw());
          break;
        }
        case nivisa_grpc::FlushRequest::MaskEnumCase::MASK_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mask was not specified or out of range");
          break;
        }
      }

      auto status = library_->Flush(vi, mask);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::GetAttribute(::grpc::ServerContext* context, const GetAttributeRequest* request, GetAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViObject object_handle = request->object_handle();
      ViAttr attribute_name = request->attribute_name();
      void attribute_value {};
      auto status = library_->GetAttribute(object_handle, attribute_name, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViObject(context, status, object_handle);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::GpibCommand(::grpc::ServerContext* context, const GpibCommandRequest* request, GpibCommandResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto buffer = const_cast<ViByte*>(request->buffer().data());
      ViUInt32 count = static_cast<ViUInt32>(request->buffer().size());
      ViUInt32 return_count {};
      auto status = library_->GpibCommand(vi, buffer, count, &return_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_return_count(return_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::GpibControlATN(::grpc::ServerContext* context, const GpibControlATNRequest* request, GpibControlATNResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mode;
      switch (request->mode_enum_case()) {
        case nivisa_grpc::GpibControlATNRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViUInt16>(request->mode());
          break;
        }
        case nivisa_grpc::GpibControlATNRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViUInt16>(request->mode_raw());
          break;
        }
        case nivisa_grpc::GpibControlATNRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->GpibControlATN(vi, mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::GpibControlREN(::grpc::ServerContext* context, const GpibControlRENRequest* request, GpibControlRENResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mode;
      switch (request->mode_enum_case()) {
        case nivisa_grpc::GpibControlRENRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViUInt16>(request->mode());
          break;
        }
        case nivisa_grpc::GpibControlRENRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViUInt16>(request->mode_raw());
          break;
        }
        case nivisa_grpc::GpibControlRENRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->GpibControlREN(vi, mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::GpibPassControl(::grpc::ServerContext* context, const GpibPassControlRequest* request, GpibPassControlResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 primary_address = request->primary_address();
      ViUInt16 secondary_address = request->secondary_address();
      auto status = library_->GpibPassControl(vi, primary_address, secondary_address);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::GpibSendIFC(::grpc::ServerContext* context, const GpibSendIFCRequest* request, GpibSendIFCResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->GpibSendIFC(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::In16Ex(::grpc::ServerContext* context, const In16ExRequest* request, In16ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::In16ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::In16ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::In16ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt16 value {};
      auto status = library_->In16Ex(vi, address_space, offset, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::In32Ex(::grpc::ServerContext* context, const In32ExRequest* request, In32ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::In32ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::In32ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::In32ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt32 value {};
      auto status = library_->In32Ex(vi, address_space, offset, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::In64Ex(::grpc::ServerContext* context, const In64ExRequest* request, In64ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::In64ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::In64ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::In64ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt64 value {};
      auto status = library_->In64Ex(vi, address_space, offset, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::In8Ex(::grpc::ServerContext* context, const In8ExRequest* request, In8ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::In8ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::In8ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::In8ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt8 value {};
      auto status = library_->In8Ex(vi, address_space, offset, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Lock(::grpc::ServerContext* context, const LockRequest* request, LockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAccessMode lock_type;
      switch (request->lock_type_enum_case()) {
        case nivisa_grpc::LockRequest::LockTypeEnumCase::kLockType: {
          lock_type = static_cast<ViAccessMode>(request->lock_type());
          break;
        }
        case nivisa_grpc::LockRequest::LockTypeEnumCase::kLockTypeRaw: {
          lock_type = static_cast<ViAccessMode>(request->lock_type_raw());
          break;
        }
        case nivisa_grpc::LockRequest::LockTypeEnumCase::LOCK_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for lock_type was not specified or out of range");
          break;
        }
      }

      ViUInt32 timeout = request->timeout();
      ViConstKeyId requested_key = request->requested_key();
      std::string access_key(256 - 1, '\0');
      auto status = library_->Lock(vi, lock_type, timeout, requested_key, (ViChar*)access_key.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      std::string access_key_utf8;
      convert_to_grpc(access_key, &access_key_utf8);
      response->set_access_key(access_key_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_access_key()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MapAddressEx(::grpc::ServerContext* context, const MapAddressExRequest* request, MapAddressExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::MapAddressExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::MapAddressExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::MapAddressExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize map_size = request->map_size();
      ViBoolean owner_access = request->owner_access();
      ViAddr suggested_address = request->suggested_address();
      ViAddr address {};
      auto status = library_->MapAddressEx(vi, address_space, offset, map_size, owner_access, suggested_address, &address);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_address(address);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MapTrigger(::grpc::ServerContext* context, const MapTriggerRequest* request, MapTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 trigger_source;
      switch (request->trigger_source_enum_case()) {
        case nivisa_grpc::MapTriggerRequest::TriggerSourceEnumCase::kTriggerSource: {
          trigger_source = static_cast<ViInt16>(request->trigger_source());
          break;
        }
        case nivisa_grpc::MapTriggerRequest::TriggerSourceEnumCase::kTriggerSourceRaw: {
          trigger_source = static_cast<ViInt16>(request->trigger_source_raw());
          break;
        }
        case nivisa_grpc::MapTriggerRequest::TriggerSourceEnumCase::TRIGGER_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_source was not specified or out of range");
          break;
        }
      }

      ViInt16 trigger_destination;
      switch (request->trigger_destination_enum_case()) {
        case nivisa_grpc::MapTriggerRequest::TriggerDestinationEnumCase::kTriggerDestination: {
          trigger_destination = static_cast<ViInt16>(request->trigger_destination());
          break;
        }
        case nivisa_grpc::MapTriggerRequest::TriggerDestinationEnumCase::kTriggerDestinationRaw: {
          trigger_destination = static_cast<ViInt16>(request->trigger_destination_raw());
          break;
        }
        case nivisa_grpc::MapTriggerRequest::TriggerDestinationEnumCase::TRIGGER_DESTINATION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_destination was not specified or out of range");
          break;
        }
      }

      ViUInt16 mode = request->mode();
      auto status = library_->MapTrigger(vi, trigger_source, trigger_destination, mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MemAlloc(::grpc::ServerContext* context, const MemAllocRequest* request, MemAllocResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViBusSize size = request->size();
      ViBusAddress offset {};
      auto status = library_->MemAlloc(vi, size, &offset);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_offset(offset);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MemAllocEx(::grpc::ServerContext* context, const MemAllocExRequest* request, MemAllocExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViBusSize size = request->size();
      ViBusAddress64 offset {};
      auto status = library_->MemAllocEx(vi, size, &offset);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_offset(offset);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MemFreeEx(::grpc::ServerContext* context, const MemFreeExRequest* request, MemFreeExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViBusAddress64 offset = request->offset();
      auto status = library_->MemFreeEx(vi, offset);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MoveIn16Ex(::grpc::ServerContext* context, const MoveIn16ExRequest* request, MoveIn16ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::MoveIn16ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::MoveIn16ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::MoveIn16ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = request->count();
      response->mutable_buffer()->Resize(count, 0);
      ViUInt16* buffer = reinterpret_cast<ViUInt16*>(response->mutable_buffer()->mutable_data());
      auto status = library_->MoveIn16Ex(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MoveIn32Ex(::grpc::ServerContext* context, const MoveIn32ExRequest* request, MoveIn32ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::MoveIn32ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::MoveIn32ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::MoveIn32ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = request->count();
      response->mutable_buffer()->Resize(count, 0);
      ViUInt32* buffer = reinterpret_cast<ViUInt32*>(response->mutable_buffer()->mutable_data());
      auto status = library_->MoveIn32Ex(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MoveIn64Ex(::grpc::ServerContext* context, const MoveIn64ExRequest* request, MoveIn64ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::MoveIn64ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::MoveIn64ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::MoveIn64ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = request->count();
      response->mutable_buffer()->Resize(count, 0);
      ViUInt64* buffer = response->mutable_buffer()->mutable_data();
      auto status = library_->MoveIn64Ex(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MoveIn8Ex(::grpc::ServerContext* context, const MoveIn8ExRequest* request, MoveIn8ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::MoveIn8ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::MoveIn8ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::MoveIn8ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = request->count();
      std::string buffer(count, '\0');
      auto status = library_->MoveIn8Ex(vi, address_space, offset, count, (ViUInt8*)buffer.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_buffer(buffer);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MoveOut16Ex(::grpc::ServerContext* context, const MoveOut16ExRequest* request, MoveOut16ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::MoveOut16ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::MoveOut16ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::MoveOut16ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = static_cast<ViBusSize>(request->buffer().size());
      auto buffer = const_cast<ViUInt16*>(reinterpret_cast<const ViUInt16*>(request->buffer().data()));
      auto status = library_->MoveOut16Ex(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MoveOut32Ex(::grpc::ServerContext* context, const MoveOut32ExRequest* request, MoveOut32ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::MoveOut32ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::MoveOut32ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::MoveOut32ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = static_cast<ViBusSize>(request->buffer().size());
      auto buffer = const_cast<ViUInt32*>(reinterpret_cast<const ViUInt32*>(request->buffer().data()));
      auto status = library_->MoveOut32Ex(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MoveOut64Ex(::grpc::ServerContext* context, const MoveOut64ExRequest* request, MoveOut64ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::MoveOut64ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::MoveOut64ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::MoveOut64ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = static_cast<ViBusSize>(request->buffer().size());
      auto buffer = const_cast<ViUInt64*>(request->buffer().data());
      auto status = library_->MoveOut64Ex(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::MoveOut8Ex(::grpc::ServerContext* context, const MoveOut8ExRequest* request, MoveOut8ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::MoveOut8ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::MoveOut8ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::MoveOut8ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = static_cast<ViBusSize>(request->buffer().size());
      ViUInt8* buffer = (ViUInt8*)request->buffer().c_str();
      auto status = library_->MoveOut8Ex(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Open(::grpc::ServerContext* context, const OpenRequest* request, OpenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto rsrc_manager_handle_grpc_session = request->rsrc_manager_handle();
      ViSession rsrc_manager_handle = session_repository_->access_session(rsrc_manager_handle_grpc_session.name());
      ViConstRsrc instrument_descriptor = request->instrument_descriptor();
      ViAccessMode access_mode;
      switch (request->access_mode_enum_case()) {
        case nivisa_grpc::OpenRequest::AccessModeEnumCase::kAccessMode: {
          access_mode = static_cast<ViAccessMode>(request->access_mode());
          break;
        }
        case nivisa_grpc::OpenRequest::AccessModeEnumCase::kAccessModeRaw: {
          access_mode = static_cast<ViAccessMode>(request->access_mode_raw());
          break;
        }
        case nivisa_grpc::OpenRequest::AccessModeEnumCase::ACCESS_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for access_mode was not specified or out of range");
          break;
        }
      }

      ViUInt32 open_timeout = request->open_timeout();
      ViSession vi {};
      auto status = library_->Open(rsrc_manager_handle, instrument_descriptor, access_mode, open_timeout, &vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, rsrc_manager_handle);
      }
      response->set_status(status);
      auto grpc_device_session_name = session_repository_->resolve_session_name(vi);
      response->mutable_vi()->set_name(grpc_device_session_name);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Out16Ex(::grpc::ServerContext* context, const Out16ExRequest* request, Out16ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::Out16ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::Out16ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::Out16ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt16 value = request->value();
      auto status = library_->Out16Ex(vi, address_space, offset, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Out32Ex(::grpc::ServerContext* context, const Out32ExRequest* request, Out32ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::Out32ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::Out32ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::Out32ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt32 value = request->value();
      auto status = library_->Out32Ex(vi, address_space, offset, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Out64Ex(::grpc::ServerContext* context, const Out64ExRequest* request, Out64ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::Out64ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::Out64ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::Out64ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt64 value = request->value();
      auto status = library_->Out64Ex(vi, address_space, offset, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Out8Ex(::grpc::ServerContext* context, const Out8ExRequest* request, Out8ExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case nivisa_grpc::Out8ExRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case nivisa_grpc::Out8ExRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case nivisa_grpc::Out8ExRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt8 value = request->value();
      auto status = library_->Out8Ex(vi, address_space, offset, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::ParseRsrcEx(::grpc::ServerContext* context, const ParseRsrcExRequest* request, ParseRsrcExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_handle_grpc_session = request->session_handle();
      ViSession session_handle = session_repository_->access_session(session_handle_grpc_session.name());
      ViConstRsrc resource_name = request->resource_name();
      ViUInt16 interface_type {};
      ViUInt16 interface_number {};
      std::string resource_class(256 - 1, '\0');
      std::string expanded_unaliased_name(256 - 1, '\0');
      std::string alias_if_exists(256 - 1, '\0');
      auto status = library_->ParseRsrcEx(session_handle, resource_name, &interface_type, &interface_number, (ViChar*)resource_class.data(), (ViChar*)expanded_unaliased_name.data(), (ViChar*)alias_if_exists.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, session_handle);
      }
      response->set_status(status);
      response->set_interface_type(interface_type);
      response->set_interface_number(interface_number);
      std::string resource_class_utf8;
      convert_to_grpc(resource_class, &resource_class_utf8);
      response->set_resource_class(resource_class_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_resource_class()));
      std::string expanded_unaliased_name_utf8;
      convert_to_grpc(expanded_unaliased_name, &expanded_unaliased_name_utf8);
      response->set_expanded_unaliased_name(expanded_unaliased_name_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_expanded_unaliased_name()));
      std::string alias_if_exists_utf8;
      convert_to_grpc(alias_if_exists, &alias_if_exists_utf8);
      response->set_alias_if_exists(alias_if_exists_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_alias_if_exists()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Peek16(::grpc::ServerContext* context, const Peek16Request* request, Peek16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = request->address();
      ViUInt16 value {};
      library_->Peek16(vi, address, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Peek32(::grpc::ServerContext* context, const Peek32Request* request, Peek32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = request->address();
      ViUInt32 value {};
      library_->Peek32(vi, address, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Peek64(::grpc::ServerContext* context, const Peek64Request* request, Peek64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = request->address();
      ViUInt64 value {};
      library_->Peek64(vi, address, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Peek8(::grpc::ServerContext* context, const Peek8Request* request, Peek8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = request->address();
      ViUInt8 value {};
      library_->Peek8(vi, address, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Poke16(::grpc::ServerContext* context, const Poke16Request* request, Poke16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = request->address();
      ViUInt16 value = request->value();
      library_->Poke16(vi, address, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Poke32(::grpc::ServerContext* context, const Poke32Request* request, Poke32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = request->address();
      ViUInt32 value = request->value();
      library_->Poke32(vi, address, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Poke64(::grpc::ServerContext* context, const Poke64Request* request, Poke64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = request->address();
      ViUInt64 value = request->value();
      library_->Poke64(vi, address, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Poke8(::grpc::ServerContext* context, const Poke8Request* request, Poke8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = request->address();
      ViUInt8 value = request->value();
      library_->Poke8(vi, address, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::PxiReserveTriggers(::grpc::ServerContext* context, const PxiReserveTriggersRequest* request, PxiReserveTriggersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto cnt_determine_from_sizes = std::array<int, 2>
      {
        request->trig_buses_size(),
        request->trig_lines_size()
      };
      const auto cnt_size_calculation = calculate_linked_array_size(cnt_determine_from_sizes, false);

      if (cnt_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [trig_buses, trig_lines] do not match");
      }
      auto cnt = cnt_size_calculation.size;

      auto trig_buses_request = request->trig_buses();
      std::vector<ViInt16> trig_buses;
      std::transform(
        trig_buses_request.begin(),
        trig_buses_request.end(),
        std::back_inserter(trig_buses),
        [](auto x) { return (ViInt16)x; }); 
      auto trig_lines_request = request->trig_lines();
      std::vector<ViInt16> trig_lines;
      std::transform(
        trig_lines_request.begin(),
        trig_lines_request.end(),
        std::back_inserter(trig_lines),
        [](auto x) { return (ViInt16)x; }); 
      ViInt16 failure_index {};
      auto status = library_->PxiReserveTriggers(vi, cnt, trig_buses.data(), trig_lines.data(), &failure_index);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_failure_index(failure_index);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Read(::grpc::ServerContext* context, const ReadRequest* request, ReadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt32 count = request->count();
      response->mutable_buffer()->Resize(return_count, 0);
      ViByte* buffer = response->mutable_buffer()->mutable_data();
      ViUInt32 return_count {};
      auto status = library_->Read(vi, buffer, count, &return_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_return_count(return_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::ReadAsync(::grpc::ServerContext* context, const ReadAsyncRequest* request, ReadAsyncResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt32 count = request->count();
      void read_buffer {};
      ViJobId job_identifier {};
      auto status = library_->ReadAsync(vi, &read_buffer, count, &job_identifier);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_job_identifier(job_identifier);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::ReadSTB(::grpc::ServerContext* context, const ReadSTBRequest* request, ReadSTBResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 status_byte {};
      auto status = library_->ReadSTB(vi, &status_byte);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_status_byte(status_byte);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::SetAttribute(::grpc::ServerContext* context, const SetAttributeRequest* request, SetAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViObject object_handle = request->object_handle();
      ViAttr attribute_name = request->attribute_name();
      ViAttrState attribute_value = request->attribute_value();
      auto status = library_->SetAttribute(object_handle, attribute_name, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViObject(context, status, object_handle);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::SetBuf(::grpc::ServerContext* context, const SetBufRequest* request, SetBufResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mask;
      switch (request->mask_enum_case()) {
        case nivisa_grpc::SetBufRequest::MaskEnumCase::kMask: {
          mask = static_cast<ViUInt16>(request->mask());
          break;
        }
        case nivisa_grpc::SetBufRequest::MaskEnumCase::kMaskRaw: {
          mask = static_cast<ViUInt16>(request->mask_raw());
          break;
        }
        case nivisa_grpc::SetBufRequest::MaskEnumCase::MASK_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mask was not specified or out of range");
          break;
        }
      }

      ViUInt32 buffer_size = request->buffer_size();
      auto status = library_->SetBuf(vi, mask, buffer_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::StatusDesc(::grpc::ServerContext* context, const StatusDescRequest* request, StatusDescResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViObject object_handle = request->object_handle();
      ViStatus status_value = request->status_value();
      std::string status_description(256 - 1, '\0');
      auto status = library_->StatusDesc(object_handle, status_value, (ViChar*)status_description.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViObject(context, status, object_handle);
      }
      response->set_status(status);
      std::string status_description_utf8;
      convert_to_grpc(status_description, &status_description_utf8);
      response->set_status_description(status_description_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_status_description()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Terminate(::grpc::ServerContext* context, const TerminateRequest* request, TerminateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 degree = request->degree();
      ViJobId job_identifier = request->job_identifier();
      auto status = library_->Terminate(vi, degree, job_identifier);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Unlock(::grpc::ServerContext* context, const UnlockRequest* request, UnlockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Unlock(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::UnmapAddress(::grpc::ServerContext* context, const UnmapAddressRequest* request, UnmapAddressResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->UnmapAddress(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::UnmapTrigger(::grpc::ServerContext* context, const UnmapTriggerRequest* request, UnmapTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 trigger_source;
      switch (request->trigger_source_enum_case()) {
        case nivisa_grpc::UnmapTriggerRequest::TriggerSourceEnumCase::kTriggerSource: {
          trigger_source = static_cast<ViInt16>(request->trigger_source());
          break;
        }
        case nivisa_grpc::UnmapTriggerRequest::TriggerSourceEnumCase::kTriggerSourceRaw: {
          trigger_source = static_cast<ViInt16>(request->trigger_source_raw());
          break;
        }
        case nivisa_grpc::UnmapTriggerRequest::TriggerSourceEnumCase::TRIGGER_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_source was not specified or out of range");
          break;
        }
      }

      ViInt16 trigger_destination;
      switch (request->trigger_destination_enum_case()) {
        case nivisa_grpc::UnmapTriggerRequest::TriggerDestinationEnumCase::kTriggerDestination: {
          trigger_destination = static_cast<ViInt16>(request->trigger_destination());
          break;
        }
        case nivisa_grpc::UnmapTriggerRequest::TriggerDestinationEnumCase::kTriggerDestinationRaw: {
          trigger_destination = static_cast<ViInt16>(request->trigger_destination_raw());
          break;
        }
        case nivisa_grpc::UnmapTriggerRequest::TriggerDestinationEnumCase::TRIGGER_DESTINATION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_destination was not specified or out of range");
          break;
        }
      }

      auto status = library_->UnmapTrigger(vi, trigger_source, trigger_destination);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::UsbControlIn(::grpc::ServerContext* context, const UsbControlInRequest* request, UsbControlInResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 bm_request_type = (ViInt16)request->bm_request_type();
      ViInt16 b_request = (ViInt16)request->b_request();
      ViUInt16 w_value = request->w_value();
      ViUInt16 w_index = request->w_index();
      ViUInt16 w_length = request->w_length();
      response->mutable_buffer()->Resize(return_count, 0);
      ViByte* buffer = response->mutable_buffer()->mutable_data();
      ViUInt16 return_count {};
      auto status = library_->UsbControlIn(vi, bm_request_type, b_request, w_value, w_index, w_length, buffer, &return_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_return_count(return_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::UsbControlOut(::grpc::ServerContext* context, const UsbControlOutRequest* request, UsbControlOutResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 bm_request_type = (ViInt16)request->bm_request_type();
      ViInt16 b_request = (ViInt16)request->b_request();
      ViUInt16 w_value = request->w_value();
      ViUInt16 w_index = request->w_index();
      ViUInt16 w_length = static_cast<ViUInt16>(request->buffer().size());
      auto buffer = const_cast<ViByte*>(request->buffer().data());
      auto status = library_->UsbControlOut(vi, bm_request_type, b_request, w_value, w_index, w_length, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::VxiCommandQuery(::grpc::ServerContext* context, const VxiCommandQueryRequest* request, VxiCommandQueryResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mode;
      switch (request->mode_enum_case()) {
        case nivisa_grpc::VxiCommandQueryRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViUInt16>(request->mode());
          break;
        }
        case nivisa_grpc::VxiCommandQueryRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViUInt16>(request->mode_raw());
          break;
        }
        case nivisa_grpc::VxiCommandQueryRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      ViUInt32 command = request->command();
      ViUInt32 response {};
      auto status = library_->VxiCommandQuery(vi, mode, command, &response);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_response(response);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::WaitOnEvent(::grpc::ServerContext* context, const WaitOnEventRequest* request, WaitOnEventResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViEventType in_event_type;
      switch (request->in_event_type_enum_case()) {
        case nivisa_grpc::WaitOnEventRequest::InEventTypeEnumCase::kInEventType: {
          in_event_type = static_cast<ViEventType>(request->in_event_type());
          break;
        }
        case nivisa_grpc::WaitOnEventRequest::InEventTypeEnumCase::kInEventTypeRaw: {
          in_event_type = static_cast<ViEventType>(request->in_event_type_raw());
          break;
        }
        case nivisa_grpc::WaitOnEventRequest::InEventTypeEnumCase::IN_EVENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for in_event_type was not specified or out of range");
          break;
        }
      }

      ViUInt32 timeout = request->timeout();
      ViEventType out_event_type {};
      ViEvent event_handle {};
      auto status = library_->WaitOnEvent(vi, in_event_type, timeout, &out_event_type, &event_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_out_event_type(static_cast<nivisa_grpc::EventType>(out_event_type));
      response->set_out_event_type_raw(out_event_type);
      response->set_event_handle(event_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::Write(::grpc::ServerContext* context, const WriteRequest* request, WriteResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto buffer = const_cast<ViByte*>(request->buffer().data());
      ViUInt32 count = static_cast<ViUInt32>(request->buffer().size());
      ViUInt32 return_count {};
      auto status = library_->Write(vi, buffer, count, &return_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_return_count(return_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiVISAService::WriteAsync(::grpc::ServerContext* context, const WriteAsyncRequest* request, WriteAsyncResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto write_buffer = const_cast<ViByte*>(request->write_buffer().data());
      ViUInt32 count = static_cast<ViUInt32>(request->write_buffer().size());
      ViJobId job_identifier {};
      auto status = library_->WriteAsync(vi, write_buffer, count, &job_identifier);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_job_identifier(job_identifier);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  NiVISAFeatureToggles::NiVISAFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nivisa", CodeReadiness::kNextRelease))
  {
  }
} // namespace nivisa_grpc

