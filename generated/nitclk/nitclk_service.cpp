
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-TClk Metadata
//---------------------------------------------------------------------
#include "nitclk_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>

namespace niTClk_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  NiTClkService::NiTClkService(
      NiTClkLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      const NiTClkFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiTClkService::~NiTClkService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiTClkService::ConfigureForHomogeneousTriggers(::grpc::ServerContext* context, const ConfigureForHomogeneousTriggersRequest* request, ConfigureForHomogeneousTriggersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = static_cast<ViUInt32>(request->sessions().size());
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      auto status = library_->ConfigureForHomogeneousTriggers(session_count, sessions.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiTClkService::FinishSyncPulseSenderSynchronize(::grpc::ServerContext* context, const FinishSyncPulseSenderSynchronizeRequest* request, FinishSyncPulseSenderSynchronizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = static_cast<ViUInt32>(request->sessions().size());
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      ViReal64 min_time = request->min_time();
      auto status = library_->FinishSyncPulseSenderSynchronize(session_count, sessions.data(), min_time);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiTClkService::Initiate(::grpc::ServerContext* context, const InitiateRequest* request, InitiateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = static_cast<ViUInt32>(request->sessions().size());
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      auto status = library_->Initiate(session_count, sessions.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiTClkService::IsDone(::grpc::ServerContext* context, const IsDoneRequest* request, IsDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = static_cast<ViUInt32>(request->sessions().size());
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      ViBoolean done {};
      auto status = library_->IsDone(session_count, sessions.data(), &done);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->set_done(done);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiTClkService::SetupForSyncPulseSenderSynchronize(::grpc::ServerContext* context, const SetupForSyncPulseSenderSynchronizeRequest* request, SetupForSyncPulseSenderSynchronizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = static_cast<ViUInt32>(request->sessions().size());
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      ViReal64 min_time = request->min_time();
      auto status = library_->SetupForSyncPulseSenderSynchronize(session_count, sessions.data(), min_time);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiTClkService::Synchronize(::grpc::ServerContext* context, const SynchronizeRequest* request, SynchronizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = static_cast<ViUInt32>(request->sessions().size());
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      ViReal64 min_tclk_period = request->min_tclk_period();
      auto status = library_->Synchronize(session_count, sessions.data(), min_tclk_period);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiTClkService::SynchronizeToSyncPulseSender(::grpc::ServerContext* context, const SynchronizeToSyncPulseSenderRequest* request, SynchronizeToSyncPulseSenderResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = static_cast<ViUInt32>(request->sessions().size());
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      ViReal64 min_time = request->min_time();
      auto status = library_->SynchronizeToSyncPulseSender(session_count, sessions.data(), min_time);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiTClkService::WaitUntilDone(::grpc::ServerContext* context, const WaitUntilDoneRequest* request, WaitUntilDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = static_cast<ViUInt32>(request->sessions().size());
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      ViReal64 timeout = request->timeout();
      auto status = library_->WaitUntilDone(session_count, sessions.data(), timeout);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  NiTClkFeatureToggles::NiTClkFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nitclk", CodeReadiness::kRelease))
  {
  }
} // namespace niTClk_grpc

