
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// EXPERIMENTAL Client convenience wrapper for NI-TClk.
//---------------------------------------------------------------------
#include "nitclk_client.h"

#include <grpcpp/grpcpp.h>

#include <nitclk.grpc.pb.h>

#include <cstdint>
#include <memory>
#include <stdexcept>
#include <vector>

namespace niTClk_grpc::experimental::client {

ConfigureForHomogeneousTriggersResponse
configure_for_homogeneous_triggers(const StubPtr& stub, const std::vector<nidevice_grpc::Session>& sessions)
{
  ::grpc::ClientContext context;

  auto request = ConfigureForHomogeneousTriggersRequest{};
  copy_array(sessions, request.mutable_sessions());

  auto response = ConfigureForHomogeneousTriggersResponse{};

  raise_if_error(
      stub->ConfigureForHomogeneousTriggers(&context, request, &response),
      context);

  return response;
}

FinishSyncPulseSenderSynchronizeResponse
finish_sync_pulse_sender_synchronize(const StubPtr& stub, const std::vector<nidevice_grpc::Session>& sessions, const double& min_time)
{
  ::grpc::ClientContext context;

  auto request = FinishSyncPulseSenderSynchronizeRequest{};
  copy_array(sessions, request.mutable_sessions());
  request.set_min_time(min_time);

  auto response = FinishSyncPulseSenderSynchronizeResponse{};

  raise_if_error(
      stub->FinishSyncPulseSenderSynchronize(&context, request, &response),
      context);

  return response;
}

InitiateResponse
initiate(const StubPtr& stub, const std::vector<nidevice_grpc::Session>& sessions)
{
  ::grpc::ClientContext context;

  auto request = InitiateRequest{};
  copy_array(sessions, request.mutable_sessions());

  auto response = InitiateResponse{};

  raise_if_error(
      stub->Initiate(&context, request, &response),
      context);

  return response;
}

IsDoneResponse
is_done(const StubPtr& stub, const std::vector<nidevice_grpc::Session>& sessions)
{
  ::grpc::ClientContext context;

  auto request = IsDoneRequest{};
  copy_array(sessions, request.mutable_sessions());

  auto response = IsDoneResponse{};

  raise_if_error(
      stub->IsDone(&context, request, &response),
      context);

  return response;
}

SetupForSyncPulseSenderSynchronizeResponse
setup_for_sync_pulse_sender_synchronize(const StubPtr& stub, const std::vector<nidevice_grpc::Session>& sessions, const double& min_time)
{
  ::grpc::ClientContext context;

  auto request = SetupForSyncPulseSenderSynchronizeRequest{};
  copy_array(sessions, request.mutable_sessions());
  request.set_min_time(min_time);

  auto response = SetupForSyncPulseSenderSynchronizeResponse{};

  raise_if_error(
      stub->SetupForSyncPulseSenderSynchronize(&context, request, &response),
      context);

  return response;
}

SynchronizeResponse
synchronize(const StubPtr& stub, const std::vector<nidevice_grpc::Session>& sessions, const double& min_tclk_period)
{
  ::grpc::ClientContext context;

  auto request = SynchronizeRequest{};
  copy_array(sessions, request.mutable_sessions());
  request.set_min_tclk_period(min_tclk_period);

  auto response = SynchronizeResponse{};

  raise_if_error(
      stub->Synchronize(&context, request, &response),
      context);

  return response;
}

SynchronizeToSyncPulseSenderResponse
synchronize_to_sync_pulse_sender(const StubPtr& stub, const std::vector<nidevice_grpc::Session>& sessions, const double& min_time)
{
  ::grpc::ClientContext context;

  auto request = SynchronizeToSyncPulseSenderRequest{};
  copy_array(sessions, request.mutable_sessions());
  request.set_min_time(min_time);

  auto response = SynchronizeToSyncPulseSenderResponse{};

  raise_if_error(
      stub->SynchronizeToSyncPulseSender(&context, request, &response),
      context);

  return response;
}

WaitUntilDoneResponse
wait_until_done(const StubPtr& stub, const std::vector<nidevice_grpc::Session>& sessions, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = WaitUntilDoneRequest{};
  copy_array(sessions, request.mutable_sessions());
  request.set_timeout(timeout);

  auto response = WaitUntilDoneResponse{};

  raise_if_error(
      stub->WaitUntilDone(&context, request, &response),
      context);

  return response;
}


} // namespace niTClk_grpc::experimental::client
