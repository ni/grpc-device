
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-RFMXBT Metadata
//---------------------------------------------------------------------
#include "nirfmxbt_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>

namespace nirfmxbt_grpc {

  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiRFmxBTService::NiRFmxBTService(
      NiRFmxBTLibraryInterface* library,
      ResourceRepositorySharedPtr session_repository, 
      ViSessionResourceRepositorySharedPtr vi_session_resource_repository,
      const NiRFmxBTFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(session_repository),
      vi_session_resource_repository_(vi_session_resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiRFmxBTService::~NiRFmxBTService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPCfgAveraging(::grpc::ServerContext* context, const ACPCfgAveragingRequest* request, ACPCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxbt_grpc::ACPCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxbt_grpc::ACPCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxbt_grpc::ACPCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      auto status = library_->ACPCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPCfgBurstSynchronizationType(::grpc::ServerContext* context, const ACPCfgBurstSynchronizationTypeRequest* request, ACPCfgBurstSynchronizationTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 burst_synchronization_type;
      switch (request->burst_synchronization_type_enum_case()) {
        case nirfmxbt_grpc::ACPCfgBurstSynchronizationTypeRequest::BurstSynchronizationTypeEnumCase::kBurstSynchronizationType: {
          burst_synchronization_type = static_cast<int32>(request->burst_synchronization_type());
          break;
        }
        case nirfmxbt_grpc::ACPCfgBurstSynchronizationTypeRequest::BurstSynchronizationTypeEnumCase::kBurstSynchronizationTypeRaw: {
          burst_synchronization_type = static_cast<int32>(request->burst_synchronization_type_raw());
          break;
        }
        case nirfmxbt_grpc::ACPCfgBurstSynchronizationTypeRequest::BurstSynchronizationTypeEnumCase::BURST_SYNCHRONIZATION_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for burst_synchronization_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->ACPCfgBurstSynchronizationType(instrument, selector_string, burst_synchronization_type);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPCfgNumberOfOffsets(::grpc::ServerContext* context, const ACPCfgNumberOfOffsetsRequest* request, ACPCfgNumberOfOffsetsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 number_of_offsets = request->number_of_offsets();
      auto status = library_->ACPCfgNumberOfOffsets(instrument, selector_string, number_of_offsets);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPCfgOffsetChannelMode(::grpc::ServerContext* context, const ACPCfgOffsetChannelModeRequest* request, ACPCfgOffsetChannelModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 offset_channel_mode;
      switch (request->offset_channel_mode_enum_case()) {
        case nirfmxbt_grpc::ACPCfgOffsetChannelModeRequest::OffsetChannelModeEnumCase::kOffsetChannelMode: {
          offset_channel_mode = static_cast<int32>(request->offset_channel_mode());
          break;
        }
        case nirfmxbt_grpc::ACPCfgOffsetChannelModeRequest::OffsetChannelModeEnumCase::kOffsetChannelModeRaw: {
          offset_channel_mode = static_cast<int32>(request->offset_channel_mode_raw());
          break;
        }
        case nirfmxbt_grpc::ACPCfgOffsetChannelModeRequest::OffsetChannelModeEnumCase::OFFSET_CHANNEL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for offset_channel_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->ACPCfgOffsetChannelMode(instrument, selector_string, offset_channel_mode);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPFetchAbsolutePowerTrace(::grpc::ServerContext* context, const ACPFetchAbsolutePowerTraceRequest* request, ACPFetchAbsolutePowerTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ACPFetchAbsolutePowerTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_absolute_power()->Resize(actual_array_size, 0);
        float32* absolute_power = response->mutable_absolute_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ACPFetchAbsolutePowerTrace(instrument, selector_string, timeout, &x0, &dx, absolute_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_x0(x0);
          response->set_dx(dx);
          response->mutable_absolute_power()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPFetchMaskTrace(::grpc::ServerContext* context, const ACPFetchMaskTraceRequest* request, ACPFetchMaskTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ACPFetchMaskTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_limit_with_exception_mask()->Resize(actual_array_size, 0);
        float32* limit_with_exception_mask = response->mutable_limit_with_exception_mask()->mutable_data();
        response->mutable_limit_without_exception_mask()->Resize(actual_array_size, 0);
        float32* limit_without_exception_mask = response->mutable_limit_without_exception_mask()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ACPFetchMaskTrace(instrument, selector_string, timeout, &x0, &dx, limit_with_exception_mask, limit_without_exception_mask, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_x0(x0);
          response->set_dx(dx);
          response->mutable_limit_with_exception_mask()->Resize(actual_array_size, 0);
          response->mutable_limit_without_exception_mask()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPFetchMeasurementStatus(::grpc::ServerContext* context, const ACPFetchMeasurementStatusRequest* request, ACPFetchMeasurementStatusResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 measurement_status {};
      auto status = library_->ACPFetchMeasurementStatus(instrument, selector_string, timeout, &measurement_status);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_measurement_status(static_cast<nirfmxbt_grpc::AcpResultsMeasurementStatus>(measurement_status));
        response->set_measurement_status_raw(measurement_status);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPFetchOffsetMeasurement(::grpc::ServerContext* context, const ACPFetchOffsetMeasurementRequest* request, ACPFetchOffsetMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 lower_absolute_power {};
      float64 upper_absolute_power {};
      float64 lower_relative_power {};
      float64 upper_relative_power {};
      float64 lower_margin {};
      float64 upper_margin {};
      auto status = library_->ACPFetchOffsetMeasurement(instrument, selector_string, timeout, &lower_absolute_power, &upper_absolute_power, &lower_relative_power, &upper_relative_power, &lower_margin, &upper_margin);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_lower_absolute_power(lower_absolute_power);
        response->set_upper_absolute_power(upper_absolute_power);
        response->set_lower_relative_power(lower_relative_power);
        response->set_upper_relative_power(upper_relative_power);
        response->set_lower_margin(lower_margin);
        response->set_upper_margin(upper_margin);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPFetchOffsetMeasurementArray(::grpc::ServerContext* context, const ACPFetchOffsetMeasurementArrayRequest* request, ACPFetchOffsetMeasurementArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ACPFetchOffsetMeasurementArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_lower_absolute_power()->Resize(actual_array_size, 0);
        float64* lower_absolute_power = response->mutable_lower_absolute_power()->mutable_data();
        response->mutable_upper_absolute_power()->Resize(actual_array_size, 0);
        float64* upper_absolute_power = response->mutable_upper_absolute_power()->mutable_data();
        response->mutable_lower_relative_power()->Resize(actual_array_size, 0);
        float64* lower_relative_power = response->mutable_lower_relative_power()->mutable_data();
        response->mutable_upper_relative_power()->Resize(actual_array_size, 0);
        float64* upper_relative_power = response->mutable_upper_relative_power()->mutable_data();
        response->mutable_lower_margin()->Resize(actual_array_size, 0);
        float64* lower_margin = response->mutable_lower_margin()->mutable_data();
        response->mutable_upper_margin()->Resize(actual_array_size, 0);
        float64* upper_margin = response->mutable_upper_margin()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ACPFetchOffsetMeasurementArray(instrument, selector_string, timeout, lower_absolute_power, upper_absolute_power, lower_relative_power, upper_relative_power, lower_margin, upper_margin, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_lower_absolute_power()->Resize(actual_array_size, 0);
          response->mutable_upper_absolute_power()->Resize(actual_array_size, 0);
          response->mutable_lower_relative_power()->Resize(actual_array_size, 0);
          response->mutable_upper_relative_power()->Resize(actual_array_size, 0);
          response->mutable_lower_margin()->Resize(actual_array_size, 0);
          response->mutable_upper_margin()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPFetchReferenceChannelPower(::grpc::ServerContext* context, const ACPFetchReferenceChannelPowerRequest* request, ACPFetchReferenceChannelPowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 reference_channel_power {};
      auto status = library_->ACPFetchReferenceChannelPower(instrument, selector_string, timeout, &reference_channel_power);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_reference_channel_power(reference_channel_power);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ACPFetchSpectrum(::grpc::ServerContext* context, const ACPFetchSpectrumRequest* request, ACPFetchSpectrumResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ACPFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        float32* spectrum = response->mutable_spectrum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ACPFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, spectrum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_x0(x0);
          response->set_dx(dx);
          response->mutable_spectrum()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::AbortMeasurements(::grpc::ServerContext* context, const AbortMeasurementsRequest* request, AbortMeasurementsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      auto status = library_->AbortMeasurements(instrument, selector_string);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::AnalyzeIQ1Waveform(::grpc::ServerContext* context, const AnalyzeIQ1WaveformRequest* request, AnalyzeIQ1WaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      char* result_name = (char*)request->result_name().c_str();
      float64 x0 = request->x0();
      float64 dx = request->dx();
      auto iq = convert_from_grpc<NIComplexSingle>(request->iq());
      int32 array_size = static_cast<int32>(request->iq().size());
      int32 reset = request->reset();
      int64 reserved = request->reserved();
      auto status = library_->AnalyzeIQ1Waveform(instrument, selector_string, result_name, x0, dx, iq.data(), array_size, reset, reserved);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::AutoDetectSignal(::grpc::ServerContext* context, const AutoDetectSignalRequest* request, AutoDetectSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      auto status = library_->AutoDetectSignal(instrument, selector_string, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::AutoLevel(::grpc::ServerContext* context, const AutoLevelRequest* request, AutoLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 measurement_interval = request->measurement_interval();
      float64 reference_level {};
      auto status = library_->AutoLevel(instrument, selector_string, measurement_interval, &reference_level);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_reference_level(reference_level);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::BuildOffsetString(::grpc::ServerContext* context, const BuildOffsetStringRequest* request, BuildOffsetStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      char* selector_string = (char*)request->selector_string().c_str();
      int32 offset_number = request->offset_number();

      while (true) {
        auto status = library_->BuildOffsetString(selector_string, offset_number, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        int32 selector_string_out_length = status;
      
        std::string selector_string_out;
        if (selector_string_out_length > 0) {
            selector_string_out.resize(selector_string_out_length - 1);
        }
        status = library_->BuildOffsetString(selector_string, offset_number, selector_string_out_length, (char*)selector_string_out.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_out_length)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_selector_string_out(selector_string_out);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string_out()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::BuildSignalString(::grpc::ServerContext* context, const BuildSignalStringRequest* request, BuildSignalStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      char* signal_name = (char*)request->signal_name().c_str();
      char* result_name = (char*)request->result_name().c_str();

      while (true) {
        auto status = library_->BuildSignalString(signal_name, result_name, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        int32 selector_string_length = status;
      
        std::string selector_string;
        if (selector_string_length > 0) {
            selector_string.resize(selector_string_length - 1);
        }
        status = library_->BuildSignalString(signal_name, result_name, selector_string_length, (char*)selector_string.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_length)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_selector_string(selector_string);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgChannelNumber(::grpc::ServerContext* context, const CfgChannelNumberRequest* request, CfgChannelNumberResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 channel_number = request->channel_number();
      auto status = library_->CfgChannelNumber(instrument, selector_string, channel_number);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgDataRate(::grpc::ServerContext* context, const CfgDataRateRequest* request, CfgDataRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 data_rate = request->data_rate();
      auto status = library_->CfgDataRate(instrument, selector_string, data_rate);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgDigitalEdgeTrigger(::grpc::ServerContext* context, const CfgDigitalEdgeTriggerRequest* request, CfgDigitalEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      char* digital_edge_source = (char*)request->digital_edge_source().c_str();
      int32 digital_edge;
      switch (request->digital_edge_enum_case()) {
        case nirfmxbt_grpc::CfgDigitalEdgeTriggerRequest::DigitalEdgeEnumCase::kDigitalEdge: {
          digital_edge = static_cast<int32>(request->digital_edge());
          break;
        }
        case nirfmxbt_grpc::CfgDigitalEdgeTriggerRequest::DigitalEdgeEnumCase::kDigitalEdgeRaw: {
          digital_edge = static_cast<int32>(request->digital_edge_raw());
          break;
        }
        case nirfmxbt_grpc::CfgDigitalEdgeTriggerRequest::DigitalEdgeEnumCase::DIGITAL_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for digital_edge was not specified or out of range");
          break;
        }
      }

      float64 trigger_delay = request->trigger_delay();
      int32 enable_trigger = request->enable_trigger();
      auto status = library_->CfgDigitalEdgeTrigger(instrument, selector_string, digital_edge_source, digital_edge, trigger_delay, enable_trigger);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgExternalAttenuation(::grpc::ServerContext* context, const CfgExternalAttenuationRequest* request, CfgExternalAttenuationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 external_attenuation = request->external_attenuation();
      auto status = library_->CfgExternalAttenuation(instrument, selector_string, external_attenuation);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgFrequency(::grpc::ServerContext* context, const CfgFrequencyRequest* request, CfgFrequencyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 center_frequency = request->center_frequency();
      auto status = library_->CfgFrequency(instrument, selector_string, center_frequency);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgFrequencyChannelNumber(::grpc::ServerContext* context, const CfgFrequencyChannelNumberRequest* request, CfgFrequencyChannelNumberResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 standard;
      switch (request->standard_enum_case()) {
        case nirfmxbt_grpc::CfgFrequencyChannelNumberRequest::StandardEnumCase::kStandard: {
          standard = static_cast<int32>(request->standard());
          break;
        }
        case nirfmxbt_grpc::CfgFrequencyChannelNumberRequest::StandardEnumCase::kStandardRaw: {
          standard = static_cast<int32>(request->standard_raw());
          break;
        }
        case nirfmxbt_grpc::CfgFrequencyChannelNumberRequest::StandardEnumCase::STANDARD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for standard was not specified or out of range");
          break;
        }
      }

      int32 channel_number = request->channel_number();
      auto status = library_->CfgFrequencyChannelNumber(instrument, selector_string, standard, channel_number);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgFrequencyReference(::grpc::ServerContext* context, const CfgFrequencyReferenceRequest* request, CfgFrequencyReferenceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* channel_name = (char*)request->channel_name().c_str();
      char* frequency_reference_source;
      switch (request->frequency_reference_source_enum_case()) {
        case nirfmxbt_grpc::CfgFrequencyReferenceRequest::FrequencyReferenceSourceEnumCase::kFrequencyReferenceSourceMapped: {
          auto frequency_reference_source_imap_it = frequencyreferencesource_input_map_.find(request->frequency_reference_source_mapped());
          if (frequency_reference_source_imap_it == frequencyreferencesource_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for frequency_reference_source_mapped was not specified or out of range.");
          }
          frequency_reference_source = const_cast<char*>((frequency_reference_source_imap_it->second).c_str());
          break;
        }
        case nirfmxbt_grpc::CfgFrequencyReferenceRequest::FrequencyReferenceSourceEnumCase::kFrequencyReferenceSourceRaw: {
          frequency_reference_source = const_cast<char*>(request->frequency_reference_source_raw().c_str());
          break;
        }
        case nirfmxbt_grpc::CfgFrequencyReferenceRequest::FrequencyReferenceSourceEnumCase::FREQUENCY_REFERENCE_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for frequency_reference_source was not specified or out of range");
          break;
        }
      }

      float64 frequency_reference_frequency = request->frequency_reference_frequency();
      auto status = library_->CfgFrequencyReference(instrument, channel_name, frequency_reference_source, frequency_reference_frequency);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgIQPowerEdgeTrigger(::grpc::ServerContext* context, const CfgIQPowerEdgeTriggerRequest* request, CfgIQPowerEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      char* iq_power_edge_source = (char*)request->iq_power_edge_source().c_str();
      int32 iq_power_edge_slope;
      switch (request->iq_power_edge_slope_enum_case()) {
        case nirfmxbt_grpc::CfgIQPowerEdgeTriggerRequest::IqPowerEdgeSlopeEnumCase::kIqPowerEdgeSlope: {
          iq_power_edge_slope = static_cast<int32>(request->iq_power_edge_slope());
          break;
        }
        case nirfmxbt_grpc::CfgIQPowerEdgeTriggerRequest::IqPowerEdgeSlopeEnumCase::kIqPowerEdgeSlopeRaw: {
          iq_power_edge_slope = static_cast<int32>(request->iq_power_edge_slope_raw());
          break;
        }
        case nirfmxbt_grpc::CfgIQPowerEdgeTriggerRequest::IqPowerEdgeSlopeEnumCase::IQ_POWER_EDGE_SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for iq_power_edge_slope was not specified or out of range");
          break;
        }
      }

      float64 iq_power_edge_level = request->iq_power_edge_level();
      float64 trigger_delay = request->trigger_delay();
      int32 trigger_min_quiet_time_mode;
      switch (request->trigger_min_quiet_time_mode_enum_case()) {
        case nirfmxbt_grpc::CfgIQPowerEdgeTriggerRequest::TriggerMinQuietTimeModeEnumCase::kTriggerMinQuietTimeMode: {
          trigger_min_quiet_time_mode = static_cast<int32>(request->trigger_min_quiet_time_mode());
          break;
        }
        case nirfmxbt_grpc::CfgIQPowerEdgeTriggerRequest::TriggerMinQuietTimeModeEnumCase::kTriggerMinQuietTimeModeRaw: {
          trigger_min_quiet_time_mode = static_cast<int32>(request->trigger_min_quiet_time_mode_raw());
          break;
        }
        case nirfmxbt_grpc::CfgIQPowerEdgeTriggerRequest::TriggerMinQuietTimeModeEnumCase::TRIGGER_MIN_QUIET_TIME_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_min_quiet_time_mode was not specified or out of range");
          break;
        }
      }

      float64 trigger_min_quiet_time_duration = request->trigger_min_quiet_time_duration();
      int32 iq_power_edge_level_type;
      switch (request->iq_power_edge_level_type_enum_case()) {
        case nirfmxbt_grpc::CfgIQPowerEdgeTriggerRequest::IqPowerEdgeLevelTypeEnumCase::kIqPowerEdgeLevelType: {
          iq_power_edge_level_type = static_cast<int32>(request->iq_power_edge_level_type());
          break;
        }
        case nirfmxbt_grpc::CfgIQPowerEdgeTriggerRequest::IqPowerEdgeLevelTypeEnumCase::kIqPowerEdgeLevelTypeRaw: {
          iq_power_edge_level_type = static_cast<int32>(request->iq_power_edge_level_type_raw());
          break;
        }
        case nirfmxbt_grpc::CfgIQPowerEdgeTriggerRequest::IqPowerEdgeLevelTypeEnumCase::IQ_POWER_EDGE_LEVEL_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for iq_power_edge_level_type was not specified or out of range");
          break;
        }
      }

      int32 enable_trigger = request->enable_trigger();
      auto status = library_->CfgIQPowerEdgeTrigger(instrument, selector_string, iq_power_edge_source, iq_power_edge_slope, iq_power_edge_level, trigger_delay, trigger_min_quiet_time_mode, trigger_min_quiet_time_duration, iq_power_edge_level_type, enable_trigger);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgLEDirectionFinding(::grpc::ServerContext* context, const CfgLEDirectionFindingRequest* request, CfgLEDirectionFindingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 direction_finding_mode;
      switch (request->direction_finding_mode_enum_case()) {
        case nirfmxbt_grpc::CfgLEDirectionFindingRequest::DirectionFindingModeEnumCase::kDirectionFindingMode: {
          direction_finding_mode = static_cast<int32>(request->direction_finding_mode());
          break;
        }
        case nirfmxbt_grpc::CfgLEDirectionFindingRequest::DirectionFindingModeEnumCase::kDirectionFindingModeRaw: {
          direction_finding_mode = static_cast<int32>(request->direction_finding_mode_raw());
          break;
        }
        case nirfmxbt_grpc::CfgLEDirectionFindingRequest::DirectionFindingModeEnumCase::DIRECTION_FINDING_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for direction_finding_mode was not specified or out of range");
          break;
        }
      }

      float64 cte_length = request->cte_length();
      float64 cte_slot_duration = request->cte_slot_duration();
      auto status = library_->CfgLEDirectionFinding(instrument, selector_string, direction_finding_mode, cte_length, cte_slot_duration);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgMechanicalAttenuation(::grpc::ServerContext* context, const CfgMechanicalAttenuationRequest* request, CfgMechanicalAttenuationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* channel_name = (char*)request->channel_name().c_str();
      int32 mechanical_attenuation_auto;
      switch (request->mechanical_attenuation_auto_enum_case()) {
        case nirfmxbt_grpc::CfgMechanicalAttenuationRequest::MechanicalAttenuationAutoEnumCase::kMechanicalAttenuationAuto: {
          mechanical_attenuation_auto = static_cast<int32>(request->mechanical_attenuation_auto());
          break;
        }
        case nirfmxbt_grpc::CfgMechanicalAttenuationRequest::MechanicalAttenuationAutoEnumCase::kMechanicalAttenuationAutoRaw: {
          mechanical_attenuation_auto = static_cast<int32>(request->mechanical_attenuation_auto_raw());
          break;
        }
        case nirfmxbt_grpc::CfgMechanicalAttenuationRequest::MechanicalAttenuationAutoEnumCase::MECHANICAL_ATTENUATION_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mechanical_attenuation_auto was not specified or out of range");
          break;
        }
      }

      float64 mechanical_attenuation_value = request->mechanical_attenuation_value();
      auto status = library_->CfgMechanicalAttenuation(instrument, channel_name, mechanical_attenuation_auto, mechanical_attenuation_value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgPacketType(::grpc::ServerContext* context, const CfgPacketTypeRequest* request, CfgPacketTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 packet_type;
      switch (request->packet_type_enum_case()) {
        case nirfmxbt_grpc::CfgPacketTypeRequest::PacketTypeEnumCase::kPacketType: {
          packet_type = static_cast<int32>(request->packet_type());
          break;
        }
        case nirfmxbt_grpc::CfgPacketTypeRequest::PacketTypeEnumCase::kPacketTypeRaw: {
          packet_type = static_cast<int32>(request->packet_type_raw());
          break;
        }
        case nirfmxbt_grpc::CfgPacketTypeRequest::PacketTypeEnumCase::PACKET_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for packet_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgPacketType(instrument, selector_string, packet_type);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgPayloadBitPattern(::grpc::ServerContext* context, const CfgPayloadBitPatternRequest* request, CfgPayloadBitPatternResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 payload_bit_pattern;
      switch (request->payload_bit_pattern_enum_case()) {
        case nirfmxbt_grpc::CfgPayloadBitPatternRequest::PayloadBitPatternEnumCase::kPayloadBitPattern: {
          payload_bit_pattern = static_cast<int32>(request->payload_bit_pattern());
          break;
        }
        case nirfmxbt_grpc::CfgPayloadBitPatternRequest::PayloadBitPatternEnumCase::kPayloadBitPatternRaw: {
          payload_bit_pattern = static_cast<int32>(request->payload_bit_pattern_raw());
          break;
        }
        case nirfmxbt_grpc::CfgPayloadBitPatternRequest::PayloadBitPatternEnumCase::PAYLOAD_BIT_PATTERN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for payload_bit_pattern was not specified or out of range");
          break;
        }
      }

      auto status = library_->CfgPayloadBitPattern(instrument, selector_string, payload_bit_pattern);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgPayloadLength(::grpc::ServerContext* context, const CfgPayloadLengthRequest* request, CfgPayloadLengthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 payload_length_mode;
      switch (request->payload_length_mode_enum_case()) {
        case nirfmxbt_grpc::CfgPayloadLengthRequest::PayloadLengthModeEnumCase::kPayloadLengthMode: {
          payload_length_mode = static_cast<int32>(request->payload_length_mode());
          break;
        }
        case nirfmxbt_grpc::CfgPayloadLengthRequest::PayloadLengthModeEnumCase::kPayloadLengthModeRaw: {
          payload_length_mode = static_cast<int32>(request->payload_length_mode_raw());
          break;
        }
        case nirfmxbt_grpc::CfgPayloadLengthRequest::PayloadLengthModeEnumCase::PAYLOAD_LENGTH_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for payload_length_mode was not specified or out of range");
          break;
        }
      }

      int32 payload_length = request->payload_length();
      auto status = library_->CfgPayloadLength(instrument, selector_string, payload_length_mode, payload_length);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgRF(::grpc::ServerContext* context, const CfgRFRequest* request, CfgRFResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 center_frequency = request->center_frequency();
      float64 reference_level = request->reference_level();
      float64 external_attenuation = request->external_attenuation();
      auto status = library_->CfgRF(instrument, selector_string, center_frequency, reference_level, external_attenuation);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgRFAttenuation(::grpc::ServerContext* context, const CfgRFAttenuationRequest* request, CfgRFAttenuationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* channel_name = (char*)request->channel_name().c_str();
      int32 rf_attenuation_auto;
      switch (request->rf_attenuation_auto_enum_case()) {
        case nirfmxbt_grpc::CfgRFAttenuationRequest::RfAttenuationAutoEnumCase::kRfAttenuationAuto: {
          rf_attenuation_auto = static_cast<int32>(request->rf_attenuation_auto());
          break;
        }
        case nirfmxbt_grpc::CfgRFAttenuationRequest::RfAttenuationAutoEnumCase::kRfAttenuationAutoRaw: {
          rf_attenuation_auto = static_cast<int32>(request->rf_attenuation_auto_raw());
          break;
        }
        case nirfmxbt_grpc::CfgRFAttenuationRequest::RfAttenuationAutoEnumCase::RF_ATTENUATION_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rf_attenuation_auto was not specified or out of range");
          break;
        }
      }

      float64 rf_attenuation_value = request->rf_attenuation_value();
      auto status = library_->CfgRFAttenuation(instrument, channel_name, rf_attenuation_auto, rf_attenuation_value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgReferenceLevel(::grpc::ServerContext* context, const CfgReferenceLevelRequest* request, CfgReferenceLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 reference_level = request->reference_level();
      auto status = library_->CfgReferenceLevel(instrument, selector_string, reference_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CfgSoftwareEdgeTrigger(::grpc::ServerContext* context, const CfgSoftwareEdgeTriggerRequest* request, CfgSoftwareEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 trigger_delay = request->trigger_delay();
      int32 enable_trigger = request->enable_trigger();
      auto status = library_->CfgSoftwareEdgeTrigger(instrument, selector_string, trigger_delay, enable_trigger);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CheckMeasurementStatus(::grpc::ServerContext* context, const CheckMeasurementStatusRequest* request, CheckMeasurementStatusResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 is_done {};
      auto status = library_->CheckMeasurementStatus(instrument, selector_string, &is_done);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_is_done(is_done);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ClearAllNamedResults(::grpc::ServerContext* context, const ClearAllNamedResultsRequest* request, ClearAllNamedResultsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      auto status = library_->ClearAllNamedResults(instrument, selector_string);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ClearNamedResult(::grpc::ServerContext* context, const ClearNamedResultRequest* request, ClearNamedResultResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      auto status = library_->ClearNamedResult(instrument, selector_string);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CloneSignalConfiguration(::grpc::ServerContext* context, const CloneSignalConfigurationRequest* request, CloneSignalConfigurationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* old_signal_name = (char*)request->old_signal_name().c_str();
      char* new_signal_name = (char*)request->new_signal_name().c_str();
      auto status = library_->CloneSignalConfiguration(instrument, old_signal_name, new_signal_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      int32 force_destroy = request->force_destroy();
      session_repository_->remove_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      auto status = library_->Close(instrument, force_destroy);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::Commit(::grpc::ServerContext* context, const CommitRequest* request, CommitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      auto status = library_->Commit(instrument, selector_string);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::CreateSignalConfiguration(::grpc::ServerContext* context, const CreateSignalConfigurationRequest* request, CreateSignalConfigurationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* signal_name = (char*)request->signal_name().c_str();
      auto status = library_->CreateSignalConfiguration(instrument, signal_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::DeleteSignalConfiguration(::grpc::ServerContext* context, const DeleteSignalConfigurationRequest* request, DeleteSignalConfigurationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* signal_name = (char*)request->signal_name().c_str();
      auto status = library_->DeleteSignalConfiguration(instrument, signal_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::DisableTrigger(::grpc::ServerContext* context, const DisableTriggerRequest* request, DisableTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      auto status = library_->DisableTrigger(instrument, selector_string);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::FrequencyRangeCfgAveraging(::grpc::ServerContext* context, const FrequencyRangeCfgAveragingRequest* request, FrequencyRangeCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxbt_grpc::FrequencyRangeCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxbt_grpc::FrequencyRangeCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxbt_grpc::FrequencyRangeCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      auto status = library_->FrequencyRangeCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::FrequencyRangeCfgSpan(::grpc::ServerContext* context, const FrequencyRangeCfgSpanRequest* request, FrequencyRangeCfgSpanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 span = request->span();
      auto status = library_->FrequencyRangeCfgSpan(instrument, selector_string, span);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::FrequencyRangeFetchMeasurement(::grpc::ServerContext* context, const FrequencyRangeFetchMeasurementRequest* request, FrequencyRangeFetchMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 high_frequency {};
      float64 low_frequency {};
      auto status = library_->FrequencyRangeFetchMeasurement(instrument, selector_string, timeout, &high_frequency, &low_frequency);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_high_frequency(high_frequency);
        response->set_low_frequency(low_frequency);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::FrequencyRangeFetchSpectrum(::grpc::ServerContext* context, const FrequencyRangeFetchSpectrumRequest* request, FrequencyRangeFetchSpectrumResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->FrequencyRangeFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        float32* spectrum = response->mutable_spectrum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->FrequencyRangeFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, spectrum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_x0(x0);
          response->set_dx(dx);
          response->mutable_spectrum()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAllNamedResultNames(::grpc::ServerContext* context, const GetAllNamedResultNamesRequest* request, GetAllNamedResultNamesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 actual_result_names_size {};
      int32 default_result_exists {};
      while (true) {
        auto status = library_->GetAllNamedResultNames(instrument, selector_string, nullptr, 0, &actual_result_names_size, &default_result_exists);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        std::string result_names;
        if (actual_result_names_size > 0) {
            result_names.resize(actual_result_names_size - 1);
        }
        auto result_names_buffer_size = actual_result_names_size;
        status = library_->GetAllNamedResultNames(instrument, selector_string, (char*)result_names.data(), result_names_buffer_size, &actual_result_names_size, &default_result_exists);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_result_names(result_names);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_result_names()));
          response->set_actual_result_names_size(actual_result_names_size);
          response->set_default_result_exists(default_result_exists);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeF32(::grpc::ServerContext* context, const GetAttributeF32Request* request, GetAttributeF32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      float32 attr_val {};
      auto status = library_->GetAttributeF32(instrument, selector_string, attribute_id, &attr_val);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_attr_val(attr_val);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeF32Array(::grpc::ServerContext* context, const GetAttributeF32ArrayRequest* request, GetAttributeF32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeF32Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        float32* attr_val = response->mutable_attr_val()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->GetAttributeF32Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_attr_val()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeF64(::grpc::ServerContext* context, const GetAttributeF64Request* request, GetAttributeF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      float64 attr_val {};
      auto status = library_->GetAttributeF64(instrument, selector_string, attribute_id, &attr_val);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_attr_val(attr_val);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeF64Array(::grpc::ServerContext* context, const GetAttributeF64ArrayRequest* request, GetAttributeF64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeF64Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        float64* attr_val = response->mutable_attr_val()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->GetAttributeF64Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_attr_val()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeI16(::grpc::ServerContext* context, const GetAttributeI16Request* request, GetAttributeI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int16 attr_val {};
      auto status = library_->GetAttributeI16(instrument, selector_string, attribute_id, &attr_val);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_attr_val(attr_val);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeI32(::grpc::ServerContext* context, const GetAttributeI32Request* request, GetAttributeI32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 attr_val {};
      auto status = library_->GetAttributeI32(instrument, selector_string, attribute_id, &attr_val);
      response->set_status(status);
      if (status_ok(status)) {
        auto checked_convert_attr_val = [](auto raw_value) {
          bool raw_value_is_valid = nirfmxbt_grpc::NiRFmxBTInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nirfmxbt_grpc::NiRFmxBTInt32AttributeValues>(valid_enum_value);
        };
        response->set_attr_val(checked_convert_attr_val(attr_val));
        response->set_attr_val_raw(attr_val);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeI32Array(::grpc::ServerContext* context, const GetAttributeI32ArrayRequest* request, GetAttributeI32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeI32Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_attr_val_raw()->Resize(actual_array_size, 0);
        int32* attr_val = reinterpret_cast<int32*>(response->mutable_attr_val_raw()->mutable_data());
        auto array_size = actual_array_size;
        status = library_->GetAttributeI32Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          auto checked_convert_attr_val = [](auto raw_value) {
            bool raw_value_is_valid = nirfmxbt_grpc::NiRFmxBTInt32AttributeValues_IsValid(raw_value);
            auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
            return static_cast<nirfmxbt_grpc::NiRFmxBTInt32AttributeValues>(valid_enum_value);
          };
          response->mutable_attr_val()->Clear();
          response->mutable_attr_val()->Reserve(actual_array_size);
          std::transform(
            response->attr_val_raw().begin(),
            response->attr_val_raw().begin() + actual_array_size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_attr_val()),
            [&](auto x) { 
                return checked_convert_attr_val(x);
            });
          response->mutable_attr_val()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeI64(::grpc::ServerContext* context, const GetAttributeI64Request* request, GetAttributeI64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int64 attr_val {};
      auto status = library_->GetAttributeI64(instrument, selector_string, attribute_id, &attr_val);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_attr_val(attr_val);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeI64Array(::grpc::ServerContext* context, const GetAttributeI64ArrayRequest* request, GetAttributeI64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeI64Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        int64* attr_val = reinterpret_cast<int64*>(response->mutable_attr_val()->mutable_data());
        auto array_size = actual_array_size;
        status = library_->GetAttributeI64Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_attr_val()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeI8(::grpc::ServerContext* context, const GetAttributeI8Request* request, GetAttributeI8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int8 attr_val {};
      auto status = library_->GetAttributeI8(instrument, selector_string, attribute_id, &attr_val);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_attr_val(attr_val);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeI8Array(::grpc::ServerContext* context, const GetAttributeI8ArrayRequest* request, GetAttributeI8ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeI8Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        std::vector<int8> attr_val(actual_array_size);
        auto array_size = actual_array_size;
        status = library_->GetAttributeI8Array(instrument, selector_string, attribute_id, attr_val.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_attr_val()->Clear();
          response->mutable_attr_val()->Reserve(actual_array_size);
          std::transform(
            attr_val.begin(),
            attr_val.begin() + actual_array_size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_attr_val()),
            [&](auto x) { 
                return x;
            });
          response->mutable_attr_val()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeNIComplexDoubleArray(::grpc::ServerContext* context, const GetAttributeNIComplexDoubleArrayRequest* request, GetAttributeNIComplexDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeNIComplexDoubleArray(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        std::vector<NIComplexDouble> attr_val(actual_array_size, NIComplexDouble());
        auto array_size = actual_array_size;
        status = library_->GetAttributeNIComplexDoubleArray(instrument, selector_string, attribute_id, attr_val.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          convert_to_grpc(attr_val, response->mutable_attr_val());
          {
            auto shrunk_size = actual_array_size;
            auto current_size = response->mutable_attr_val()->size();
            if (shrunk_size != current_size) {
              response->mutable_attr_val()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
            }
          }        
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeNIComplexSingleArray(::grpc::ServerContext* context, const GetAttributeNIComplexSingleArrayRequest* request, GetAttributeNIComplexSingleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeNIComplexSingleArray(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        std::vector<NIComplexSingle> attr_val(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->GetAttributeNIComplexSingleArray(instrument, selector_string, attribute_id, attr_val.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          convert_to_grpc(attr_val, response->mutable_attr_val());
          {
            auto shrunk_size = actual_array_size;
            auto current_size = response->mutable_attr_val()->size();
            if (shrunk_size != current_size) {
              response->mutable_attr_val()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
            }
          }        
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeString(::grpc::ServerContext* context, const GetAttributeStringRequest* request, GetAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();

      while (true) {
        auto status = library_->GetAttributeString(instrument, selector_string, attribute_id, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        int32 array_size = status;
      
        std::string attr_val;
        if (array_size > 0) {
            attr_val.resize(array_size - 1);
        }
        status = library_->GetAttributeString(instrument, selector_string, attribute_id, array_size, (char*)attr_val.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(array_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_attr_val(attr_val);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_attr_val()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeU16(::grpc::ServerContext* context, const GetAttributeU16Request* request, GetAttributeU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      uInt16 attr_val {};
      auto status = library_->GetAttributeU16(instrument, selector_string, attribute_id, &attr_val);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_attr_val(attr_val);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeU32(::grpc::ServerContext* context, const GetAttributeU32Request* request, GetAttributeU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      uInt32 attr_val {};
      auto status = library_->GetAttributeU32(instrument, selector_string, attribute_id, &attr_val);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_attr_val(attr_val);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeU32Array(::grpc::ServerContext* context, const GetAttributeU32ArrayRequest* request, GetAttributeU32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeU32Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        uInt32* attr_val = reinterpret_cast<uInt32*>(response->mutable_attr_val()->mutable_data());
        auto array_size = actual_array_size;
        status = library_->GetAttributeU32Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_attr_val()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeU64Array(::grpc::ServerContext* context, const GetAttributeU64ArrayRequest* request, GetAttributeU64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeU64Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        uInt64* attr_val = reinterpret_cast<uInt64*>(response->mutable_attr_val()->mutable_data());
        auto array_size = actual_array_size;
        status = library_->GetAttributeU64Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_attr_val()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeU8(::grpc::ServerContext* context, const GetAttributeU8Request* request, GetAttributeU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      uInt8 attr_val {};
      auto status = library_->GetAttributeU8(instrument, selector_string, attribute_id, &attr_val);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_attr_val(attr_val);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetAttributeU8Array(::grpc::ServerContext* context, const GetAttributeU8ArrayRequest* request, GetAttributeU8ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeU8Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        std::string attr_val(actual_array_size, '\0');
        auto array_size = actual_array_size;
        status = library_->GetAttributeU8Array(instrument, selector_string, attribute_id, (uInt8*)attr_val.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_attr_val(attr_val);
          response->mutable_attr_val()->resize(actual_array_size);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetError(::grpc::ServerContext* context, const GetErrorRequest* request, GetErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());

      while (true) {
        auto status = library_->GetError(instrument, nullptr, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        int32 error_description_buffer_size = status;
      
        int32 error_code {};
        std::string error_description;
        if (error_description_buffer_size > 0) {
            error_description.resize(error_description_buffer_size - 1);
        }
        status = library_->GetError(instrument, &error_code, error_description_buffer_size, (char*)error_description.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(error_description_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_error_code(error_code);
          response->set_error_description(error_description);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_description()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::GetErrorString(::grpc::ServerContext* context, const GetErrorStringRequest* request, GetErrorStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      int32 error_code = request->error_code();

      while (true) {
        auto status = library_->GetErrorString(instrument, error_code, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        int32 error_description_buffer_size = status;
      
        std::string error_description;
        if (error_description_buffer_size > 0) {
            error_description.resize(error_description_buffer_size - 1);
        }
        status = library_->GetErrorString(instrument, error_code, error_description_buffer_size, (char*)error_description.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(error_description_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_error_description(error_description);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_description()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::Initialize(::grpc::ServerContext* context, const InitializeRequest* request, InitializeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      char* resource_name = (char*)request->resource_name().c_str();
      char* option_string = (char*)request->option_string().c_str();

      int32 is_new_session {};
      auto init_lambda = [&] () {
        niRFmxInstrHandle instrument;
        int status = library_->Initialize(resource_name, option_string, &instrument, &is_new_session);
        return std::make_tuple(status, instrument);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (niRFmxInstrHandle id) { library_->Close(id, RFMXBT_VAL_FALSE); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_instrument()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::InitializeFromNIRFSASession(::grpc::ServerContext* context, const InitializeFromNIRFSASessionRequest* request, InitializeFromNIRFSASessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto nirfsa_session_grpc_session = request->nirfsa_session();
      uInt32 nirfsa_session = vi_session_resource_repository_->access_session(nirfsa_session_grpc_session.id(), nirfsa_session_grpc_session.name());

      auto init_lambda = [&] () {
        niRFmxInstrHandle instrument;
        int status = library_->InitializeFromNIRFSASession(nirfsa_session, &instrument);
        return std::make_tuple(status, instrument);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (niRFmxInstrHandle id) { library_->Close(id, RFMXBT_VAL_FALSE); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_instrument()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::Initiate(::grpc::ServerContext* context, const InitiateRequest* request, InitiateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      char* result_name = (char*)request->result_name().c_str();
      auto status = library_->Initiate(instrument, selector_string, result_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccCfgAveraging(::grpc::ServerContext* context, const ModAccCfgAveragingRequest* request, ModAccCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxbt_grpc::ModAccCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxbt_grpc::ModAccCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxbt_grpc::ModAccCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      auto status = library_->ModAccCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccCfgBurstSynchronizationType(::grpc::ServerContext* context, const ModAccCfgBurstSynchronizationTypeRequest* request, ModAccCfgBurstSynchronizationTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 burst_synchronization_type;
      switch (request->burst_synchronization_type_enum_case()) {
        case nirfmxbt_grpc::ModAccCfgBurstSynchronizationTypeRequest::BurstSynchronizationTypeEnumCase::kBurstSynchronizationType: {
          burst_synchronization_type = static_cast<int32>(request->burst_synchronization_type());
          break;
        }
        case nirfmxbt_grpc::ModAccCfgBurstSynchronizationTypeRequest::BurstSynchronizationTypeEnumCase::kBurstSynchronizationTypeRaw: {
          burst_synchronization_type = static_cast<int32>(request->burst_synchronization_type_raw());
          break;
        }
        case nirfmxbt_grpc::ModAccCfgBurstSynchronizationTypeRequest::BurstSynchronizationTypeEnumCase::BURST_SYNCHRONIZATION_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for burst_synchronization_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->ModAccCfgBurstSynchronizationType(instrument, selector_string, burst_synchronization_type);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchConstellationTrace(::grpc::ServerContext* context, const ModAccFetchConstellationTraceRequest* request, ModAccFetchConstellationTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ModAccFetchConstellationTrace(instrument, selector_string, timeout, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        std::vector<NIComplexSingle> constellation(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->ModAccFetchConstellationTrace(instrument, selector_string, timeout, constellation.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          convert_to_grpc(constellation, response->mutable_constellation());
          {
            auto shrunk_size = actual_array_size;
            auto current_size = response->mutable_constellation()->size();
            if (shrunk_size != current_size) {
              response->mutable_constellation()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
            }
          }        
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchDEVM(::grpc::ServerContext* context, const ModAccFetchDEVMRequest* request, ModAccFetchDEVMResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 peak_rms_devm_maximum {};
      float64 peak_devm_maximum {};
      float64 ninetynine_percent_devm {};
      auto status = library_->ModAccFetchDEVM(instrument, selector_string, timeout, &peak_rms_devm_maximum, &peak_devm_maximum, &ninetynine_percent_devm);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_peak_rms_devm_maximum(peak_rms_devm_maximum);
        response->set_peak_devm_maximum(peak_devm_maximum);
        response->set_ninetynine_percent_devm(ninetynine_percent_devm);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchDEVMMagnitudeError(::grpc::ServerContext* context, const ModAccFetchDEVMMagnitudeErrorRequest* request, ModAccFetchDEVMMagnitudeErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 average_rms_magnitude_error_mean {};
      float64 peak_rms_magnitude_error_maximum {};
      auto status = library_->ModAccFetchDEVMMagnitudeError(instrument, selector_string, timeout, &average_rms_magnitude_error_mean, &peak_rms_magnitude_error_maximum);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_average_rms_magnitude_error_mean(average_rms_magnitude_error_mean);
        response->set_peak_rms_magnitude_error_maximum(peak_rms_magnitude_error_maximum);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchDEVMPerSymbolTrace(::grpc::ServerContext* context, const ModAccFetchDEVMPerSymbolTraceRequest* request, ModAccFetchDEVMPerSymbolTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ModAccFetchDEVMPerSymbolTrace(instrument, selector_string, timeout, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_devm_per_symbol()->Resize(actual_array_size, 0);
        float32* devm_per_symbol = response->mutable_devm_per_symbol()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ModAccFetchDEVMPerSymbolTrace(instrument, selector_string, timeout, devm_per_symbol, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_devm_per_symbol()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchDEVMPhaseError(::grpc::ServerContext* context, const ModAccFetchDEVMPhaseErrorRequest* request, ModAccFetchDEVMPhaseErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 average_rms_phase_error_mean {};
      float64 peak_rms_phase_error_maximum {};
      auto status = library_->ModAccFetchDEVMPhaseError(instrument, selector_string, timeout, &average_rms_phase_error_mean, &peak_rms_phase_error_maximum);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_average_rms_phase_error_mean(average_rms_phase_error_mean);
        response->set_peak_rms_phase_error_maximum(peak_rms_phase_error_maximum);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchDemodulatedBitTrace(::grpc::ServerContext* context, const ModAccFetchDemodulatedBitTraceRequest* request, ModAccFetchDemodulatedBitTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ModAccFetchDemodulatedBitTrace(instrument, selector_string, timeout, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        std::vector<int8> demodulated_bits(actual_array_size);
        auto array_size = actual_array_size;
        status = library_->ModAccFetchDemodulatedBitTrace(instrument, selector_string, timeout, demodulated_bits.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_demodulated_bits()->Clear();
          response->mutable_demodulated_bits()->Reserve(actual_array_size);
          std::transform(
            demodulated_bits.begin(),
            demodulated_bits.begin() + actual_array_size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_demodulated_bits()),
            [&](auto x) { 
                return x;
            });
          response->mutable_demodulated_bits()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchDf1(::grpc::ServerContext* context, const ModAccFetchDf1Request* request, ModAccFetchDf1Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 df1avg_maximum {};
      float64 df1avg_minimum {};
      auto status = library_->ModAccFetchDf1(instrument, selector_string, timeout, &df1avg_maximum, &df1avg_minimum);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_df1avg_maximum(df1avg_maximum);
        response->set_df1avg_minimum(df1avg_minimum);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchDf1maxTrace(::grpc::ServerContext* context, const ModAccFetchDf1maxTraceRequest* request, ModAccFetchDf1maxTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ModAccFetchDf1maxTrace(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_time()->Resize(actual_array_size, 0);
        float32* time = response->mutable_time()->mutable_data();
        response->mutable_df1max()->Resize(actual_array_size, 0);
        float32* df1max = response->mutable_df1max()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ModAccFetchDf1maxTrace(instrument, selector_string, timeout, time, df1max, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_time()->Resize(actual_array_size, 0);
          response->mutable_df1max()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchDf2(::grpc::ServerContext* context, const ModAccFetchDf2Request* request, ModAccFetchDf2Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 df2avg_minimum {};
      float64 percentage_of_symbols_above_df2max_threshold {};
      auto status = library_->ModAccFetchDf2(instrument, selector_string, timeout, &df2avg_minimum, &percentage_of_symbols_above_df2max_threshold);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_df2avg_minimum(df2avg_minimum);
        response->set_percentage_of_symbols_above_df2max_threshold(percentage_of_symbols_above_df2max_threshold);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchDf2maxTrace(::grpc::ServerContext* context, const ModAccFetchDf2maxTraceRequest* request, ModAccFetchDf2maxTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ModAccFetchDf2maxTrace(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_time()->Resize(actual_array_size, 0);
        float32* time = response->mutable_time()->mutable_data();
        response->mutable_df2max()->Resize(actual_array_size, 0);
        float32* df2max = response->mutable_df2max()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ModAccFetchDf2maxTrace(instrument, selector_string, timeout, time, df2max, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_time()->Resize(actual_array_size, 0);
          response->mutable_df2max()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchFrequencyErrorBR(::grpc::ServerContext* context, const ModAccFetchFrequencyErrorBRRequest* request, ModAccFetchFrequencyErrorBRResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 initial_frequency_error_maximum {};
      float64 peak_frequency_drift_maximum {};
      float64 peak_frequency_drift_rate_maximum {};
      auto status = library_->ModAccFetchFrequencyErrorBR(instrument, selector_string, timeout, &initial_frequency_error_maximum, &peak_frequency_drift_maximum, &peak_frequency_drift_rate_maximum);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_initial_frequency_error_maximum(initial_frequency_error_maximum);
        response->set_peak_frequency_drift_maximum(peak_frequency_drift_maximum);
        response->set_peak_frequency_drift_rate_maximum(peak_frequency_drift_rate_maximum);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchFrequencyErrorEDR(::grpc::ServerContext* context, const ModAccFetchFrequencyErrorEDRRequest* request, ModAccFetchFrequencyErrorEDRResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 header_frequency_error_wi_maximum {};
      float64 peak_frequency_error_wi_plus_w0_maximum {};
      float64 peak_frequency_error_w0_maximum {};
      auto status = library_->ModAccFetchFrequencyErrorEDR(instrument, selector_string, timeout, &header_frequency_error_wi_maximum, &peak_frequency_error_wi_plus_w0_maximum, &peak_frequency_error_w0_maximum);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_header_frequency_error_wi_maximum(header_frequency_error_wi_maximum);
        response->set_peak_frequency_error_wi_plus_w0_maximum(peak_frequency_error_wi_plus_w0_maximum);
        response->set_peak_frequency_error_w0_maximum(peak_frequency_error_w0_maximum);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchFrequencyErrorLE(::grpc::ServerContext* context, const ModAccFetchFrequencyErrorLERequest* request, ModAccFetchFrequencyErrorLEResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 peak_frequency_error_maximum {};
      float64 initial_frequency_drift_maximum {};
      float64 peak_frequency_drift_maximum {};
      float64 peak_frequency_drift_rate_maximum {};
      auto status = library_->ModAccFetchFrequencyErrorLE(instrument, selector_string, timeout, &peak_frequency_error_maximum, &initial_frequency_drift_maximum, &peak_frequency_drift_maximum, &peak_frequency_drift_rate_maximum);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_peak_frequency_error_maximum(peak_frequency_error_maximum);
        response->set_initial_frequency_drift_maximum(initial_frequency_drift_maximum);
        response->set_peak_frequency_drift_maximum(peak_frequency_drift_maximum);
        response->set_peak_frequency_drift_rate_maximum(peak_frequency_drift_rate_maximum);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchFrequencyErrorTraceBR(::grpc::ServerContext* context, const ModAccFetchFrequencyErrorTraceBRRequest* request, ModAccFetchFrequencyErrorTraceBRResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ModAccFetchFrequencyErrorTraceBR(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_time()->Resize(actual_array_size, 0);
        float32* time = response->mutable_time()->mutable_data();
        response->mutable_frequency_error()->Resize(actual_array_size, 0);
        float32* frequency_error = response->mutable_frequency_error()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ModAccFetchFrequencyErrorTraceBR(instrument, selector_string, timeout, time, frequency_error, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_time()->Resize(actual_array_size, 0);
          response->mutable_frequency_error()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchFrequencyErrorTraceLE(::grpc::ServerContext* context, const ModAccFetchFrequencyErrorTraceLERequest* request, ModAccFetchFrequencyErrorTraceLEResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ModAccFetchFrequencyErrorTraceLE(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_time()->Resize(actual_array_size, 0);
        float32* time = response->mutable_time()->mutable_data();
        response->mutable_frequency_error()->Resize(actual_array_size, 0);
        float32* frequency_error = response->mutable_frequency_error()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ModAccFetchFrequencyErrorTraceLE(instrument, selector_string, timeout, time, frequency_error, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_time()->Resize(actual_array_size, 0);
          response->mutable_frequency_error()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchFrequencyErrorWiPlusW0TraceEDR(::grpc::ServerContext* context, const ModAccFetchFrequencyErrorWiPlusW0TraceEDRRequest* request, ModAccFetchFrequencyErrorWiPlusW0TraceEDRResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ModAccFetchFrequencyErrorWiPlusW0TraceEDR(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_time()->Resize(actual_array_size, 0);
        float32* time = response->mutable_time()->mutable_data();
        response->mutable_frequency_error_wi_plus_w0()->Resize(actual_array_size, 0);
        float32* frequency_error_wi_plus_w0 = response->mutable_frequency_error_wi_plus_w0()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ModAccFetchFrequencyErrorWiPlusW0TraceEDR(instrument, selector_string, timeout, time, frequency_error_wi_plus_w0, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_time()->Resize(actual_array_size, 0);
          response->mutable_frequency_error_wi_plus_w0()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchFrequencyTrace(::grpc::ServerContext* context, const ModAccFetchFrequencyTraceRequest* request, ModAccFetchFrequencyTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ModAccFetchFrequencyTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_frequency()->Resize(actual_array_size, 0);
        float32* frequency = response->mutable_frequency()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ModAccFetchFrequencyTrace(instrument, selector_string, timeout, &x0, &dx, frequency, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_x0(x0);
          response->set_dx(dx);
          response->mutable_frequency()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ModAccFetchRMSDEVMTrace(::grpc::ServerContext* context, const ModAccFetchRMSDEVMTraceRequest* request, ModAccFetchRMSDEVMTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ModAccFetchRMSDEVMTrace(instrument, selector_string, timeout, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_rms_devm()->Resize(actual_array_size, 0);
        float32* rms_devm = response->mutable_rms_devm()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ModAccFetchRMSDEVMTrace(instrument, selector_string, timeout, rms_devm, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_rms_devm()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ResetAttribute(::grpc::ServerContext* context, const ResetAttributeRequest* request, ResetAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto status = library_->ResetAttribute(instrument, selector_string, attribute_id);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::ResetToDefault(::grpc::ServerContext* context, const ResetToDefaultRequest* request, ResetToDefaultResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      auto status = library_->ResetToDefault(instrument, selector_string);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SelectMeasurements(::grpc::ServerContext* context, const SelectMeasurementsRequest* request, SelectMeasurementsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      uInt32 measurements;
      switch (request->measurements_enum_case()) {
        case nirfmxbt_grpc::SelectMeasurementsRequest::MeasurementsEnumCase::kMeasurements: {
          measurements = static_cast<uInt32>(request->measurements());
          break;
        }
        case nirfmxbt_grpc::SelectMeasurementsRequest::MeasurementsEnumCase::kMeasurementsRaw: {
          measurements = static_cast<uInt32>(request->measurements_raw());
          break;
        }
        case nirfmxbt_grpc::SelectMeasurementsRequest::MeasurementsEnumCase::MEASUREMENTS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurements was not specified or out of range");
          break;
        }
      }

      int32 enable_all_traces = request->enable_all_traces();
      auto status = library_->SelectMeasurements(instrument, selector_string, measurements, enable_all_traces);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SendSoftwareEdgeTrigger(::grpc::ServerContext* context, const SendSoftwareEdgeTriggerRequest* request, SendSoftwareEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      auto status = library_->SendSoftwareEdgeTrigger(instrument);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeF32(::grpc::ServerContext* context, const SetAttributeF32Request* request, SetAttributeF32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      float32 attr_val = request->attr_val();
      auto status = library_->SetAttributeF32(instrument, selector_string, attribute_id, attr_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeF32Array(::grpc::ServerContext* context, const SetAttributeF32ArrayRequest* request, SetAttributeF32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = const_cast<float32*>(request->attr_val().data());
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeF32Array(instrument, selector_string, attribute_id, attr_val, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeF64(::grpc::ServerContext* context, const SetAttributeF64Request* request, SetAttributeF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      float64 attr_val = request->attr_val();
      auto status = library_->SetAttributeF64(instrument, selector_string, attribute_id, attr_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeF64Array(::grpc::ServerContext* context, const SetAttributeF64ArrayRequest* request, SetAttributeF64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = const_cast<float64*>(request->attr_val().data());
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeF64Array(instrument, selector_string, attribute_id, attr_val, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeI16(::grpc::ServerContext* context, const SetAttributeI16Request* request, SetAttributeI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val_raw = request->attr_val();
      if (attr_val_raw < std::numeric_limits<int16>::min() || attr_val_raw > std::numeric_limits<int16>::max()) {
          std::string message("value ");
          message.append(std::to_string(attr_val_raw));
          message.append(" doesn't fit in datatype ");
          message.append("int16");
          throw nidevice_grpc::ValueOutOfRangeException(message);
      }
      auto attr_val = static_cast<int16>(attr_val_raw);

      auto status = library_->SetAttributeI16(instrument, selector_string, attribute_id, attr_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeI32(::grpc::ServerContext* context, const SetAttributeI32Request* request, SetAttributeI32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int32 attr_val;
      switch (request->attr_val_enum_case()) {
        case nirfmxbt_grpc::SetAttributeI32Request::AttrValEnumCase::kAttrVal: {
          attr_val = static_cast<int32>(request->attr_val());
          break;
        }
        case nirfmxbt_grpc::SetAttributeI32Request::AttrValEnumCase::kAttrValRaw: {
          attr_val = static_cast<int32>(request->attr_val_raw());
          break;
        }
        case nirfmxbt_grpc::SetAttributeI32Request::AttrValEnumCase::ATTR_VAL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attr_val was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeI32(instrument, selector_string, attribute_id, attr_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeI32Array(::grpc::ServerContext* context, const SetAttributeI32ArrayRequest* request, SetAttributeI32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val_vector = std::vector<int32>();
      attr_val_vector.reserve(request->attr_val().size());
      std::transform(
        request->attr_val().begin(),
        request->attr_val().end(),
        std::back_inserter(attr_val_vector),
        [](auto x) { return x; });
      auto attr_val = attr_val_vector.data();

      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeI32Array(instrument, selector_string, attribute_id, attr_val, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeI64(::grpc::ServerContext* context, const SetAttributeI64Request* request, SetAttributeI64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      int64 attr_val = request->attr_val();
      auto status = library_->SetAttributeI64(instrument, selector_string, attribute_id, attr_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeI64Array(::grpc::ServerContext* context, const SetAttributeI64ArrayRequest* request, SetAttributeI64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = const_cast<int64*>(reinterpret_cast<const int64*>(request->attr_val().data()));
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeI64Array(instrument, selector_string, attribute_id, attr_val, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeI8(::grpc::ServerContext* context, const SetAttributeI8Request* request, SetAttributeI8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val_raw = request->attr_val();
      if (attr_val_raw < std::numeric_limits<int8>::min() || attr_val_raw > std::numeric_limits<int8>::max()) {
          std::string message("value ");
          message.append(std::to_string(attr_val_raw));
          message.append(" doesn't fit in datatype ");
          message.append("int8");
          throw nidevice_grpc::ValueOutOfRangeException(message);
      }
      auto attr_val = static_cast<int8>(attr_val_raw);

      auto status = library_->SetAttributeI8(instrument, selector_string, attribute_id, attr_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeI8Array(::grpc::ServerContext* context, const SetAttributeI8ArrayRequest* request, SetAttributeI8ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val_raw = request->attr_val();
      auto attr_val = std::vector<int8>();
      attr_val.reserve(attr_val_raw.size());
      std::transform(
        attr_val_raw.begin(),
        attr_val_raw.end(),
        std::back_inserter(attr_val),
        [](auto x) { 
              if (x < std::numeric_limits<int8>::min() || x > std::numeric_limits<int8>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("int8");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<int8>(x);
        });

      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeI8Array(instrument, selector_string, attribute_id, attr_val.data(), array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeNIComplexDoubleArray(::grpc::ServerContext* context, const SetAttributeNIComplexDoubleArrayRequest* request, SetAttributeNIComplexDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = convert_from_grpc<NIComplexDouble>(request->attr_val());
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeNIComplexDoubleArray(instrument, selector_string, attribute_id, attr_val.data(), array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeNIComplexSingleArray(::grpc::ServerContext* context, const SetAttributeNIComplexSingleArrayRequest* request, SetAttributeNIComplexSingleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = convert_from_grpc<NIComplexSingle>(request->attr_val());
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeNIComplexSingleArray(instrument, selector_string, attribute_id, attr_val.data(), array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeString(::grpc::ServerContext* context, const SetAttributeStringRequest* request, SetAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      char* attr_val = (char*)request->attr_val().c_str();
      auto status = library_->SetAttributeString(instrument, selector_string, attribute_id, attr_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeU16(::grpc::ServerContext* context, const SetAttributeU16Request* request, SetAttributeU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val_raw = request->attr_val();
      if (attr_val_raw < std::numeric_limits<uInt16>::min() || attr_val_raw > std::numeric_limits<uInt16>::max()) {
          std::string message("value ");
          message.append(std::to_string(attr_val_raw));
          message.append(" doesn't fit in datatype ");
          message.append("uInt16");
          throw nidevice_grpc::ValueOutOfRangeException(message);
      }
      auto attr_val = static_cast<uInt16>(attr_val_raw);

      auto status = library_->SetAttributeU16(instrument, selector_string, attribute_id, attr_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::ValueOutOfRangeException& ex) {
      return ::grpc::Status(::grpc::OUT_OF_RANGE, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeU32(::grpc::ServerContext* context, const SetAttributeU32Request* request, SetAttributeU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      uInt32 attr_val = request->attr_val();
      auto status = library_->SetAttributeU32(instrument, selector_string, attribute_id, attr_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeU32Array(::grpc::ServerContext* context, const SetAttributeU32ArrayRequest* request, SetAttributeU32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = const_cast<uInt32*>(reinterpret_cast<const uInt32*>(request->attr_val().data()));
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeU32Array(instrument, selector_string, attribute_id, attr_val, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeU64Array(::grpc::ServerContext* context, const SetAttributeU64ArrayRequest* request, SetAttributeU64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = const_cast<uInt64*>(reinterpret_cast<const uInt64*>(request->attr_val().data()));
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeU64Array(instrument, selector_string, attribute_id, attr_val, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeU8(::grpc::ServerContext* context, const SetAttributeU8Request* request, SetAttributeU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      uInt8 attr_val = request->attr_val();
      auto status = library_->SetAttributeU8(instrument, selector_string, attribute_id, attr_val);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::SetAttributeU8Array(::grpc::ServerContext* context, const SetAttributeU8ArrayRequest* request, SetAttributeU8ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 attribute_id = request->attribute_id();
      uInt8* attr_val = (uInt8*)request->attr_val().c_str();
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeU8Array(instrument, selector_string, attribute_id, attr_val, array_size);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::TXPCfgAveraging(::grpc::ServerContext* context, const TXPCfgAveragingRequest* request, TXPCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxbt_grpc::TXPCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxbt_grpc::TXPCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxbt_grpc::TXPCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      auto status = library_->TXPCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::TXPCfgBurstSynchronizationType(::grpc::ServerContext* context, const TXPCfgBurstSynchronizationTypeRequest* request, TXPCfgBurstSynchronizationTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      int32 burst_synchronization_type;
      switch (request->burst_synchronization_type_enum_case()) {
        case nirfmxbt_grpc::TXPCfgBurstSynchronizationTypeRequest::BurstSynchronizationTypeEnumCase::kBurstSynchronizationType: {
          burst_synchronization_type = static_cast<int32>(request->burst_synchronization_type());
          break;
        }
        case nirfmxbt_grpc::TXPCfgBurstSynchronizationTypeRequest::BurstSynchronizationTypeEnumCase::kBurstSynchronizationTypeRaw: {
          burst_synchronization_type = static_cast<int32>(request->burst_synchronization_type_raw());
          break;
        }
        case nirfmxbt_grpc::TXPCfgBurstSynchronizationTypeRequest::BurstSynchronizationTypeEnumCase::BURST_SYNCHRONIZATION_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for burst_synchronization_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->TXPCfgBurstSynchronizationType(instrument, selector_string, burst_synchronization_type);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::TXPFetchEDRPowers(::grpc::ServerContext* context, const TXPFetchEDRPowersRequest* request, TXPFetchEDRPowersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 edrgfsk_average_power_mean {};
      float64 edrdpsk_average_power_mean {};
      float64 edr_d_psk_g_fsk_average_power_ratio_mean {};
      auto status = library_->TXPFetchEDRPowers(instrument, selector_string, timeout, &edrgfsk_average_power_mean, &edrdpsk_average_power_mean, &edr_d_psk_g_fsk_average_power_ratio_mean);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_edrgfsk_average_power_mean(edrgfsk_average_power_mean);
        response->set_edrdpsk_average_power_mean(edrdpsk_average_power_mean);
        response->set_edr_d_psk_g_fsk_average_power_ratio_mean(edr_d_psk_g_fsk_average_power_ratio_mean);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::TXPFetchLECTEReferencePeriodPowers(::grpc::ServerContext* context, const TXPFetchLECTEReferencePeriodPowersRequest* request, TXPFetchLECTEReferencePeriodPowersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 reference_period_average_power_mean {};
      float64 reference_period_peak_absolute_power_deviation_maximum {};
      auto status = library_->TXPFetchLECTEReferencePeriodPowers(instrument, selector_string, timeout, &reference_period_average_power_mean, &reference_period_peak_absolute_power_deviation_maximum);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_reference_period_average_power_mean(reference_period_average_power_mean);
        response->set_reference_period_peak_absolute_power_deviation_maximum(reference_period_peak_absolute_power_deviation_maximum);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::TXPFetchLECTETransmitSlotPowers(::grpc::ServerContext* context, const TXPFetchLECTETransmitSlotPowersRequest* request, TXPFetchLECTETransmitSlotPowersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 transmit_slot_average_power_mean {};
      float64 transmit_slot_peak_absolute_power_deviation_maximum {};
      auto status = library_->TXPFetchLECTETransmitSlotPowers(instrument, selector_string, timeout, &transmit_slot_average_power_mean, &transmit_slot_peak_absolute_power_deviation_maximum);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_transmit_slot_average_power_mean(transmit_slot_average_power_mean);
        response->set_transmit_slot_peak_absolute_power_deviation_maximum(transmit_slot_peak_absolute_power_deviation_maximum);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::TXPFetchLECTETransmitSlotPowersArray(::grpc::ServerContext* context, const TXPFetchLECTETransmitSlotPowersArrayRequest* request, TXPFetchLECTETransmitSlotPowersArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->TXPFetchLECTETransmitSlotPowersArray(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_transmit_slot_average_power_mean()->Resize(actual_array_size, 0);
        float64* transmit_slot_average_power_mean = response->mutable_transmit_slot_average_power_mean()->mutable_data();
        response->mutable_transmit_slot_peak_absolute_power_deviation_maximum()->Resize(actual_array_size, 0);
        float64* transmit_slot_peak_absolute_power_deviation_maximum = response->mutable_transmit_slot_peak_absolute_power_deviation_maximum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->TXPFetchLECTETransmitSlotPowersArray(instrument, selector_string, timeout, transmit_slot_average_power_mean, transmit_slot_peak_absolute_power_deviation_maximum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_transmit_slot_average_power_mean()->Resize(actual_array_size, 0);
          response->mutable_transmit_slot_peak_absolute_power_deviation_maximum()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::TXPFetchPowerTrace(::grpc::ServerContext* context, const TXPFetchPowerTraceRequest* request, TXPFetchPowerTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->TXPFetchPowerTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_power()->Resize(actual_array_size, 0);
        float32* power = response->mutable_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->TXPFetchPowerTrace(instrument, selector_string, timeout, &x0, &dx, power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_x0(x0);
          response->set_dx(dx);
          response->mutable_power()->Resize(actual_array_size, 0);
          response->set_actual_array_size(actual_array_size);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::TXPFetchPowers(::grpc::ServerContext* context, const TXPFetchPowersRequest* request, TXPFetchPowersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      float64 average_power_mean {};
      float64 average_power_maximum {};
      float64 average_power_minimum {};
      float64 peak_to_average_power_ratio_maximum {};
      auto status = library_->TXPFetchPowers(instrument, selector_string, timeout, &average_power_mean, &average_power_maximum, &average_power_minimum, &peak_to_average_power_ratio_maximum);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_average_power_mean(average_power_mean);
        response->set_average_power_maximum(average_power_maximum);
        response->set_average_power_minimum(average_power_minimum);
        response->set_peak_to_average_power_ratio_maximum(peak_to_average_power_ratio_maximum);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::WaitForAcquisitionComplete(::grpc::ServerContext* context, const WaitForAcquisitionCompleteRequest* request, WaitForAcquisitionCompleteResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      float64 timeout = request->timeout();
      auto status = library_->WaitForAcquisitionComplete(instrument, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxBTService::WaitForMeasurementComplete(::grpc::ServerContext* context, const WaitForMeasurementCompleteRequest* request, WaitForMeasurementCompleteResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.id(), instrument_grpc_session.name());
      char* selector_string = (char*)request->selector_string().c_str();
      float64 timeout = request->timeout();
      auto status = library_->WaitForMeasurementComplete(instrument, selector_string, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  NiRFmxBTFeatureToggles::NiRFmxBTFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nirfmxbt", CodeReadiness::kNextRelease))
  {
  }
} // namespace nirfmxbt_grpc

