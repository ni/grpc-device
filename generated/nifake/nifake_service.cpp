
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-FAKE Metadata
//---------------------------------------------------------------------
#include "nifake_service.h"

#include <niFake.h>
#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>

namespace ni {
namespace fake {
namespace grpc {

  namespace internal = ni::hardware::grpc::internal;
  using niFake_AbortPtr = ViStatus (*)(ViSession vi);
  using niFake_EnumInputFunctionWithDefaultsPtr = ViStatus (*)(ViSession vi, ViInt16 aTurtle);
  using niFake_GetABooleanPtr = ViStatus (*)(ViSession vi, ViBoolean* aBoolean);
  using niFake_GetANumberPtr = ViStatus (*)(ViSession vi, ViInt16* aNumber);
  using niFake_GetArraySizeForPythonCodePtr = ViStatus (*)(ViSession vi, ViInt32* sizeOut);
  using niFake_GetAttributeViBooleanPtr = ViStatus (*)(ViSession vi, ViConstString channelName, ViAttr attributeId, ViBoolean* attributeValue);
  using niFake_GetAttributeViInt32Ptr = ViStatus (*)(ViSession vi, ViConstString channelName, ViAttr attributeId, ViInt32* attributeValue);
  using niFake_GetAttributeViInt64Ptr = ViStatus (*)(ViSession vi, ViConstString channelName, ViAttr attributeId, ViInt64* attributeValue);
  using niFake_GetAttributeViReal64Ptr = ViStatus (*)(ViSession vi, ViConstString channelName, ViAttr attributeId, ViReal64* attributeValue);
  using niFake_GetCalDateAndTimePtr = ViStatus (*)(ViSession vi, ViInt32 calType, ViInt32* month, ViInt32* day, ViInt32* year, ViInt32* hour, ViInt32* minute);
  using niFake_GetCalIntervalPtr = ViStatus (*)(ViSession vi, ViInt32* months);
  using niFake_GetEnumValuePtr = ViStatus (*)(ViSession vi, ViInt32* aQuantity, ViInt16* aTurtle);
  using niFake_InitWithOptionsPtr = ViStatus (*)(ViString resourceName, ViBoolean idQuery, ViBoolean resetDevice, ViConstString optionString, ViSession* vi);
  using niFake_InitiatePtr = ViStatus (*)(ViSession vi);
  using niFake_OneInputFunctionPtr = ViStatus (*)(ViSession vi, ViInt32 aNumber);
  using niFake_ParametersAreMultipleTypesPtr = ViStatus (*)(ViSession vi, ViBoolean aBoolean, ViInt32 anInt32, ViInt64 anInt64, ViInt16 anIntEnum, ViReal64 aFloat, ViReal64 aFloatEnum, ViInt32 stringSize, ViConstString aString);
  using niFake_PoorlyNamedSimpleFunctionPtr = ViStatus (*)(ViSession vi);
  using niFake_ReadPtr = ViStatus (*)(ViSession vi, ViReal64 maximumTime, ViReal64* reading);
  using niFake_ReadFromChannelPtr = ViStatus (*)(ViSession vi, ViConstString channelName, ViInt32 maximumTime, ViReal64* reading);
  using niFake_ReturnDurationInSecondsPtr = ViStatus (*)(ViSession vi, ViReal64* timedelta);
  using niFake_SetAttributeViBooleanPtr = ViStatus (*)(ViSession vi, ViConstString channelName, ViAttr attributeId, ViBoolean attributeValue);
  using niFake_SetAttributeViInt32Ptr = ViStatus (*)(ViSession vi, ViConstString channelName, ViAttr attributeId, ViInt32 attributeValue);
  using niFake_SetAttributeViInt64Ptr = ViStatus (*)(ViSession vi, ViConstString channelName, ViAttr attributeId, ViInt64 attributeValue);
  using niFake_SetAttributeViReal64Ptr = ViStatus (*)(ViSession vi, ViConstString channelName, ViAttr attributeId, ViReal64 attributeValue);
  using niFake_SetAttributeViStringPtr = ViStatus (*)(ViSession vi, ViConstString channelName, ViAttr attributeId, ViConstString attributeValue);
  using niFake_StringValuedEnumInputFunctionWithDefaultsPtr = ViStatus (*)(ViSession vi, ViConstString aMobileOSName);
  using niFake_TwoInputFunctionPtr = ViStatus (*)(ViSession vi, ViReal64 aNumber, ViString aString);
  using niFake_Use64BitNumberPtr = ViStatus (*)(ViSession vi, ViInt64 input, ViInt64* output);
  using niFake_closePtr = ViStatus (*)(ViSession vi);

  #if defined(_MSC_VER)
    static const char* driver_api_library_name = "nifake_64.dll";
  #else
    static const char* driver_api_library_name = "./libnifake.so";
  #endif

  NiFakeService::NiFakeService(internal::SharedLibrary* shared_library, internal::SessionRepository* session_repository)
      : shared_library_(shared_library), session_repository_(session_repository)
  {
    shared_library_->set_library_name(driver_api_library_name);
  }

  NiFakeService::~NiFakeService()
  {
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::Abort(::grpc::ServerContext* context, const AbortRequest* request, AbortResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_Abort_function = reinterpret_cast<niFake_AbortPtr>(shared_library_->get_function_pointer("niFake_Abort"));
    if (niFake_Abort_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_Abort");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    auto status = niFake_Abort_function(vi);
    response->set_status(status);
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::AcceptListOfDurationsInSeconds(::grpc::ServerContext* context, const AcceptListOfDurationsInSecondsRequest* request, AcceptListOfDurationsInSecondsResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::BoolArrayOutputFunction(::grpc::ServerContext* context, const BoolArrayOutputFunctionRequest* request, BoolArrayOutputFunctionResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::DoubleAllTheNums(::grpc::ServerContext* context, const DoubleAllTheNumsRequest* request, DoubleAllTheNumsResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::EnumArrayOutputFunction(::grpc::ServerContext* context, const EnumArrayOutputFunctionRequest* request, EnumArrayOutputFunctionResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::EnumInputFunctionWithDefaults(::grpc::ServerContext* context, const EnumInputFunctionWithDefaultsRequest* request, EnumInputFunctionWithDefaultsResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_EnumInputFunctionWithDefaults_function = reinterpret_cast<niFake_EnumInputFunctionWithDefaultsPtr>(shared_library_->get_function_pointer("niFake_EnumInputFunctionWithDefaults"));
    if (niFake_EnumInputFunctionWithDefaults_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_EnumInputFunctionWithDefaults");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    // TODO: The below would work with integer enums but we need to properly convert non-integer enums to their corresponding values of the correct type.
    // auto a_turtle = static_cast<ViInt16>(($ViInt16)request->a_turtle();)
    ViInt16 a_turtle;
    auto status = niFake_EnumInputFunctionWithDefaults_function(vi, a_turtle);
    response->set_status(status);
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ExportAttributeConfigurationBuffer(::grpc::ServerContext* context, const ExportAttributeConfigurationBufferRequest* request, ExportAttributeConfigurationBufferResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::FetchWaveform(::grpc::ServerContext* context, const FetchWaveformRequest* request, FetchWaveformResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetABoolean(::grpc::ServerContext* context, const GetABooleanRequest* request, GetABooleanResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_GetABoolean_function = reinterpret_cast<niFake_GetABooleanPtr>(shared_library_->get_function_pointer("niFake_GetABoolean"));
    if (niFake_GetABoolean_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_GetABoolean");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViBoolean a_boolean;
    auto status = niFake_GetABoolean_function(vi, &a_boolean);
    response->set_status(status);
    if (status == 0) {
      response->set_a_boolean(a_boolean);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetANumber(::grpc::ServerContext* context, const GetANumberRequest* request, GetANumberResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_GetANumber_function = reinterpret_cast<niFake_GetANumberPtr>(shared_library_->get_function_pointer("niFake_GetANumber"));
    if (niFake_GetANumber_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_GetANumber");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViInt16 a_number;
    auto status = niFake_GetANumber_function(vi, &a_number);
    response->set_status(status);
    if (status == 0) {
      response->set_a_number(a_number);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAStringOfFixedMaximumSize(::grpc::ServerContext* context, const GetAStringOfFixedMaximumSizeRequest* request, GetAStringOfFixedMaximumSizeResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAStringUsingPythonCode(::grpc::ServerContext* context, const GetAStringUsingPythonCodeRequest* request, GetAStringUsingPythonCodeResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAnIviDanceString(::grpc::ServerContext* context, const GetAnIviDanceStringRequest* request, GetAnIviDanceStringResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAnIviDanceWithATwistString(::grpc::ServerContext* context, const GetAnIviDanceWithATwistStringRequest* request, GetAnIviDanceWithATwistStringResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetArrayForPythonCodeCustomType(::grpc::ServerContext* context, const GetArrayForPythonCodeCustomTypeRequest* request, GetArrayForPythonCodeCustomTypeResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetArrayForPythonCodeDouble(::grpc::ServerContext* context, const GetArrayForPythonCodeDoubleRequest* request, GetArrayForPythonCodeDoubleResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetArraySizeForPythonCode(::grpc::ServerContext* context, const GetArraySizeForPythonCodeRequest* request, GetArraySizeForPythonCodeResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_GetArraySizeForPythonCode_function = reinterpret_cast<niFake_GetArraySizeForPythonCodePtr>(shared_library_->get_function_pointer("niFake_GetArraySizeForPythonCode"));
    if (niFake_GetArraySizeForPythonCode_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_GetArraySizeForPythonCode");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViInt32 size_out;
    auto status = niFake_GetArraySizeForPythonCode_function(vi, &size_out);
    response->set_status(status);
    if (status == 0) {
      response->set_size_out(size_out);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetArrayUsingIviDance(::grpc::ServerContext* context, const GetArrayUsingIviDanceRequest* request, GetArrayUsingIviDanceResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViBoolean(::grpc::ServerContext* context, const GetAttributeViBooleanRequest* request, GetAttributeViBooleanResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_GetAttributeViBoolean_function = reinterpret_cast<niFake_GetAttributeViBooleanPtr>(shared_library_->get_function_pointer("niFake_GetAttributeViBoolean"));
    if (niFake_GetAttributeViBoolean_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_GetAttributeViBoolean");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViConstString channel_name = request->channel_name().c_str();
    ViAttr attribute_id = request->attribute_id();
    ViBoolean attribute_value;
    auto status = niFake_GetAttributeViBoolean_function(vi, channel_name, attribute_id, &attribute_value);
    response->set_status(status);
    if (status == 0) {
      response->set_attribute_value(attribute_value);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViInt32(::grpc::ServerContext* context, const GetAttributeViInt32Request* request, GetAttributeViInt32Response* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_GetAttributeViInt32_function = reinterpret_cast<niFake_GetAttributeViInt32Ptr>(shared_library_->get_function_pointer("niFake_GetAttributeViInt32"));
    if (niFake_GetAttributeViInt32_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_GetAttributeViInt32");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViConstString channel_name = request->channel_name().c_str();
    ViAttr attribute_id = request->attribute_id();
    ViInt32 attribute_value;
    auto status = niFake_GetAttributeViInt32_function(vi, channel_name, attribute_id, &attribute_value);
    response->set_status(status);
    if (status == 0) {
      response->set_attribute_value(attribute_value);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViInt64(::grpc::ServerContext* context, const GetAttributeViInt64Request* request, GetAttributeViInt64Response* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_GetAttributeViInt64_function = reinterpret_cast<niFake_GetAttributeViInt64Ptr>(shared_library_->get_function_pointer("niFake_GetAttributeViInt64"));
    if (niFake_GetAttributeViInt64_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_GetAttributeViInt64");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViConstString channel_name = request->channel_name().c_str();
    ViAttr attribute_id = request->attribute_id();
    ViInt64 attribute_value;
    auto status = niFake_GetAttributeViInt64_function(vi, channel_name, attribute_id, &attribute_value);
    response->set_status(status);
    if (status == 0) {
      response->set_attribute_value(attribute_value);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViReal64(::grpc::ServerContext* context, const GetAttributeViReal64Request* request, GetAttributeViReal64Response* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_GetAttributeViReal64_function = reinterpret_cast<niFake_GetAttributeViReal64Ptr>(shared_library_->get_function_pointer("niFake_GetAttributeViReal64"));
    if (niFake_GetAttributeViReal64_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_GetAttributeViReal64");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViConstString channel_name = request->channel_name().c_str();
    ViAttr attribute_id = request->attribute_id();
    ViReal64 attribute_value;
    auto status = niFake_GetAttributeViReal64_function(vi, channel_name, attribute_id, &attribute_value);
    response->set_status(status);
    if (status == 0) {
      response->set_attribute_value(attribute_value);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViString(::grpc::ServerContext* context, const GetAttributeViStringRequest* request, GetAttributeViStringResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetCalDateAndTime(::grpc::ServerContext* context, const GetCalDateAndTimeRequest* request, GetCalDateAndTimeResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_GetCalDateAndTime_function = reinterpret_cast<niFake_GetCalDateAndTimePtr>(shared_library_->get_function_pointer("niFake_GetCalDateAndTime"));
    if (niFake_GetCalDateAndTime_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_GetCalDateAndTime");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViInt32 cal_type = request->cal_type();
    ViInt32 month;
    ViInt32 day;
    ViInt32 year;
    ViInt32 hour;
    ViInt32 minute;
    auto status = niFake_GetCalDateAndTime_function(vi, cal_type, &month, &day, &year, &hour, &minute);
    response->set_status(status);
    if (status == 0) {
      response->set_month(month);
      response->set_day(day);
      response->set_year(year);
      response->set_hour(hour);
      response->set_minute(minute);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetCalInterval(::grpc::ServerContext* context, const GetCalIntervalRequest* request, GetCalIntervalResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_GetCalInterval_function = reinterpret_cast<niFake_GetCalIntervalPtr>(shared_library_->get_function_pointer("niFake_GetCalInterval"));
    if (niFake_GetCalInterval_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_GetCalInterval");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViInt32 months;
    auto status = niFake_GetCalInterval_function(vi, &months);
    response->set_status(status);
    if (status == 0) {
      response->set_months(months);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetCustomType(::grpc::ServerContext* context, const GetCustomTypeRequest* request, GetCustomTypeResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetCustomTypeArray(::grpc::ServerContext* context, const GetCustomTypeArrayRequest* request, GetCustomTypeArrayResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetEnumValue(::grpc::ServerContext* context, const GetEnumValueRequest* request, GetEnumValueResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_GetEnumValue_function = reinterpret_cast<niFake_GetEnumValuePtr>(shared_library_->get_function_pointer("niFake_GetEnumValue"));
    if (niFake_GetEnumValue_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_GetEnumValue");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViInt32 a_quantity;
    ViInt16 a_turtle_ctype;
    auto status = niFake_GetEnumValue_function(vi, &a_quantity, &a_turtle_ctype);
    response->set_status(status);
    if (status == 0) {
      response->set_a_quantity(a_quantity);
      response->set_a_turtle(static_cast<ni::fake::grpc::Turtle>(a_turtle_ctype));
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ImportAttributeConfigurationBuffer(::grpc::ServerContext* context, const ImportAttributeConfigurationBufferRequest* request, ImportAttributeConfigurationBufferResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::InitWithOptions(::grpc::ServerContext* context, const InitWithOptionsRequest* request, InitWithOptionsResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_InitWithOptions_function = reinterpret_cast<niFake_InitWithOptionsPtr>(shared_library_->get_function_pointer("niFake_InitWithOptions"));
    if (niFake_InitWithOptions_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_InitWithOptions");
    }

    ViString resource_name = (ViString)request->resource_name().c_str();
    ViBoolean id_query = request->id_query();
    ViBoolean reset_device = request->reset_device();
    ViConstString option_string = request->option_string().c_str();
    ViSession vi;
    auto status = niFake_InitWithOptions_function(resource_name, id_query, reset_device, option_string, &vi);
    response->set_status(status);
    if (status == 0) {
      response->set_allocated_vi(new ni::hardware::grpc::Session()); // TODO: Go through session_repository_
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MultipleArrayTypes(::grpc::ServerContext* context, const MultipleArrayTypesRequest* request, MultipleArrayTypesResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MultipleArraysSameSize(::grpc::ServerContext* context, const MultipleArraysSameSizeRequest* request, MultipleArraysSameSizeResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::OneInputFunction(::grpc::ServerContext* context, const OneInputFunctionRequest* request, OneInputFunctionResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_OneInputFunction_function = reinterpret_cast<niFake_OneInputFunctionPtr>(shared_library_->get_function_pointer("niFake_OneInputFunction"));
    if (niFake_OneInputFunction_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_OneInputFunction");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViInt32 a_number = request->a_number();
    auto status = niFake_OneInputFunction_function(vi, a_number);
    response->set_status(status);
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ParametersAreMultipleTypes(::grpc::ServerContext* context, const ParametersAreMultipleTypesRequest* request, ParametersAreMultipleTypesResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_ParametersAreMultipleTypes_function = reinterpret_cast<niFake_ParametersAreMultipleTypesPtr>(shared_library_->get_function_pointer("niFake_ParametersAreMultipleTypes"));
    if (niFake_ParametersAreMultipleTypes_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_ParametersAreMultipleTypes");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViBoolean a_boolean = request->a_boolean();
    ViInt32 an_int32 = request->an_int32();
    ViInt64 an_int64 = request->an_int64();
    // TODO: The below would work with integer enums but we need to properly convert non-integer enums to their corresponding values of the correct type.
    // auto an_int_enum = static_cast<ViInt16>(($ViInt16)request->an_int_enum();)
    ViInt16 an_int_enum;
    ViReal64 a_float = request->a_float();
    // TODO: The below would work with integer enums but we need to properly convert non-integer enums to their corresponding values of the correct type.
    // auto a_float_enum = static_cast<ViReal64>(($ViReal64)request->a_float_enum();)
    ViReal64 a_float_enum;
    ViInt32 string_size = request->string_size();
    ViConstString a_string = request->a_string().c_str();
    auto status = niFake_ParametersAreMultipleTypes_function(vi, a_boolean, an_int32, an_int64, an_int_enum, a_float, a_float_enum, string_size, a_string);
    response->set_status(status);
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::PoorlyNamedSimpleFunction(::grpc::ServerContext* context, const PoorlyNamedSimpleFunctionRequest* request, PoorlyNamedSimpleFunctionResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_PoorlyNamedSimpleFunction_function = reinterpret_cast<niFake_PoorlyNamedSimpleFunctionPtr>(shared_library_->get_function_pointer("niFake_PoorlyNamedSimpleFunction"));
    if (niFake_PoorlyNamedSimpleFunction_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_PoorlyNamedSimpleFunction");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    auto status = niFake_PoorlyNamedSimpleFunction_function(vi);
    response->set_status(status);
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::Read(::grpc::ServerContext* context, const ReadRequest* request, ReadResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_Read_function = reinterpret_cast<niFake_ReadPtr>(shared_library_->get_function_pointer("niFake_Read"));
    if (niFake_Read_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_Read");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViReal64 maximum_time = request->maximum_time();
    ViReal64 reading;
    auto status = niFake_Read_function(vi, maximum_time, &reading);
    response->set_status(status);
    if (status == 0) {
      response->set_reading(reading);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReadFromChannel(::grpc::ServerContext* context, const ReadFromChannelRequest* request, ReadFromChannelResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_ReadFromChannel_function = reinterpret_cast<niFake_ReadFromChannelPtr>(shared_library_->get_function_pointer("niFake_ReadFromChannel"));
    if (niFake_ReadFromChannel_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_ReadFromChannel");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViConstString channel_name = request->channel_name().c_str();
    ViInt32 maximum_time = request->maximum_time();
    ViReal64 reading;
    auto status = niFake_ReadFromChannel_function(vi, channel_name, maximum_time, &reading);
    response->set_status(status);
    if (status == 0) {
      response->set_reading(reading);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReturnANumberAndAString(::grpc::ServerContext* context, const ReturnANumberAndAStringRequest* request, ReturnANumberAndAStringResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReturnDurationInSeconds(::grpc::ServerContext* context, const ReturnDurationInSecondsRequest* request, ReturnDurationInSecondsResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_ReturnDurationInSeconds_function = reinterpret_cast<niFake_ReturnDurationInSecondsPtr>(shared_library_->get_function_pointer("niFake_ReturnDurationInSeconds"));
    if (niFake_ReturnDurationInSeconds_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_ReturnDurationInSeconds");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViReal64 timedelta;
    auto status = niFake_ReturnDurationInSeconds_function(vi, &timedelta);
    response->set_status(status);
    if (status == 0) {
      response->set_timedelta(timedelta);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReturnListOfDurationsInSeconds(::grpc::ServerContext* context, const ReturnListOfDurationsInSecondsRequest* request, ReturnListOfDurationsInSecondsResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReturnMultipleTypes(::grpc::ServerContext* context, const ReturnMultipleTypesRequest* request, ReturnMultipleTypesResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::SetCustomType(::grpc::ServerContext* context, const SetCustomTypeRequest* request, SetCustomTypeResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::SetCustomTypeArray(::grpc::ServerContext* context, const SetCustomTypeArrayRequest* request, SetCustomTypeArrayResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::StringValuedEnumInputFunctionWithDefaults(::grpc::ServerContext* context, const StringValuedEnumInputFunctionWithDefaultsRequest* request, StringValuedEnumInputFunctionWithDefaultsResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_StringValuedEnumInputFunctionWithDefaults_function = reinterpret_cast<niFake_StringValuedEnumInputFunctionWithDefaultsPtr>(shared_library_->get_function_pointer("niFake_StringValuedEnumInputFunctionWithDefaults"));
    if (niFake_StringValuedEnumInputFunctionWithDefaults_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_StringValuedEnumInputFunctionWithDefaults");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    // TODO: The below would work with integer enums but we need to properly convert non-integer enums to their corresponding values of the correct type.
    // auto a_mobile_o_s_name = static_cast<ViConstString>(request->a_mobile_o_s_name().c_str();)
    ViConstString a_mobile_o_s_name;
    auto status = niFake_StringValuedEnumInputFunctionWithDefaults_function(vi, a_mobile_o_s_name);
    response->set_status(status);
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::TwoInputFunction(::grpc::ServerContext* context, const TwoInputFunctionRequest* request, TwoInputFunctionResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_TwoInputFunction_function = reinterpret_cast<niFake_TwoInputFunctionPtr>(shared_library_->get_function_pointer("niFake_TwoInputFunction"));
    if (niFake_TwoInputFunction_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_TwoInputFunction");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViReal64 a_number = request->a_number();
    ViString a_string = (ViString)request->a_string().c_str();
    auto status = niFake_TwoInputFunction_function(vi, a_number, a_string);
    response->set_status(status);
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::Use64BitNumber(::grpc::ServerContext* context, const Use64BitNumberRequest* request, Use64BitNumberResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_Use64BitNumber_function = reinterpret_cast<niFake_Use64BitNumberPtr>(shared_library_->get_function_pointer("niFake_Use64BitNumber"));
    if (niFake_Use64BitNumber_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_Use64BitNumber");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    ViInt64 input = request->input();
    ViInt64 output;
    auto status = niFake_Use64BitNumber_function(vi, input, &output);
    response->set_status(status);
    if (status == 0) {
      response->set_output(output);
    }
    return ::grpc::Status::OK;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::WriteWaveform(::grpc::ServerContext* context, const WriteWaveformRequest* request, WriteWaveformResponse* response)
  {
    return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    shared_library_->load();
    if (!shared_library_->is_loaded()) {
      std::string message("The library could not be loaded: ");
      message += driver_api_library_name;
      return ::grpc::Status(::grpc::NOT_FOUND, message.c_str());
    }
    auto niFake_close_function = reinterpret_cast<niFake_closePtr>(shared_library_->get_function_pointer("niFake_close"));
    if (niFake_close_function == nullptr) {
      return ::grpc::Status(::grpc::NOT_FOUND, "The requested function was not found: niFake_close");
    }

    ViSession vi = (request->vi()).id(); // TODO: Go through session_repository_ instead of directly using the id.
    auto status = niFake_close_function(vi);
    response->set_status(status);
    return ::grpc::Status::OK;
  }

} // namespace grpc
} // namespace fake
} // namespace ni
