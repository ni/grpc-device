
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-FAKE Metadata
//---------------------------------------------------------------------
#include "nifake_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <numeric>
#include <server/converters.h>

namespace nifake_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiFakeService::NiFakeService(
      NiFakeLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      const NiFakeFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiFakeService::~NiFakeService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  template <typename TEnum>
  void NiFakeService::CopyBytesToEnums(const std::string& input, google::protobuf::RepeatedField<TEnum>* output)
  {
    for (auto item : input)
    {
      output->Add(item);
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::Abort(::grpc::ServerContext* context, const AbortRequest* request, AbortResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Abort(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::AcceptListOfDurationsInSeconds(::grpc::ServerContext* context, const AcceptListOfDurationsInSecondsRequest* request, AcceptListOfDurationsInSecondsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 count = static_cast<ViInt32>(request->delays().size());
      auto delays = const_cast<ViReal64*>(request->delays().data());
      auto status = library_->AcceptListOfDurationsInSeconds(vi, count, delays);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::AcceptViSessionArray(::grpc::ServerContext* context, const AcceptViSessionArrayRequest* request, AcceptViSessionArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = request->session_count();
      auto session_array_request = request->session_array();
      std::vector<ViSession> session_array;
      std::transform(
        session_array_request.begin(),
        session_array_request.end(),
        std::back_inserter(session_array),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      auto status = library_->AcceptViSessionArray(session_count, session_array.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::AcceptViUInt32Array(::grpc::ServerContext* context, const AcceptViUInt32ArrayRequest* request, AcceptViUInt32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 array_len = static_cast<ViInt32>(request->u_int32_array().size());
      auto u_int32_array = const_cast<ViUInt32*>(reinterpret_cast<const ViUInt32*>(request->u_int32_array().data()));
      auto status = library_->AcceptViUInt32Array(vi, array_len, u_int32_array);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::BoolArrayInputFunction(::grpc::ServerContext* context, const BoolArrayInputFunctionRequest* request, BoolArrayInputFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_of_elements = request->number_of_elements();
      auto an_array = convert_from_grpc<ViBoolean>(request->an_array());
      auto status = library_->BoolArrayInputFunction(vi, number_of_elements, an_array.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::BoolArrayOutputFunction(::grpc::ServerContext* context, const BoolArrayOutputFunctionRequest* request, BoolArrayOutputFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_of_elements = request->number_of_elements();
      std::vector<ViBoolean> an_array(number_of_elements, ViBoolean());
      auto status = library_->BoolArrayOutputFunction(vi, number_of_elements, an_array.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      convert_to_grpc(an_array, response->mutable_an_array());
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      session_repository_->remove_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Close(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::CloseExtCal(::grpc::ServerContext* context, const CloseExtCalRequest* request, CloseExtCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 action = request->action();
      session_repository_->remove_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->CloseExtCal(vi, action);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::CommandWithReservedParam(::grpc::ServerContext* context, const CommandWithReservedParamRequest* request, CommandWithReservedParamResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto reserved = nullptr;
      auto status = library_->CommandWithReservedParam(vi, reserved);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::Control4022(::grpc::ServerContext* context, const Control4022Request* request, Control4022Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViString resource_name = (ViString)request->resource_name().c_str();
      ViInt32 configuration = request->configuration();
      auto status = library_->Control4022(resource_name, configuration);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::CreateConfigurationList(::grpc::ServerContext* context, const CreateConfigurationListRequest* request, CreateConfigurationListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViInt32 number_of_list_attributes = static_cast<ViInt32>(request->list_attribute_ids().size());
      auto list_attribute_ids = const_cast<ViAttr*>(reinterpret_cast<const ViAttr*>(request->list_attribute_ids().data()));
      auto status = library_->CreateConfigurationList(number_of_list_attributes, list_attribute_ids);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::CustomNestedStructRoundtrip(::grpc::ServerContext* context, const CustomNestedStructRoundtripRequest* request, CustomNestedStructRoundtripResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto nested_custom_type_in = convert_from_grpc<CustomStructNestedTypedef_struct>(request->nested_custom_type_in());
      CustomStructNestedTypedef_struct nested_custom_type_out {};
      auto status = library_->CustomNestedStructRoundtrip(nested_custom_type_in, &nested_custom_type_out);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      convert_to_grpc(nested_custom_type_out, response->mutable_nested_custom_type_out());
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::DoubleAllTheNums(::grpc::ServerContext* context, const DoubleAllTheNumsRequest* request, DoubleAllTheNumsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_count = static_cast<ViInt32>(request->numbers().size());
      auto numbers = const_cast<ViReal64*>(request->numbers().data());
      auto status = library_->DoubleAllTheNums(vi, number_count, numbers);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::EnumArrayOutputFunction(::grpc::ServerContext* context, const EnumArrayOutputFunctionRequest* request, EnumArrayOutputFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      return ::grpc::Status(::grpc::UNIMPLEMENTED, "TODO: This server handler has not been implemented.");
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::EnumInputFunctionWithDefaults(::grpc::ServerContext* context, const EnumInputFunctionWithDefaultsRequest* request, EnumInputFunctionWithDefaultsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt16 a_turtle;
      switch (request->a_turtle_enum_case()) {
        case nifake_grpc::EnumInputFunctionWithDefaultsRequest::ATurtleEnumCase::kATurtle: {
          a_turtle = static_cast<ViInt16>(request->a_turtle());
          break;
        }
        case nifake_grpc::EnumInputFunctionWithDefaultsRequest::ATurtleEnumCase::kATurtleRaw: {
          a_turtle = static_cast<ViInt16>(request->a_turtle_raw());
          break;
        }
        case nifake_grpc::EnumInputFunctionWithDefaultsRequest::ATurtleEnumCase::A_TURTLE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for a_turtle was not specified or out of range");
          break;
        }
      }

      auto status = library_->EnumInputFunctionWithDefaults(vi, a_turtle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ExportAttributeConfigurationBuffer(::grpc::ServerContext* context, const ExportAttributeConfigurationBufferRequest* request, ExportAttributeConfigurationBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());

      while (true) {
        auto status = library_->ExportAttributeConfigurationBuffer(vi, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 size_in_bytes = status;

        std::string configuration(size_in_bytes, '\0');
        status = library_->ExportAttributeConfigurationBuffer(vi, size_in_bytes, (ViInt8*)configuration.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size_in_bytes)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_configuration(configuration);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::FetchWaveform(::grpc::ServerContext* context, const FetchWaveformRequest* request, FetchWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_of_samples = request->number_of_samples();
      response->mutable_waveform_data()->Resize(number_of_samples, 0);
      ViReal64* waveform_data = response->mutable_waveform_data()->mutable_data();
      ViInt32 actual_number_of_samples {};
      auto status = library_->FetchWaveform(vi, number_of_samples, waveform_data, &actual_number_of_samples);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_actual_number_of_samples(actual_number_of_samples);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetABoolean(::grpc::ServerContext* context, const GetABooleanRequest* request, GetABooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViBoolean a_boolean {};
      auto status = library_->GetABoolean(vi, &a_boolean);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_a_boolean(a_boolean);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetANumber(::grpc::ServerContext* context, const GetANumberRequest* request, GetANumberResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt16 a_number {};
      auto status = library_->GetANumber(vi, &a_number);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_a_number(a_number);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAStringOfFixedMaximumSize(::grpc::ServerContext* context, const GetAStringOfFixedMaximumSizeRequest* request, GetAStringOfFixedMaximumSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      std::string a_string(256 - 1, '\0');
      auto status = library_->GetAStringOfFixedMaximumSize(vi, (ViChar*)a_string.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_a_string(a_string);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_a_string()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAnIviDanceString(::grpc::ServerContext* context, const GetAnIviDanceStringRequest* request, GetAnIviDanceStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());

      while (true) {
        auto status = library_->GetAnIviDanceString(vi, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string a_string;
        if (buffer_size > 0) {
            a_string.resize(buffer_size - 1);
        }
        status = library_->GetAnIviDanceString(vi, buffer_size, (ViChar*)a_string.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_a_string(a_string);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_a_string()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAnIviDanceWithATwistArray(::grpc::ServerContext* context, const GetAnIviDanceWithATwistArrayRequest* request, GetAnIviDanceWithATwistArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto a_string = request->a_string().c_str();
      ViInt32 actual_size {};
      while (true) {
        auto status = library_->GetAnIviDanceWithATwistArray(vi, a_string, 0, nullptr, &actual_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->mutable_array_out()->Resize(actual_size, 0);
        ViInt32* array_out = reinterpret_cast<ViInt32*>(response->mutable_array_out()->mutable_data());
        auto buffer_size = actual_size;
        status = library_->GetAnIviDanceWithATwistArray(vi, a_string, buffer_size, array_out, &actual_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->mutable_array_out()->Resize(actual_size, 0);
        response->set_actual_size(actual_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAnIviDanceWithATwistArrayOfCustomType(::grpc::ServerContext* context, const GetAnIviDanceWithATwistArrayOfCustomTypeRequest* request, GetAnIviDanceWithATwistArrayOfCustomTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 actual_size {};
      while (true) {
        auto status = library_->GetAnIviDanceWithATwistArrayOfCustomType(vi, 0, nullptr, &actual_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        std::vector<CustomStruct> array_out(actual_size, CustomStruct());
        auto buffer_size = actual_size;
        status = library_->GetAnIviDanceWithATwistArrayOfCustomType(vi, buffer_size, array_out.data(), &actual_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        convert_to_grpc(array_out, response->mutable_array_out());
        {
          auto shrunk_size = actual_size;
          auto current_size = response->mutable_array_out()->size();
          if (shrunk_size != current_size) {
            response->mutable_array_out()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_size(actual_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAnIviDanceWithATwistArrayWithInputArray(::grpc::ServerContext* context, const GetAnIviDanceWithATwistArrayWithInputArrayRequest* request, GetAnIviDanceWithATwistArrayWithInputArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto data_in = const_cast<ViInt32*>(reinterpret_cast<const ViInt32*>(request->data_in().data()));
      ViInt32 array_size_in = static_cast<ViInt32>(request->data_in().size());
      ViInt32 actual_size {};
      while (true) {
        auto status = library_->GetAnIviDanceWithATwistArrayWithInputArray(data_in, array_size_in, 0, nullptr, &actual_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        response->mutable_array_out()->Resize(actual_size, 0);
        ViInt32* array_out = reinterpret_cast<ViInt32*>(response->mutable_array_out()->mutable_data());
        auto buffer_size = actual_size;
        status = library_->GetAnIviDanceWithATwistArrayWithInputArray(data_in, array_size_in, buffer_size, array_out, &actual_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        response->set_status(status);
        response->mutable_array_out()->Resize(actual_size, 0);
        response->set_actual_size(actual_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAnIviDanceWithATwistByteArray(::grpc::ServerContext* context, const GetAnIviDanceWithATwistByteArrayRequest* request, GetAnIviDanceWithATwistByteArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViInt32 actual_size {};
      while (true) {
        auto status = library_->GetAnIviDanceWithATwistByteArray(0, nullptr, &actual_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        std::string array_out(actual_size, '\0');
        auto buffer_size = actual_size;
        status = library_->GetAnIviDanceWithATwistByteArray(buffer_size, (ViInt8*)array_out.data(), &actual_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        response->set_status(status);
        response->set_array_out(array_out);
        response->mutable_array_out()->resize(actual_size);
        response->set_actual_size(actual_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAnIviDanceWithATwistString(::grpc::ServerContext* context, const GetAnIviDanceWithATwistStringRequest* request, GetAnIviDanceWithATwistStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 actual_size {};
      while (true) {
        auto status = library_->GetAnIviDanceWithATwistString(vi, 0, nullptr, &actual_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        std::string a_string;
        if (actual_size > 0) {
            a_string.resize(actual_size - 1);
        }
        auto buffer_size = actual_size;
        status = library_->GetAnIviDanceWithATwistString(vi, buffer_size, (ViChar*)a_string.data(), &actual_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_a_string(a_string);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_a_string()));
        response->set_actual_size(actual_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAnIviDanceWithATwistStringStrlenBug(::grpc::ServerContext* context, const GetAnIviDanceWithATwistStringStrlenBugRequest* request, GetAnIviDanceWithATwistStringStrlenBugResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViInt32 actual_size {};
      while (true) {
        auto status = library_->GetAnIviDanceWithATwistStringStrlenBug(0, nullptr, &actual_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        std::string string_out;
        if (actual_size > 0) {
            string_out.resize(actual_size /* Workaround: strlen-bug */);
        }
        auto buffer_size = actual_size;
        status = library_->GetAnIviDanceWithATwistStringStrlenBug(buffer_size, (ViChar*)string_out.data(), &actual_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        response->set_status(status);
        response->set_string_out(string_out);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_string_out()));
        response->set_actual_size(actual_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetArraySizeForCustomCode(::grpc::ServerContext* context, const GetArraySizeForCustomCodeRequest* request, GetArraySizeForCustomCodeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 size_out {};
      auto status = library_->GetArraySizeForCustomCode(vi, &size_out);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_size_out(size_out);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetArrayUsingIviDance(::grpc::ServerContext* context, const GetArrayUsingIviDanceRequest* request, GetArrayUsingIviDanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());

      while (true) {
        auto status = library_->GetArrayUsingIviDance(vi, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 array_size = status;

        response->mutable_array_out()->Resize(array_size, 0);
        ViReal64* array_out = response->mutable_array_out()->mutable_data();
        status = library_->GetArrayUsingIviDance(vi, array_size, array_out);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(array_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetArrayViUInt8WithEnum(::grpc::ServerContext* context, const GetArrayViUInt8WithEnumRequest* request, GetArrayViUInt8WithEnumResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 array_len = request->array_len();
      std::string u_int8_enum_array(array_len, '\0');
      auto status = library_->GetArrayViUInt8WithEnum(vi, array_len, (ViUInt8*)u_int8_enum_array.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      CopyBytesToEnums(u_int8_enum_array, response->mutable_u_int8_enum_array());
      response->set_u_int8_enum_array_raw(u_int8_enum_array);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViBoolean(::grpc::ServerContext* context, const GetAttributeViBooleanRequest* request, GetAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViBoolean attribute_value {};
      auto status = library_->GetAttributeViBoolean(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViInt32(::grpc::ServerContext* context, const GetAttributeViInt32Request* request, GetAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt32 attribute_value {};
      auto status = library_->GetAttributeViInt32(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViInt64(::grpc::ServerContext* context, const GetAttributeViInt64Request* request, GetAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt64 attribute_value {};
      auto status = library_->GetAttributeViInt64(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViReal64(::grpc::ServerContext* context, const GetAttributeViReal64Request* request, GetAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViReal64 attribute_value {};
      auto status = library_->GetAttributeViReal64(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViSession(::grpc::ServerContext* context, const GetAttributeViSessionRequest* request, GetAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViSession attribute_value {};
      auto status = library_->GetAttributeViSession(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      auto session_id = session_repository_->resolve_session_id(attribute_value);
      response->mutable_attribute_value()->set_id(session_id);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetAttributeViString(::grpc::ServerContext* context, const GetAttributeViStringRequest* request, GetAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute_id = request->attribute_id();

      while (true) {
        auto status = library_->GetAttributeViString(vi, channel_name, attribute_id, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string attribute_value;
        if (buffer_size > 0) {
            attribute_value.resize(buffer_size - 1);
        }
        status = library_->GetAttributeViString(vi, channel_name, attribute_id, buffer_size, (ViChar*)attribute_value.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_attribute_value(attribute_value);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_attribute_value()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetBitfieldAsEnumArray(::grpc::ServerContext* context, const GetBitfieldAsEnumArrayRequest* request, GetBitfieldAsEnumArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViInt64 flags {};
      auto status = library_->GetBitfieldAsEnumArray(&flags);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      if (flags & 0x1)
        response->add_flags_array(Bitfield::BITFIELD_FLAG_A);
      if (flags & 0x2)
        response->add_flags_array(Bitfield::BITFIELD_FLAG_B);
      if (flags & 0x4)
        response->add_flags_array(Bitfield::BITFIELD_FLAG_C);
      if (flags & 0x8)
        response->add_flags_array(Bitfield::BITFIELD_FLAG_D);
      response->set_flags_raw(flags);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetCalDateAndTime(::grpc::ServerContext* context, const GetCalDateAndTimeRequest* request, GetCalDateAndTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 cal_type = request->cal_type();
      ViInt32 month {};
      ViInt32 day {};
      ViInt32 year {};
      ViInt32 hour {};
      ViInt32 minute {};
      auto status = library_->GetCalDateAndTime(vi, cal_type, &month, &day, &year, &hour, &minute);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_month(month);
      response->set_day(day);
      response->set_year(year);
      response->set_hour(hour);
      response->set_minute(minute);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetCalInterval(::grpc::ServerContext* context, const GetCalIntervalRequest* request, GetCalIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 months {};
      auto status = library_->GetCalInterval(vi, &months);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_months(months);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetCustomType(::grpc::ServerContext* context, const GetCustomTypeRequest* request, GetCustomTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      CustomStruct cs {};
      auto status = library_->GetCustomType(vi, &cs);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      convert_to_grpc(cs, response->mutable_cs());
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetCustomTypeArray(::grpc::ServerContext* context, const GetCustomTypeArrayRequest* request, GetCustomTypeArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_of_elements = request->number_of_elements();
      std::vector<CustomStruct> cs(number_of_elements, CustomStruct());
      auto status = library_->GetCustomTypeArray(vi, number_of_elements, cs.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      convert_to_grpc(cs, response->mutable_cs());
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetEnumValue(::grpc::ServerContext* context, const GetEnumValueRequest* request, GetEnumValueResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 a_quantity {};
      ViInt16 a_turtle {};
      auto status = library_->GetEnumValue(vi, &a_quantity, &a_turtle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_a_quantity(a_quantity);
      response->set_a_turtle(static_cast<nifake_grpc::Turtle>(a_turtle));
      response->set_a_turtle_raw(a_turtle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetViInt32Array(::grpc::ServerContext* context, const GetViInt32ArrayRequest* request, GetViInt32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 array_len = request->array_len();
      response->mutable_int32_array()->Resize(array_len, 0);
      ViInt32* int32_array = reinterpret_cast<ViInt32*>(response->mutable_int32_array()->mutable_data());
      auto status = library_->GetViInt32Array(vi, array_len, int32_array);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetViUInt32Array(::grpc::ServerContext* context, const GetViUInt32ArrayRequest* request, GetViUInt32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 array_len = request->array_len();
      response->mutable_u_int32_array()->Resize(array_len, 0);
      ViUInt32* u_int32_array = reinterpret_cast<ViUInt32*>(response->mutable_u_int32_array()->mutable_data());
      auto status = library_->GetViUInt32Array(vi, array_len, u_int32_array);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::GetViUInt8(::grpc::ServerContext* context, const GetViUInt8Request* request, GetViUInt8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViUInt8 a_uint8_number {};
      auto status = library_->GetViUInt8(vi, &a_uint8_number);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_a_uint8_number(a_uint8_number);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ImportAttributeConfigurationBuffer(::grpc::ServerContext* context, const ImportAttributeConfigurationBufferRequest* request, ImportAttributeConfigurationBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 size_in_bytes = static_cast<ViInt32>(request->configuration().size());
      ViInt8* configuration = (ViInt8*)request->configuration().c_str();
      auto status = library_->ImportAttributeConfigurationBuffer(vi, size_in_bytes, configuration);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::InitExtCal(::grpc::ServerContext* context, const InitExtCalRequest* request, InitExtCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViRsrc resource_name = (ViRsrc)request->resource_name().c_str();
      ViString calibration_password = (ViString)request->calibration_password().c_str();

      auto init_lambda = [&] () {
        ViSession vi;
        auto status = library_->InitExtCal(resource_name, calibration_password, &vi);
        return std::make_tuple(status, vi);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->CloseExtCal(id, 0); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->mutable_vi()->set_id(session_id);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::SessionException& ex) {
      return ::grpc::Status(::grpc::INVALID_ARGUMENT, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::InitWithOptions(::grpc::ServerContext* context, const InitWithOptionsRequest* request, InitWithOptionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViString resource_name = (ViString)request->resource_name().c_str();
      ViBoolean id_query = request->id_query();
      ViBoolean reset_device = request->reset_device();
      auto option_string = request->option_string().c_str();

      auto init_lambda = [&] () {
        ViSession vi;
        auto status = library_->InitWithOptions(resource_name, id_query, reset_device, option_string, &vi);
        return std::make_tuple(status, vi);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->mutable_vi()->set_id(session_id);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::SessionException& ex) {
      return ::grpc::Status(::grpc::INVALID_ARGUMENT, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::InitWithVarArgs(::grpc::ServerContext* context, const InitWithVarArgsRequest* request, InitWithVarArgsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViRsrc resource_name = (ViRsrc)request->resource_name().c_str();
      auto get_stringArg_if = [](const google::protobuf::RepeatedPtrField<StringAndTurtle>& vector, int n) -> ViConstString {
            if (vector.size() > n) {
                  return vector[n].string_arg().c_str();
            }
            return nullptr;
      };
      auto get_turtle_if = [](const google::protobuf::RepeatedPtrField<StringAndTurtle>& vector, int n) -> ViInt16 {
            if (vector.size() > n) {
                  return vector[n].turtle();
            }
            return 0;
      };
      auto name_and_turtle = request->name_and_turtle();
      if (name_and_turtle.size() == 0) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "No values for nameAndTurtle were specified");
      }
      if (name_and_turtle.size() > 3) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "More than 3 values for nameAndTurtle were specified");
      }


      auto init_lambda = [&] () {
        ViSession vi;
        auto status = library_->InitWithVarArgs(resource_name, &vi, get_stringArg_if(name_and_turtle, 0), get_turtle_if(name_and_turtle, 0), get_stringArg_if(name_and_turtle, 1), get_turtle_if(name_and_turtle, 1), get_stringArg_if(name_and_turtle, 2), get_turtle_if(name_and_turtle, 2), get_stringArg_if(name_and_turtle, 3), get_turtle_if(name_and_turtle, 3));
        return std::make_tuple(status, vi);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->mutable_vi()->set_id(session_id);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
    catch (nidevice_grpc::SessionException& ex) {
      return ::grpc::Status(::grpc::INVALID_ARGUMENT, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MethodUsingEnumWithGrpcNameValues(::grpc::ServerContext* context, const MethodUsingEnumWithGrpcNameValuesRequest* request, MethodUsingEnumWithGrpcNameValuesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViInt32 using_enum;
      switch (request->using_enum_enum_case()) {
        case nifake_grpc::MethodUsingEnumWithGrpcNameValuesRequest::UsingEnumEnumCase::kUsingEnum: {
          using_enum = static_cast<ViInt32>(request->using_enum());
          break;
        }
        case nifake_grpc::MethodUsingEnumWithGrpcNameValuesRequest::UsingEnumEnumCase::kUsingEnumRaw: {
          using_enum = static_cast<ViInt32>(request->using_enum_raw());
          break;
        }
        case nifake_grpc::MethodUsingEnumWithGrpcNameValuesRequest::UsingEnumEnumCase::USING_ENUM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for using_enum was not specified or out of range");
          break;
        }
      }

      auto status = library_->MethodUsingEnumWithGrpcNameValues(using_enum);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MethodUsingWholeAndFractionalNumbers(::grpc::ServerContext* context, const MethodUsingWholeAndFractionalNumbersRequest* request, MethodUsingWholeAndFractionalNumbersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViInt32 whole_number {};
      ViReal64 fractional_number {};
      auto status = library_->MethodUsingWholeAndFractionalNumbers(&whole_number, &fractional_number);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->set_whole_number(static_cast<nifake_grpc::DecimalWholeNumber>(whole_number));
      response->set_whole_number_raw(whole_number);
      auto fractional_number_omap_it = decimalmixednumber_output_map_.find(fractional_number);
      if(fractional_number_omap_it != decimalmixednumber_output_map_.end()) {
        response->set_fractional_number_mapped(static_cast<nifake_grpc::DecimalMixedNumber>(fractional_number_omap_it->second));
      }
      response->set_fractional_number_raw(fractional_number);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MethodUsingWholeMappedNumbers(::grpc::ServerContext* context, const MethodUsingWholeMappedNumbersRequest* request, MethodUsingWholeMappedNumbersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViReal64 whole_number {};
      auto status = library_->MethodUsingWholeMappedNumbers(&whole_number);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      auto whole_number_omap_it = decimalwholenumbermapped_output_map_.find(whole_number);
      if(whole_number_omap_it != decimalwholenumbermapped_output_map_.end()) {
        response->set_whole_number_mapped(static_cast<nifake_grpc::DecimalWholeNumberMapped>(whole_number_omap_it->second));
      }
      response->set_whole_number_raw(whole_number);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MethodWithGetLastErrorParam(::grpc::ServerContext* context, const MethodWithGetLastErrorParamRequest* request, MethodWithGetLastErrorParamResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto status = library_->MethodWithGetLastErrorParam();
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MethodWithGrpcFieldNumber(::grpc::ServerContext* context, const MethodWithGrpcFieldNumberRequest* request, MethodWithGrpcFieldNumberResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViInt32 attribute_value = request->attribute_value();
      auto status = library_->MethodWithGrpcFieldNumber(attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MethodWithGrpcOnlyParam(::grpc::ServerContext* context, const MethodWithGrpcOnlyParamRequest* request, MethodWithGrpcOnlyParamResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViInt32 simple_param = request->simple_param();
      ViInt32 grpc_only_param {};
      auto status = library_->MethodWithGrpcOnlyParam(simple_param, &grpc_only_param);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->set_grpc_only_param(grpc_only_param);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MultipleArrayTypes(::grpc::ServerContext* context, const MultipleArrayTypesRequest* request, MultipleArrayTypesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 output_array_size = request->output_array_size();
      auto input_array_sizes_determine_from_sizes = std::array<int, 2>
      {
        request->input_array_of_floats_size(),
        request->input_array_of_integers_size()
      };
      const auto input_array_sizes_size_calculation = calculate_linked_array_size(input_array_sizes_determine_from_sizes, false);

      if (input_array_sizes_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [input_array_of_floats, input_array_of_integers] do not match");
      }
      auto input_array_sizes = input_array_sizes_size_calculation.size;

      auto input_array_of_floats = const_cast<ViReal64*>(request->input_array_of_floats().data());
      auto input_array_of_integers_request = request->input_array_of_integers();
      std::vector<ViInt16> input_array_of_integers;
      std::transform(
        input_array_of_integers_request.begin(),
        input_array_of_integers_request.end(),
        std::back_inserter(input_array_of_integers),
        [](auto x) { return (ViInt16)x; }); 
      response->mutable_output_array()->Resize(output_array_size, 0);
      ViReal64* output_array = response->mutable_output_array()->mutable_data();
      response->mutable_output_array_of_fixed_length()->Resize(3, 0);
      ViReal64* output_array_of_fixed_length = response->mutable_output_array_of_fixed_length()->mutable_data();
      auto status = library_->MultipleArrayTypes(vi, output_array_size, output_array, output_array_of_fixed_length, input_array_sizes, input_array_of_floats, input_array_of_integers.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MultipleArraysSameSize(::grpc::ServerContext* context, const MultipleArraysSameSizeRequest* request, MultipleArraysSameSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto values1 = const_cast<ViReal64*>(request->values1().data());
      auto values2 = const_cast<ViReal64*>(request->values2().data());
      auto values3 = const_cast<ViReal64*>(request->values3().data());
      auto values4 = const_cast<ViReal64*>(request->values4().data());
      auto size_determine_from_sizes = std::array<int, 4>
      {
        request->values1_size(),
        request->values2_size(),
        request->values3_size(),
        request->values4_size()
      };
      const auto size_size_calculation = calculate_linked_array_size(size_determine_from_sizes, false);

      if (size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [values1, values2, values3, values4] do not match");
      }
      auto size = size_size_calculation.size;

      auto status = library_->MultipleArraysSameSize(vi, values1, values2, values3, values4, size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::MultipleArraysSameSizeWithOptional(::grpc::ServerContext* context, const MultipleArraysSameSizeWithOptionalRequest* request, MultipleArraysSameSizeWithOptionalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto values1 = const_cast<ViReal64*>(request->values1().data());
      auto values2 = const_cast<ViReal64*>(request->values2().data());
      auto values3 = const_cast<ViReal64*>(request->values3().data());
      auto values4 = const_cast<ViReal64*>(request->values4().data());
      auto values5 = convert_from_grpc<CustomStruct>(request->values5());
      auto size_determine_from_sizes = std::array<int, 5>
      {
        request->values1_size(),
        request->values2_size(),
        request->values3_size(),
        request->values4_size(),
        request->values5_size()
      };
      const auto size_size_calculation = calculate_linked_array_size(size_determine_from_sizes, true);

      if (size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [values1, values2, values3, values4, values5] do not match");
      }
      // NULL out optional params with zero sizes.
      if (size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        values1 = request->values1_size() ? std::move(values1) : nullptr;
        values2 = request->values2_size() ? std::move(values2) : nullptr;
        values3 = request->values3_size() ? std::move(values3) : nullptr;
        values4 = request->values4_size() ? std::move(values4) : nullptr;
        values5 = request->values5_size() ? std::move(values5) : nullptr;
      }
      auto size = size_size_calculation.size;

      auto status = library_->MultipleArraysSameSizeWithOptional(vi, values1, values2, values3, values4, values5.data(), size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::OneInputFunction(::grpc::ServerContext* context, const OneInputFunctionRequest* request, OneInputFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 a_number = request->a_number();
      auto status = library_->OneInputFunction(vi, a_number);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ParametersAreMultipleTypes(::grpc::ServerContext* context, const ParametersAreMultipleTypesRequest* request, ParametersAreMultipleTypesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViBoolean a_boolean = request->a_boolean();
      ViInt32 an_int32 = request->an_int32();
      ViInt64 an_int64 = request->an_int64();
      ViInt16 an_int_enum;
      switch (request->an_int_enum_enum_case()) {
        case nifake_grpc::ParametersAreMultipleTypesRequest::AnIntEnumEnumCase::kAnIntEnum: {
          an_int_enum = static_cast<ViInt16>(request->an_int_enum());
          break;
        }
        case nifake_grpc::ParametersAreMultipleTypesRequest::AnIntEnumEnumCase::kAnIntEnumRaw: {
          an_int_enum = static_cast<ViInt16>(request->an_int_enum_raw());
          break;
        }
        case nifake_grpc::ParametersAreMultipleTypesRequest::AnIntEnumEnumCase::AN_INT_ENUM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for an_int_enum was not specified or out of range");
          break;
        }
      }

      ViReal64 a_float = request->a_float();
      ViReal64 a_float_enum;
      switch (request->a_float_enum_enum_case()) {
        case nifake_grpc::ParametersAreMultipleTypesRequest::AFloatEnumEnumCase::kAFloatEnumMapped: {
          auto a_float_enum_imap_it = floatenum_input_map_.find(request->a_float_enum_mapped());
          if (a_float_enum_imap_it == floatenum_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for a_float_enum_mapped was not specified or out of range.");
          }
          a_float_enum = static_cast<ViReal64>(a_float_enum_imap_it->second);
          break;
        }
        case nifake_grpc::ParametersAreMultipleTypesRequest::AFloatEnumEnumCase::kAFloatEnumRaw: {
          a_float_enum = static_cast<ViReal64>(request->a_float_enum_raw());
          break;
        }
        case nifake_grpc::ParametersAreMultipleTypesRequest::AFloatEnumEnumCase::A_FLOAT_ENUM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for a_float_enum was not specified or out of range");
          break;
        }
      }

      ViInt32 string_size = static_cast<ViInt32>(request->a_string().size());
      auto a_string = request->a_string().c_str();
      auto status = library_->ParametersAreMultipleTypes(vi, a_boolean, an_int32, an_int64, an_int_enum, a_float, a_float_enum, string_size, a_string);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::PoorlyNamedSimpleFunction(::grpc::ServerContext* context, const PoorlyNamedSimpleFunctionRequest* request, PoorlyNamedSimpleFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->PoorlyNamedSimpleFunction(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::Read(::grpc::ServerContext* context, const ReadRequest* request, ReadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViReal64 maximum_time = request->maximum_time();
      ViReal64 reading {};
      auto status = library_->Read(vi, maximum_time, &reading);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_reading(reading);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReadDataWithInOutIviTwist(::grpc::ServerContext* context, const ReadDataWithInOutIviTwistRequest* request, ReadDataWithInOutIviTwistResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViInt32 buffer_size {};
      while (true) {
        auto status = library_->ReadDataWithInOutIviTwist(nullptr, &buffer_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        response->mutable_data()->Resize(buffer_size, 0);
        ViInt32* data = reinterpret_cast<ViInt32*>(response->mutable_data()->mutable_data());
        status = library_->ReadDataWithInOutIviTwist(data, &buffer_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        response->set_status(status);
        response->mutable_data()->Resize(buffer_size, 0);
        response->set_buffer_size(buffer_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReadDataWithMultipleIviTwistParamSets(::grpc::ServerContext* context, const ReadDataWithMultipleIviTwistParamSetsRequest* request, ReadDataWithMultipleIviTwistParamSetsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViInt32 actual_size {};
      ViInt32 other_actual_size {};
      while (true) {
        auto status = library_->ReadDataWithMultipleIviTwistParamSets(0, nullptr, &actual_size, 0, nullptr, &other_actual_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        response->mutable_array_out()->Resize(actual_size, 0);
        ViInt32* array_out = reinterpret_cast<ViInt32*>(response->mutable_array_out()->mutable_data());
        response->mutable_other_array_out()->Resize(other_actual_size, 0);
        ViInt32* other_array_out = reinterpret_cast<ViInt32*>(response->mutable_other_array_out()->mutable_data());
        auto buffer_size = actual_size;
        auto other_buffer_size = other_actual_size;
        status = library_->ReadDataWithMultipleIviTwistParamSets(buffer_size, array_out, &actual_size, other_buffer_size, other_array_out, &other_actual_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        response->set_status(status);
        response->mutable_array_out()->Resize(actual_size, 0);
        response->set_actual_size(actual_size);
        response->mutable_other_array_out()->Resize(other_actual_size, 0);
        response->set_other_actual_size(other_actual_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReadFromChannel(::grpc::ServerContext* context, const ReadFromChannelRequest* request, ReadFromChannelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViInt32 maximum_time = request->maximum_time();
      ViReal64 reading {};
      auto status = library_->ReadFromChannel(vi, channel_name, maximum_time, &reading);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_reading(reading);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReturnANumberAndAString(::grpc::ServerContext* context, const ReturnANumberAndAStringRequest* request, ReturnANumberAndAStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt16 a_number {};
      std::string a_string(256 - 1, '\0');
      auto status = library_->ReturnANumberAndAString(vi, &a_number, (ViChar*)a_string.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_a_number(a_number);
      response->set_a_string(a_string);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_a_string()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReturnDurationInSeconds(::grpc::ServerContext* context, const ReturnDurationInSecondsRequest* request, ReturnDurationInSecondsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViReal64 timedelta {};
      auto status = library_->ReturnDurationInSeconds(vi, &timedelta);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_timedelta(timedelta);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReturnListOfDurationsInSeconds(::grpc::ServerContext* context, const ReturnListOfDurationsInSecondsRequest* request, ReturnListOfDurationsInSecondsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_of_elements = request->number_of_elements();
      response->mutable_timedeltas()->Resize(number_of_elements, 0);
      ViReal64* timedeltas = response->mutable_timedeltas()->mutable_data();
      auto status = library_->ReturnListOfDurationsInSeconds(vi, number_of_elements, timedeltas);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ReturnMultipleTypes(::grpc::ServerContext* context, const ReturnMultipleTypesRequest* request, ReturnMultipleTypesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 array_size = request->array_size();

      while (true) {
        auto status = library_->ReturnMultipleTypes(vi, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0, nullptr, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 string_size = status;

        ViBoolean a_boolean {};
        ViInt32 an_int32 {};
        ViInt64 an_int64 {};
        ViInt16 an_int_enum {};
        ViReal64 a_float {};
        ViReal64 a_float_enum {};
        response->mutable_an_array()->Resize(array_size, 0);
        ViReal64* an_array = response->mutable_an_array()->mutable_data();
        std::string a_string;
        if (string_size > 0) {
            a_string.resize(string_size - 1);
        }
        status = library_->ReturnMultipleTypes(vi, &a_boolean, &an_int32, &an_int64, &an_int_enum, &a_float, &a_float_enum, array_size, an_array, string_size, (ViChar*)a_string.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(string_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_a_boolean(a_boolean);
        response->set_an_int32(an_int32);
        response->set_an_int64(an_int64);
        response->set_an_int_enum(static_cast<nifake_grpc::Turtle>(an_int_enum));
        response->set_an_int_enum_raw(an_int_enum);
        response->set_a_float(a_float);
        auto a_float_enum_omap_it = floatenum_output_map_.find(a_float_enum);
        if(a_float_enum_omap_it != floatenum_output_map_.end()) {
          response->set_a_float_enum_mapped(static_cast<nifake_grpc::FloatEnum>(a_float_enum_omap_it->second));
        }
        response->set_a_float_enum_raw(a_float_enum);
        response->set_a_string(a_string);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_a_string()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::SetCustomType(::grpc::ServerContext* context, const SetCustomTypeRequest* request, SetCustomTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto cs = convert_from_grpc<CustomStruct>(request->cs());
      auto status = library_->SetCustomType(vi, cs);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::SetCustomTypeArray(::grpc::ServerContext* context, const SetCustomTypeArrayRequest* request, SetCustomTypeArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_of_elements = static_cast<ViInt32>(request->cs().size());
      auto cs = convert_from_grpc<CustomStruct>(request->cs());
      auto status = library_->SetCustomTypeArray(vi, number_of_elements, cs.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::StringValuedEnumInputFunctionWithDefaults(::grpc::ServerContext* context, const StringValuedEnumInputFunctionWithDefaultsRequest* request, StringValuedEnumInputFunctionWithDefaultsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViConstString a_mobile_os_name;
      switch (request->a_mobile_os_name_enum_case()) {
        case nifake_grpc::StringValuedEnumInputFunctionWithDefaultsRequest::AMobileOsNameEnumCase::kAMobileOsNameMapped: {
          auto a_mobile_os_name_imap_it = mobileosnames_input_map_.find(request->a_mobile_os_name_mapped());
          if (a_mobile_os_name_imap_it == mobileosnames_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for a_mobile_os_name_mapped was not specified or out of range.");
          }
          a_mobile_os_name = const_cast<ViConstString>((a_mobile_os_name_imap_it->second).c_str());
          break;
        }
        case nifake_grpc::StringValuedEnumInputFunctionWithDefaultsRequest::AMobileOsNameEnumCase::kAMobileOsNameRaw: {
          a_mobile_os_name = const_cast<ViConstString>(request->a_mobile_os_name_raw().c_str());
          break;
        }
        case nifake_grpc::StringValuedEnumInputFunctionWithDefaultsRequest::AMobileOsNameEnumCase::A_MOBILE_OS_NAME_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for a_mobile_os_name was not specified or out of range");
          break;
        }
      }

      auto status = library_->StringValuedEnumInputFunctionWithDefaults(vi, a_mobile_os_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::TwoInputFunction(::grpc::ServerContext* context, const TwoInputFunctionRequest* request, TwoInputFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViReal64 a_number = request->a_number();
      ViString a_string = (ViString)request->a_string().c_str();
      auto status = library_->TwoInputFunction(vi, a_number, a_string);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::Use64BitNumber(::grpc::ServerContext* context, const Use64BitNumberRequest* request, Use64BitNumberResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt64 input = request->input();
      ViInt64 output {};
      auto status = library_->Use64BitNumber(vi, input, &output);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_output(output);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::UseATwoDimensionParameter(::grpc::ServerContext* context, const UseATwoDimensionParameterRequest* request, UseATwoDimensionParameterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto array = const_cast<ViInt32*>(reinterpret_cast<const ViInt32*>(request->array().data()));
      auto total_length = std::accumulate(request->array_lengths().cbegin(), request->array_lengths().cend(), 0);

      if (total_length != request->array_size()) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The total size of the two-dimensional array array does not match the expected size from the sum of array_lengths");
      }

      auto array_lengths = const_cast<ViInt32*>(reinterpret_cast<const ViInt32*>(request->array_lengths().data()));
      ViInt32 array_size = static_cast<ViInt32>(request->array_lengths().size());
      auto status = library_->UseATwoDimensionParameter(vi, array, array_lengths, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ViInt16ArrayInputFunction(::grpc::ServerContext* context, const ViInt16ArrayInputFunctionRequest* request, ViInt16ArrayInputFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_of_elements = static_cast<ViInt32>(request->an_array().size());
      auto an_array_request = request->an_array();
      std::vector<ViInt16> an_array;
      std::transform(
        an_array_request.begin(),
        an_array_request.end(),
        std::back_inserter(an_array),
        [](auto x) { return (ViInt16)x; }); 
      auto status = library_->ViInt16ArrayInputFunction(vi, number_of_elements, an_array.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ViUInt8ArrayInputFunction(::grpc::ServerContext* context, const ViUInt8ArrayInputFunctionRequest* request, ViUInt8ArrayInputFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_of_elements = request->number_of_elements();
      ViUInt8* an_array = (ViUInt8*)request->an_array().c_str();
      auto status = library_->ViUInt8ArrayInputFunction(vi, number_of_elements, an_array);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::ViUInt8ArrayOutputFunction(::grpc::ServerContext* context, const ViUInt8ArrayOutputFunctionRequest* request, ViUInt8ArrayOutputFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_of_elements = request->number_of_elements();
      std::string an_array(number_of_elements, '\0');
      auto status = library_->ViUInt8ArrayOutputFunction(vi, number_of_elements, (ViUInt8*)an_array.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_an_array(an_array);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFakeService::WriteWaveform(::grpc::ServerContext* context, const WriteWaveformRequest* request, WriteWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 number_of_samples = static_cast<ViInt32>(request->waveform().size());
      auto waveform = const_cast<ViReal64*>(request->waveform().data());
      auto status = library_->WriteWaveform(vi, number_of_samples, waveform);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  NiFakeFeatureToggles::NiFakeFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nifake", CodeReadiness::kRelease))
  {
  }
} // namespace nifake_grpc

namespace nidevice_grpc {
namespace converters {
template <>
void convert_to_grpc(const CustomStruct& input, nifake_grpc::FakeCustomStruct* output) 
{
  output->set_struct_int(input.structInt);
  output->set_struct_double(input.structDouble);
}

template <>
CustomStruct convert_from_grpc(const nifake_grpc::FakeCustomStruct& input) 
{
  auto output = CustomStruct();  
  output.structInt = input.struct_int();
  output.structDouble = input.struct_double();
  return output;
}

template <>
void convert_to_grpc(const CustomStructNestedTypedef_struct& input, nifake_grpc::CustomStructNestedTypedef* output) 
{
  convert_to_grpc(input.structCustomStruct, output->mutable_struct_custom_struct());
  convert_to_grpc(input.structCustomStructTypedef, output->mutable_struct_custom_struct_typedef());
}

template <>
CustomStructNestedTypedef_struct convert_from_grpc(const nifake_grpc::CustomStructNestedTypedef& input) 
{
  auto output = CustomStructNestedTypedef_struct();  
  output.structCustomStruct = convert_from_grpc<CustomStruct>(input.struct_custom_struct());
  output.structCustomStructTypedef = convert_from_grpc<CustomStructTypedef_struct>(input.struct_custom_struct_typedef());
  return output;
}

template <>
void convert_to_grpc(const CustomStructTypedef_struct& input, nifake_grpc::CustomStructTypedef* output) 
{
  output->set_struct_int(input.structInt);
  output->set_struct_double(input.structDouble);
}

template <>
CustomStructTypedef_struct convert_from_grpc(const nifake_grpc::CustomStructTypedef& input) 
{
  auto output = CustomStructTypedef_struct();  
  output.structInt = input.struct_int();
  output.structDouble = input.struct_double();
  return output;
}

} // converters
} // nidevice_grpc

