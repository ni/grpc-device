
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// EXPERIMENTAL Client convenience wrapper for NI-RFMXLTE.
//---------------------------------------------------------------------
#include "nirfmxlte_client.h"

#include <grpcpp/grpcpp.h>

#include <nirfmxlte.grpc.pb.h>

#include <cstdint>
#include <memory>
#include <stdexcept>
#include <vector>

namespace nirfmxlte_grpc::experimental::client {

ACPCfgAveragingResponse
acp_cfg_averaging(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AcpAveragingEnabled, pb::int32>& averaging_enabled, const pb::int32& averaging_count, const simple_variant<AcpAveragingType, pb::int32>& averaging_type)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgAveragingRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto averaging_enabled_ptr = averaging_enabled.get_if<AcpAveragingEnabled>();
  const auto averaging_enabled_raw_ptr = averaging_enabled.get_if<pb::int32>();
  if (averaging_enabled_ptr) {
    request.set_averaging_enabled(*averaging_enabled_ptr);
  }
  else if (averaging_enabled_raw_ptr) {
    request.set_averaging_enabled_raw(*averaging_enabled_raw_ptr);
  }
  request.set_averaging_count(averaging_count);
  const auto averaging_type_ptr = averaging_type.get_if<AcpAveragingType>();
  const auto averaging_type_raw_ptr = averaging_type.get_if<pb::int32>();
  if (averaging_type_ptr) {
    request.set_averaging_type(*averaging_type_ptr);
  }
  else if (averaging_type_raw_ptr) {
    request.set_averaging_type_raw(*averaging_type_raw_ptr);
  }

  auto response = ACPCfgAveragingResponse{};

  raise_if_error(
      stub->ACPCfgAveraging(&context, request, &response),
      context);

  return response;
}

ACPCfgConfigurableNumberOfOffsetsEnabledResponse
acp_cfg_configurable_number_of_offsets_enabled(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AcpConfigurableNumberOfOffsetsEnabled, pb::int32>& configurable_number_of_offsets_enabled)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgConfigurableNumberOfOffsetsEnabledRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto configurable_number_of_offsets_enabled_ptr = configurable_number_of_offsets_enabled.get_if<AcpConfigurableNumberOfOffsetsEnabled>();
  const auto configurable_number_of_offsets_enabled_raw_ptr = configurable_number_of_offsets_enabled.get_if<pb::int32>();
  if (configurable_number_of_offsets_enabled_ptr) {
    request.set_configurable_number_of_offsets_enabled(*configurable_number_of_offsets_enabled_ptr);
  }
  else if (configurable_number_of_offsets_enabled_raw_ptr) {
    request.set_configurable_number_of_offsets_enabled_raw(*configurable_number_of_offsets_enabled_raw_ptr);
  }

  auto response = ACPCfgConfigurableNumberOfOffsetsEnabledResponse{};

  raise_if_error(
      stub->ACPCfgConfigurableNumberOfOffsetsEnabled(&context, request, &response),
      context);

  return response;
}

ACPCfgMeasurementMethodResponse
acp_cfg_measurement_method(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AcpMeasurementMethod, pb::int32>& measurement_method)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgMeasurementMethodRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto measurement_method_ptr = measurement_method.get_if<AcpMeasurementMethod>();
  const auto measurement_method_raw_ptr = measurement_method.get_if<pb::int32>();
  if (measurement_method_ptr) {
    request.set_measurement_method(*measurement_method_ptr);
  }
  else if (measurement_method_raw_ptr) {
    request.set_measurement_method_raw(*measurement_method_raw_ptr);
  }

  auto response = ACPCfgMeasurementMethodResponse{};

  raise_if_error(
      stub->ACPCfgMeasurementMethod(&context, request, &response),
      context);

  return response;
}

ACPCfgNoiseCompensationEnabledResponse
acp_cfg_noise_compensation_enabled(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AcpNoiseCompensationEnabled, pb::int32>& noise_compensation_enabled)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgNoiseCompensationEnabledRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto noise_compensation_enabled_ptr = noise_compensation_enabled.get_if<AcpNoiseCompensationEnabled>();
  const auto noise_compensation_enabled_raw_ptr = noise_compensation_enabled.get_if<pb::int32>();
  if (noise_compensation_enabled_ptr) {
    request.set_noise_compensation_enabled(*noise_compensation_enabled_ptr);
  }
  else if (noise_compensation_enabled_raw_ptr) {
    request.set_noise_compensation_enabled_raw(*noise_compensation_enabled_raw_ptr);
  }

  auto response = ACPCfgNoiseCompensationEnabledResponse{};

  raise_if_error(
      stub->ACPCfgNoiseCompensationEnabled(&context, request, &response),
      context);

  return response;
}

ACPCfgNumberOfEUTRAOffsetsResponse
acp_cfg_number_of_eutra_offsets(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_eutra_offsets)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgNumberOfEUTRAOffsetsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_eutra_offsets(number_of_eutra_offsets);

  auto response = ACPCfgNumberOfEUTRAOffsetsResponse{};

  raise_if_error(
      stub->ACPCfgNumberOfEUTRAOffsets(&context, request, &response),
      context);

  return response;
}

ACPCfgNumberOfGSMOffsetsResponse
acp_cfg_number_of_gsm_offsets(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_gsm_offsets)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgNumberOfGSMOffsetsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_gsm_offsets(number_of_gsm_offsets);

  auto response = ACPCfgNumberOfGSMOffsetsResponse{};

  raise_if_error(
      stub->ACPCfgNumberOfGSMOffsets(&context, request, &response),
      context);

  return response;
}

ACPCfgNumberOfUTRAOffsetsResponse
acp_cfg_number_of_utra_offsets(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_utra_offsets)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgNumberOfUTRAOffsetsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_utra_offsets(number_of_utra_offsets);

  auto response = ACPCfgNumberOfUTRAOffsetsResponse{};

  raise_if_error(
      stub->ACPCfgNumberOfUTRAOffsets(&context, request, &response),
      context);

  return response;
}

ACPCfgPowerUnitsResponse
acp_cfg_power_units(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AcpPowerUnits, pb::int32>& power_units)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgPowerUnitsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto power_units_ptr = power_units.get_if<AcpPowerUnits>();
  const auto power_units_raw_ptr = power_units.get_if<pb::int32>();
  if (power_units_ptr) {
    request.set_power_units(*power_units_ptr);
  }
  else if (power_units_raw_ptr) {
    request.set_power_units_raw(*power_units_raw_ptr);
  }

  auto response = ACPCfgPowerUnitsResponse{};

  raise_if_error(
      stub->ACPCfgPowerUnits(&context, request, &response),
      context);

  return response;
}

ACPCfgRBWFilterResponse
acp_cfg_rbw_filter(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AcpRbwAutoBandwidth, pb::int32>& rbw_auto, const double& rbw, const simple_variant<AcpRbwFilterType, pb::int32>& rbw_filter_type)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgRBWFilterRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto rbw_auto_ptr = rbw_auto.get_if<AcpRbwAutoBandwidth>();
  const auto rbw_auto_raw_ptr = rbw_auto.get_if<pb::int32>();
  if (rbw_auto_ptr) {
    request.set_rbw_auto(*rbw_auto_ptr);
  }
  else if (rbw_auto_raw_ptr) {
    request.set_rbw_auto_raw(*rbw_auto_raw_ptr);
  }
  request.set_rbw(rbw);
  const auto rbw_filter_type_ptr = rbw_filter_type.get_if<AcpRbwFilterType>();
  const auto rbw_filter_type_raw_ptr = rbw_filter_type.get_if<pb::int32>();
  if (rbw_filter_type_ptr) {
    request.set_rbw_filter_type(*rbw_filter_type_ptr);
  }
  else if (rbw_filter_type_raw_ptr) {
    request.set_rbw_filter_type_raw(*rbw_filter_type_raw_ptr);
  }

  auto response = ACPCfgRBWFilterResponse{};

  raise_if_error(
      stub->ACPCfgRBWFilter(&context, request, &response),
      context);

  return response;
}

ACPCfgSweepTimeResponse
acp_cfg_sweep_time(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AcpSweepTimeAuto, pb::int32>& sweep_time_auto, const double& sweep_time_interval)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgSweepTimeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto sweep_time_auto_ptr = sweep_time_auto.get_if<AcpSweepTimeAuto>();
  const auto sweep_time_auto_raw_ptr = sweep_time_auto.get_if<pb::int32>();
  if (sweep_time_auto_ptr) {
    request.set_sweep_time_auto(*sweep_time_auto_ptr);
  }
  else if (sweep_time_auto_raw_ptr) {
    request.set_sweep_time_auto_raw(*sweep_time_auto_raw_ptr);
  }
  request.set_sweep_time_interval(sweep_time_interval);

  auto response = ACPCfgSweepTimeResponse{};

  raise_if_error(
      stub->ACPCfgSweepTime(&context, request, &response),
      context);

  return response;
}

ACPCfgUTRAAndEUTRAOffsetsResponse
acp_cfg_utra_and_eutra_offsets(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_utra_offsets, const pb::int32& number_of_eutra_offsets)
{
  ::grpc::ClientContext context;

  auto request = ACPCfgUTRAAndEUTRAOffsetsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_utra_offsets(number_of_utra_offsets);
  request.set_number_of_eutra_offsets(number_of_eutra_offsets);

  auto response = ACPCfgUTRAAndEUTRAOffsetsResponse{};

  raise_if_error(
      stub->ACPCfgUTRAAndEUTRAOffsets(&context, request, &response),
      context);

  return response;
}

ACPFetchAbsolutePowersTraceResponse
acp_fetch_absolute_powers_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout, const pb::int32& trace_index)
{
  ::grpc::ClientContext context;

  auto request = ACPFetchAbsolutePowersTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);
  request.set_trace_index(trace_index);

  auto response = ACPFetchAbsolutePowersTraceResponse{};

  raise_if_error(
      stub->ACPFetchAbsolutePowersTrace(&context, request, &response),
      context);

  return response;
}

ACPFetchComponentCarrierMeasurementResponse
acp_fetch_component_carrier_measurement(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ACPFetchComponentCarrierMeasurementRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ACPFetchComponentCarrierMeasurementResponse{};

  raise_if_error(
      stub->ACPFetchComponentCarrierMeasurement(&context, request, &response),
      context);

  return response;
}

ACPFetchComponentCarrierMeasurementArrayResponse
acp_fetch_component_carrier_measurement_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ACPFetchComponentCarrierMeasurementArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ACPFetchComponentCarrierMeasurementArrayResponse{};

  raise_if_error(
      stub->ACPFetchComponentCarrierMeasurementArray(&context, request, &response),
      context);

  return response;
}

ACPFetchOffsetMeasurementResponse
acp_fetch_offset_measurement(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ACPFetchOffsetMeasurementRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ACPFetchOffsetMeasurementResponse{};

  raise_if_error(
      stub->ACPFetchOffsetMeasurement(&context, request, &response),
      context);

  return response;
}

ACPFetchOffsetMeasurementArrayResponse
acp_fetch_offset_measurement_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ACPFetchOffsetMeasurementArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ACPFetchOffsetMeasurementArrayResponse{};

  raise_if_error(
      stub->ACPFetchOffsetMeasurementArray(&context, request, &response),
      context);

  return response;
}

ACPFetchRelativePowersTraceResponse
acp_fetch_relative_powers_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout, const pb::int32& trace_index)
{
  ::grpc::ClientContext context;

  auto request = ACPFetchRelativePowersTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);
  request.set_trace_index(trace_index);

  auto response = ACPFetchRelativePowersTraceResponse{};

  raise_if_error(
      stub->ACPFetchRelativePowersTrace(&context, request, &response),
      context);

  return response;
}

ACPFetchSpectrumResponse
acp_fetch_spectrum(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ACPFetchSpectrumRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ACPFetchSpectrumResponse{};

  raise_if_error(
      stub->ACPFetchSpectrum(&context, request, &response),
      context);

  return response;
}

ACPFetchSubblockMeasurementResponse
acp_fetch_subblock_measurement(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ACPFetchSubblockMeasurementRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ACPFetchSubblockMeasurementResponse{};

  raise_if_error(
      stub->ACPFetchSubblockMeasurement(&context, request, &response),
      context);

  return response;
}

ACPFetchTotalAggregatedPowerResponse
acp_fetch_total_aggregated_power(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ACPFetchTotalAggregatedPowerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ACPFetchTotalAggregatedPowerResponse{};

  raise_if_error(
      stub->ACPFetchTotalAggregatedPower(&context, request, &response),
      context);

  return response;
}

ACPValidateNoiseCalibrationDataResponse
acp_validate_noise_calibration_data(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = ACPValidateNoiseCalibrationDataRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = ACPValidateNoiseCalibrationDataResponse{};

  raise_if_error(
      stub->ACPValidateNoiseCalibrationData(&context, request, &response),
      context);

  return response;
}

AbortMeasurementsResponse
abort_measurements(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = AbortMeasurementsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = AbortMeasurementsResponse{};

  raise_if_error(
      stub->AbortMeasurements(&context, request, &response),
      context);

  return response;
}

AnalyzeIQ1WaveformResponse
analyze_iq1_waveform(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::string& result_name, const double& x0, const double& dx, const std::vector<nidevice_grpc::NIComplexNumberF32>& iq, const pb::int32& reset)
{
  ::grpc::ClientContext context;

  auto request = AnalyzeIQ1WaveformRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_result_name(result_name);
  request.set_x0(x0);
  request.set_dx(dx);
  copy_array(iq, request.mutable_iq());
  request.set_reset(reset);

  auto response = AnalyzeIQ1WaveformResponse{};

  raise_if_error(
      stub->AnalyzeIQ1Waveform(&context, request, &response),
      context);

  return response;
}

AnalyzeSpectrum1WaveformResponse
analyze_spectrum1_waveform(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::string& result_name, const double& x0, const double& dx, const std::vector<float>& spectrum, const pb::int32& reset)
{
  ::grpc::ClientContext context;

  auto request = AnalyzeSpectrum1WaveformRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_result_name(result_name);
  request.set_x0(x0);
  request.set_dx(dx);
  copy_array(spectrum, request.mutable_spectrum());
  request.set_reset(reset);

  auto response = AnalyzeSpectrum1WaveformResponse{};

  raise_if_error(
      stub->AnalyzeSpectrum1Waveform(&context, request, &response),
      context);

  return response;
}

AutoLevelResponse
auto_level(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& measurement_interval)
{
  ::grpc::ClientContext context;

  auto request = AutoLevelRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_measurement_interval(measurement_interval);

  auto response = AutoLevelResponse{};

  raise_if_error(
      stub->AutoLevel(&context, request, &response),
      context);

  return response;
}

BuildCarrierStringResponse
build_carrier_string(const StubPtr& stub, const pb::string& selector_string, const pb::int32& carrier_number)
{
  ::grpc::ClientContext context;

  auto request = BuildCarrierStringRequest{};
  request.set_selector_string(selector_string);
  request.set_carrier_number(carrier_number);

  auto response = BuildCarrierStringResponse{};

  raise_if_error(
      stub->BuildCarrierString(&context, request, &response),
      context);

  return response;
}

BuildClusterStringResponse
build_cluster_string(const StubPtr& stub, const pb::string& selector_string, const pb::int32& cluster_number)
{
  ::grpc::ClientContext context;

  auto request = BuildClusterStringRequest{};
  request.set_selector_string(selector_string);
  request.set_cluster_number(cluster_number);

  auto response = BuildClusterStringResponse{};

  raise_if_error(
      stub->BuildClusterString(&context, request, &response),
      context);

  return response;
}

BuildOffsetStringResponse
build_offset_string(const StubPtr& stub, const pb::string& selector_string, const pb::int32& offset_number)
{
  ::grpc::ClientContext context;

  auto request = BuildOffsetStringRequest{};
  request.set_selector_string(selector_string);
  request.set_offset_number(offset_number);

  auto response = BuildOffsetStringResponse{};

  raise_if_error(
      stub->BuildOffsetString(&context, request, &response),
      context);

  return response;
}

BuildPDSCHStringResponse
build_pdsch_string(const StubPtr& stub, const pb::string& selector_string, const pb::int32& pdsch_number)
{
  ::grpc::ClientContext context;

  auto request = BuildPDSCHStringRequest{};
  request.set_selector_string(selector_string);
  request.set_pdsch_number(pdsch_number);

  auto response = BuildPDSCHStringResponse{};

  raise_if_error(
      stub->BuildPDSCHString(&context, request, &response),
      context);

  return response;
}

BuildSignalStringResponse
build_signal_string(const StubPtr& stub, const pb::string& signal_name, const pb::string& result_name)
{
  ::grpc::ClientContext context;

  auto request = BuildSignalStringRequest{};
  request.set_signal_name(signal_name);
  request.set_result_name(result_name);

  auto response = BuildSignalStringResponse{};

  raise_if_error(
      stub->BuildSignalString(&context, request, &response),
      context);

  return response;
}

BuildSubblockStringResponse
build_subblock_string(const StubPtr& stub, const pb::string& selector_string, const pb::int32& subblock_number)
{
  ::grpc::ClientContext context;

  auto request = BuildSubblockStringRequest{};
  request.set_selector_string(selector_string);
  request.set_subblock_number(subblock_number);

  auto response = BuildSubblockStringResponse{};

  raise_if_error(
      stub->BuildSubblockString(&context, request, &response),
      context);

  return response;
}

BuildSubframeStringResponse
build_subframe_string(const StubPtr& stub, const pb::string& selector_string, const pb::int32& subframe_number)
{
  ::grpc::ClientContext context;

  auto request = BuildSubframeStringRequest{};
  request.set_selector_string(selector_string);
  request.set_subframe_number(subframe_number);

  auto response = BuildSubframeStringResponse{};

  raise_if_error(
      stub->BuildSubframeString(&context, request, &response),
      context);

  return response;
}

CHPCfgAveragingResponse
chp_cfg_averaging(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ChpAveragingEnabled, pb::int32>& averaging_enabled, const pb::int32& averaging_count, const simple_variant<ChpAveragingType, pb::int32>& averaging_type)
{
  ::grpc::ClientContext context;

  auto request = CHPCfgAveragingRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto averaging_enabled_ptr = averaging_enabled.get_if<ChpAveragingEnabled>();
  const auto averaging_enabled_raw_ptr = averaging_enabled.get_if<pb::int32>();
  if (averaging_enabled_ptr) {
    request.set_averaging_enabled(*averaging_enabled_ptr);
  }
  else if (averaging_enabled_raw_ptr) {
    request.set_averaging_enabled_raw(*averaging_enabled_raw_ptr);
  }
  request.set_averaging_count(averaging_count);
  const auto averaging_type_ptr = averaging_type.get_if<ChpAveragingType>();
  const auto averaging_type_raw_ptr = averaging_type.get_if<pb::int32>();
  if (averaging_type_ptr) {
    request.set_averaging_type(*averaging_type_ptr);
  }
  else if (averaging_type_raw_ptr) {
    request.set_averaging_type_raw(*averaging_type_raw_ptr);
  }

  auto response = CHPCfgAveragingResponse{};

  raise_if_error(
      stub->CHPCfgAveraging(&context, request, &response),
      context);

  return response;
}

CHPCfgIntegrationBandwidthTypeResponse
chp_cfg_integration_bandwidth_type(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ChpIntegrationBandwidthType, pb::int32>& integration_bandwidth_type)
{
  ::grpc::ClientContext context;

  auto request = CHPCfgIntegrationBandwidthTypeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto integration_bandwidth_type_ptr = integration_bandwidth_type.get_if<ChpIntegrationBandwidthType>();
  const auto integration_bandwidth_type_raw_ptr = integration_bandwidth_type.get_if<pb::int32>();
  if (integration_bandwidth_type_ptr) {
    request.set_integration_bandwidth_type(*integration_bandwidth_type_ptr);
  }
  else if (integration_bandwidth_type_raw_ptr) {
    request.set_integration_bandwidth_type_raw(*integration_bandwidth_type_raw_ptr);
  }

  auto response = CHPCfgIntegrationBandwidthTypeResponse{};

  raise_if_error(
      stub->CHPCfgIntegrationBandwidthType(&context, request, &response),
      context);

  return response;
}

CHPCfgRBWFilterResponse
chp_cfg_rbw_filter(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ChpRbwAutoBandwidth, pb::int32>& rbw_auto, const double& rbw, const simple_variant<ChpRbwFilterType, pb::int32>& rbw_filter_type)
{
  ::grpc::ClientContext context;

  auto request = CHPCfgRBWFilterRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto rbw_auto_ptr = rbw_auto.get_if<ChpRbwAutoBandwidth>();
  const auto rbw_auto_raw_ptr = rbw_auto.get_if<pb::int32>();
  if (rbw_auto_ptr) {
    request.set_rbw_auto(*rbw_auto_ptr);
  }
  else if (rbw_auto_raw_ptr) {
    request.set_rbw_auto_raw(*rbw_auto_raw_ptr);
  }
  request.set_rbw(rbw);
  const auto rbw_filter_type_ptr = rbw_filter_type.get_if<ChpRbwFilterType>();
  const auto rbw_filter_type_raw_ptr = rbw_filter_type.get_if<pb::int32>();
  if (rbw_filter_type_ptr) {
    request.set_rbw_filter_type(*rbw_filter_type_ptr);
  }
  else if (rbw_filter_type_raw_ptr) {
    request.set_rbw_filter_type_raw(*rbw_filter_type_raw_ptr);
  }

  auto response = CHPCfgRBWFilterResponse{};

  raise_if_error(
      stub->CHPCfgRBWFilter(&context, request, &response),
      context);

  return response;
}

CHPCfgSweepTimeResponse
chp_cfg_sweep_time(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ChpSweepTimeAuto, pb::int32>& sweep_time_auto, const double& sweep_time_interval)
{
  ::grpc::ClientContext context;

  auto request = CHPCfgSweepTimeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto sweep_time_auto_ptr = sweep_time_auto.get_if<ChpSweepTimeAuto>();
  const auto sweep_time_auto_raw_ptr = sweep_time_auto.get_if<pb::int32>();
  if (sweep_time_auto_ptr) {
    request.set_sweep_time_auto(*sweep_time_auto_ptr);
  }
  else if (sweep_time_auto_raw_ptr) {
    request.set_sweep_time_auto_raw(*sweep_time_auto_raw_ptr);
  }
  request.set_sweep_time_interval(sweep_time_interval);

  auto response = CHPCfgSweepTimeResponse{};

  raise_if_error(
      stub->CHPCfgSweepTime(&context, request, &response),
      context);

  return response;
}

CHPFetchComponentCarrierMeasurementResponse
chp_fetch_component_carrier_measurement(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = CHPFetchComponentCarrierMeasurementRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = CHPFetchComponentCarrierMeasurementResponse{};

  raise_if_error(
      stub->CHPFetchComponentCarrierMeasurement(&context, request, &response),
      context);

  return response;
}

CHPFetchComponentCarrierMeasurementArrayResponse
chp_fetch_component_carrier_measurement_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = CHPFetchComponentCarrierMeasurementArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = CHPFetchComponentCarrierMeasurementArrayResponse{};

  raise_if_error(
      stub->CHPFetchComponentCarrierMeasurementArray(&context, request, &response),
      context);

  return response;
}

CHPFetchSpectrumResponse
chp_fetch_spectrum(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = CHPFetchSpectrumRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = CHPFetchSpectrumResponse{};

  raise_if_error(
      stub->CHPFetchSpectrum(&context, request, &response),
      context);

  return response;
}

CHPFetchSubblockMeasurementResponse
chp_fetch_subblock_measurement(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = CHPFetchSubblockMeasurementRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = CHPFetchSubblockMeasurementResponse{};

  raise_if_error(
      stub->CHPFetchSubblockMeasurement(&context, request, &response),
      context);

  return response;
}

CHPFetchTotalAggregatedPowerResponse
chp_fetch_total_aggregated_power(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = CHPFetchTotalAggregatedPowerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = CHPFetchTotalAggregatedPowerResponse{};

  raise_if_error(
      stub->CHPFetchTotalAggregatedPower(&context, request, &response),
      context);

  return response;
}

CHPValidateNoiseCalibrationDataResponse
chp_validate_noise_calibration_data(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = CHPValidateNoiseCalibrationDataRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = CHPValidateNoiseCalibrationDataResponse{};

  raise_if_error(
      stub->CHPValidateNoiseCalibrationData(&context, request, &response),
      context);

  return response;
}

CfgAutoDMRSDetectionEnabledResponse
cfg_auto_dmrs_detection_enabled(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AutoDmrsDetectionEnabled, pb::int32>& auto_dmrs_detection_enabled)
{
  ::grpc::ClientContext context;

  auto request = CfgAutoDMRSDetectionEnabledRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto auto_dmrs_detection_enabled_ptr = auto_dmrs_detection_enabled.get_if<AutoDmrsDetectionEnabled>();
  const auto auto_dmrs_detection_enabled_raw_ptr = auto_dmrs_detection_enabled.get_if<pb::int32>();
  if (auto_dmrs_detection_enabled_ptr) {
    request.set_auto_dmrs_detection_enabled(*auto_dmrs_detection_enabled_ptr);
  }
  else if (auto_dmrs_detection_enabled_raw_ptr) {
    request.set_auto_dmrs_detection_enabled_raw(*auto_dmrs_detection_enabled_raw_ptr);
  }

  auto response = CfgAutoDMRSDetectionEnabledResponse{};

  raise_if_error(
      stub->CfgAutoDMRSDetectionEnabled(&context, request, &response),
      context);

  return response;
}

CfgAutoNPUSCHChannelDetectionEnabledResponse
cfg_auto_npusch_channel_detection_enabled(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AutoNPuschChannelDetectionEnabled, pb::int32>& auto_npusch_channel_detection_enabled)
{
  ::grpc::ClientContext context;

  auto request = CfgAutoNPUSCHChannelDetectionEnabledRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto auto_npusch_channel_detection_enabled_ptr = auto_npusch_channel_detection_enabled.get_if<AutoNPuschChannelDetectionEnabled>();
  const auto auto_npusch_channel_detection_enabled_raw_ptr = auto_npusch_channel_detection_enabled.get_if<pb::int32>();
  if (auto_npusch_channel_detection_enabled_ptr) {
    request.set_auto_npusch_channel_detection_enabled(*auto_npusch_channel_detection_enabled_ptr);
  }
  else if (auto_npusch_channel_detection_enabled_raw_ptr) {
    request.set_auto_npusch_channel_detection_enabled_raw(*auto_npusch_channel_detection_enabled_raw_ptr);
  }

  auto response = CfgAutoNPUSCHChannelDetectionEnabledResponse{};

  raise_if_error(
      stub->CfgAutoNPUSCHChannelDetectionEnabled(&context, request, &response),
      context);

  return response;
}

CfgAutoResourceBlockDetectionEnabledResponse
cfg_auto_resource_block_detection_enabled(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AutoResourceBlockDetectionEnabled, pb::int32>& auto_resource_block_detection_enabled)
{
  ::grpc::ClientContext context;

  auto request = CfgAutoResourceBlockDetectionEnabledRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto auto_resource_block_detection_enabled_ptr = auto_resource_block_detection_enabled.get_if<AutoResourceBlockDetectionEnabled>();
  const auto auto_resource_block_detection_enabled_raw_ptr = auto_resource_block_detection_enabled.get_if<pb::int32>();
  if (auto_resource_block_detection_enabled_ptr) {
    request.set_auto_resource_block_detection_enabled(*auto_resource_block_detection_enabled_ptr);
  }
  else if (auto_resource_block_detection_enabled_raw_ptr) {
    request.set_auto_resource_block_detection_enabled_raw(*auto_resource_block_detection_enabled_raw_ptr);
  }

  auto response = CfgAutoResourceBlockDetectionEnabledResponse{};

  raise_if_error(
      stub->CfgAutoResourceBlockDetectionEnabled(&context, request, &response),
      context);

  return response;
}

CfgBandResponse
cfg_band(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& band)
{
  ::grpc::ClientContext context;

  auto request = CfgBandRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_band(band);

  auto response = CfgBandResponse{};

  raise_if_error(
      stub->CfgBand(&context, request, &response),
      context);

  return response;
}

CfgCellSpecificRatioResponse
cfg_cell_specific_ratio(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<DownlinkUserDefinedRatio, pb::int32>& cell_specific_ratio)
{
  ::grpc::ClientContext context;

  auto request = CfgCellSpecificRatioRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto cell_specific_ratio_ptr = cell_specific_ratio.get_if<DownlinkUserDefinedRatio>();
  const auto cell_specific_ratio_raw_ptr = cell_specific_ratio.get_if<pb::int32>();
  if (cell_specific_ratio_ptr) {
    request.set_cell_specific_ratio(*cell_specific_ratio_ptr);
  }
  else if (cell_specific_ratio_raw_ptr) {
    request.set_cell_specific_ratio_raw(*cell_specific_ratio_raw_ptr);
  }

  auto response = CfgCellSpecificRatioResponse{};

  raise_if_error(
      stub->CfgCellSpecificRatio(&context, request, &response),
      context);

  return response;
}

CfgComponentCarrierResponse
cfg_component_carrier(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& component_carrier_bandwidth, const double& component_carrier_frequency, const pb::int32& cell_id)
{
  ::grpc::ClientContext context;

  auto request = CfgComponentCarrierRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_component_carrier_bandwidth(component_carrier_bandwidth);
  request.set_component_carrier_frequency(component_carrier_frequency);
  request.set_cell_id(cell_id);

  auto response = CfgComponentCarrierResponse{};

  raise_if_error(
      stub->CfgComponentCarrier(&context, request, &response),
      context);

  return response;
}

CfgComponentCarrierArrayResponse
cfg_component_carrier_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const std::vector<double>& component_carrier_bandwidth, const std::vector<double>& component_carrier_frequency, const std::vector<pb::int32>& cell_id)
{
  ::grpc::ClientContext context;

  auto request = CfgComponentCarrierArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  copy_array(component_carrier_bandwidth, request.mutable_component_carrier_bandwidth());
  copy_array(component_carrier_frequency, request.mutable_component_carrier_frequency());
  copy_array(cell_id, request.mutable_cell_id());

  auto response = CfgComponentCarrierArrayResponse{};

  raise_if_error(
      stub->CfgComponentCarrierArray(&context, request, &response),
      context);

  return response;
}

CfgComponentCarrierSpacingResponse
cfg_component_carrier_spacing(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ComponentCarrierSpacingType, pb::int32>& component_carrier_spacing_type, const pb::int32& component_carrier_at_center_frequency)
{
  ::grpc::ClientContext context;

  auto request = CfgComponentCarrierSpacingRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto component_carrier_spacing_type_ptr = component_carrier_spacing_type.get_if<ComponentCarrierSpacingType>();
  const auto component_carrier_spacing_type_raw_ptr = component_carrier_spacing_type.get_if<pb::int32>();
  if (component_carrier_spacing_type_ptr) {
    request.set_component_carrier_spacing_type(*component_carrier_spacing_type_ptr);
  }
  else if (component_carrier_spacing_type_raw_ptr) {
    request.set_component_carrier_spacing_type_raw(*component_carrier_spacing_type_raw_ptr);
  }
  request.set_component_carrier_at_center_frequency(component_carrier_at_center_frequency);

  auto response = CfgComponentCarrierSpacingResponse{};

  raise_if_error(
      stub->CfgComponentCarrierSpacing(&context, request, &response),
      context);

  return response;
}

CfgDigitalEdgeTriggerResponse
cfg_digital_edge_trigger(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<DigitalEdgeTriggerSource, std::string>& digital_edge_source, const simple_variant<DigitalEdgeTriggerEdge, pb::int32>& digital_edge, const double& trigger_delay, const pb::int32& enable_trigger)
{
  ::grpc::ClientContext context;

  auto request = CfgDigitalEdgeTriggerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto digital_edge_source_ptr = digital_edge_source.get_if<DigitalEdgeTriggerSource>();
  const auto digital_edge_source_raw_ptr = digital_edge_source.get_if<std::string>();
  if (digital_edge_source_ptr) {
    request.set_digital_edge_source_mapped(*digital_edge_source_ptr);
  }
  else if (digital_edge_source_raw_ptr) {
    request.set_digital_edge_source_raw(*digital_edge_source_raw_ptr);
  }
  const auto digital_edge_ptr = digital_edge.get_if<DigitalEdgeTriggerEdge>();
  const auto digital_edge_raw_ptr = digital_edge.get_if<pb::int32>();
  if (digital_edge_ptr) {
    request.set_digital_edge(*digital_edge_ptr);
  }
  else if (digital_edge_raw_ptr) {
    request.set_digital_edge_raw(*digital_edge_raw_ptr);
  }
  request.set_trigger_delay(trigger_delay);
  request.set_enable_trigger(enable_trigger);

  auto response = CfgDigitalEdgeTriggerResponse{};

  raise_if_error(
      stub->CfgDigitalEdgeTrigger(&context, request, &response),
      context);

  return response;
}

CfgDownlinkAutoCellIDDetectionEnabledResponse
cfg_downlink_auto_cell_id_detection_enabled(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<DownlinkAutoCellIDDetectionEnabled, pb::int32>& auto_cell_id_detection_enabled)
{
  ::grpc::ClientContext context;

  auto request = CfgDownlinkAutoCellIDDetectionEnabledRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto auto_cell_id_detection_enabled_ptr = auto_cell_id_detection_enabled.get_if<DownlinkAutoCellIDDetectionEnabled>();
  const auto auto_cell_id_detection_enabled_raw_ptr = auto_cell_id_detection_enabled.get_if<pb::int32>();
  if (auto_cell_id_detection_enabled_ptr) {
    request.set_auto_cell_id_detection_enabled(*auto_cell_id_detection_enabled_ptr);
  }
  else if (auto_cell_id_detection_enabled_raw_ptr) {
    request.set_auto_cell_id_detection_enabled_raw(*auto_cell_id_detection_enabled_raw_ptr);
  }

  auto response = CfgDownlinkAutoCellIDDetectionEnabledResponse{};

  raise_if_error(
      stub->CfgDownlinkAutoCellIDDetectionEnabled(&context, request, &response),
      context);

  return response;
}

CfgDownlinkAutoChannelDetectionResponse
cfg_downlink_auto_channel_detection(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<AutoPdschChannelDetectionEnabled, pb::int32>& auto_pdsch_channel_detection_enabled, const simple_variant<AutoControlChannelPowerDetectionEnabled, pb::int32>& auto_control_channel_power_detection_enabled, const simple_variant<AutoPcfichCfiDetectionEnabled, pb::int32>& auto_pcfich_cfi_detection_enabled)
{
  ::grpc::ClientContext context;

  auto request = CfgDownlinkAutoChannelDetectionRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto auto_pdsch_channel_detection_enabled_ptr = auto_pdsch_channel_detection_enabled.get_if<AutoPdschChannelDetectionEnabled>();
  const auto auto_pdsch_channel_detection_enabled_raw_ptr = auto_pdsch_channel_detection_enabled.get_if<pb::int32>();
  if (auto_pdsch_channel_detection_enabled_ptr) {
    request.set_auto_pdsch_channel_detection_enabled(*auto_pdsch_channel_detection_enabled_ptr);
  }
  else if (auto_pdsch_channel_detection_enabled_raw_ptr) {
    request.set_auto_pdsch_channel_detection_enabled_raw(*auto_pdsch_channel_detection_enabled_raw_ptr);
  }
  const auto auto_control_channel_power_detection_enabled_ptr = auto_control_channel_power_detection_enabled.get_if<AutoControlChannelPowerDetectionEnabled>();
  const auto auto_control_channel_power_detection_enabled_raw_ptr = auto_control_channel_power_detection_enabled.get_if<pb::int32>();
  if (auto_control_channel_power_detection_enabled_ptr) {
    request.set_auto_control_channel_power_detection_enabled(*auto_control_channel_power_detection_enabled_ptr);
  }
  else if (auto_control_channel_power_detection_enabled_raw_ptr) {
    request.set_auto_control_channel_power_detection_enabled_raw(*auto_control_channel_power_detection_enabled_raw_ptr);
  }
  const auto auto_pcfich_cfi_detection_enabled_ptr = auto_pcfich_cfi_detection_enabled.get_if<AutoPcfichCfiDetectionEnabled>();
  const auto auto_pcfich_cfi_detection_enabled_raw_ptr = auto_pcfich_cfi_detection_enabled.get_if<pb::int32>();
  if (auto_pcfich_cfi_detection_enabled_ptr) {
    request.set_auto_pcfich_cfi_detection_enabled(*auto_pcfich_cfi_detection_enabled_ptr);
  }
  else if (auto_pcfich_cfi_detection_enabled_raw_ptr) {
    request.set_auto_pcfich_cfi_detection_enabled_raw(*auto_pcfich_cfi_detection_enabled_raw_ptr);
  }

  auto response = CfgDownlinkAutoChannelDetectionResponse{};

  raise_if_error(
      stub->CfgDownlinkAutoChannelDetection(&context, request, &response),
      context);

  return response;
}

CfgDownlinkChannelConfigurationModeResponse
cfg_downlink_channel_configuration_mode(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<DownlinkChannelConfigurationMode, pb::int32>& channel_configuration_mode)
{
  ::grpc::ClientContext context;

  auto request = CfgDownlinkChannelConfigurationModeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto channel_configuration_mode_ptr = channel_configuration_mode.get_if<DownlinkChannelConfigurationMode>();
  const auto channel_configuration_mode_raw_ptr = channel_configuration_mode.get_if<pb::int32>();
  if (channel_configuration_mode_ptr) {
    request.set_channel_configuration_mode(*channel_configuration_mode_ptr);
  }
  else if (channel_configuration_mode_raw_ptr) {
    request.set_channel_configuration_mode_raw(*channel_configuration_mode_raw_ptr);
  }

  auto response = CfgDownlinkChannelConfigurationModeResponse{};

  raise_if_error(
      stub->CfgDownlinkChannelConfigurationMode(&context, request, &response),
      context);

  return response;
}

CfgDownlinkNumberOfSubframesResponse
cfg_downlink_number_of_subframes(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_subframes)
{
  ::grpc::ClientContext context;

  auto request = CfgDownlinkNumberOfSubframesRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_subframes(number_of_subframes);

  auto response = CfgDownlinkNumberOfSubframesResponse{};

  raise_if_error(
      stub->CfgDownlinkNumberOfSubframes(&context, request, &response),
      context);

  return response;
}

CfgDownlinkSynchronizationSignalResponse
cfg_downlink_synchronization_signal(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& pss_power, const double& sss_power)
{
  ::grpc::ClientContext context;

  auto request = CfgDownlinkSynchronizationSignalRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_pss_power(pss_power);
  request.set_sss_power(sss_power);

  auto response = CfgDownlinkSynchronizationSignalResponse{};

  raise_if_error(
      stub->CfgDownlinkSynchronizationSignal(&context, request, &response),
      context);

  return response;
}

CfgDownlinkTestModelResponse
cfg_downlink_test_model(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<DownlinkTestModel, pb::int32>& downlink_test_model)
{
  ::grpc::ClientContext context;

  auto request = CfgDownlinkTestModelRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto downlink_test_model_ptr = downlink_test_model.get_if<DownlinkTestModel>();
  const auto downlink_test_model_raw_ptr = downlink_test_model.get_if<pb::int32>();
  if (downlink_test_model_ptr) {
    request.set_downlink_test_model(*downlink_test_model_ptr);
  }
  else if (downlink_test_model_raw_ptr) {
    request.set_downlink_test_model_raw(*downlink_test_model_raw_ptr);
  }

  auto response = CfgDownlinkTestModelResponse{};

  raise_if_error(
      stub->CfgDownlinkTestModel(&context, request, &response),
      context);

  return response;
}

CfgDownlinkTestModelArrayResponse
cfg_downlink_test_model_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const std::vector<pb::int32>& downlink_test_model)
{
  ::grpc::ClientContext context;

  auto request = CfgDownlinkTestModelArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  copy_array(downlink_test_model, request.mutable_downlink_test_model());

  auto response = CfgDownlinkTestModelArrayResponse{};

  raise_if_error(
      stub->CfgDownlinkTestModelArray(&context, request, &response),
      context);

  return response;
}

CfgDuplexSchemeResponse
cfg_duplex_scheme(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<DuplexScheme, pb::int32>& duplex_scheme, const simple_variant<UplinkDownlinkConfiguration, pb::int32>& uplink_downlink_configuration)
{
  ::grpc::ClientContext context;

  auto request = CfgDuplexSchemeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto duplex_scheme_ptr = duplex_scheme.get_if<DuplexScheme>();
  const auto duplex_scheme_raw_ptr = duplex_scheme.get_if<pb::int32>();
  if (duplex_scheme_ptr) {
    request.set_duplex_scheme(*duplex_scheme_ptr);
  }
  else if (duplex_scheme_raw_ptr) {
    request.set_duplex_scheme_raw(*duplex_scheme_raw_ptr);
  }
  const auto uplink_downlink_configuration_ptr = uplink_downlink_configuration.get_if<UplinkDownlinkConfiguration>();
  const auto uplink_downlink_configuration_raw_ptr = uplink_downlink_configuration.get_if<pb::int32>();
  if (uplink_downlink_configuration_ptr) {
    request.set_uplink_downlink_configuration(*uplink_downlink_configuration_ptr);
  }
  else if (uplink_downlink_configuration_raw_ptr) {
    request.set_uplink_downlink_configuration_raw(*uplink_downlink_configuration_raw_ptr);
  }

  auto response = CfgDuplexSchemeResponse{};

  raise_if_error(
      stub->CfgDuplexScheme(&context, request, &response),
      context);

  return response;
}

CfgEMTCAnalysisEnabledResponse
cfg_emtc_analysis_enabled(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<EmtcAnalysisEnabled, pb::int32>& emtc_analysis_enabled)
{
  ::grpc::ClientContext context;

  auto request = CfgEMTCAnalysisEnabledRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto emtc_analysis_enabled_ptr = emtc_analysis_enabled.get_if<EmtcAnalysisEnabled>();
  const auto emtc_analysis_enabled_raw_ptr = emtc_analysis_enabled.get_if<pb::int32>();
  if (emtc_analysis_enabled_ptr) {
    request.set_emtc_analysis_enabled(*emtc_analysis_enabled_ptr);
  }
  else if (emtc_analysis_enabled_raw_ptr) {
    request.set_emtc_analysis_enabled_raw(*emtc_analysis_enabled_raw_ptr);
  }

  auto response = CfgEMTCAnalysisEnabledResponse{};

  raise_if_error(
      stub->CfgEMTCAnalysisEnabled(&context, request, &response),
      context);

  return response;
}

CfgExternalAttenuationResponse
cfg_external_attenuation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& external_attenuation)
{
  ::grpc::ClientContext context;

  auto request = CfgExternalAttenuationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_external_attenuation(external_attenuation);

  auto response = CfgExternalAttenuationResponse{};

  raise_if_error(
      stub->CfgExternalAttenuation(&context, request, &response),
      context);

  return response;
}

CfgFrequencyResponse
cfg_frequency(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& center_frequency)
{
  ::grpc::ClientContext context;

  auto request = CfgFrequencyRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_center_frequency(center_frequency);

  auto response = CfgFrequencyResponse{};

  raise_if_error(
      stub->CfgFrequency(&context, request, &response),
      context);

  return response;
}

CfgFrequencyEARFCNResponse
cfg_frequency_earfcn(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<LinkDirection, pb::int32>& link_direction, const pb::int32& band, const pb::int32& earfcn)
{
  ::grpc::ClientContext context;

  auto request = CfgFrequencyEARFCNRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto link_direction_ptr = link_direction.get_if<LinkDirection>();
  const auto link_direction_raw_ptr = link_direction.get_if<pb::int32>();
  if (link_direction_ptr) {
    request.set_link_direction(*link_direction_ptr);
  }
  else if (link_direction_raw_ptr) {
    request.set_link_direction_raw(*link_direction_raw_ptr);
  }
  request.set_band(band);
  request.set_earfcn(earfcn);

  auto response = CfgFrequencyEARFCNResponse{};

  raise_if_error(
      stub->CfgFrequencyEARFCN(&context, request, &response),
      context);

  return response;
}

CfgFrequencyReferenceResponse
cfg_frequency_reference(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& channel_name, const simple_variant<FrequencyReferenceSource, std::string>& frequency_reference_source, const double& frequency_reference_frequency)
{
  ::grpc::ClientContext context;

  auto request = CfgFrequencyReferenceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_channel_name(channel_name);
  const auto frequency_reference_source_ptr = frequency_reference_source.get_if<FrequencyReferenceSource>();
  const auto frequency_reference_source_raw_ptr = frequency_reference_source.get_if<std::string>();
  if (frequency_reference_source_ptr) {
    request.set_frequency_reference_source_mapped(*frequency_reference_source_ptr);
  }
  else if (frequency_reference_source_raw_ptr) {
    request.set_frequency_reference_source_raw(*frequency_reference_source_raw_ptr);
  }
  request.set_frequency_reference_frequency(frequency_reference_frequency);

  auto response = CfgFrequencyReferenceResponse{};

  raise_if_error(
      stub->CfgFrequencyReference(&context, request, &response),
      context);

  return response;
}

CfgIQPowerEdgeTriggerResponse
cfg_iq_power_edge_trigger(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::string& iq_power_edge_source, const simple_variant<IQPowerEdgeTriggerSlope, pb::int32>& iq_power_edge_slope, const double& iq_power_edge_level, const double& trigger_delay, const simple_variant<TriggerMinimumQuietTimeMode, pb::int32>& trigger_min_quiet_time_mode, const double& trigger_min_quiet_time_duration, const simple_variant<IQPowerEdgeTriggerLevelType, pb::int32>& iq_power_edge_level_type, const pb::int32& enable_trigger)
{
  ::grpc::ClientContext context;

  auto request = CfgIQPowerEdgeTriggerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_iq_power_edge_source(iq_power_edge_source);
  const auto iq_power_edge_slope_ptr = iq_power_edge_slope.get_if<IQPowerEdgeTriggerSlope>();
  const auto iq_power_edge_slope_raw_ptr = iq_power_edge_slope.get_if<pb::int32>();
  if (iq_power_edge_slope_ptr) {
    request.set_iq_power_edge_slope(*iq_power_edge_slope_ptr);
  }
  else if (iq_power_edge_slope_raw_ptr) {
    request.set_iq_power_edge_slope_raw(*iq_power_edge_slope_raw_ptr);
  }
  request.set_iq_power_edge_level(iq_power_edge_level);
  request.set_trigger_delay(trigger_delay);
  const auto trigger_min_quiet_time_mode_ptr = trigger_min_quiet_time_mode.get_if<TriggerMinimumQuietTimeMode>();
  const auto trigger_min_quiet_time_mode_raw_ptr = trigger_min_quiet_time_mode.get_if<pb::int32>();
  if (trigger_min_quiet_time_mode_ptr) {
    request.set_trigger_min_quiet_time_mode(*trigger_min_quiet_time_mode_ptr);
  }
  else if (trigger_min_quiet_time_mode_raw_ptr) {
    request.set_trigger_min_quiet_time_mode_raw(*trigger_min_quiet_time_mode_raw_ptr);
  }
  request.set_trigger_min_quiet_time_duration(trigger_min_quiet_time_duration);
  const auto iq_power_edge_level_type_ptr = iq_power_edge_level_type.get_if<IQPowerEdgeTriggerLevelType>();
  const auto iq_power_edge_level_type_raw_ptr = iq_power_edge_level_type.get_if<pb::int32>();
  if (iq_power_edge_level_type_ptr) {
    request.set_iq_power_edge_level_type(*iq_power_edge_level_type_ptr);
  }
  else if (iq_power_edge_level_type_raw_ptr) {
    request.set_iq_power_edge_level_type_raw(*iq_power_edge_level_type_raw_ptr);
  }
  request.set_enable_trigger(enable_trigger);

  auto response = CfgIQPowerEdgeTriggerResponse{};

  raise_if_error(
      stub->CfgIQPowerEdgeTrigger(&context, request, &response),
      context);

  return response;
}

CfgLinkDirectionResponse
cfg_link_direction(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<LinkDirection, pb::int32>& link_direction)
{
  ::grpc::ClientContext context;

  auto request = CfgLinkDirectionRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto link_direction_ptr = link_direction.get_if<LinkDirection>();
  const auto link_direction_raw_ptr = link_direction.get_if<pb::int32>();
  if (link_direction_ptr) {
    request.set_link_direction(*link_direction_ptr);
  }
  else if (link_direction_raw_ptr) {
    request.set_link_direction_raw(*link_direction_raw_ptr);
  }

  auto response = CfgLinkDirectionResponse{};

  raise_if_error(
      stub->CfgLinkDirection(&context, request, &response),
      context);

  return response;
}

CfgMechanicalAttenuationResponse
cfg_mechanical_attenuation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& channel_name, const simple_variant<MechanicalAttenuationAuto, pb::int32>& mechanical_attenuation_auto, const double& mechanical_attenuation_value)
{
  ::grpc::ClientContext context;

  auto request = CfgMechanicalAttenuationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_channel_name(channel_name);
  const auto mechanical_attenuation_auto_ptr = mechanical_attenuation_auto.get_if<MechanicalAttenuationAuto>();
  const auto mechanical_attenuation_auto_raw_ptr = mechanical_attenuation_auto.get_if<pb::int32>();
  if (mechanical_attenuation_auto_ptr) {
    request.set_mechanical_attenuation_auto(*mechanical_attenuation_auto_ptr);
  }
  else if (mechanical_attenuation_auto_raw_ptr) {
    request.set_mechanical_attenuation_auto_raw(*mechanical_attenuation_auto_raw_ptr);
  }
  request.set_mechanical_attenuation_value(mechanical_attenuation_value);

  auto response = CfgMechanicalAttenuationResponse{};

  raise_if_error(
      stub->CfgMechanicalAttenuation(&context, request, &response),
      context);

  return response;
}

CfgNBIoTComponentCarrierResponse
cfg_nb_io_t_component_carrier(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& n_cell_id, const simple_variant<NBIoTUplinkSubcarrierSpacing, pb::int32>& uplink_subcarrier_spacing)
{
  ::grpc::ClientContext context;

  auto request = CfgNBIoTComponentCarrierRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_n_cell_id(n_cell_id);
  const auto uplink_subcarrier_spacing_ptr = uplink_subcarrier_spacing.get_if<NBIoTUplinkSubcarrierSpacing>();
  const auto uplink_subcarrier_spacing_raw_ptr = uplink_subcarrier_spacing.get_if<pb::int32>();
  if (uplink_subcarrier_spacing_ptr) {
    request.set_uplink_subcarrier_spacing(*uplink_subcarrier_spacing_ptr);
  }
  else if (uplink_subcarrier_spacing_raw_ptr) {
    request.set_uplink_subcarrier_spacing_raw(*uplink_subcarrier_spacing_raw_ptr);
  }

  auto response = CfgNBIoTComponentCarrierResponse{};

  raise_if_error(
      stub->CfgNBIoTComponentCarrier(&context, request, &response),
      context);

  return response;
}

CfgNPUSCHDMRSResponse
cfg_npuschdmrs(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<NPuschDmrsBaseSequenceMode, pb::int32>& npusch_dmrs_base_sequence_mode, const pb::int32& npusch_dmrs_base_sequence_index, const pb::int32& npusch_dmrs_cyclic_shift, const simple_variant<NPuschDmrsGroupHoppingEnabled, pb::int32>& npusch_dmrs_group_hopping_enabled, const pb::int32& npusch_dmrs_delta_ss)
{
  ::grpc::ClientContext context;

  auto request = CfgNPUSCHDMRSRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto npusch_dmrs_base_sequence_mode_ptr = npusch_dmrs_base_sequence_mode.get_if<NPuschDmrsBaseSequenceMode>();
  const auto npusch_dmrs_base_sequence_mode_raw_ptr = npusch_dmrs_base_sequence_mode.get_if<pb::int32>();
  if (npusch_dmrs_base_sequence_mode_ptr) {
    request.set_npusch_dmrs_base_sequence_mode(*npusch_dmrs_base_sequence_mode_ptr);
  }
  else if (npusch_dmrs_base_sequence_mode_raw_ptr) {
    request.set_npusch_dmrs_base_sequence_mode_raw(*npusch_dmrs_base_sequence_mode_raw_ptr);
  }
  request.set_npusch_dmrs_base_sequence_index(npusch_dmrs_base_sequence_index);
  request.set_npusch_dmrs_cyclic_shift(npusch_dmrs_cyclic_shift);
  const auto npusch_dmrs_group_hopping_enabled_ptr = npusch_dmrs_group_hopping_enabled.get_if<NPuschDmrsGroupHoppingEnabled>();
  const auto npusch_dmrs_group_hopping_enabled_raw_ptr = npusch_dmrs_group_hopping_enabled.get_if<pb::int32>();
  if (npusch_dmrs_group_hopping_enabled_ptr) {
    request.set_npusch_dmrs_group_hopping_enabled(*npusch_dmrs_group_hopping_enabled_ptr);
  }
  else if (npusch_dmrs_group_hopping_enabled_raw_ptr) {
    request.set_npusch_dmrs_group_hopping_enabled_raw(*npusch_dmrs_group_hopping_enabled_raw_ptr);
  }
  request.set_npusch_dmrs_delta_ss(npusch_dmrs_delta_ss);

  auto response = CfgNPUSCHDMRSResponse{};

  raise_if_error(
      stub->CfgNPUSCHDMRS(&context, request, &response),
      context);

  return response;
}

CfgNPUSCHFormatResponse
cfg_npusch_format(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& format)
{
  ::grpc::ClientContext context;

  auto request = CfgNPUSCHFormatRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_format(format);

  auto response = CfgNPUSCHFormatResponse{};

  raise_if_error(
      stub->CfgNPUSCHFormat(&context, request, &response),
      context);

  return response;
}

CfgNPUSCHStartingSlotResponse
cfg_npusch_starting_slot(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& starting_slot)
{
  ::grpc::ClientContext context;

  auto request = CfgNPUSCHStartingSlotRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_starting_slot(starting_slot);

  auto response = CfgNPUSCHStartingSlotResponse{};

  raise_if_error(
      stub->CfgNPUSCHStartingSlot(&context, request, &response),
      context);

  return response;
}

CfgNPUSCHTonesResponse
cfg_npusch_tones(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& tone_offset, const pb::int32& number_of_tones, const simple_variant<NPuschModulationType, pb::int32>& modulation_type)
{
  ::grpc::ClientContext context;

  auto request = CfgNPUSCHTonesRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_tone_offset(tone_offset);
  request.set_number_of_tones(number_of_tones);
  const auto modulation_type_ptr = modulation_type.get_if<NPuschModulationType>();
  const auto modulation_type_raw_ptr = modulation_type.get_if<pb::int32>();
  if (modulation_type_ptr) {
    request.set_modulation_type(*modulation_type_ptr);
  }
  else if (modulation_type_raw_ptr) {
    request.set_modulation_type_raw(*modulation_type_raw_ptr);
  }

  auto response = CfgNPUSCHTonesResponse{};

  raise_if_error(
      stub->CfgNPUSCHTones(&context, request, &response),
      context);

  return response;
}

CfgNumberOfComponentCarriersResponse
cfg_number_of_component_carriers(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_component_carriers)
{
  ::grpc::ClientContext context;

  auto request = CfgNumberOfComponentCarriersRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_component_carriers(number_of_component_carriers);

  auto response = CfgNumberOfComponentCarriersResponse{};

  raise_if_error(
      stub->CfgNumberOfComponentCarriers(&context, request, &response),
      context);

  return response;
}

CfgNumberOfDUTAntennasResponse
cfg_number_of_dut_antennas(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_dut_antennas)
{
  ::grpc::ClientContext context;

  auto request = CfgNumberOfDUTAntennasRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_dut_antennas(number_of_dut_antennas);

  auto response = CfgNumberOfDUTAntennasResponse{};

  raise_if_error(
      stub->CfgNumberOfDUTAntennas(&context, request, &response),
      context);

  return response;
}

CfgNumberOfPDSCHChannelsResponse
cfg_number_of_pdsch_channels(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_pdsch_channels)
{
  ::grpc::ClientContext context;

  auto request = CfgNumberOfPDSCHChannelsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_pdsch_channels(number_of_pdsch_channels);

  auto response = CfgNumberOfPDSCHChannelsResponse{};

  raise_if_error(
      stub->CfgNumberOfPDSCHChannels(&context, request, &response),
      context);

  return response;
}

CfgNumberOfPUSCHResourceBlockClustersResponse
cfg_number_of_pusch_resource_block_clusters(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_resource_block_clusters)
{
  ::grpc::ClientContext context;

  auto request = CfgNumberOfPUSCHResourceBlockClustersRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_resource_block_clusters(number_of_resource_block_clusters);

  auto response = CfgNumberOfPUSCHResourceBlockClustersResponse{};

  raise_if_error(
      stub->CfgNumberOfPUSCHResourceBlockClusters(&context, request, &response),
      context);

  return response;
}

CfgNumberOfSubblocksResponse
cfg_number_of_subblocks(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_subblocks)
{
  ::grpc::ClientContext context;

  auto request = CfgNumberOfSubblocksRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_subblocks(number_of_subblocks);

  auto response = CfgNumberOfSubblocksResponse{};

  raise_if_error(
      stub->CfgNumberOfSubblocks(&context, request, &response),
      context);

  return response;
}

CfgPBCHResponse
cfg_pbch(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& pbch_power)
{
  ::grpc::ClientContext context;

  auto request = CfgPBCHRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_pbch_power(pbch_power);

  auto response = CfgPBCHResponse{};

  raise_if_error(
      stub->CfgPBCH(&context, request, &response),
      context);

  return response;
}

CfgPCFICHResponse
cfg_pcfich(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& cfi, const double& power)
{
  ::grpc::ClientContext context;

  auto request = CfgPCFICHRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_cfi(cfi);
  request.set_power(power);

  auto response = CfgPCFICHResponse{};

  raise_if_error(
      stub->CfgPCFICH(&context, request, &response),
      context);

  return response;
}

CfgPDCCHResponse
cfg_pdcch(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& pdcch_power)
{
  ::grpc::ClientContext context;

  auto request = CfgPDCCHRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_pdcch_power(pdcch_power);

  auto response = CfgPDCCHResponse{};

  raise_if_error(
      stub->CfgPDCCH(&context, request, &response),
      context);

  return response;
}

CfgPDSCHResponse
cfg_pdsch(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<UserDefinedPdschCW0ModulationType, pb::int32>& cw0_modulation_type, const pb::string& resource_block_allocation, const double& power)
{
  ::grpc::ClientContext context;

  auto request = CfgPDSCHRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto cw0_modulation_type_ptr = cw0_modulation_type.get_if<UserDefinedPdschCW0ModulationType>();
  const auto cw0_modulation_type_raw_ptr = cw0_modulation_type.get_if<pb::int32>();
  if (cw0_modulation_type_ptr) {
    request.set_cw0_modulation_type(*cw0_modulation_type_ptr);
  }
  else if (cw0_modulation_type_raw_ptr) {
    request.set_cw0_modulation_type_raw(*cw0_modulation_type_raw_ptr);
  }
  request.set_resource_block_allocation(resource_block_allocation);
  request.set_power(power);

  auto response = CfgPDSCHResponse{};

  raise_if_error(
      stub->CfgPDSCH(&context, request, &response),
      context);

  return response;
}

CfgPHICHResponse
cfg_phich(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<DownlinkUserDefinedPhichResource, pb::int32>& resource, const simple_variant<DownlinkUserDefinedPhichDuration, pb::int32>& duration, const double& power)
{
  ::grpc::ClientContext context;

  auto request = CfgPHICHRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto resource_ptr = resource.get_if<DownlinkUserDefinedPhichResource>();
  const auto resource_raw_ptr = resource.get_if<pb::int32>();
  if (resource_ptr) {
    request.set_resource(*resource_ptr);
  }
  else if (resource_raw_ptr) {
    request.set_resource_raw(*resource_raw_ptr);
  }
  const auto duration_ptr = duration.get_if<DownlinkUserDefinedPhichDuration>();
  const auto duration_raw_ptr = duration.get_if<pb::int32>();
  if (duration_ptr) {
    request.set_duration(*duration_ptr);
  }
  else if (duration_raw_ptr) {
    request.set_duration_raw(*duration_raw_ptr);
  }
  request.set_power(power);

  auto response = CfgPHICHResponse{};

  raise_if_error(
      stub->CfgPHICH(&context, request, &response),
      context);

  return response;
}

CfgPSSCHModulationTypeResponse
cfg_pssch_modulation_type(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& modulation_type)
{
  ::grpc::ClientContext context;

  auto request = CfgPSSCHModulationTypeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_modulation_type(modulation_type);

  auto response = CfgPSSCHModulationTypeResponse{};

  raise_if_error(
      stub->CfgPSSCHModulationType(&context, request, &response),
      context);

  return response;
}

CfgPSSCHResourceBlocksResponse
cfg_pssch_resource_blocks(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& resource_block_offset, const pb::int32& number_of_resource_blocks)
{
  ::grpc::ClientContext context;

  auto request = CfgPSSCHResourceBlocksRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_resource_block_offset(resource_block_offset);
  request.set_number_of_resource_blocks(number_of_resource_blocks);

  auto response = CfgPSSCHResourceBlocksResponse{};

  raise_if_error(
      stub->CfgPSSCHResourceBlocks(&context, request, &response),
      context);

  return response;
}

CfgPUSCHModulationTypeResponse
cfg_pusch_modulation_type(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<PuschModulationType, pb::int32>& modulation_type)
{
  ::grpc::ClientContext context;

  auto request = CfgPUSCHModulationTypeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto modulation_type_ptr = modulation_type.get_if<PuschModulationType>();
  const auto modulation_type_raw_ptr = modulation_type.get_if<pb::int32>();
  if (modulation_type_ptr) {
    request.set_modulation_type(*modulation_type_ptr);
  }
  else if (modulation_type_raw_ptr) {
    request.set_modulation_type_raw(*modulation_type_raw_ptr);
  }

  auto response = CfgPUSCHModulationTypeResponse{};

  raise_if_error(
      stub->CfgPUSCHModulationType(&context, request, &response),
      context);

  return response;
}

CfgPUSCHResourceBlocksResponse
cfg_pusch_resource_blocks(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& resource_block_offset, const pb::int32& number_of_resource_blocks)
{
  ::grpc::ClientContext context;

  auto request = CfgPUSCHResourceBlocksRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_resource_block_offset(resource_block_offset);
  request.set_number_of_resource_blocks(number_of_resource_blocks);

  auto response = CfgPUSCHResourceBlocksResponse{};

  raise_if_error(
      stub->CfgPUSCHResourceBlocks(&context, request, &response),
      context);

  return response;
}

CfgRFResponse
cfg_rf(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& center_frequency, const double& reference_level, const double& external_attenuation)
{
  ::grpc::ClientContext context;

  auto request = CfgRFRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_center_frequency(center_frequency);
  request.set_reference_level(reference_level);
  request.set_external_attenuation(external_attenuation);

  auto response = CfgRFResponse{};

  raise_if_error(
      stub->CfgRF(&context, request, &response),
      context);

  return response;
}

CfgRFAttenuationResponse
cfg_rf_attenuation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& channel_name, const simple_variant<RFAttenuationAuto, pb::int32>& rf_attenuation_auto, const double& rf_attenuation_value)
{
  ::grpc::ClientContext context;

  auto request = CfgRFAttenuationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_channel_name(channel_name);
  const auto rf_attenuation_auto_ptr = rf_attenuation_auto.get_if<RFAttenuationAuto>();
  const auto rf_attenuation_auto_raw_ptr = rf_attenuation_auto.get_if<pb::int32>();
  if (rf_attenuation_auto_ptr) {
    request.set_rf_attenuation_auto(*rf_attenuation_auto_ptr);
  }
  else if (rf_attenuation_auto_raw_ptr) {
    request.set_rf_attenuation_auto_raw(*rf_attenuation_auto_raw_ptr);
  }
  request.set_rf_attenuation_value(rf_attenuation_value);

  auto response = CfgRFAttenuationResponse{};

  raise_if_error(
      stub->CfgRFAttenuation(&context, request, &response),
      context);

  return response;
}

CfgReferenceLevelResponse
cfg_reference_level(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& reference_level)
{
  ::grpc::ClientContext context;

  auto request = CfgReferenceLevelRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_reference_level(reference_level);

  auto response = CfgReferenceLevelResponse{};

  raise_if_error(
      stub->CfgReferenceLevel(&context, request, &response),
      context);

  return response;
}

CfgSoftwareEdgeTriggerResponse
cfg_software_edge_trigger(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& trigger_delay, const pb::int32& enable_trigger)
{
  ::grpc::ClientContext context;

  auto request = CfgSoftwareEdgeTriggerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_trigger_delay(trigger_delay);
  request.set_enable_trigger(enable_trigger);

  auto response = CfgSoftwareEdgeTriggerResponse{};

  raise_if_error(
      stub->CfgSoftwareEdgeTrigger(&context, request, &response),
      context);

  return response;
}

CfgTransmitAntennaToAnalyzeResponse
cfg_transmit_antenna_to_analyze(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& transmit_antenna_to_analyze)
{
  ::grpc::ClientContext context;

  auto request = CfgTransmitAntennaToAnalyzeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_transmit_antenna_to_analyze(transmit_antenna_to_analyze);

  auto response = CfgTransmitAntennaToAnalyzeResponse{};

  raise_if_error(
      stub->CfgTransmitAntennaToAnalyze(&context, request, &response),
      context);

  return response;
}

CfgeNodeBCategoryResponse
cfge_node_b_category(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ENodeBCategory, pb::int32>& enodeb_category)
{
  ::grpc::ClientContext context;

  auto request = CfgeNodeBCategoryRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto enodeb_category_ptr = enodeb_category.get_if<ENodeBCategory>();
  const auto enodeb_category_raw_ptr = enodeb_category.get_if<pb::int32>();
  if (enodeb_category_ptr) {
    request.set_enodeb_category(*enodeb_category_ptr);
  }
  else if (enodeb_category_raw_ptr) {
    request.set_enodeb_category_raw(*enodeb_category_raw_ptr);
  }

  auto response = CfgeNodeBCategoryResponse{};

  raise_if_error(
      stub->CfgeNodeBCategory(&context, request, &response),
      context);

  return response;
}

CheckMeasurementStatusResponse
check_measurement_status(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = CheckMeasurementStatusRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = CheckMeasurementStatusResponse{};

  raise_if_error(
      stub->CheckMeasurementStatus(&context, request, &response),
      context);

  return response;
}

ClearAllNamedResultsResponse
clear_all_named_results(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = ClearAllNamedResultsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = ClearAllNamedResultsResponse{};

  raise_if_error(
      stub->ClearAllNamedResults(&context, request, &response),
      context);

  return response;
}

ClearNamedResultResponse
clear_named_result(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = ClearNamedResultRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = ClearNamedResultResponse{};

  raise_if_error(
      stub->ClearNamedResult(&context, request, &response),
      context);

  return response;
}

ClearNoiseCalibrationDatabaseResponse
clear_noise_calibration_database(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = ClearNoiseCalibrationDatabaseRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = ClearNoiseCalibrationDatabaseResponse{};

  raise_if_error(
      stub->ClearNoiseCalibrationDatabase(&context, request, &response),
      context);

  return response;
}

CloneSignalConfigurationResponse
clone_signal_configuration(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& old_signal_name, const pb::string& new_signal_name)
{
  ::grpc::ClientContext context;

  auto request = CloneSignalConfigurationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_old_signal_name(old_signal_name);
  request.set_new_signal_name(new_signal_name);

  auto response = CloneSignalConfigurationResponse{};

  raise_if_error(
      stub->CloneSignalConfiguration(&context, request, &response),
      context);

  return response;
}

CloseResponse
close(const StubPtr& stub, const nidevice_grpc::Session& instrument, const bool& force_destroy)
{
  ::grpc::ClientContext context;

  auto request = CloseRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_force_destroy(force_destroy);

  auto response = CloseResponse{};

  raise_if_error(
      stub->Close(&context, request, &response),
      context);

  return response;
}

CommitResponse
commit(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = CommitRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = CommitResponse{};

  raise_if_error(
      stub->Commit(&context, request, &response),
      context);

  return response;
}

CreateSignalConfigurationResponse
create_signal_configuration(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& signal_name)
{
  ::grpc::ClientContext context;

  auto request = CreateSignalConfigurationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_signal_name(signal_name);

  auto response = CreateSignalConfigurationResponse{};

  raise_if_error(
      stub->CreateSignalConfiguration(&context, request, &response),
      context);

  return response;
}

DeleteSignalConfigurationResponse
delete_signal_configuration(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& signal_name)
{
  ::grpc::ClientContext context;

  auto request = DeleteSignalConfigurationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_signal_name(signal_name);

  auto response = DeleteSignalConfigurationResponse{};

  raise_if_error(
      stub->DeleteSignalConfiguration(&context, request, &response),
      context);

  return response;
}

DisableTriggerResponse
disable_trigger(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = DisableTriggerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = DisableTriggerResponse{};

  raise_if_error(
      stub->DisableTrigger(&context, request, &response),
      context);

  return response;
}

GetAllNamedResultNamesResponse
get_all_named_result_names(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = GetAllNamedResultNamesRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = GetAllNamedResultNamesResponse{};

  raise_if_error(
      stub->GetAllNamedResultNames(&context, request, &response),
      context);

  return response;
}

GetAttributeF32Response
get_attribute_f32(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeF32Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeF32Response{};

  raise_if_error(
      stub->GetAttributeF32(&context, request, &response),
      context);

  return response;
}

GetAttributeF32ArrayResponse
get_attribute_f32_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeF32ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeF32ArrayResponse{};

  raise_if_error(
      stub->GetAttributeF32Array(&context, request, &response),
      context);

  return response;
}

GetAttributeF64Response
get_attribute_f64(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeF64Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeF64Response{};

  raise_if_error(
      stub->GetAttributeF64(&context, request, &response),
      context);

  return response;
}

GetAttributeF64ArrayResponse
get_attribute_f64_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeF64ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeF64ArrayResponse{};

  raise_if_error(
      stub->GetAttributeF64Array(&context, request, &response),
      context);

  return response;
}

GetAttributeI16Response
get_attribute_i16(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeI16Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeI16Response{};

  raise_if_error(
      stub->GetAttributeI16(&context, request, &response),
      context);

  return response;
}

GetAttributeI32Response
get_attribute_i32(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeI32Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeI32Response{};

  raise_if_error(
      stub->GetAttributeI32(&context, request, &response),
      context);

  return response;
}

GetAttributeI32ArrayResponse
get_attribute_i32_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeI32ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeI32ArrayResponse{};

  raise_if_error(
      stub->GetAttributeI32Array(&context, request, &response),
      context);

  return response;
}

GetAttributeI64Response
get_attribute_i64(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeI64Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeI64Response{};

  raise_if_error(
      stub->GetAttributeI64(&context, request, &response),
      context);

  return response;
}

GetAttributeI64ArrayResponse
get_attribute_i64_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeI64ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeI64ArrayResponse{};

  raise_if_error(
      stub->GetAttributeI64Array(&context, request, &response),
      context);

  return response;
}

GetAttributeI8Response
get_attribute_i8(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeI8Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeI8Response{};

  raise_if_error(
      stub->GetAttributeI8(&context, request, &response),
      context);

  return response;
}

GetAttributeI8ArrayResponse
get_attribute_i8_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeI8ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeI8ArrayResponse{};

  raise_if_error(
      stub->GetAttributeI8Array(&context, request, &response),
      context);

  return response;
}

GetAttributeNIComplexDoubleArrayResponse
get_attribute_ni_complex_double_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeNIComplexDoubleArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeNIComplexDoubleArrayResponse{};

  raise_if_error(
      stub->GetAttributeNIComplexDoubleArray(&context, request, &response),
      context);

  return response;
}

GetAttributeNIComplexSingleArrayResponse
get_attribute_ni_complex_single_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeNIComplexSingleArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeNIComplexSingleArrayResponse{};

  raise_if_error(
      stub->GetAttributeNIComplexSingleArray(&context, request, &response),
      context);

  return response;
}

GetAttributeStringResponse
get_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeStringRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeStringResponse{};

  raise_if_error(
      stub->GetAttributeString(&context, request, &response),
      context);

  return response;
}

GetAttributeU16Response
get_attribute_u16(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeU16Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeU16Response{};

  raise_if_error(
      stub->GetAttributeU16(&context, request, &response),
      context);

  return response;
}

GetAttributeU32Response
get_attribute_u32(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeU32Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeU32Response{};

  raise_if_error(
      stub->GetAttributeU32(&context, request, &response),
      context);

  return response;
}

GetAttributeU32ArrayResponse
get_attribute_u32_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeU32ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeU32ArrayResponse{};

  raise_if_error(
      stub->GetAttributeU32Array(&context, request, &response),
      context);

  return response;
}

GetAttributeU64ArrayResponse
get_attribute_u64_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeU64ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeU64ArrayResponse{};

  raise_if_error(
      stub->GetAttributeU64Array(&context, request, &response),
      context);

  return response;
}

GetAttributeU8Response
get_attribute_u8(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeU8Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeU8Response{};

  raise_if_error(
      stub->GetAttributeU8(&context, request, &response),
      context);

  return response;
}

GetAttributeU8ArrayResponse
get_attribute_u8_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeU8ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = GetAttributeU8ArrayResponse{};

  raise_if_error(
      stub->GetAttributeU8Array(&context, request, &response),
      context);

  return response;
}

GetErrorResponse
get_error(const StubPtr& stub, const nidevice_grpc::Session& instrument)
{
  ::grpc::ClientContext context;

  auto request = GetErrorRequest{};
  request.mutable_instrument()->CopyFrom(instrument);

  auto response = GetErrorResponse{};

  raise_if_error(
      stub->GetError(&context, request, &response),
      context);

  return response;
}

GetErrorStringResponse
get_error_string(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::int32& error_code)
{
  ::grpc::ClientContext context;

  auto request = GetErrorStringRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_error_code(error_code);

  auto response = GetErrorStringResponse{};

  raise_if_error(
      stub->GetErrorString(&context, request, &response),
      context);

  return response;
}

InitializeResponse
initialize(const StubPtr& stub, const pb::string& resource_name, const pb::string& option_string)
{
  ::grpc::ClientContext context;

  auto request = InitializeRequest{};
  request.set_resource_name(resource_name);
  request.set_option_string(option_string);

  auto response = InitializeResponse{};

  raise_if_error(
      stub->Initialize(&context, request, &response),
      context);

  return response;
}

InitializeFromNIRFSASessionResponse
initialize_from_nirfsa_session(const StubPtr& stub, const nidevice_grpc::Session& nirfsa_session)
{
  ::grpc::ClientContext context;

  auto request = InitializeFromNIRFSASessionRequest{};
  request.mutable_nirfsa_session()->CopyFrom(nirfsa_session);

  auto response = InitializeFromNIRFSASessionResponse{};

  raise_if_error(
      stub->InitializeFromNIRFSASession(&context, request, &response),
      context);

  return response;
}

InitiateResponse
initiate(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::string& result_name)
{
  ::grpc::ClientContext context;

  auto request = InitiateRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_result_name(result_name);

  auto response = InitiateResponse{};

  raise_if_error(
      stub->Initiate(&context, request, &response),
      context);

  return response;
}

ModAccCfgAveragingResponse
mod_acc_cfg_averaging(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ModAccAveragingEnabled, pb::int32>& averaging_enabled, const pb::int32& averaging_count)
{
  ::grpc::ClientContext context;

  auto request = ModAccCfgAveragingRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto averaging_enabled_ptr = averaging_enabled.get_if<ModAccAveragingEnabled>();
  const auto averaging_enabled_raw_ptr = averaging_enabled.get_if<pb::int32>();
  if (averaging_enabled_ptr) {
    request.set_averaging_enabled(*averaging_enabled_ptr);
  }
  else if (averaging_enabled_raw_ptr) {
    request.set_averaging_enabled_raw(*averaging_enabled_raw_ptr);
  }
  request.set_averaging_count(averaging_count);

  auto response = ModAccCfgAveragingResponse{};

  raise_if_error(
      stub->ModAccCfgAveraging(&context, request, &response),
      context);

  return response;
}

ModAccCfgCommonClockSourceEnabledResponse
mod_acc_cfg_common_clock_source_enabled(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ModAccCommonClockSourceEnabled, pb::int32>& common_clock_source_enabled)
{
  ::grpc::ClientContext context;

  auto request = ModAccCfgCommonClockSourceEnabledRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto common_clock_source_enabled_ptr = common_clock_source_enabled.get_if<ModAccCommonClockSourceEnabled>();
  const auto common_clock_source_enabled_raw_ptr = common_clock_source_enabled.get_if<pb::int32>();
  if (common_clock_source_enabled_ptr) {
    request.set_common_clock_source_enabled(*common_clock_source_enabled_ptr);
  }
  else if (common_clock_source_enabled_raw_ptr) {
    request.set_common_clock_source_enabled_raw(*common_clock_source_enabled_raw_ptr);
  }

  auto response = ModAccCfgCommonClockSourceEnabledResponse{};

  raise_if_error(
      stub->ModAccCfgCommonClockSourceEnabled(&context, request, &response),
      context);

  return response;
}

ModAccCfgEVMUnitResponse
mod_acc_cfg_evm_unit(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ModAccEvmUnit, pb::int32>& evm_unit)
{
  ::grpc::ClientContext context;

  auto request = ModAccCfgEVMUnitRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto evm_unit_ptr = evm_unit.get_if<ModAccEvmUnit>();
  const auto evm_unit_raw_ptr = evm_unit.get_if<pb::int32>();
  if (evm_unit_ptr) {
    request.set_evm_unit(*evm_unit_ptr);
  }
  else if (evm_unit_raw_ptr) {
    request.set_evm_unit_raw(*evm_unit_raw_ptr);
  }

  auto response = ModAccCfgEVMUnitResponse{};

  raise_if_error(
      stub->ModAccCfgEVMUnit(&context, request, &response),
      context);

  return response;
}

ModAccCfgFFTWindowOffsetResponse
mod_acc_cfg_fft_window_offset(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& fft_window_offset)
{
  ::grpc::ClientContext context;

  auto request = ModAccCfgFFTWindowOffsetRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_fft_window_offset(fft_window_offset);

  auto response = ModAccCfgFFTWindowOffsetResponse{};

  raise_if_error(
      stub->ModAccCfgFFTWindowOffset(&context, request, &response),
      context);

  return response;
}

ModAccCfgFFTWindowPositionResponse
mod_acc_cfg_fft_window_position(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ModAccFftWindowType, pb::int32>& fft_window_type, const double& fft_window_offset, const double& fft_window_length)
{
  ::grpc::ClientContext context;

  auto request = ModAccCfgFFTWindowPositionRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto fft_window_type_ptr = fft_window_type.get_if<ModAccFftWindowType>();
  const auto fft_window_type_raw_ptr = fft_window_type.get_if<pb::int32>();
  if (fft_window_type_ptr) {
    request.set_fft_window_type(*fft_window_type_ptr);
  }
  else if (fft_window_type_raw_ptr) {
    request.set_fft_window_type_raw(*fft_window_type_raw_ptr);
  }
  request.set_fft_window_offset(fft_window_offset);
  request.set_fft_window_length(fft_window_length);

  auto response = ModAccCfgFFTWindowPositionResponse{};

  raise_if_error(
      stub->ModAccCfgFFTWindowPosition(&context, request, &response),
      context);

  return response;
}

ModAccCfgInBandEmissionMaskTypeResponse
mod_acc_cfg_in_band_emission_mask_type(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ModAccInBandEmissionMaskType, pb::int32>& in_band_emission_mask_type)
{
  ::grpc::ClientContext context;

  auto request = ModAccCfgInBandEmissionMaskTypeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto in_band_emission_mask_type_ptr = in_band_emission_mask_type.get_if<ModAccInBandEmissionMaskType>();
  const auto in_band_emission_mask_type_raw_ptr = in_band_emission_mask_type.get_if<pb::int32>();
  if (in_band_emission_mask_type_ptr) {
    request.set_in_band_emission_mask_type(*in_band_emission_mask_type_ptr);
  }
  else if (in_band_emission_mask_type_raw_ptr) {
    request.set_in_band_emission_mask_type_raw(*in_band_emission_mask_type_raw_ptr);
  }

  auto response = ModAccCfgInBandEmissionMaskTypeResponse{};

  raise_if_error(
      stub->ModAccCfgInBandEmissionMaskType(&context, request, &response),
      context);

  return response;
}

ModAccCfgSynchronizationModeAndIntervalResponse
mod_acc_cfg_synchronization_mode_and_interval(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ModAccSynchronizationMode, pb::int32>& synchronization_mode, const pb::int32& measurement_offset, const pb::int32& measurement_length)
{
  ::grpc::ClientContext context;

  auto request = ModAccCfgSynchronizationModeAndIntervalRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto synchronization_mode_ptr = synchronization_mode.get_if<ModAccSynchronizationMode>();
  const auto synchronization_mode_raw_ptr = synchronization_mode.get_if<pb::int32>();
  if (synchronization_mode_ptr) {
    request.set_synchronization_mode(*synchronization_mode_ptr);
  }
  else if (synchronization_mode_raw_ptr) {
    request.set_synchronization_mode_raw(*synchronization_mode_raw_ptr);
  }
  request.set_measurement_offset(measurement_offset);
  request.set_measurement_length(measurement_length);

  auto response = ModAccCfgSynchronizationModeAndIntervalResponse{};

  raise_if_error(
      stub->ModAccCfgSynchronizationModeAndInterval(&context, request, &response),
      context);

  return response;
}

ModAccFetchCSRSConstellationResponse
mod_acc_fetch_csrs_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchCSRSConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchCSRSConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchCSRSConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchCSRSEVMResponse
mod_acc_fetch_csrsevm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchCSRSEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchCSRSEVMResponse{};

  raise_if_error(
      stub->ModAccFetchCSRSEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchCSRSEVMArrayResponse
mod_acc_fetch_csrsevm_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchCSRSEVMArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchCSRSEVMArrayResponse{};

  raise_if_error(
      stub->ModAccFetchCSRSEVMArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchCompositeEVMResponse
mod_acc_fetch_composite_evm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchCompositeEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchCompositeEVMResponse{};

  raise_if_error(
      stub->ModAccFetchCompositeEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchCompositeEVMArrayResponse
mod_acc_fetch_composite_evm_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchCompositeEVMArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchCompositeEVMArrayResponse{};

  raise_if_error(
      stub->ModAccFetchCompositeEVMArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchCompositeMagnitudeAndPhaseErrorResponse
mod_acc_fetch_composite_magnitude_and_phase_error(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchCompositeMagnitudeAndPhaseErrorRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchCompositeMagnitudeAndPhaseErrorResponse{};

  raise_if_error(
      stub->ModAccFetchCompositeMagnitudeAndPhaseError(&context, request, &response),
      context);

  return response;
}

ModAccFetchCompositeMagnitudeAndPhaseErrorArrayResponse
mod_acc_fetch_composite_magnitude_and_phase_error_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchCompositeMagnitudeAndPhaseErrorArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchCompositeMagnitudeAndPhaseErrorArrayResponse{};

  raise_if_error(
      stub->ModAccFetchCompositeMagnitudeAndPhaseErrorArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchDownlinkDetectedCellIDResponse
mod_acc_fetch_downlink_detected_cell_id(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchDownlinkDetectedCellIDRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchDownlinkDetectedCellIDResponse{};

  raise_if_error(
      stub->ModAccFetchDownlinkDetectedCellID(&context, request, &response),
      context);

  return response;
}

ModAccFetchDownlinkDetectedCellIDArrayResponse
mod_acc_fetch_downlink_detected_cell_id_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchDownlinkDetectedCellIDArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchDownlinkDetectedCellIDArrayResponse{};

  raise_if_error(
      stub->ModAccFetchDownlinkDetectedCellIDArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchDownlinkPBCHConstellationResponse
mod_acc_fetch_downlink_pbch_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchDownlinkPBCHConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchDownlinkPBCHConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchDownlinkPBCHConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchDownlinkPCFICHConstellationResponse
mod_acc_fetch_downlink_pcfich_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchDownlinkPCFICHConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchDownlinkPCFICHConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchDownlinkPCFICHConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchDownlinkPDCCHConstellationResponse
mod_acc_fetch_downlink_pdcch_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchDownlinkPDCCHConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchDownlinkPDCCHConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchDownlinkPDCCHConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchDownlinkPHICHConstellationResponse
mod_acc_fetch_downlink_phich_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchDownlinkPHICHConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchDownlinkPHICHConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchDownlinkPHICHConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchDownlinkTransmitPowerResponse
mod_acc_fetch_downlink_transmit_power(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchDownlinkTransmitPowerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchDownlinkTransmitPowerResponse{};

  raise_if_error(
      stub->ModAccFetchDownlinkTransmitPower(&context, request, &response),
      context);

  return response;
}

ModAccFetchDownlinkTransmitPowerArrayResponse
mod_acc_fetch_downlink_transmit_power_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchDownlinkTransmitPowerArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchDownlinkTransmitPowerArrayResponse{};

  raise_if_error(
      stub->ModAccFetchDownlinkTransmitPowerArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchEVMHighPerSymbolTraceResponse
mod_acc_fetch_evm_high_per_symbol_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchEVMHighPerSymbolTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchEVMHighPerSymbolTraceResponse{};

  raise_if_error(
      stub->ModAccFetchEVMHighPerSymbolTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchEVMLowPerSymbolTraceResponse
mod_acc_fetch_evm_low_per_symbol_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchEVMLowPerSymbolTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchEVMLowPerSymbolTraceResponse{};

  raise_if_error(
      stub->ModAccFetchEVMLowPerSymbolTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchEVMPerSlotTraceResponse
mod_acc_fetch_evm_per_slot_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchEVMPerSlotTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchEVMPerSlotTraceResponse{};

  raise_if_error(
      stub->ModAccFetchEVMPerSlotTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchEVMPerSubcarrierTraceResponse
mod_acc_fetch_evm_per_subcarrier_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchEVMPerSubcarrierTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchEVMPerSubcarrierTraceResponse{};

  raise_if_error(
      stub->ModAccFetchEVMPerSubcarrierTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchEVMPerSymbolTraceResponse
mod_acc_fetch_evm_per_symbol_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchEVMPerSymbolTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchEVMPerSymbolTraceResponse{};

  raise_if_error(
      stub->ModAccFetchEVMPerSymbolTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchIQImpairmentsResponse
mod_acc_fetch_iq_impairments(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchIQImpairmentsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchIQImpairmentsResponse{};

  raise_if_error(
      stub->ModAccFetchIQImpairments(&context, request, &response),
      context);

  return response;
}

ModAccFetchIQImpairmentsArrayResponse
mod_acc_fetch_iq_impairments_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchIQImpairmentsArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchIQImpairmentsArrayResponse{};

  raise_if_error(
      stub->ModAccFetchIQImpairmentsArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchInBandEmissionMarginResponse
mod_acc_fetch_in_band_emission_margin(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchInBandEmissionMarginRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchInBandEmissionMarginResponse{};

  raise_if_error(
      stub->ModAccFetchInBandEmissionMargin(&context, request, &response),
      context);

  return response;
}

ModAccFetchInBandEmissionMarginArrayResponse
mod_acc_fetch_in_band_emission_margin_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchInBandEmissionMarginArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchInBandEmissionMarginArrayResponse{};

  raise_if_error(
      stub->ModAccFetchInBandEmissionMarginArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchInBandEmissionTraceResponse
mod_acc_fetch_in_band_emission_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchInBandEmissionTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchInBandEmissionTraceResponse{};

  raise_if_error(
      stub->ModAccFetchInBandEmissionTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchMaximumEVMPerSlotTraceResponse
mod_acc_fetch_maximum_evm_per_slot_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchMaximumEVMPerSlotTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchMaximumEVMPerSlotTraceResponse{};

  raise_if_error(
      stub->ModAccFetchMaximumEVMPerSlotTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchMaximumEVMPerSubcarrierTraceResponse
mod_acc_fetch_maximum_evm_per_subcarrier_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchMaximumEVMPerSubcarrierTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchMaximumEVMPerSubcarrierTraceResponse{};

  raise_if_error(
      stub->ModAccFetchMaximumEVMPerSubcarrierTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchMaximumEVMPerSymbolTraceResponse
mod_acc_fetch_maximum_evm_per_symbol_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchMaximumEVMPerSymbolTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchMaximumEVMPerSymbolTraceResponse{};

  raise_if_error(
      stub->ModAccFetchMaximumEVMPerSymbolTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchMaximumMagnitudeErrorPerSymbolTraceResponse
mod_acc_fetch_maximum_magnitude_error_per_symbol_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchMaximumMagnitudeErrorPerSymbolTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchMaximumMagnitudeErrorPerSymbolTraceResponse{};

  raise_if_error(
      stub->ModAccFetchMaximumMagnitudeErrorPerSymbolTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchMaximumPhaseErrorPerSymbolTraceResponse
mod_acc_fetch_maximum_phase_error_per_symbol_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchMaximumPhaseErrorPerSymbolTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchMaximumPhaseErrorPerSymbolTraceResponse{};

  raise_if_error(
      stub->ModAccFetchMaximumPhaseErrorPerSymbolTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchNPUSCHConstellationTraceResponse
mod_acc_fetch_npusch_constellation_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchNPUSCHConstellationTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchNPUSCHConstellationTraceResponse{};

  raise_if_error(
      stub->ModAccFetchNPUSCHConstellationTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchNPUSCHDMRSEVMResponse
mod_acc_fetch_npuschdmrsevm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchNPUSCHDMRSEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchNPUSCHDMRSEVMResponse{};

  raise_if_error(
      stub->ModAccFetchNPUSCHDMRSEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchNPUSCHDataEVMResponse
mod_acc_fetch_npusch_data_evm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchNPUSCHDataEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchNPUSCHDataEVMResponse{};

  raise_if_error(
      stub->ModAccFetchNPUSCHDataEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchNPUSCHSymbolPowerResponse
mod_acc_fetch_npusch_symbol_power(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchNPUSCHSymbolPowerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchNPUSCHSymbolPowerResponse{};

  raise_if_error(
      stub->ModAccFetchNPUSCHSymbolPower(&context, request, &response),
      context);

  return response;
}

ModAccFetchPDSCH1024QAMConstellationResponse
mod_acc_fetch_pdsch1024q_am_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPDSCH1024QAMConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPDSCH1024QAMConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchPDSCH1024QAMConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchPDSCH1024QAMEVMResponse
mod_acc_fetch_pdsch1024q_amevm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPDSCH1024QAMEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPDSCH1024QAMEVMResponse{};

  raise_if_error(
      stub->ModAccFetchPDSCH1024QAMEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchPDSCH1024QAMEVMArrayResponse
mod_acc_fetch_pdsch1024q_amevm_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPDSCH1024QAMEVMArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPDSCH1024QAMEVMArrayResponse{};

  raise_if_error(
      stub->ModAccFetchPDSCH1024QAMEVMArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchPDSCH16QAMConstellationResponse
mod_acc_fetch_pdsch16q_am_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPDSCH16QAMConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPDSCH16QAMConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchPDSCH16QAMConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchPDSCH256QAMConstellationResponse
mod_acc_fetch_pdsch256q_am_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPDSCH256QAMConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPDSCH256QAMConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchPDSCH256QAMConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchPDSCH64QAMConstellationResponse
mod_acc_fetch_pdsch64q_am_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPDSCH64QAMConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPDSCH64QAMConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchPDSCH64QAMConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchPDSCHEVMResponse
mod_acc_fetch_pdschevm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPDSCHEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPDSCHEVMResponse{};

  raise_if_error(
      stub->ModAccFetchPDSCHEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchPDSCHEVMArrayResponse
mod_acc_fetch_pdschevm_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPDSCHEVMArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPDSCHEVMArrayResponse{};

  raise_if_error(
      stub->ModAccFetchPDSCHEVMArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchPDSCHQPSKConstellationResponse
mod_acc_fetch_pdschqpsk_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPDSCHQPSKConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPDSCHQPSKConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchPDSCHQPSKConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchPSSCHConstellationTraceResponse
mod_acc_fetch_pssch_constellation_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPSSCHConstellationTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPSSCHConstellationTraceResponse{};

  raise_if_error(
      stub->ModAccFetchPSSCHConstellationTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchPSSCHDMRSEVMResponse
mod_acc_fetch_psschdmrsevm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPSSCHDMRSEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPSSCHDMRSEVMResponse{};

  raise_if_error(
      stub->ModAccFetchPSSCHDMRSEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchPSSCHDMRSEVMArrayResponse
mod_acc_fetch_psschdmrsevm_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPSSCHDMRSEVMArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPSSCHDMRSEVMArrayResponse{};

  raise_if_error(
      stub->ModAccFetchPSSCHDMRSEVMArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchPSSCHDataEVMResponse
mod_acc_fetch_pssch_data_evm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPSSCHDataEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPSSCHDataEVMResponse{};

  raise_if_error(
      stub->ModAccFetchPSSCHDataEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchPSSCHDataEVMArrayResponse
mod_acc_fetch_pssch_data_evm_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPSSCHDataEVMArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPSSCHDataEVMArrayResponse{};

  raise_if_error(
      stub->ModAccFetchPSSCHDataEVMArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchPSSCHSymbolPowerResponse
mod_acc_fetch_pssch_symbol_power(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPSSCHSymbolPowerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPSSCHSymbolPowerResponse{};

  raise_if_error(
      stub->ModAccFetchPSSCHSymbolPower(&context, request, &response),
      context);

  return response;
}

ModAccFetchPSSCHSymbolPowerArrayResponse
mod_acc_fetch_pssch_symbol_power_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPSSCHSymbolPowerArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPSSCHSymbolPowerArrayResponse{};

  raise_if_error(
      stub->ModAccFetchPSSCHSymbolPowerArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchPUSCHConstellationTraceResponse
mod_acc_fetch_pusch_constellation_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPUSCHConstellationTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPUSCHConstellationTraceResponse{};

  raise_if_error(
      stub->ModAccFetchPUSCHConstellationTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchPUSCHDMRSEVMResponse
mod_acc_fetch_puschdmrsevm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPUSCHDMRSEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPUSCHDMRSEVMResponse{};

  raise_if_error(
      stub->ModAccFetchPUSCHDMRSEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchPUSCHDMRSEVMArrayResponse
mod_acc_fetch_puschdmrsevm_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPUSCHDMRSEVMArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPUSCHDMRSEVMArrayResponse{};

  raise_if_error(
      stub->ModAccFetchPUSCHDMRSEVMArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchPUSCHDataEVMResponse
mod_acc_fetch_pusch_data_evm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPUSCHDataEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPUSCHDataEVMResponse{};

  raise_if_error(
      stub->ModAccFetchPUSCHDataEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchPUSCHDataEVMArrayResponse
mod_acc_fetch_pusch_data_evm_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPUSCHDataEVMArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPUSCHDataEVMArrayResponse{};

  raise_if_error(
      stub->ModAccFetchPUSCHDataEVMArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchPUSCHDemodulatedBitsResponse
mod_acc_fetch_pusch_demodulated_bits(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPUSCHDemodulatedBitsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPUSCHDemodulatedBitsResponse{};

  raise_if_error(
      stub->ModAccFetchPUSCHDemodulatedBits(&context, request, &response),
      context);

  return response;
}

ModAccFetchPUSCHSymbolPowerResponse
mod_acc_fetch_pusch_symbol_power(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPUSCHSymbolPowerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPUSCHSymbolPowerResponse{};

  raise_if_error(
      stub->ModAccFetchPUSCHSymbolPower(&context, request, &response),
      context);

  return response;
}

ModAccFetchPUSCHSymbolPowerArrayResponse
mod_acc_fetch_pusch_symbol_power_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchPUSCHSymbolPowerArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchPUSCHSymbolPowerArrayResponse{};

  raise_if_error(
      stub->ModAccFetchPUSCHSymbolPowerArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchRMSMagnitudeErrorPerSymbolTraceResponse
mod_acc_fetch_rms_magnitude_error_per_symbol_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchRMSMagnitudeErrorPerSymbolTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchRMSMagnitudeErrorPerSymbolTraceResponse{};

  raise_if_error(
      stub->ModAccFetchRMSMagnitudeErrorPerSymbolTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchRMSPhaseErrorPerSymbolTraceResponse
mod_acc_fetch_rms_phase_error_per_symbol_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchRMSPhaseErrorPerSymbolTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchRMSPhaseErrorPerSymbolTraceResponse{};

  raise_if_error(
      stub->ModAccFetchRMSPhaseErrorPerSymbolTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchSRSConstellationResponse
mod_acc_fetch_srs_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSRSConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSRSConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchSRSConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchSRSEVMResponse
mod_acc_fetch_srsevm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSRSEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSRSEVMResponse{};

  raise_if_error(
      stub->ModAccFetchSRSEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchSRSEVMArrayResponse
mod_acc_fetch_srsevm_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSRSEVMArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSRSEVMArrayResponse{};

  raise_if_error(
      stub->ModAccFetchSRSEVMArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchSpectralFlatnessResponse
mod_acc_fetch_spectral_flatness(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSpectralFlatnessRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSpectralFlatnessResponse{};

  raise_if_error(
      stub->ModAccFetchSpectralFlatness(&context, request, &response),
      context);

  return response;
}

ModAccFetchSpectralFlatnessArrayResponse
mod_acc_fetch_spectral_flatness_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSpectralFlatnessArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSpectralFlatnessArrayResponse{};

  raise_if_error(
      stub->ModAccFetchSpectralFlatnessArray(&context, request, &response),
      context);

  return response;
}

ModAccFetchSpectralFlatnessTraceResponse
mod_acc_fetch_spectral_flatness_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSpectralFlatnessTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSpectralFlatnessTraceResponse{};

  raise_if_error(
      stub->ModAccFetchSpectralFlatnessTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchSubblockIQImpairmentsResponse
mod_acc_fetch_subblock_iq_impairments(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSubblockIQImpairmentsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSubblockIQImpairmentsResponse{};

  raise_if_error(
      stub->ModAccFetchSubblockIQImpairments(&context, request, &response),
      context);

  return response;
}

ModAccFetchSubblockInBandEmissionMarginResponse
mod_acc_fetch_subblock_in_band_emission_margin(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSubblockInBandEmissionMarginRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSubblockInBandEmissionMarginResponse{};

  raise_if_error(
      stub->ModAccFetchSubblockInBandEmissionMargin(&context, request, &response),
      context);

  return response;
}

ModAccFetchSubblockInBandEmissionTraceResponse
mod_acc_fetch_subblock_in_band_emission_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSubblockInBandEmissionTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSubblockInBandEmissionTraceResponse{};

  raise_if_error(
      stub->ModAccFetchSubblockInBandEmissionTrace(&context, request, &response),
      context);

  return response;
}

ModAccFetchSynchronizationSignalConstellationResponse
mod_acc_fetch_synchronization_signal_constellation(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSynchronizationSignalConstellationRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSynchronizationSignalConstellationResponse{};

  raise_if_error(
      stub->ModAccFetchSynchronizationSignalConstellation(&context, request, &response),
      context);

  return response;
}

ModAccFetchSynchronizationSignalEVMResponse
mod_acc_fetch_synchronization_signal_evm(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSynchronizationSignalEVMRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSynchronizationSignalEVMResponse{};

  raise_if_error(
      stub->ModAccFetchSynchronizationSignalEVM(&context, request, &response),
      context);

  return response;
}

ModAccFetchSynchronizationSignalEVMArrayResponse
mod_acc_fetch_synchronization_signal_evm_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = ModAccFetchSynchronizationSignalEVMArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = ModAccFetchSynchronizationSignalEVMArrayResponse{};

  raise_if_error(
      stub->ModAccFetchSynchronizationSignalEVMArray(&context, request, &response),
      context);

  return response;
}

OBWCfgAveragingResponse
obw_cfg_averaging(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ObwAveragingEnabled, pb::int32>& averaging_enabled, const pb::int32& averaging_count, const simple_variant<ObwAveragingType, pb::int32>& averaging_type)
{
  ::grpc::ClientContext context;

  auto request = OBWCfgAveragingRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto averaging_enabled_ptr = averaging_enabled.get_if<ObwAveragingEnabled>();
  const auto averaging_enabled_raw_ptr = averaging_enabled.get_if<pb::int32>();
  if (averaging_enabled_ptr) {
    request.set_averaging_enabled(*averaging_enabled_ptr);
  }
  else if (averaging_enabled_raw_ptr) {
    request.set_averaging_enabled_raw(*averaging_enabled_raw_ptr);
  }
  request.set_averaging_count(averaging_count);
  const auto averaging_type_ptr = averaging_type.get_if<ObwAveragingType>();
  const auto averaging_type_raw_ptr = averaging_type.get_if<pb::int32>();
  if (averaging_type_ptr) {
    request.set_averaging_type(*averaging_type_ptr);
  }
  else if (averaging_type_raw_ptr) {
    request.set_averaging_type_raw(*averaging_type_raw_ptr);
  }

  auto response = OBWCfgAveragingResponse{};

  raise_if_error(
      stub->OBWCfgAveraging(&context, request, &response),
      context);

  return response;
}

OBWCfgRBWFilterResponse
obw_cfg_rbw_filter(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ObwRbwAutoBandwidth, pb::int32>& rbw_auto, const double& rbw, const simple_variant<ObwRbwFilterType, pb::int32>& rbw_filter_type)
{
  ::grpc::ClientContext context;

  auto request = OBWCfgRBWFilterRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto rbw_auto_ptr = rbw_auto.get_if<ObwRbwAutoBandwidth>();
  const auto rbw_auto_raw_ptr = rbw_auto.get_if<pb::int32>();
  if (rbw_auto_ptr) {
    request.set_rbw_auto(*rbw_auto_ptr);
  }
  else if (rbw_auto_raw_ptr) {
    request.set_rbw_auto_raw(*rbw_auto_raw_ptr);
  }
  request.set_rbw(rbw);
  const auto rbw_filter_type_ptr = rbw_filter_type.get_if<ObwRbwFilterType>();
  const auto rbw_filter_type_raw_ptr = rbw_filter_type.get_if<pb::int32>();
  if (rbw_filter_type_ptr) {
    request.set_rbw_filter_type(*rbw_filter_type_ptr);
  }
  else if (rbw_filter_type_raw_ptr) {
    request.set_rbw_filter_type_raw(*rbw_filter_type_raw_ptr);
  }

  auto response = OBWCfgRBWFilterResponse{};

  raise_if_error(
      stub->OBWCfgRBWFilter(&context, request, &response),
      context);

  return response;
}

OBWCfgSweepTimeResponse
obw_cfg_sweep_time(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<ObwSweepTimeAuto, pb::int32>& sweep_time_auto, const double& sweep_time_interval)
{
  ::grpc::ClientContext context;

  auto request = OBWCfgSweepTimeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto sweep_time_auto_ptr = sweep_time_auto.get_if<ObwSweepTimeAuto>();
  const auto sweep_time_auto_raw_ptr = sweep_time_auto.get_if<pb::int32>();
  if (sweep_time_auto_ptr) {
    request.set_sweep_time_auto(*sweep_time_auto_ptr);
  }
  else if (sweep_time_auto_raw_ptr) {
    request.set_sweep_time_auto_raw(*sweep_time_auto_raw_ptr);
  }
  request.set_sweep_time_interval(sweep_time_interval);

  auto response = OBWCfgSweepTimeResponse{};

  raise_if_error(
      stub->OBWCfgSweepTime(&context, request, &response),
      context);

  return response;
}

OBWFetchMeasurementResponse
obw_fetch_measurement(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = OBWFetchMeasurementRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = OBWFetchMeasurementResponse{};

  raise_if_error(
      stub->OBWFetchMeasurement(&context, request, &response),
      context);

  return response;
}

OBWFetchSpectrumResponse
obw_fetch_spectrum(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = OBWFetchSpectrumRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = OBWFetchSpectrumResponse{};

  raise_if_error(
      stub->OBWFetchSpectrum(&context, request, &response),
      context);

  return response;
}

PVTCfgAveragingResponse
pvt_cfg_averaging(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<PvtAveragingEnabled, pb::int32>& averaging_enabled, const pb::int32& averaging_count, const simple_variant<PvtAveragingType, pb::int32>& averaging_type)
{
  ::grpc::ClientContext context;

  auto request = PVTCfgAveragingRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto averaging_enabled_ptr = averaging_enabled.get_if<PvtAveragingEnabled>();
  const auto averaging_enabled_raw_ptr = averaging_enabled.get_if<pb::int32>();
  if (averaging_enabled_ptr) {
    request.set_averaging_enabled(*averaging_enabled_ptr);
  }
  else if (averaging_enabled_raw_ptr) {
    request.set_averaging_enabled_raw(*averaging_enabled_raw_ptr);
  }
  request.set_averaging_count(averaging_count);
  const auto averaging_type_ptr = averaging_type.get_if<PvtAveragingType>();
  const auto averaging_type_raw_ptr = averaging_type.get_if<pb::int32>();
  if (averaging_type_ptr) {
    request.set_averaging_type(*averaging_type_ptr);
  }
  else if (averaging_type_raw_ptr) {
    request.set_averaging_type_raw(*averaging_type_raw_ptr);
  }

  auto response = PVTCfgAveragingResponse{};

  raise_if_error(
      stub->PVTCfgAveraging(&context, request, &response),
      context);

  return response;
}

PVTCfgMeasurementMethodResponse
pvt_cfg_measurement_method(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<PvtMeasurementMethod, pb::int32>& measurement_method)
{
  ::grpc::ClientContext context;

  auto request = PVTCfgMeasurementMethodRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto measurement_method_ptr = measurement_method.get_if<PvtMeasurementMethod>();
  const auto measurement_method_raw_ptr = measurement_method.get_if<pb::int32>();
  if (measurement_method_ptr) {
    request.set_measurement_method(*measurement_method_ptr);
  }
  else if (measurement_method_raw_ptr) {
    request.set_measurement_method_raw(*measurement_method_raw_ptr);
  }

  auto response = PVTCfgMeasurementMethodResponse{};

  raise_if_error(
      stub->PVTCfgMeasurementMethod(&context, request, &response),
      context);

  return response;
}

PVTCfgOFFPowerExclusionPeriodsResponse
pvt_cfg_off_power_exclusion_periods(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& off_power_exclusion_before, const double& off_power_exclusion_after)
{
  ::grpc::ClientContext context;

  auto request = PVTCfgOFFPowerExclusionPeriodsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_off_power_exclusion_before(off_power_exclusion_before);
  request.set_off_power_exclusion_after(off_power_exclusion_after);

  auto response = PVTCfgOFFPowerExclusionPeriodsResponse{};

  raise_if_error(
      stub->PVTCfgOFFPowerExclusionPeriods(&context, request, &response),
      context);

  return response;
}

PVTFetchMeasurementResponse
pvt_fetch_measurement(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = PVTFetchMeasurementRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = PVTFetchMeasurementResponse{};

  raise_if_error(
      stub->PVTFetchMeasurement(&context, request, &response),
      context);

  return response;
}

PVTFetchMeasurementArrayResponse
pvt_fetch_measurement_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = PVTFetchMeasurementArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = PVTFetchMeasurementArrayResponse{};

  raise_if_error(
      stub->PVTFetchMeasurementArray(&context, request, &response),
      context);

  return response;
}

PVTFetchSignalPowerTraceResponse
pvt_fetch_signal_power_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = PVTFetchSignalPowerTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = PVTFetchSignalPowerTraceResponse{};

  raise_if_error(
      stub->PVTFetchSignalPowerTrace(&context, request, &response),
      context);

  return response;
}

ResetAttributeResponse
reset_attribute(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id)
{
  ::grpc::ClientContext context;

  auto request = ResetAttributeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);

  auto response = ResetAttributeResponse{};

  raise_if_error(
      stub->ResetAttribute(&context, request, &response),
      context);

  return response;
}

ResetToDefaultResponse
reset_to_default(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string)
{
  ::grpc::ClientContext context;

  auto request = ResetToDefaultRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);

  auto response = ResetToDefaultResponse{};

  raise_if_error(
      stub->ResetToDefault(&context, request, &response),
      context);

  return response;
}

SEMCfgAveragingResponse
sem_cfg_averaging(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<SemAveragingEnabled, pb::int32>& averaging_enabled, const pb::int32& averaging_count, const simple_variant<SemAveragingType, pb::int32>& averaging_type)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgAveragingRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto averaging_enabled_ptr = averaging_enabled.get_if<SemAveragingEnabled>();
  const auto averaging_enabled_raw_ptr = averaging_enabled.get_if<pb::int32>();
  if (averaging_enabled_ptr) {
    request.set_averaging_enabled(*averaging_enabled_ptr);
  }
  else if (averaging_enabled_raw_ptr) {
    request.set_averaging_enabled_raw(*averaging_enabled_raw_ptr);
  }
  request.set_averaging_count(averaging_count);
  const auto averaging_type_ptr = averaging_type.get_if<SemAveragingType>();
  const auto averaging_type_raw_ptr = averaging_type.get_if<pb::int32>();
  if (averaging_type_ptr) {
    request.set_averaging_type(*averaging_type_ptr);
  }
  else if (averaging_type_raw_ptr) {
    request.set_averaging_type_raw(*averaging_type_raw_ptr);
  }

  auto response = SEMCfgAveragingResponse{};

  raise_if_error(
      stub->SEMCfgAveraging(&context, request, &response),
      context);

  return response;
}

SEMCfgComponentCarrierMaximumOutputPowerResponse
sem_cfg_component_carrier_maximum_output_power(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& component_carrier_maximum_output_power)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgComponentCarrierMaximumOutputPowerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_component_carrier_maximum_output_power(component_carrier_maximum_output_power);

  auto response = SEMCfgComponentCarrierMaximumOutputPowerResponse{};

  raise_if_error(
      stub->SEMCfgComponentCarrierMaximumOutputPower(&context, request, &response),
      context);

  return response;
}

SEMCfgComponentCarrierMaximumOutputPowerArrayResponse
sem_cfg_component_carrier_maximum_output_power_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const std::vector<double>& component_carrier_maximum_output_power)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgComponentCarrierMaximumOutputPowerArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  copy_array(component_carrier_maximum_output_power, request.mutable_component_carrier_maximum_output_power());

  auto response = SEMCfgComponentCarrierMaximumOutputPowerArrayResponse{};

  raise_if_error(
      stub->SEMCfgComponentCarrierMaximumOutputPowerArray(&context, request, &response),
      context);

  return response;
}

SEMCfgDownlinkMaskResponse
sem_cfg_downlink_mask(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<SemDownlinkMaskType, pb::int32>& downlink_mask_type, const double& delta_f_maximum, const double& aggregated_maximum_power)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgDownlinkMaskRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto downlink_mask_type_ptr = downlink_mask_type.get_if<SemDownlinkMaskType>();
  const auto downlink_mask_type_raw_ptr = downlink_mask_type.get_if<pb::int32>();
  if (downlink_mask_type_ptr) {
    request.set_downlink_mask_type(*downlink_mask_type_ptr);
  }
  else if (downlink_mask_type_raw_ptr) {
    request.set_downlink_mask_type_raw(*downlink_mask_type_raw_ptr);
  }
  request.set_delta_f_maximum(delta_f_maximum);
  request.set_aggregated_maximum_power(aggregated_maximum_power);

  auto response = SEMCfgDownlinkMaskResponse{};

  raise_if_error(
      stub->SEMCfgDownlinkMask(&context, request, &response),
      context);

  return response;
}

SEMCfgNumberOfOffsetsResponse
sem_cfg_number_of_offsets(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& number_of_offsets)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgNumberOfOffsetsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_number_of_offsets(number_of_offsets);

  auto response = SEMCfgNumberOfOffsetsResponse{};

  raise_if_error(
      stub->SEMCfgNumberOfOffsets(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetAbsoluteLimitResponse
sem_cfg_offset_absolute_limit(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& offset_absolute_limit_start, const double& offset_absolute_limit_stop)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetAbsoluteLimitRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_offset_absolute_limit_start(offset_absolute_limit_start);
  request.set_offset_absolute_limit_stop(offset_absolute_limit_stop);

  auto response = SEMCfgOffsetAbsoluteLimitResponse{};

  raise_if_error(
      stub->SEMCfgOffsetAbsoluteLimit(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetAbsoluteLimitArrayResponse
sem_cfg_offset_absolute_limit_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const std::vector<double>& offset_absolute_limit_start, const std::vector<double>& offset_absolute_limit_stop)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetAbsoluteLimitArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  copy_array(offset_absolute_limit_start, request.mutable_offset_absolute_limit_start());
  copy_array(offset_absolute_limit_stop, request.mutable_offset_absolute_limit_stop());

  auto response = SEMCfgOffsetAbsoluteLimitArrayResponse{};

  raise_if_error(
      stub->SEMCfgOffsetAbsoluteLimitArray(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetBandwidthIntegralResponse
sem_cfg_offset_bandwidth_integral(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& offset_bandwidth_integral)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetBandwidthIntegralRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_offset_bandwidth_integral(offset_bandwidth_integral);

  auto response = SEMCfgOffsetBandwidthIntegralResponse{};

  raise_if_error(
      stub->SEMCfgOffsetBandwidthIntegral(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetBandwidthIntegralArrayResponse
sem_cfg_offset_bandwidth_integral_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const std::vector<pb::int32>& offset_bandwidth_integral)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetBandwidthIntegralArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  copy_array(offset_bandwidth_integral, request.mutable_offset_bandwidth_integral());

  auto response = SEMCfgOffsetBandwidthIntegralArrayResponse{};

  raise_if_error(
      stub->SEMCfgOffsetBandwidthIntegralArray(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetFrequencyResponse
sem_cfg_offset_frequency(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& offset_start_frequency, const double& offset_stop_frequency, const simple_variant<SemOffsetSideband, pb::int32>& offset_sideband)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetFrequencyRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_offset_start_frequency(offset_start_frequency);
  request.set_offset_stop_frequency(offset_stop_frequency);
  const auto offset_sideband_ptr = offset_sideband.get_if<SemOffsetSideband>();
  const auto offset_sideband_raw_ptr = offset_sideband.get_if<pb::int32>();
  if (offset_sideband_ptr) {
    request.set_offset_sideband(*offset_sideband_ptr);
  }
  else if (offset_sideband_raw_ptr) {
    request.set_offset_sideband_raw(*offset_sideband_raw_ptr);
  }

  auto response = SEMCfgOffsetFrequencyResponse{};

  raise_if_error(
      stub->SEMCfgOffsetFrequency(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetFrequencyArrayResponse
sem_cfg_offset_frequency_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const std::vector<double>& offset_start_frequency, const std::vector<double>& offset_stop_frequency, const std::vector<pb::int32>& offset_sideband)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetFrequencyArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  copy_array(offset_start_frequency, request.mutable_offset_start_frequency());
  copy_array(offset_stop_frequency, request.mutable_offset_stop_frequency());
  copy_array(offset_sideband, request.mutable_offset_sideband());

  auto response = SEMCfgOffsetFrequencyArrayResponse{};

  raise_if_error(
      stub->SEMCfgOffsetFrequencyArray(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetLimitFailMaskResponse
sem_cfg_offset_limit_fail_mask(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<SemOffsetLimitFailMask, pb::int32>& limit_fail_mask)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetLimitFailMaskRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto limit_fail_mask_ptr = limit_fail_mask.get_if<SemOffsetLimitFailMask>();
  const auto limit_fail_mask_raw_ptr = limit_fail_mask.get_if<pb::int32>();
  if (limit_fail_mask_ptr) {
    request.set_limit_fail_mask(*limit_fail_mask_ptr);
  }
  else if (limit_fail_mask_raw_ptr) {
    request.set_limit_fail_mask_raw(*limit_fail_mask_raw_ptr);
  }

  auto response = SEMCfgOffsetLimitFailMaskResponse{};

  raise_if_error(
      stub->SEMCfgOffsetLimitFailMask(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetLimitFailMaskArrayResponse
sem_cfg_offset_limit_fail_mask_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const std::vector<pb::int32>& limit_fail_mask)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetLimitFailMaskArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  copy_array(limit_fail_mask, request.mutable_limit_fail_mask());

  auto response = SEMCfgOffsetLimitFailMaskArrayResponse{};

  raise_if_error(
      stub->SEMCfgOffsetLimitFailMaskArray(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetRBWFilterResponse
sem_cfg_offset_rbw_filter(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& offset_rbw, const simple_variant<SemOffsetRbwFilterType, pb::int32>& offset_rbw_filter_type)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetRBWFilterRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_offset_rbw(offset_rbw);
  const auto offset_rbw_filter_type_ptr = offset_rbw_filter_type.get_if<SemOffsetRbwFilterType>();
  const auto offset_rbw_filter_type_raw_ptr = offset_rbw_filter_type.get_if<pb::int32>();
  if (offset_rbw_filter_type_ptr) {
    request.set_offset_rbw_filter_type(*offset_rbw_filter_type_ptr);
  }
  else if (offset_rbw_filter_type_raw_ptr) {
    request.set_offset_rbw_filter_type_raw(*offset_rbw_filter_type_raw_ptr);
  }

  auto response = SEMCfgOffsetRBWFilterResponse{};

  raise_if_error(
      stub->SEMCfgOffsetRBWFilter(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetRBWFilterArrayResponse
sem_cfg_offset_rbw_filter_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const std::vector<double>& offset_rbw, const std::vector<pb::int32>& offset_rbw_filter_type)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetRBWFilterArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  copy_array(offset_rbw, request.mutable_offset_rbw());
  copy_array(offset_rbw_filter_type, request.mutable_offset_rbw_filter_type());

  auto response = SEMCfgOffsetRBWFilterArrayResponse{};

  raise_if_error(
      stub->SEMCfgOffsetRBWFilterArray(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetRelativeLimitResponse
sem_cfg_offset_relative_limit(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& relative_limit_start, const double& relative_limit_stop)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetRelativeLimitRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_relative_limit_start(relative_limit_start);
  request.set_relative_limit_stop(relative_limit_stop);

  auto response = SEMCfgOffsetRelativeLimitResponse{};

  raise_if_error(
      stub->SEMCfgOffsetRelativeLimit(&context, request, &response),
      context);

  return response;
}

SEMCfgOffsetRelativeLimitArrayResponse
sem_cfg_offset_relative_limit_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const std::vector<double>& relative_limit_start, const std::vector<double>& relative_limit_stop)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgOffsetRelativeLimitArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  copy_array(relative_limit_start, request.mutable_relative_limit_start());
  copy_array(relative_limit_stop, request.mutable_relative_limit_stop());

  auto response = SEMCfgOffsetRelativeLimitArrayResponse{};

  raise_if_error(
      stub->SEMCfgOffsetRelativeLimitArray(&context, request, &response),
      context);

  return response;
}

SEMCfgSweepTimeResponse
sem_cfg_sweep_time(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<SemSweepTimeAuto, pb::int32>& sweep_time_auto, const double& sweep_time_interval)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgSweepTimeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto sweep_time_auto_ptr = sweep_time_auto.get_if<SemSweepTimeAuto>();
  const auto sweep_time_auto_raw_ptr = sweep_time_auto.get_if<pb::int32>();
  if (sweep_time_auto_ptr) {
    request.set_sweep_time_auto(*sweep_time_auto_ptr);
  }
  else if (sweep_time_auto_raw_ptr) {
    request.set_sweep_time_auto_raw(*sweep_time_auto_raw_ptr);
  }
  request.set_sweep_time_interval(sweep_time_interval);

  auto response = SEMCfgSweepTimeResponse{};

  raise_if_error(
      stub->SEMCfgSweepTime(&context, request, &response),
      context);

  return response;
}

SEMCfgUplinkMaskTypeResponse
sem_cfg_uplink_mask_type(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<SemUplinkMaskType, pb::int32>& uplink_mask_type)
{
  ::grpc::ClientContext context;

  auto request = SEMCfgUplinkMaskTypeRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto uplink_mask_type_ptr = uplink_mask_type.get_if<SemUplinkMaskType>();
  const auto uplink_mask_type_raw_ptr = uplink_mask_type.get_if<pb::int32>();
  if (uplink_mask_type_ptr) {
    request.set_uplink_mask_type(*uplink_mask_type_ptr);
  }
  else if (uplink_mask_type_raw_ptr) {
    request.set_uplink_mask_type_raw(*uplink_mask_type_raw_ptr);
  }

  auto response = SEMCfgUplinkMaskTypeResponse{};

  raise_if_error(
      stub->SEMCfgUplinkMaskType(&context, request, &response),
      context);

  return response;
}

SEMFetchComponentCarrierMeasurementResponse
sem_fetch_component_carrier_measurement(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchComponentCarrierMeasurementRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchComponentCarrierMeasurementResponse{};

  raise_if_error(
      stub->SEMFetchComponentCarrierMeasurement(&context, request, &response),
      context);

  return response;
}

SEMFetchComponentCarrierMeasurementArrayResponse
sem_fetch_component_carrier_measurement_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchComponentCarrierMeasurementArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchComponentCarrierMeasurementArrayResponse{};

  raise_if_error(
      stub->SEMFetchComponentCarrierMeasurementArray(&context, request, &response),
      context);

  return response;
}

SEMFetchLowerOffsetMarginResponse
sem_fetch_lower_offset_margin(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchLowerOffsetMarginRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchLowerOffsetMarginResponse{};

  raise_if_error(
      stub->SEMFetchLowerOffsetMargin(&context, request, &response),
      context);

  return response;
}

SEMFetchLowerOffsetMarginArrayResponse
sem_fetch_lower_offset_margin_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchLowerOffsetMarginArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchLowerOffsetMarginArrayResponse{};

  raise_if_error(
      stub->SEMFetchLowerOffsetMarginArray(&context, request, &response),
      context);

  return response;
}

SEMFetchLowerOffsetPowerResponse
sem_fetch_lower_offset_power(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchLowerOffsetPowerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchLowerOffsetPowerResponse{};

  raise_if_error(
      stub->SEMFetchLowerOffsetPower(&context, request, &response),
      context);

  return response;
}

SEMFetchLowerOffsetPowerArrayResponse
sem_fetch_lower_offset_power_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchLowerOffsetPowerArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchLowerOffsetPowerArrayResponse{};

  raise_if_error(
      stub->SEMFetchLowerOffsetPowerArray(&context, request, &response),
      context);

  return response;
}

SEMFetchMeasurementStatusResponse
sem_fetch_measurement_status(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchMeasurementStatusRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchMeasurementStatusResponse{};

  raise_if_error(
      stub->SEMFetchMeasurementStatus(&context, request, &response),
      context);

  return response;
}

SEMFetchSpectrumResponse
sem_fetch_spectrum(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchSpectrumRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchSpectrumResponse{};

  raise_if_error(
      stub->SEMFetchSpectrum(&context, request, &response),
      context);

  return response;
}

SEMFetchSubblockMeasurementResponse
sem_fetch_subblock_measurement(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchSubblockMeasurementRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchSubblockMeasurementResponse{};

  raise_if_error(
      stub->SEMFetchSubblockMeasurement(&context, request, &response),
      context);

  return response;
}

SEMFetchTotalAggregatedPowerResponse
sem_fetch_total_aggregated_power(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchTotalAggregatedPowerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchTotalAggregatedPowerResponse{};

  raise_if_error(
      stub->SEMFetchTotalAggregatedPower(&context, request, &response),
      context);

  return response;
}

SEMFetchUpperOffsetMarginResponse
sem_fetch_upper_offset_margin(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchUpperOffsetMarginRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchUpperOffsetMarginResponse{};

  raise_if_error(
      stub->SEMFetchUpperOffsetMargin(&context, request, &response),
      context);

  return response;
}

SEMFetchUpperOffsetMarginArrayResponse
sem_fetch_upper_offset_margin_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchUpperOffsetMarginArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchUpperOffsetMarginArrayResponse{};

  raise_if_error(
      stub->SEMFetchUpperOffsetMarginArray(&context, request, &response),
      context);

  return response;
}

SEMFetchUpperOffsetPowerResponse
sem_fetch_upper_offset_power(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchUpperOffsetPowerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchUpperOffsetPowerResponse{};

  raise_if_error(
      stub->SEMFetchUpperOffsetPower(&context, request, &response),
      context);

  return response;
}

SEMFetchUpperOffsetPowerArrayResponse
sem_fetch_upper_offset_power_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SEMFetchUpperOffsetPowerArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SEMFetchUpperOffsetPowerArrayResponse{};

  raise_if_error(
      stub->SEMFetchUpperOffsetPowerArray(&context, request, &response),
      context);

  return response;
}

SelectMeasurementsResponse
select_measurements(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<MeasurementTypes, pb::uint32>& measurements, const bool& enable_all_traces)
{
  ::grpc::ClientContext context;

  auto request = SelectMeasurementsRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto measurements_ptr = measurements.get_if<MeasurementTypes>();
  const auto measurements_raw_ptr = measurements.get_if<pb::uint32>();
  if (measurements_ptr) {
    request.set_measurements(*measurements_ptr);
  }
  else if (measurements_raw_ptr) {
    request.set_measurements_raw(*measurements_raw_ptr);
  }
  request.set_enable_all_traces(enable_all_traces);

  auto response = SelectMeasurementsResponse{};

  raise_if_error(
      stub->SelectMeasurements(&context, request, &response),
      context);

  return response;
}

SendSoftwareEdgeTriggerResponse
send_software_edge_trigger(const StubPtr& stub, const nidevice_grpc::Session& instrument)
{
  ::grpc::ClientContext context;

  auto request = SendSoftwareEdgeTriggerRequest{};
  request.mutable_instrument()->CopyFrom(instrument);

  auto response = SendSoftwareEdgeTriggerResponse{};

  raise_if_error(
      stub->SendSoftwareEdgeTrigger(&context, request, &response),
      context);

  return response;
}

SetAttributeF32Response
set_attribute_f32(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const float& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeF32Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  request.set_attr_val(attr_val);

  auto response = SetAttributeF32Response{};

  raise_if_error(
      stub->SetAttributeF32(&context, request, &response),
      context);

  return response;
}

SetAttributeF32ArrayResponse
set_attribute_f32_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const std::vector<float>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeF32ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  copy_array(attr_val, request.mutable_attr_val());

  auto response = SetAttributeF32ArrayResponse{};

  raise_if_error(
      stub->SetAttributeF32Array(&context, request, &response),
      context);

  return response;
}

SetAttributeF64Response
set_attribute_f64(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const double& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeF64Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  request.set_attr_val(attr_val);

  auto response = SetAttributeF64Response{};

  raise_if_error(
      stub->SetAttributeF64(&context, request, &response),
      context);

  return response;
}

SetAttributeF64ArrayResponse
set_attribute_f64_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const std::vector<double>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeF64ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  copy_array(attr_val, request.mutable_attr_val());

  auto response = SetAttributeF64ArrayResponse{};

  raise_if_error(
      stub->SetAttributeF64Array(&context, request, &response),
      context);

  return response;
}

SetAttributeI16Response
set_attribute_i16(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const pb::int32& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeI16Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  request.set_attr_val(attr_val);

  auto response = SetAttributeI16Response{};

  raise_if_error(
      stub->SetAttributeI16(&context, request, &response),
      context);

  return response;
}

SetAttributeI32Response
set_attribute_i32(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const simple_variant<NiRFmxLTEInt32AttributeValues, pb::int32>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeI32Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  const auto attr_val_ptr = attr_val.get_if<NiRFmxLTEInt32AttributeValues>();
  const auto attr_val_raw_ptr = attr_val.get_if<pb::int32>();
  if (attr_val_ptr) {
    request.set_attr_val(*attr_val_ptr);
  }
  else if (attr_val_raw_ptr) {
    request.set_attr_val_raw(*attr_val_raw_ptr);
  }

  auto response = SetAttributeI32Response{};

  raise_if_error(
      stub->SetAttributeI32(&context, request, &response),
      context);

  return response;
}

SetAttributeI32ArrayResponse
set_attribute_i32_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const std::vector<pb::int32>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeI32ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  copy_array(attr_val, request.mutable_attr_val());

  auto response = SetAttributeI32ArrayResponse{};

  raise_if_error(
      stub->SetAttributeI32Array(&context, request, &response),
      context);

  return response;
}

SetAttributeI64Response
set_attribute_i64(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const pb::int64& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeI64Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  request.set_attr_val(attr_val);

  auto response = SetAttributeI64Response{};

  raise_if_error(
      stub->SetAttributeI64(&context, request, &response),
      context);

  return response;
}

SetAttributeI64ArrayResponse
set_attribute_i64_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const std::vector<pb::int64>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeI64ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  copy_array(attr_val, request.mutable_attr_val());

  auto response = SetAttributeI64ArrayResponse{};

  raise_if_error(
      stub->SetAttributeI64Array(&context, request, &response),
      context);

  return response;
}

SetAttributeI8Response
set_attribute_i8(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const pb::int32& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeI8Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  request.set_attr_val(attr_val);

  auto response = SetAttributeI8Response{};

  raise_if_error(
      stub->SetAttributeI8(&context, request, &response),
      context);

  return response;
}

SetAttributeI8ArrayResponse
set_attribute_i8_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const std::vector<pb::int32>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeI8ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  copy_array(attr_val, request.mutable_attr_val());

  auto response = SetAttributeI8ArrayResponse{};

  raise_if_error(
      stub->SetAttributeI8Array(&context, request, &response),
      context);

  return response;
}

SetAttributeNIComplexDoubleArrayResponse
set_attribute_ni_complex_double_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const std::vector<nidevice_grpc::NIComplexNumber>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeNIComplexDoubleArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  copy_array(attr_val, request.mutable_attr_val());

  auto response = SetAttributeNIComplexDoubleArrayResponse{};

  raise_if_error(
      stub->SetAttributeNIComplexDoubleArray(&context, request, &response),
      context);

  return response;
}

SetAttributeNIComplexSingleArrayResponse
set_attribute_ni_complex_single_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const std::vector<nidevice_grpc::NIComplexNumberF32>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeNIComplexSingleArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  copy_array(attr_val, request.mutable_attr_val());

  auto response = SetAttributeNIComplexSingleArrayResponse{};

  raise_if_error(
      stub->SetAttributeNIComplexSingleArray(&context, request, &response),
      context);

  return response;
}

SetAttributeStringResponse
set_attribute_string(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const simple_variant<NiRFmxLTEStringAttributeValuesMapped, std::string>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeStringRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  const auto attr_val_ptr = attr_val.get_if<NiRFmxLTEStringAttributeValuesMapped>();
  const auto attr_val_raw_ptr = attr_val.get_if<std::string>();
  if (attr_val_ptr) {
    request.set_attr_val_mapped(*attr_val_ptr);
  }
  else if (attr_val_raw_ptr) {
    request.set_attr_val_raw(*attr_val_raw_ptr);
  }

  auto response = SetAttributeStringResponse{};

  raise_if_error(
      stub->SetAttributeString(&context, request, &response),
      context);

  return response;
}

SetAttributeU16Response
set_attribute_u16(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const pb::uint32& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeU16Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  request.set_attr_val(attr_val);

  auto response = SetAttributeU16Response{};

  raise_if_error(
      stub->SetAttributeU16(&context, request, &response),
      context);

  return response;
}

SetAttributeU32Response
set_attribute_u32(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const pb::uint32& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeU32Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  request.set_attr_val(attr_val);

  auto response = SetAttributeU32Response{};

  raise_if_error(
      stub->SetAttributeU32(&context, request, &response),
      context);

  return response;
}

SetAttributeU32ArrayResponse
set_attribute_u32_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const std::vector<pb::uint32>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeU32ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  copy_array(attr_val, request.mutable_attr_val());

  auto response = SetAttributeU32ArrayResponse{};

  raise_if_error(
      stub->SetAttributeU32Array(&context, request, &response),
      context);

  return response;
}

SetAttributeU64ArrayResponse
set_attribute_u64_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const std::vector<pb::uint64>& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeU64ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  copy_array(attr_val, request.mutable_attr_val());

  auto response = SetAttributeU64ArrayResponse{};

  raise_if_error(
      stub->SetAttributeU64Array(&context, request, &response),
      context);

  return response;
}

SetAttributeU8Response
set_attribute_u8(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const pb::uint32& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeU8Request{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  request.set_attr_val(attr_val);

  auto response = SetAttributeU8Response{};

  raise_if_error(
      stub->SetAttributeU8(&context, request, &response),
      context);

  return response;
}

SetAttributeU8ArrayResponse
set_attribute_u8_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const NiRFmxLTEAttribute& attribute_id, const pb::string& attr_val)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeU8ArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_attribute_id(attribute_id);
  request.set_attr_val(attr_val);

  auto response = SetAttributeU8ArrayResponse{};

  raise_if_error(
      stub->SetAttributeU8Array(&context, request, &response),
      context);

  return response;
}

SlotPhaseCfgSynchronizationModeAndIntervalResponse
slot_phase_cfg_synchronization_mode_and_interval(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const simple_variant<SlotPhaseSynchronizationMode, pb::int32>& synchronization_mode, const pb::int32& measurement_offset, const pb::int32& measurement_length)
{
  ::grpc::ClientContext context;

  auto request = SlotPhaseCfgSynchronizationModeAndIntervalRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  const auto synchronization_mode_ptr = synchronization_mode.get_if<SlotPhaseSynchronizationMode>();
  const auto synchronization_mode_raw_ptr = synchronization_mode.get_if<pb::int32>();
  if (synchronization_mode_ptr) {
    request.set_synchronization_mode(*synchronization_mode_ptr);
  }
  else if (synchronization_mode_raw_ptr) {
    request.set_synchronization_mode_raw(*synchronization_mode_raw_ptr);
  }
  request.set_measurement_offset(measurement_offset);
  request.set_measurement_length(measurement_length);

  auto response = SlotPhaseCfgSynchronizationModeAndIntervalResponse{};

  raise_if_error(
      stub->SlotPhaseCfgSynchronizationModeAndInterval(&context, request, &response),
      context);

  return response;
}

SlotPhaseFetchMaximumPhaseDiscontinuityResponse
slot_phase_fetch_maximum_phase_discontinuity(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SlotPhaseFetchMaximumPhaseDiscontinuityRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SlotPhaseFetchMaximumPhaseDiscontinuityResponse{};

  raise_if_error(
      stub->SlotPhaseFetchMaximumPhaseDiscontinuity(&context, request, &response),
      context);

  return response;
}

SlotPhaseFetchMaximumPhaseDiscontinuityArrayResponse
slot_phase_fetch_maximum_phase_discontinuity_array(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SlotPhaseFetchMaximumPhaseDiscontinuityArrayRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SlotPhaseFetchMaximumPhaseDiscontinuityArrayResponse{};

  raise_if_error(
      stub->SlotPhaseFetchMaximumPhaseDiscontinuityArray(&context, request, &response),
      context);

  return response;
}

SlotPhaseFetchPhaseDiscontinuitiesResponse
slot_phase_fetch_phase_discontinuities(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SlotPhaseFetchPhaseDiscontinuitiesRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SlotPhaseFetchPhaseDiscontinuitiesResponse{};

  raise_if_error(
      stub->SlotPhaseFetchPhaseDiscontinuities(&context, request, &response),
      context);

  return response;
}

SlotPhaseFetchSamplePhaseErrorResponse
slot_phase_fetch_sample_phase_error(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SlotPhaseFetchSamplePhaseErrorRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SlotPhaseFetchSamplePhaseErrorResponse{};

  raise_if_error(
      stub->SlotPhaseFetchSamplePhaseError(&context, request, &response),
      context);

  return response;
}

SlotPhaseFetchSamplePhaseErrorLinearFitTraceResponse
slot_phase_fetch_sample_phase_error_linear_fit_trace(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SlotPhaseFetchSamplePhaseErrorLinearFitTraceRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SlotPhaseFetchSamplePhaseErrorLinearFitTraceResponse{};

  raise_if_error(
      stub->SlotPhaseFetchSamplePhaseErrorLinearFitTrace(&context, request, &response),
      context);

  return response;
}

SlotPowerCfgMeasurementIntervalResponse
slot_power_cfg_measurement_interval(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const pb::int32& measurement_offset, const pb::int32& measurement_length)
{
  ::grpc::ClientContext context;

  auto request = SlotPowerCfgMeasurementIntervalRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_measurement_offset(measurement_offset);
  request.set_measurement_length(measurement_length);

  auto response = SlotPowerCfgMeasurementIntervalResponse{};

  raise_if_error(
      stub->SlotPowerCfgMeasurementInterval(&context, request, &response),
      context);

  return response;
}

SlotPowerFetchPowersResponse
slot_power_fetch_powers(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = SlotPowerFetchPowersRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = SlotPowerFetchPowersResponse{};

  raise_if_error(
      stub->SlotPowerFetchPowers(&context, request, &response),
      context);

  return response;
}

WaitForAcquisitionCompleteResponse
wait_for_acquisition_complete(const StubPtr& stub, const nidevice_grpc::Session& instrument, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = WaitForAcquisitionCompleteRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_timeout(timeout);

  auto response = WaitForAcquisitionCompleteResponse{};

  raise_if_error(
      stub->WaitForAcquisitionComplete(&context, request, &response),
      context);

  return response;
}

WaitForMeasurementCompleteResponse
wait_for_measurement_complete(const StubPtr& stub, const nidevice_grpc::Session& instrument, const pb::string& selector_string, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = WaitForMeasurementCompleteRequest{};
  request.mutable_instrument()->CopyFrom(instrument);
  request.set_selector_string(selector_string);
  request.set_timeout(timeout);

  auto response = WaitForMeasurementCompleteResponse{};

  raise_if_error(
      stub->WaitForMeasurementComplete(&context, request, &response),
      context);

  return response;
}


} // namespace nirfmxlte_grpc::experimental::client
