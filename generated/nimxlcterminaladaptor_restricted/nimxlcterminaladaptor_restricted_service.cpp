
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-MXLCTERMINALADAPTOR-RESTRICTED Metadata
//---------------------------------------------------------------------
#include "nimxlcterminaladaptor_restricted_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/nimxlcterminaladaptor_restricted_converters.h"
#include <server/converters.h>

namespace nimxlcterminaladaptor_restricted_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  NimxlcTerminalAdaptorRestrictedService::NimxlcTerminalAdaptorRestrictedService(
      NimxlcTerminalAdaptorRestrictedLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      const NimxlcTerminalAdaptorRestrictedFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NimxlcTerminalAdaptorRestrictedService::~NimxlcTerminalAdaptorRestrictedService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NimxlcTerminalAdaptorRestrictedService::CreateSession(::grpc::ServerContext* context, const CreateSessionRequest* request, CreateSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto hostname_mbcs = convert_from_grpc<std::string>(request->hostname());
      auto hostname = hostname_mbcs.c_str();
      auto initialization_behavior = request->initialization_behavior();

      auto c_status = allocate_output_storage<nierr_Status, NIErrStatus>(context);
      bool new_session_initialized {};
      auto init_lambda = [&] () {
        auto handle = library_->createSession(hostname, &c_status);
        auto status = (&c_status)->code;
        return std::make_tuple(status, handle);
      };
      std::string grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (nimxlc_Session id) { library_->destroySession(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNimxlc_Session(context, status, 0);
      }
      response->set_status(status);
      convert_to_grpc(c_status, response->mutable_c_status());
      response->mutable_handle()->set_name(grpc_device_session_name);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NimxlcTerminalAdaptorRestrictedService::DestroySession(::grpc::ServerContext* context, const DestroySessionRequest* request, DestroySessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nimxlc_Session session = session_repository_->access_session(session_grpc_session.name());
      session_repository_->remove_session(session_grpc_session.name());
      library_->destroySession(session);
      auto status = 0;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNimxlc_Session(context, status, session);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NimxlcTerminalAdaptorRestrictedService::RefreshTerminalCache(::grpc::ServerContext* context, const RefreshTerminalCacheRequest* request, RefreshTerminalCacheResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nimxlc_Session session = session_repository_->access_session(session_grpc_session.name());
      auto c_status = allocate_output_storage<nierr_Status, NIErrStatus>(context);
      library_->refreshTerminalCache(session, &c_status);
      auto status = (&c_status)->code;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNimxlc_Session(context, status, session);
      }
      response->set_status(status);
      convert_to_grpc(c_status, response->mutable_c_status());
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NimxlcTerminalAdaptorRestrictedService::HasTerminalInformationChanged(::grpc::ServerContext* context, const HasTerminalInformationChangedRequest* request, HasTerminalInformationChangedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nimxlc_Session session = session_repository_->access_session(session_grpc_session.name());
      uint32_t system_change_number = request->system_change_number();
      auto c_status = allocate_output_storage<nierr_Status, NIErrStatus>(context);
      auto terminal_information_changed = library_->hasTerminalInformationChanged(session, system_change_number, &c_status);
      auto status = (&c_status)->code;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNimxlc_Session(context, status, session);
      }
      response->set_status(status);
      convert_to_grpc(c_status, response->mutable_c_status());
      response->set_terminal_information_changed(terminal_information_changed);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NimxlcTerminalAdaptorRestrictedService::GetSystemChangeNumber(::grpc::ServerContext* context, const GetSystemChangeNumberRequest* request, GetSystemChangeNumberResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nimxlc_Session session = session_repository_->access_session(session_grpc_session.name());
      auto c_status = allocate_output_storage<nierr_Status, NIErrStatus>(context);
      auto system_change_number = library_->getSystemChangeNumber(session, &c_status);
      auto status = (&c_status)->code;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNimxlc_Session(context, status, session);
      }
      response->set_status(status);
      convert_to_grpc(c_status, response->mutable_c_status());
      response->set_system_change_number(system_change_number);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  NimxlcTerminalAdaptorRestrictedFeatureToggles::NimxlcTerminalAdaptorRestrictedFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nimxlcterminaladaptor_restricted", CodeReadiness::kRelease))
  {
  }
} // namespace nimxlcterminaladaptor_restricted_grpc

