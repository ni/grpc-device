
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-FGEN Metadata
//---------------------------------------------------------------------
#include "nifgen_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/ivi_errors.h"
#include <server/converters.h>

namespace nifgen_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiFgenService::NiFgenService(
      LibrarySharedPtr library,
      ResourceRepositorySharedPtr resource_repository,
      const NiFgenFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiFgenService::~NiFgenService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::AbortGeneration(::grpc::ServerContext* context, const AbortGenerationRequest* request, AbortGenerationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->AbortGeneration(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::AdjustSampleClockRelativeDelay(::grpc::ServerContext* context, const AdjustSampleClockRelativeDelayRequest* request, AdjustSampleClockRelativeDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViReal64 adjustment_time = request->adjustment_time();
      auto status = library_->AdjustSampleClockRelativeDelay(vi, adjustment_time);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::AllocateNamedWaveform(::grpc::ServerContext* context, const AllocateNamedWaveformRequest* request, AllocateNamedWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto waveform_name_mbcs = convert_from_grpc<std::string>(request->waveform_name());
      auto waveform_name = waveform_name_mbcs.c_str();
      ViInt32 waveform_size = request->waveform_size();
      auto status = library_->AllocateNamedWaveform(vi, channel_name, waveform_name, waveform_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::AllocateWaveform(::grpc::ServerContext* context, const AllocateWaveformRequest* request, AllocateWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 waveform_size = request->waveform_size();
      ViInt32 waveform_handle {};
      auto status = library_->AllocateWaveform(vi, channel_name, waveform_size, &waveform_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_waveform_handle(waveform_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CheckAttributeViBoolean(::grpc::ServerContext* context, const CheckAttributeViBooleanRequest* request, CheckAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViBoolean attribute_value = request->attribute_value();
      auto status = library_->CheckAttributeViBoolean(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CheckAttributeViInt32(::grpc::ServerContext* context, const CheckAttributeViInt32Request* request, CheckAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt32 attribute_value;
      switch (request->attribute_value_enum_case()) {
        case nifgen_grpc::CheckAttributeViInt32Request::AttributeValueEnumCase::kAttributeValue: {
          attribute_value = static_cast<ViInt32>(request->attribute_value());
          break;
        }
        case nifgen_grpc::CheckAttributeViInt32Request::AttributeValueEnumCase::kAttributeValueRaw: {
          attribute_value = static_cast<ViInt32>(request->attribute_value_raw());
          break;
        }
        case nifgen_grpc::CheckAttributeViInt32Request::AttributeValueEnumCase::ATTRIBUTE_VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute_value was not specified or out of range");
          break;
        }
      }

      auto status = library_->CheckAttributeViInt32(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CheckAttributeViInt64(::grpc::ServerContext* context, const CheckAttributeViInt64Request* request, CheckAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt64 attribute_value = request->attribute_value_raw();
      auto status = library_->CheckAttributeViInt64(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CheckAttributeViReal64(::grpc::ServerContext* context, const CheckAttributeViReal64Request* request, CheckAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViReal64 attribute_value;
      switch (request->attribute_value_enum_case()) {
        case nifgen_grpc::CheckAttributeViReal64Request::AttributeValueEnumCase::kAttributeValue: {
          attribute_value = static_cast<ViReal64>(request->attribute_value());
          break;
        }
        case nifgen_grpc::CheckAttributeViReal64Request::AttributeValueEnumCase::kAttributeValueRaw: {
          attribute_value = static_cast<ViReal64>(request->attribute_value_raw());
          break;
        }
        case nifgen_grpc::CheckAttributeViReal64Request::AttributeValueEnumCase::ATTRIBUTE_VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute_value was not specified or out of range");
          break;
        }
      }

      auto status = library_->CheckAttributeViReal64(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CheckAttributeViSession(::grpc::ServerContext* context, const CheckAttributeViSessionRequest* request, CheckAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      auto attribute_value_grpc_session = request->attribute_value();
      ViSession attribute_value = session_repository_->access_session(attribute_value_grpc_session.name());
      auto status = library_->CheckAttributeViSession(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CheckAttributeViString(::grpc::ServerContext* context, const CheckAttributeViStringRequest* request, CheckAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViConstString attribute_value;
      std::string attribute_value_buffer;
      switch (request->attribute_value_enum_case()) {
        case nifgen_grpc::CheckAttributeViStringRequest::AttributeValueEnumCase::kAttributeValueMapped: {
          auto attribute_value_imap_it = nifgenstringattributevaluesmapped_input_map_.find(request->attribute_value_mapped());
          if (attribute_value_imap_it == nifgenstringattributevaluesmapped_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute_value_mapped was not specified or out of range.");
          }
          attribute_value = const_cast<ViConstString>((attribute_value_imap_it->second).c_str());
          break;
        }
        case nifgen_grpc::CheckAttributeViStringRequest::AttributeValueEnumCase::kAttributeValueRaw: {
          attribute_value_buffer = convert_from_grpc<std::string>(request->attribute_value_raw());
          attribute_value = const_cast<ViConstString>(attribute_value_buffer.c_str());
          break;
        }
        case nifgen_grpc::CheckAttributeViStringRequest::AttributeValueEnumCase::ATTRIBUTE_VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute_value was not specified or out of range");
          break;
        }
      }

      auto status = library_->CheckAttributeViString(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ClearArbMemory(::grpc::ServerContext* context, const ClearArbMemoryRequest* request, ClearArbMemoryResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ClearArbMemory(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ClearArbSequence(::grpc::ServerContext* context, const ClearArbSequenceRequest* request, ClearArbSequenceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 sequence_handle;
      switch (request->sequence_handle_enum_case()) {
        case nifgen_grpc::ClearArbSequenceRequest::SequenceHandleEnumCase::kSequenceHandle: {
          sequence_handle = static_cast<ViInt32>(request->sequence_handle());
          break;
        }
        case nifgen_grpc::ClearArbSequenceRequest::SequenceHandleEnumCase::kSequenceHandleRaw: {
          sequence_handle = static_cast<ViInt32>(request->sequence_handle_raw());
          break;
        }
        case nifgen_grpc::ClearArbSequenceRequest::SequenceHandleEnumCase::SEQUENCE_HANDLE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sequence_handle was not specified or out of range");
          break;
        }
      }

      auto status = library_->ClearArbSequence(vi, sequence_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ClearArbWaveform(::grpc::ServerContext* context, const ClearArbWaveformRequest* request, ClearArbWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 waveform_handle;
      switch (request->waveform_handle_enum_case()) {
        case nifgen_grpc::ClearArbWaveformRequest::WaveformHandleEnumCase::kWaveformHandle: {
          waveform_handle = static_cast<ViInt32>(request->waveform_handle());
          break;
        }
        case nifgen_grpc::ClearArbWaveformRequest::WaveformHandleEnumCase::kWaveformHandleRaw: {
          waveform_handle = static_cast<ViInt32>(request->waveform_handle_raw());
          break;
        }
        case nifgen_grpc::ClearArbWaveformRequest::WaveformHandleEnumCase::WAVEFORM_HANDLE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for waveform_handle was not specified or out of range");
          break;
        }
      }

      auto status = library_->ClearArbWaveform(vi, waveform_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ClearError(::grpc::ServerContext* context, const ClearErrorRequest* request, ClearErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ClearError(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ClearFreqList(::grpc::ServerContext* context, const ClearFreqListRequest* request, ClearFreqListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 frequency_list_handle;
      switch (request->frequency_list_handle_enum_case()) {
        case nifgen_grpc::ClearFreqListRequest::FrequencyListHandleEnumCase::kFrequencyListHandle: {
          frequency_list_handle = static_cast<ViInt32>(request->frequency_list_handle());
          break;
        }
        case nifgen_grpc::ClearFreqListRequest::FrequencyListHandleEnumCase::kFrequencyListHandleRaw: {
          frequency_list_handle = static_cast<ViInt32>(request->frequency_list_handle_raw());
          break;
        }
        case nifgen_grpc::ClearFreqListRequest::FrequencyListHandleEnumCase::FREQUENCY_LIST_HANDLE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for frequency_list_handle was not specified or out of range");
          break;
        }
      }

      auto status = library_->ClearFreqList(vi, frequency_list_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ClearInterchangeWarnings(::grpc::ServerContext* context, const ClearInterchangeWarningsRequest* request, ClearInterchangeWarningsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ClearInterchangeWarnings(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ClearUserStandardWaveform(::grpc::ServerContext* context, const ClearUserStandardWaveformRequest* request, ClearUserStandardWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->ClearUserStandardWaveform(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      session_repository_->remove_session(vi_grpc_session.name());
      auto status = library_->Close(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::Commit(::grpc::ServerContext* context, const CommitRequest* request, CommitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Commit(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureAmplitude(::grpc::ServerContext* context, const ConfigureAmplitudeRequest* request, ConfigureAmplitudeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 amplitude = request->amplitude();
      auto status = library_->ConfigureAmplitude(vi, channel_name, amplitude);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureArbSequence(::grpc::ServerContext* context, const ConfigureArbSequenceRequest* request, ConfigureArbSequenceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 sequence_handle = request->sequence_handle();
      ViReal64 gain = request->gain();
      ViReal64 offset = request->offset();
      auto status = library_->ConfigureArbSequence(vi, channel_name, sequence_handle, gain, offset);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureArbWaveform(::grpc::ServerContext* context, const ConfigureArbWaveformRequest* request, ConfigureArbWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 waveform_handle = request->waveform_handle();
      ViReal64 gain = request->gain();
      ViReal64 offset = request->offset();
      auto status = library_->ConfigureArbWaveform(vi, channel_name, waveform_handle, gain, offset);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureChannels(::grpc::ServerContext* context, const ConfigureChannelsRequest* request, ConfigureChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channels_mbcs = convert_from_grpc<std::string>(request->channels());
      auto channels = channels_mbcs.c_str();
      auto status = library_->ConfigureChannels(vi, channels);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureClockMode(::grpc::ServerContext* context, const ConfigureClockModeRequest* request, ConfigureClockModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 clock_mode;
      switch (request->clock_mode_enum_case()) {
        case nifgen_grpc::ConfigureClockModeRequest::ClockModeEnumCase::kClockMode: {
          clock_mode = static_cast<ViInt32>(request->clock_mode());
          break;
        }
        case nifgen_grpc::ConfigureClockModeRequest::ClockModeEnumCase::kClockModeRaw: {
          clock_mode = static_cast<ViInt32>(request->clock_mode_raw());
          break;
        }
        case nifgen_grpc::ConfigureClockModeRequest::ClockModeEnumCase::CLOCK_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for clock_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureClockMode(vi, clock_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureCustomFIRFilterCoefficients(::grpc::ServerContext* context, const ConfigureCustomFIRFilterCoefficientsRequest* request, ConfigureCustomFIRFilterCoefficientsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 number_of_coefficients = static_cast<ViInt32>(request->coefficients_array().size());
      auto coefficients_array = const_cast<ViReal64*>(request->coefficients_array().data());
      auto status = library_->ConfigureCustomFIRFilterCoefficients(vi, channel_name, number_of_coefficients, coefficients_array);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureDigitalEdgeScriptTrigger(::grpc::ServerContext* context, const ConfigureDigitalEdgeScriptTriggerRequest* request, ConfigureDigitalEdgeScriptTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto trigger_id_mbcs = convert_from_grpc<std::string>(request->trigger_id());
      auto trigger_id = trigger_id_mbcs.c_str();
      auto source_mbcs = convert_from_grpc<std::string>(request->source());
      auto source = source_mbcs.c_str();
      ViInt32 edge = request->edge();
      auto status = library_->ConfigureDigitalEdgeScriptTrigger(vi, trigger_id, source, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureDigitalEdgeStartTrigger(::grpc::ServerContext* context, const ConfigureDigitalEdgeStartTriggerRequest* request, ConfigureDigitalEdgeStartTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto source_mbcs = convert_from_grpc<std::string>(request->source());
      auto source = source_mbcs.c_str();
      ViInt32 edge = request->edge();
      auto status = library_->ConfigureDigitalEdgeStartTrigger(vi, source, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureDigitalLevelScriptTrigger(::grpc::ServerContext* context, const ConfigureDigitalLevelScriptTriggerRequest* request, ConfigureDigitalLevelScriptTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto trigger_id_mbcs = convert_from_grpc<std::string>(request->trigger_id());
      auto trigger_id = trigger_id_mbcs.c_str();
      auto source_mbcs = convert_from_grpc<std::string>(request->source());
      auto source = source_mbcs.c_str();
      ViInt32 trigger_when;
      switch (request->trigger_when_enum_case()) {
        case nifgen_grpc::ConfigureDigitalLevelScriptTriggerRequest::TriggerWhenEnumCase::kTriggerWhen: {
          trigger_when = static_cast<ViInt32>(request->trigger_when());
          break;
        }
        case nifgen_grpc::ConfigureDigitalLevelScriptTriggerRequest::TriggerWhenEnumCase::kTriggerWhenRaw: {
          trigger_when = static_cast<ViInt32>(request->trigger_when_raw());
          break;
        }
        case nifgen_grpc::ConfigureDigitalLevelScriptTriggerRequest::TriggerWhenEnumCase::TRIGGER_WHEN_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_when was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalLevelScriptTrigger(vi, trigger_id, source, trigger_when);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureFreqList(::grpc::ServerContext* context, const ConfigureFreqListRequest* request, ConfigureFreqListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 frequency_list_handle = request->frequency_list_handle();
      ViReal64 amplitude = request->amplitude();
      ViReal64 dc_offset = request->dc_offset();
      ViReal64 start_phase = request->start_phase();
      auto status = library_->ConfigureFreqList(vi, channel_name, frequency_list_handle, amplitude, dc_offset, start_phase);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureFrequency(::grpc::ServerContext* context, const ConfigureFrequencyRequest* request, ConfigureFrequencyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 frequency = request->frequency();
      auto status = library_->ConfigureFrequency(vi, channel_name, frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureOperationMode(::grpc::ServerContext* context, const ConfigureOperationModeRequest* request, ConfigureOperationModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 operation_mode = request->operation_mode();
      auto status = library_->ConfigureOperationMode(vi, channel_name, operation_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureOutputEnabled(::grpc::ServerContext* context, const ConfigureOutputEnabledRequest* request, ConfigureOutputEnabledResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViBoolean enabled = request->enabled();
      auto status = library_->ConfigureOutputEnabled(vi, channel_name, enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureOutputImpedance(::grpc::ServerContext* context, const ConfigureOutputImpedanceRequest* request, ConfigureOutputImpedanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 impedance = request->impedance();
      auto status = library_->ConfigureOutputImpedance(vi, channel_name, impedance);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureOutputMode(::grpc::ServerContext* context, const ConfigureOutputModeRequest* request, ConfigureOutputModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 output_mode;
      switch (request->output_mode_enum_case()) {
        case nifgen_grpc::ConfigureOutputModeRequest::OutputModeEnumCase::kOutputMode: {
          output_mode = static_cast<ViInt32>(request->output_mode());
          break;
        }
        case nifgen_grpc::ConfigureOutputModeRequest::OutputModeEnumCase::kOutputModeRaw: {
          output_mode = static_cast<ViInt32>(request->output_mode_raw());
          break;
        }
        case nifgen_grpc::ConfigureOutputModeRequest::OutputModeEnumCase::OUTPUT_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for output_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureOutputMode(vi, output_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureP2PEndpointFullnessStartTrigger(::grpc::ServerContext* context, const ConfigureP2PEndpointFullnessStartTriggerRequest* request, ConfigureP2PEndpointFullnessStartTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 p2p_endpoint_fullness_level = request->p2p_endpoint_fullness_level();
      auto status = library_->ConfigureP2PEndpointFullnessStartTrigger(vi, p2p_endpoint_fullness_level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureReferenceClock(::grpc::ServerContext* context, const ConfigureReferenceClockRequest* request, ConfigureReferenceClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto reference_clock_source_mbcs = convert_from_grpc<std::string>(request->reference_clock_source());
      auto reference_clock_source = reference_clock_source_mbcs.c_str();
      ViReal64 reference_clock_frequency = request->reference_clock_frequency();
      auto status = library_->ConfigureReferenceClock(vi, reference_clock_source, reference_clock_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureSampleClockSource(::grpc::ServerContext* context, const ConfigureSampleClockSourceRequest* request, ConfigureSampleClockSourceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto sample_clock_source_mbcs = convert_from_grpc<std::string>(request->sample_clock_source());
      auto sample_clock_source = sample_clock_source_mbcs.c_str();
      auto status = library_->ConfigureSampleClockSource(vi, sample_clock_source);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureSampleRate(::grpc::ServerContext* context, const ConfigureSampleRateRequest* request, ConfigureSampleRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViReal64 sample_rate = request->sample_rate();
      auto status = library_->ConfigureSampleRate(vi, sample_rate);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureSoftwareEdgeScriptTrigger(::grpc::ServerContext* context, const ConfigureSoftwareEdgeScriptTriggerRequest* request, ConfigureSoftwareEdgeScriptTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto trigger_id_mbcs = convert_from_grpc<std::string>(request->trigger_id());
      auto trigger_id = trigger_id_mbcs.c_str();
      auto status = library_->ConfigureSoftwareEdgeScriptTrigger(vi, trigger_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureSoftwareEdgeStartTrigger(::grpc::ServerContext* context, const ConfigureSoftwareEdgeStartTriggerRequest* request, ConfigureSoftwareEdgeStartTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ConfigureSoftwareEdgeStartTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureStandardWaveform(::grpc::ServerContext* context, const ConfigureStandardWaveformRequest* request, ConfigureStandardWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 waveform;
      switch (request->waveform_enum_case()) {
        case nifgen_grpc::ConfigureStandardWaveformRequest::WaveformEnumCase::kWaveform: {
          waveform = static_cast<ViInt32>(request->waveform());
          break;
        }
        case nifgen_grpc::ConfigureStandardWaveformRequest::WaveformEnumCase::kWaveformRaw: {
          waveform = static_cast<ViInt32>(request->waveform_raw());
          break;
        }
        case nifgen_grpc::ConfigureStandardWaveformRequest::WaveformEnumCase::WAVEFORM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for waveform was not specified or out of range");
          break;
        }
      }

      ViReal64 amplitude = request->amplitude();
      ViReal64 dc_offset = request->dc_offset();
      ViReal64 frequency = request->frequency();
      ViReal64 start_phase = request->start_phase();
      auto status = library_->ConfigureStandardWaveform(vi, channel_name, waveform, amplitude, dc_offset, frequency, start_phase);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureSynchronization(::grpc::ServerContext* context, const ConfigureSynchronizationRequest* request, ConfigureSynchronizationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 synchronization_source = request->synchronization_source();
      auto status = library_->ConfigureSynchronization(vi, channel_name, synchronization_source);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ConfigureTriggerMode(::grpc::ServerContext* context, const ConfigureTriggerModeRequest* request, ConfigureTriggerModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 trigger_mode;
      switch (request->trigger_mode_enum_case()) {
        case nifgen_grpc::ConfigureTriggerModeRequest::TriggerModeEnumCase::kTriggerMode: {
          trigger_mode = static_cast<ViInt32>(request->trigger_mode());
          break;
        }
        case nifgen_grpc::ConfigureTriggerModeRequest::TriggerModeEnumCase::kTriggerModeRaw: {
          trigger_mode = static_cast<ViInt32>(request->trigger_mode_raw());
          break;
        }
        case nifgen_grpc::ConfigureTriggerModeRequest::TriggerModeEnumCase::TRIGGER_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureTriggerMode(vi, channel_name, trigger_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CreateArbSequence(::grpc::ServerContext* context, const CreateArbSequenceRequest* request, CreateArbSequenceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto sequence_length_determine_from_sizes = std::array<int, 2>
      {
        request->waveform_handles_array_size(),
        request->loop_counts_array_size()
      };
      const auto sequence_length_size_calculation = calculate_linked_array_size(sequence_length_determine_from_sizes, false);

      if (sequence_length_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [waveform_handles_array, loop_counts_array] do not match");
      }
      auto sequence_length = sequence_length_size_calculation.size;

      auto waveform_handles_array = const_cast<ViInt32*>(reinterpret_cast<const ViInt32*>(request->waveform_handles_array().data()));
      auto loop_counts_array = const_cast<ViInt32*>(reinterpret_cast<const ViInt32*>(request->loop_counts_array().data()));
      ViInt32 sequence_handle {};
      auto status = library_->CreateArbSequence(vi, sequence_length, waveform_handles_array, loop_counts_array, &sequence_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_sequence_handle(sequence_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CreateFreqList(::grpc::ServerContext* context, const CreateFreqListRequest* request, CreateFreqListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 waveform;
      switch (request->waveform_enum_case()) {
        case nifgen_grpc::CreateFreqListRequest::WaveformEnumCase::kWaveform: {
          waveform = static_cast<ViInt32>(request->waveform());
          break;
        }
        case nifgen_grpc::CreateFreqListRequest::WaveformEnumCase::kWaveformRaw: {
          waveform = static_cast<ViInt32>(request->waveform_raw());
          break;
        }
        case nifgen_grpc::CreateFreqListRequest::WaveformEnumCase::WAVEFORM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for waveform was not specified or out of range");
          break;
        }
      }

      auto frequency_list_length_determine_from_sizes = std::array<int, 2>
      {
        request->frequency_array_size(),
        request->duration_array_size()
      };
      const auto frequency_list_length_size_calculation = calculate_linked_array_size(frequency_list_length_determine_from_sizes, false);

      if (frequency_list_length_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [frequency_array, duration_array] do not match");
      }
      auto frequency_list_length = frequency_list_length_size_calculation.size;

      auto frequency_array = const_cast<ViReal64*>(request->frequency_array().data());
      auto duration_array = const_cast<ViReal64*>(request->duration_array().data());
      ViInt32 frequency_list_handle {};
      auto status = library_->CreateFreqList(vi, waveform, frequency_list_length, frequency_array, duration_array, &frequency_list_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_frequency_list_handle(frequency_list_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CreateWaveformComplexF64(::grpc::ServerContext* context, const CreateWaveformComplexF64Request* request, CreateWaveformComplexF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 number_of_samples = static_cast<ViInt32>(request->waveform_data_array().size());
      auto waveform_data_array = convert_from_grpc<NIComplexNumber_struct>(request->waveform_data_array());
      ViInt32 waveform_handle {};
      auto status = library_->CreateWaveformComplexF64(vi, channel_name, number_of_samples, waveform_data_array.data(), &waveform_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_waveform_handle(waveform_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CreateWaveformF64(::grpc::ServerContext* context, const CreateWaveformF64Request* request, CreateWaveformF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 waveform_size = static_cast<ViInt32>(request->waveform_data_array().size());
      auto waveform_data_array = const_cast<ViReal64*>(request->waveform_data_array().data());
      ViInt32 waveform_handle {};
      auto status = library_->CreateWaveformF64(vi, channel_name, waveform_size, waveform_data_array, &waveform_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_waveform_handle(waveform_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CreateWaveformFromFileF64(::grpc::ServerContext* context, const CreateWaveformFromFileF64Request* request, CreateWaveformFromFileF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto file_name_mbcs = convert_from_grpc<std::string>(request->file_name());
      auto file_name = file_name_mbcs.c_str();
      ViInt32 byte_order;
      switch (request->byte_order_enum_case()) {
        case nifgen_grpc::CreateWaveformFromFileF64Request::ByteOrderEnumCase::kByteOrder: {
          byte_order = static_cast<ViInt32>(request->byte_order());
          break;
        }
        case nifgen_grpc::CreateWaveformFromFileF64Request::ByteOrderEnumCase::kByteOrderRaw: {
          byte_order = static_cast<ViInt32>(request->byte_order_raw());
          break;
        }
        case nifgen_grpc::CreateWaveformFromFileF64Request::ByteOrderEnumCase::BYTE_ORDER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for byte_order was not specified or out of range");
          break;
        }
      }

      ViInt32 waveform_handle {};
      auto status = library_->CreateWaveformFromFileF64(vi, channel_name, file_name, byte_order, &waveform_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_waveform_handle(waveform_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CreateWaveformFromFileHWS(::grpc::ServerContext* context, const CreateWaveformFromFileHWSRequest* request, CreateWaveformFromFileHWSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto file_name_mbcs = convert_from_grpc<std::string>(request->file_name());
      auto file_name = file_name_mbcs.c_str();
      ViBoolean use_rate_from_waveform = request->use_rate_from_waveform();
      ViBoolean use_gain_and_offset_from_waveform = request->use_gain_and_offset_from_waveform();
      ViInt32 waveform_handle {};
      auto status = library_->CreateWaveformFromFileHWS(vi, channel_name, file_name, use_rate_from_waveform, use_gain_and_offset_from_waveform, &waveform_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_waveform_handle(waveform_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CreateWaveformFromFileI16(::grpc::ServerContext* context, const CreateWaveformFromFileI16Request* request, CreateWaveformFromFileI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto file_name_mbcs = convert_from_grpc<std::string>(request->file_name());
      auto file_name = file_name_mbcs.c_str();
      ViInt32 byte_order;
      switch (request->byte_order_enum_case()) {
        case nifgen_grpc::CreateWaveformFromFileI16Request::ByteOrderEnumCase::kByteOrder: {
          byte_order = static_cast<ViInt32>(request->byte_order());
          break;
        }
        case nifgen_grpc::CreateWaveformFromFileI16Request::ByteOrderEnumCase::kByteOrderRaw: {
          byte_order = static_cast<ViInt32>(request->byte_order_raw());
          break;
        }
        case nifgen_grpc::CreateWaveformFromFileI16Request::ByteOrderEnumCase::BYTE_ORDER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for byte_order was not specified or out of range");
          break;
        }
      }

      ViInt32 waveform_handle {};
      auto status = library_->CreateWaveformFromFileI16(vi, channel_name, file_name, byte_order, &waveform_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_waveform_handle(waveform_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::CreateWaveformI16(::grpc::ServerContext* context, const CreateWaveformI16Request* request, CreateWaveformI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 waveform_size = static_cast<ViInt32>(request->waveform_data_array().size());
      auto waveform_data_array_request = request->waveform_data_array();
      std::vector<ViInt16> waveform_data_array;
      std::transform(
        waveform_data_array_request.begin(),
        waveform_data_array_request.end(),
        std::back_inserter(waveform_data_array),
        [](auto x) { return (ViInt16)x; }); 
      ViInt32 waveform_handle {};
      auto status = library_->CreateWaveformI16(vi, channel_name, waveform_size, waveform_data_array.data(), &waveform_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_waveform_handle(waveform_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::DefineUserStandardWaveform(::grpc::ServerContext* context, const DefineUserStandardWaveformRequest* request, DefineUserStandardWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 waveform_size = static_cast<ViInt32>(request->waveform_data_array().size());
      auto waveform_data_array = const_cast<ViReal64*>(request->waveform_data_array().data());
      auto status = library_->DefineUserStandardWaveform(vi, channel_name, waveform_size, waveform_data_array);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::DeleteNamedWaveform(::grpc::ServerContext* context, const DeleteNamedWaveformRequest* request, DeleteNamedWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto waveform_name_mbcs = convert_from_grpc<std::string>(request->waveform_name());
      auto waveform_name = waveform_name_mbcs.c_str();
      auto status = library_->DeleteNamedWaveform(vi, channel_name, waveform_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::DeleteScript(::grpc::ServerContext* context, const DeleteScriptRequest* request, DeleteScriptResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto script_name_mbcs = convert_from_grpc<std::string>(request->script_name());
      auto script_name = script_name_mbcs.c_str();
      auto status = library_->DeleteScript(vi, channel_name, script_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::Disable(::grpc::ServerContext* context, const DisableRequest* request, DisableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Disable(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::DisableAnalogFilter(::grpc::ServerContext* context, const DisableAnalogFilterRequest* request, DisableAnalogFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->DisableAnalogFilter(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::DisableDigitalFilter(::grpc::ServerContext* context, const DisableDigitalFilterRequest* request, DisableDigitalFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->DisableDigitalFilter(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::DisableDigitalPatterning(::grpc::ServerContext* context, const DisableDigitalPatterningRequest* request, DisableDigitalPatterningResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->DisableDigitalPatterning(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::DisableScriptTrigger(::grpc::ServerContext* context, const DisableScriptTriggerRequest* request, DisableScriptTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto trigger_id_mbcs = convert_from_grpc<std::string>(request->trigger_id());
      auto trigger_id = trigger_id_mbcs.c_str();
      auto status = library_->DisableScriptTrigger(vi, trigger_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::DisableStartTrigger(::grpc::ServerContext* context, const DisableStartTriggerRequest* request, DisableStartTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->DisableStartTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::EnableAnalogFilter(::grpc::ServerContext* context, const EnableAnalogFilterRequest* request, EnableAnalogFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 filter_correction_frequency = request->filter_correction_frequency();
      auto status = library_->EnableAnalogFilter(vi, channel_name, filter_correction_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::EnableDigitalFilter(::grpc::ServerContext* context, const EnableDigitalFilterRequest* request, EnableDigitalFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->EnableDigitalFilter(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::EnableDigitalPatterning(::grpc::ServerContext* context, const EnableDigitalPatterningRequest* request, EnableDigitalPatterningResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->EnableDigitalPatterning(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ErrorHandler(::grpc::ServerContext* context, const ErrorHandlerRequest* request, ErrorHandlerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViStatus error_code = request->error_code();
      std::string error_message(256 - 1, '\0');
      auto status = library_->ErrorHandler(vi, error_code, (ViChar*)error_message.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      std::string error_message_utf8;
      convert_to_grpc(error_message, &error_message_utf8);
      response->set_error_message(error_message_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_message()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ErrorMessage(::grpc::ServerContext* context, const ErrorMessageRequest* request, ErrorMessageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViStatus error_code = request->error_code();
      std::string error_message(256 - 1, '\0');
      auto status = library_->ErrorMessage(vi, error_code, (ViChar*)error_message.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      std::string error_message_utf8;
      convert_to_grpc(error_message, &error_message_utf8);
      response->set_error_message(error_message_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_message()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ErrorQuery(::grpc::ServerContext* context, const ErrorQueryRequest* request, ErrorQueryResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 error_code {};
      std::string error_message(256 - 1, '\0');
      auto status = library_->ErrorQuery(vi, &error_code, (ViChar*)error_message.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_error_code(error_code);
      std::string error_message_utf8;
      convert_to_grpc(error_message, &error_message_utf8);
      response->set_error_message(error_message_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_message()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ExportAttributeConfigurationBuffer(::grpc::ServerContext* context, const ExportAttributeConfigurationBufferRequest* request, ExportAttributeConfigurationBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());

      while (true) {
        auto status = library_->ExportAttributeConfigurationBuffer(vi, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 size_in_bytes = status;

        std::string configuration(size_in_bytes, '\0');
        status = library_->ExportAttributeConfigurationBuffer(vi, size_in_bytes, (ViInt8*)configuration.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size_in_bytes)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_configuration(configuration);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ExportAttributeConfigurationFile(::grpc::ServerContext* context, const ExportAttributeConfigurationFileRequest* request, ExportAttributeConfigurationFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto file_path_mbcs = convert_from_grpc<std::string>(request->file_path());
      auto file_path = file_path_mbcs.c_str();
      auto status = library_->ExportAttributeConfigurationFile(vi, file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ExportSignal(::grpc::ServerContext* context, const ExportSignalRequest* request, ExportSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 signal;
      switch (request->signal_enum_case()) {
        case nifgen_grpc::ExportSignalRequest::SignalEnumCase::kSignal: {
          signal = static_cast<ViInt32>(request->signal());
          break;
        }
        case nifgen_grpc::ExportSignalRequest::SignalEnumCase::kSignalRaw: {
          signal = static_cast<ViInt32>(request->signal_raw());
          break;
        }
        case nifgen_grpc::ExportSignalRequest::SignalEnumCase::SIGNAL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal was not specified or out of range");
          break;
        }
      }

      auto signal_identifier_mbcs = convert_from_grpc<std::string>(request->signal_identifier());
      auto signal_identifier = signal_identifier_mbcs.c_str();
      auto output_terminal_mbcs = convert_from_grpc<std::string>(request->output_terminal());
      auto output_terminal = output_terminal_mbcs.c_str();
      auto status = library_->ExportSignal(vi, signal, signal_identifier, output_terminal);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetAttributeViBoolean(::grpc::ServerContext* context, const GetAttributeViBooleanRequest* request, GetAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViBoolean attribute_value {};
      auto status = library_->GetAttributeViBoolean(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetAttributeViInt32(::grpc::ServerContext* context, const GetAttributeViInt32Request* request, GetAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt32 attribute_value {};
      auto status = library_->GetAttributeViInt32(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetAttributeViInt64(::grpc::ServerContext* context, const GetAttributeViInt64Request* request, GetAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt64 attribute_value {};
      auto status = library_->GetAttributeViInt64(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetAttributeViReal64(::grpc::ServerContext* context, const GetAttributeViReal64Request* request, GetAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViReal64 attribute_value {};
      auto status = library_->GetAttributeViReal64(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetAttributeViSession(::grpc::ServerContext* context, const GetAttributeViSessionRequest* request, GetAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViSession attribute_value {};
      auto status = library_->GetAttributeViSession(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      auto grpc_device_session_name = session_repository_->resolve_session_name(attribute_value);
      response->mutable_attribute_value()->set_name(grpc_device_session_name);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetAttributeViString(::grpc::ServerContext* context, const GetAttributeViStringRequest* request, GetAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();

      while (true) {
        auto status = library_->GetAttributeViString(vi, channel_name, attribute_id, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 array_size = status;

        std::string attribute_value;
        if (array_size > 0) {
            attribute_value.resize(array_size - 1);
        }
        status = library_->GetAttributeViString(vi, channel_name, attribute_id, array_size, (ViChar*)attribute_value.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(array_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        std::string attribute_value_utf8;
        convert_to_grpc(attribute_value, &attribute_value_utf8);
        response->set_attribute_value(attribute_value_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_attribute_value()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetChannelName(::grpc::ServerContext* context, const GetChannelNameRequest* request, GetChannelNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 index = request->index();

      while (true) {
        auto status = library_->GetChannelName(vi, index, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string channel_string;
        if (buffer_size > 0) {
            channel_string.resize(buffer_size - 1);
        }
        status = library_->GetChannelName(vi, index, buffer_size, (ViChar*)channel_string.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        std::string channel_string_utf8;
        convert_to_grpc(channel_string, &channel_string_utf8);
        response->set_channel_string(channel_string_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_channel_string()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetError(::grpc::ServerContext* context, const GetErrorRequest* request, GetErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());

      while (true) {
        auto status = library_->GetError(vi, nullptr, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 error_description_buffer_size = status;

        ViStatus error_code {};
        std::string error_description;
        if (error_description_buffer_size > 0) {
            error_description.resize(error_description_buffer_size - 1);
        }
        status = library_->GetError(vi, &error_code, error_description_buffer_size, (ViChar*)error_description.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(error_description_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_error_code(error_code);
        std::string error_description_utf8;
        convert_to_grpc(error_description, &error_description_utf8);
        response->set_error_description(error_description_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_description()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetExtCalLastDateAndTime(::grpc::ServerContext* context, const GetExtCalLastDateAndTimeRequest* request, GetExtCalLastDateAndTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 year {};
      ViInt32 month {};
      ViInt32 day {};
      ViInt32 hour {};
      ViInt32 minute {};
      auto status = library_->GetExtCalLastDateAndTime(vi, &year, &month, &day, &hour, &minute);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_year(year);
      response->set_month(month);
      response->set_day(day);
      response->set_hour(hour);
      response->set_minute(minute);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetExtCalLastTemp(::grpc::ServerContext* context, const GetExtCalLastTempRequest* request, GetExtCalLastTempResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViReal64 temperature {};
      auto status = library_->GetExtCalLastTemp(vi, &temperature);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_temperature(temperature);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetExtCalRecommendedInterval(::grpc::ServerContext* context, const GetExtCalRecommendedIntervalRequest* request, GetExtCalRecommendedIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 months {};
      auto status = library_->GetExtCalRecommendedInterval(vi, &months);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_months(months);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetFIRFilterCoefficients(::grpc::ServerContext* context, const GetFIRFilterCoefficientsRequest* request, GetFIRFilterCoefficientsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 number_of_coefficients_read {};
      while (true) {
        auto status = library_->GetFIRFilterCoefficients(vi, channel_name, 0, nullptr, &number_of_coefficients_read);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->mutable_coefficients_array()->Resize(number_of_coefficients_read, 0);
        ViReal64* coefficients_array = response->mutable_coefficients_array()->mutable_data();
        auto array_size = number_of_coefficients_read;
        status = library_->GetFIRFilterCoefficients(vi, channel_name, array_size, coefficients_array, &number_of_coefficients_read);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->mutable_coefficients_array()->Resize(number_of_coefficients_read, 0);
        response->set_number_of_coefficients_read(number_of_coefficients_read);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetHardwareState(::grpc::ServerContext* context, const GetHardwareStateRequest* request, GetHardwareStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 state {};
      auto status = library_->GetHardwareState(vi, &state);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_state(static_cast<nifgen_grpc::HardwareState>(state));
      response->set_state_raw(state);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetNextCoercionRecord(::grpc::ServerContext* context, const GetNextCoercionRecordRequest* request, GetNextCoercionRecordResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());

      while (true) {
        auto status = library_->GetNextCoercionRecord(vi, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string coercion_record;
        if (buffer_size > 0) {
            coercion_record.resize(buffer_size - 1);
        }
        status = library_->GetNextCoercionRecord(vi, buffer_size, (ViChar*)coercion_record.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        std::string coercion_record_utf8;
        convert_to_grpc(coercion_record, &coercion_record_utf8);
        response->set_coercion_record(coercion_record_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_coercion_record()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetNextInterchangeWarning(::grpc::ServerContext* context, const GetNextInterchangeWarningRequest* request, GetNextInterchangeWarningResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());

      while (true) {
        auto status = library_->GetNextInterchangeWarning(vi, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string interchange_warning;
        if (buffer_size > 0) {
            interchange_warning.resize(buffer_size - 1);
        }
        status = library_->GetNextInterchangeWarning(vi, buffer_size, (ViChar*)interchange_warning.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        std::string interchange_warning_utf8;
        convert_to_grpc(interchange_warning, &interchange_warning_utf8);
        response->set_interchange_warning(interchange_warning_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_interchange_warning()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetSelfCalLastDateAndTime(::grpc::ServerContext* context, const GetSelfCalLastDateAndTimeRequest* request, GetSelfCalLastDateAndTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 year {};
      ViInt32 month {};
      ViInt32 day {};
      ViInt32 hour {};
      ViInt32 minute {};
      auto status = library_->GetSelfCalLastDateAndTime(vi, &year, &month, &day, &hour, &minute);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_year(year);
      response->set_month(month);
      response->set_day(day);
      response->set_hour(hour);
      response->set_minute(minute);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetSelfCalLastTemp(::grpc::ServerContext* context, const GetSelfCalLastTempRequest* request, GetSelfCalLastTempResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViReal64 temperature {};
      auto status = library_->GetSelfCalLastTemp(vi, &temperature);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_temperature(temperature);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetSelfCalSupported(::grpc::ServerContext* context, const GetSelfCalSupportedRequest* request, GetSelfCalSupportedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViBoolean self_cal_supported {};
      auto status = library_->GetSelfCalSupported(vi, &self_cal_supported);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_self_cal_supported(self_cal_supported);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::GetStreamEndpointHandle(::grpc::ServerContext* context, const GetStreamEndpointHandleRequest* request, GetStreamEndpointHandleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto stream_endpoint_mbcs = convert_from_grpc<std::string>(request->stream_endpoint());
      auto stream_endpoint = stream_endpoint_mbcs.c_str();
      ViUInt32 reader_handle {};
      auto status = library_->GetStreamEndpointHandle(vi, stream_endpoint, &reader_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_reader_handle(reader_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ImportAttributeConfigurationBuffer(::grpc::ServerContext* context, const ImportAttributeConfigurationBufferRequest* request, ImportAttributeConfigurationBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 size_in_bytes = static_cast<ViInt32>(request->configuration().size());
      ViInt8* configuration = (ViInt8*)request->configuration().c_str();
      auto status = library_->ImportAttributeConfigurationBuffer(vi, size_in_bytes, configuration);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ImportAttributeConfigurationFile(::grpc::ServerContext* context, const ImportAttributeConfigurationFileRequest* request, ImportAttributeConfigurationFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto file_path_mbcs = convert_from_grpc<std::string>(request->file_path());
      auto file_path = file_path_mbcs.c_str();
      auto status = library_->ImportAttributeConfigurationFile(vi, file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::Init(::grpc::ServerContext* context, const InitRequest* request, InitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto resource_name_mbcs = convert_from_grpc<std::string>(request->resource_name());
      ViRsrc resource_name = (ViRsrc)resource_name_mbcs.c_str();
      ViBoolean id_query = request->id_query();
      ViBoolean reset_device = request->reset_device();
      auto initialization_behavior = request->initialization_behavior();

      bool new_session_initialized {};
      auto init_lambda = [&] () {
        ViSession vi;
        auto status = library_->Init(resource_name, id_query, reset_device, &vi);
        return std::make_tuple(status, vi);
      };
      std::string grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->mutable_vi()->set_name(grpc_device_session_name);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::InitWithOptions(::grpc::ServerContext* context, const InitWithOptionsRequest* request, InitWithOptionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto resource_name_mbcs = convert_from_grpc<std::string>(request->resource_name());
      ViRsrc resource_name = (ViRsrc)resource_name_mbcs.c_str();
      ViBoolean id_query = request->id_query();
      ViBoolean reset_device = request->reset_device();
      auto option_string_mbcs = convert_from_grpc<std::string>(request->option_string());
      ViString option_string = (ViString)option_string_mbcs.c_str();
      auto initialization_behavior = request->initialization_behavior();

      bool new_session_initialized {};
      auto init_lambda = [&] () {
        ViSession vi;
        auto status = library_->InitWithOptions(resource_name, id_query, reset_device, option_string, &vi);
        return std::make_tuple(status, vi);
      };
      std::string grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->mutable_vi()->set_name(grpc_device_session_name);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::InitializeWithChannels(::grpc::ServerContext* context, const InitializeWithChannelsRequest* request, InitializeWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto resource_name_mbcs = convert_from_grpc<std::string>(request->resource_name());
      ViRsrc resource_name = (ViRsrc)resource_name_mbcs.c_str();
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      ViString channel_name = (ViString)channel_name_mbcs.c_str();
      ViBoolean reset_device = request->reset_device();
      auto option_string_mbcs = convert_from_grpc<std::string>(request->option_string());
      ViString option_string = (ViString)option_string_mbcs.c_str();
      auto initialization_behavior = request->initialization_behavior();

      bool new_session_initialized {};
      auto init_lambda = [&] () {
        ViSession vi;
        auto status = library_->InitializeWithChannels(resource_name, channel_name, reset_device, option_string, &vi);
        return std::make_tuple(status, vi);
      };
      std::string grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->mutable_vi()->set_name(grpc_device_session_name);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::InitiateGeneration(::grpc::ServerContext* context, const InitiateGenerationRequest* request, InitiateGenerationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->InitiateGeneration(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::InvalidateAllAttributes(::grpc::ServerContext* context, const InvalidateAllAttributesRequest* request, InvalidateAllAttributesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->InvalidateAllAttributes(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::IsDone(::grpc::ServerContext* context, const IsDoneRequest* request, IsDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViBoolean done {};
      auto status = library_->IsDone(vi, &done);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_done(done);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ManualEnableP2PStream(::grpc::ServerContext* context, const ManualEnableP2PStreamRequest* request, ManualEnableP2PStreamResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto endpoint_name_mbcs = convert_from_grpc<std::string>(request->endpoint_name());
      auto endpoint_name = endpoint_name_mbcs.c_str();
      auto status = library_->ManualEnableP2PStream(vi, endpoint_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::QueryArbSeqCapabilities(::grpc::ServerContext* context, const QueryArbSeqCapabilitiesRequest* request, QueryArbSeqCapabilitiesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 maximum_number_of_sequences {};
      ViInt32 minimum_sequence_length {};
      ViInt32 maximum_sequence_length {};
      ViInt32 maximum_loop_count {};
      auto status = library_->QueryArbSeqCapabilities(vi, &maximum_number_of_sequences, &minimum_sequence_length, &maximum_sequence_length, &maximum_loop_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_maximum_number_of_sequences(maximum_number_of_sequences);
      response->set_minimum_sequence_length(minimum_sequence_length);
      response->set_maximum_sequence_length(maximum_sequence_length);
      response->set_maximum_loop_count(maximum_loop_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::QueryArbWfmCapabilities(::grpc::ServerContext* context, const QueryArbWfmCapabilitiesRequest* request, QueryArbWfmCapabilitiesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 maximum_number_of_waveforms {};
      ViInt32 waveform_quantum {};
      ViInt32 minimum_waveform_size {};
      ViInt32 maximum_waveform_size {};
      auto status = library_->QueryArbWfmCapabilities(vi, &maximum_number_of_waveforms, &waveform_quantum, &minimum_waveform_size, &maximum_waveform_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_maximum_number_of_waveforms(maximum_number_of_waveforms);
      response->set_waveform_quantum(waveform_quantum);
      response->set_minimum_waveform_size(minimum_waveform_size);
      response->set_maximum_waveform_size(maximum_waveform_size);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::QueryFreqListCapabilities(::grpc::ServerContext* context, const QueryFreqListCapabilitiesRequest* request, QueryFreqListCapabilitiesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 maximum_number_of_freq_lists {};
      ViInt32 minimum_frequency_list_length {};
      ViInt32 maximum_frequency_list_length {};
      ViReal64 minimum_frequency_list_duration {};
      ViReal64 maximum_frequency_list_duration {};
      ViReal64 frequency_list_duration_quantum {};
      auto status = library_->QueryFreqListCapabilities(vi, &maximum_number_of_freq_lists, &minimum_frequency_list_length, &maximum_frequency_list_length, &minimum_frequency_list_duration, &maximum_frequency_list_duration, &frequency_list_duration_quantum);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_maximum_number_of_freq_lists(maximum_number_of_freq_lists);
      response->set_minimum_frequency_list_length(minimum_frequency_list_length);
      response->set_maximum_frequency_list_length(maximum_frequency_list_length);
      response->set_minimum_frequency_list_duration(minimum_frequency_list_duration);
      response->set_maximum_frequency_list_duration(maximum_frequency_list_duration);
      response->set_frequency_list_duration_quantum(frequency_list_duration_quantum);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ReadCurrentTemperature(::grpc::ServerContext* context, const ReadCurrentTemperatureRequest* request, ReadCurrentTemperatureResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViReal64 temperature {};
      auto status = library_->ReadCurrentTemperature(vi, &temperature);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_temperature(temperature);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::Reset(::grpc::ServerContext* context, const ResetRequest* request, ResetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Reset(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ResetAttribute(::grpc::ServerContext* context, const ResetAttributeRequest* request, ResetAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      auto status = library_->ResetAttribute(vi, channel_name, attribute_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ResetDevice(::grpc::ServerContext* context, const ResetDeviceRequest* request, ResetDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ResetDevice(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ResetInterchangeCheck(::grpc::ServerContext* context, const ResetInterchangeCheckRequest* request, ResetInterchangeCheckResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ResetInterchangeCheck(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::ResetWithDefaults(::grpc::ServerContext* context, const ResetWithDefaultsRequest* request, ResetWithDefaultsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ResetWithDefaults(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::RevisionQuery(::grpc::ServerContext* context, const RevisionQueryRequest* request, RevisionQueryResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      std::string instrument_driver_revision(256 - 1, '\0');
      std::string firmware_revision(256 - 1, '\0');
      auto status = library_->RevisionQuery(vi, (ViChar*)instrument_driver_revision.data(), (ViChar*)firmware_revision.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      std::string instrument_driver_revision_utf8;
      convert_to_grpc(instrument_driver_revision, &instrument_driver_revision_utf8);
      response->set_instrument_driver_revision(instrument_driver_revision_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_instrument_driver_revision()));
      std::string firmware_revision_utf8;
      convert_to_grpc(firmware_revision, &firmware_revision_utf8);
      response->set_firmware_revision(firmware_revision_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_firmware_revision()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::RouteSignalOut(::grpc::ServerContext* context, const RouteSignalOutRequest* request, RouteSignalOutResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 route_signal_from;
      switch (request->route_signal_from_enum_case()) {
        case nifgen_grpc::RouteSignalOutRequest::RouteSignalFromEnumCase::kRouteSignalFrom: {
          route_signal_from = static_cast<ViInt32>(request->route_signal_from());
          break;
        }
        case nifgen_grpc::RouteSignalOutRequest::RouteSignalFromEnumCase::kRouteSignalFromRaw: {
          route_signal_from = static_cast<ViInt32>(request->route_signal_from_raw());
          break;
        }
        case nifgen_grpc::RouteSignalOutRequest::RouteSignalFromEnumCase::ROUTE_SIGNAL_FROM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for route_signal_from was not specified or out of range");
          break;
        }
      }

      ViInt32 route_signal_to;
      switch (request->route_signal_to_enum_case()) {
        case nifgen_grpc::RouteSignalOutRequest::RouteSignalToEnumCase::kRouteSignalTo: {
          route_signal_to = static_cast<ViInt32>(request->route_signal_to());
          break;
        }
        case nifgen_grpc::RouteSignalOutRequest::RouteSignalToEnumCase::kRouteSignalToRaw: {
          route_signal_to = static_cast<ViInt32>(request->route_signal_to_raw());
          break;
        }
        case nifgen_grpc::RouteSignalOutRequest::RouteSignalToEnumCase::ROUTE_SIGNAL_TO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for route_signal_to was not specified or out of range");
          break;
        }
      }

      auto status = library_->RouteSignalOut(vi, channel_name, route_signal_from, route_signal_to);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SelfCal(::grpc::ServerContext* context, const SelfCalRequest* request, SelfCalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->SelfCal(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SelfTest(::grpc::ServerContext* context, const SelfTestRequest* request, SelfTestResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 self_test_result {};
      std::string self_test_message(256 - 1, '\0');
      auto status = library_->SelfTest(vi, &self_test_result, (ViChar*)self_test_message.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_self_test_result(self_test_result);
      std::string self_test_message_utf8;
      convert_to_grpc(self_test_message, &self_test_message_utf8);
      response->set_self_test_message(self_test_message_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_self_test_message()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SendSoftwareEdgeTrigger(::grpc::ServerContext* context, const SendSoftwareEdgeTriggerRequest* request, SendSoftwareEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 trigger;
      switch (request->trigger_enum_case()) {
        case nifgen_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::kTrigger: {
          trigger = static_cast<ViInt32>(request->trigger());
          break;
        }
        case nifgen_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::kTriggerRaw: {
          trigger = static_cast<ViInt32>(request->trigger_raw());
          break;
        }
        case nifgen_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::TRIGGER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger was not specified or out of range");
          break;
        }
      }

      auto trigger_id_mbcs = convert_from_grpc<std::string>(request->trigger_id());
      auto trigger_id = trigger_id_mbcs.c_str();
      auto status = library_->SendSoftwareEdgeTrigger(vi, trigger, trigger_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SetAttributeViBoolean(::grpc::ServerContext* context, const SetAttributeViBooleanRequest* request, SetAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViBoolean attribute_value = request->attribute_value();
      auto status = library_->SetAttributeViBoolean(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SetAttributeViInt32(::grpc::ServerContext* context, const SetAttributeViInt32Request* request, SetAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt32 attribute_value;
      switch (request->attribute_value_enum_case()) {
        case nifgen_grpc::SetAttributeViInt32Request::AttributeValueEnumCase::kAttributeValue: {
          attribute_value = static_cast<ViInt32>(request->attribute_value());
          break;
        }
        case nifgen_grpc::SetAttributeViInt32Request::AttributeValueEnumCase::kAttributeValueRaw: {
          attribute_value = static_cast<ViInt32>(request->attribute_value_raw());
          break;
        }
        case nifgen_grpc::SetAttributeViInt32Request::AttributeValueEnumCase::ATTRIBUTE_VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute_value was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeViInt32(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SetAttributeViInt64(::grpc::ServerContext* context, const SetAttributeViInt64Request* request, SetAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt64 attribute_value = request->attribute_value_raw();
      auto status = library_->SetAttributeViInt64(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SetAttributeViReal64(::grpc::ServerContext* context, const SetAttributeViReal64Request* request, SetAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViReal64 attribute_value;
      switch (request->attribute_value_enum_case()) {
        case nifgen_grpc::SetAttributeViReal64Request::AttributeValueEnumCase::kAttributeValue: {
          attribute_value = static_cast<ViReal64>(request->attribute_value());
          break;
        }
        case nifgen_grpc::SetAttributeViReal64Request::AttributeValueEnumCase::kAttributeValueRaw: {
          attribute_value = static_cast<ViReal64>(request->attribute_value_raw());
          break;
        }
        case nifgen_grpc::SetAttributeViReal64Request::AttributeValueEnumCase::ATTRIBUTE_VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute_value was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeViReal64(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SetAttributeViSession(::grpc::ServerContext* context, const SetAttributeViSessionRequest* request, SetAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      auto attribute_value_grpc_session = request->attribute_value();
      ViSession attribute_value = session_repository_->access_session(attribute_value_grpc_session.name());
      auto status = library_->SetAttributeViSession(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SetAttributeViString(::grpc::ServerContext* context, const SetAttributeViStringRequest* request, SetAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViConstString attribute_value;
      std::string attribute_value_buffer;
      switch (request->attribute_value_enum_case()) {
        case nifgen_grpc::SetAttributeViStringRequest::AttributeValueEnumCase::kAttributeValueMapped: {
          auto attribute_value_imap_it = nifgenstringattributevaluesmapped_input_map_.find(request->attribute_value_mapped());
          if (attribute_value_imap_it == nifgenstringattributevaluesmapped_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute_value_mapped was not specified or out of range.");
          }
          attribute_value = const_cast<ViConstString>((attribute_value_imap_it->second).c_str());
          break;
        }
        case nifgen_grpc::SetAttributeViStringRequest::AttributeValueEnumCase::kAttributeValueRaw: {
          attribute_value_buffer = convert_from_grpc<std::string>(request->attribute_value_raw());
          attribute_value = const_cast<ViConstString>(attribute_value_buffer.c_str());
          break;
        }
        case nifgen_grpc::SetAttributeViStringRequest::AttributeValueEnumCase::ATTRIBUTE_VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute_value was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeViString(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SetNamedWaveformNextWritePosition(::grpc::ServerContext* context, const SetNamedWaveformNextWritePositionRequest* request, SetNamedWaveformNextWritePositionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto waveform_name_mbcs = convert_from_grpc<std::string>(request->waveform_name());
      auto waveform_name = waveform_name_mbcs.c_str();
      ViInt32 relative_to;
      switch (request->relative_to_enum_case()) {
        case nifgen_grpc::SetNamedWaveformNextWritePositionRequest::RelativeToEnumCase::kRelativeTo: {
          relative_to = static_cast<ViInt32>(request->relative_to());
          break;
        }
        case nifgen_grpc::SetNamedWaveformNextWritePositionRequest::RelativeToEnumCase::kRelativeToRaw: {
          relative_to = static_cast<ViInt32>(request->relative_to_raw());
          break;
        }
        case nifgen_grpc::SetNamedWaveformNextWritePositionRequest::RelativeToEnumCase::RELATIVE_TO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for relative_to was not specified or out of range");
          break;
        }
      }

      ViInt32 offset = request->offset();
      auto status = library_->SetNamedWaveformNextWritePosition(vi, channel_name, waveform_name, relative_to, offset);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::SetWaveformNextWritePosition(::grpc::ServerContext* context, const SetWaveformNextWritePositionRequest* request, SetWaveformNextWritePositionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 waveform_handle = request->waveform_handle();
      ViInt32 relative_to;
      switch (request->relative_to_enum_case()) {
        case nifgen_grpc::SetWaveformNextWritePositionRequest::RelativeToEnumCase::kRelativeTo: {
          relative_to = static_cast<ViInt32>(request->relative_to());
          break;
        }
        case nifgen_grpc::SetWaveformNextWritePositionRequest::RelativeToEnumCase::kRelativeToRaw: {
          relative_to = static_cast<ViInt32>(request->relative_to_raw());
          break;
        }
        case nifgen_grpc::SetWaveformNextWritePositionRequest::RelativeToEnumCase::RELATIVE_TO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for relative_to was not specified or out of range");
          break;
        }
      }

      ViInt32 offset = request->offset();
      auto status = library_->SetWaveformNextWritePosition(vi, channel_name, waveform_handle, relative_to, offset);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WaitUntilDone(::grpc::ServerContext* context, const WaitUntilDoneRequest* request, WaitUntilDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 max_time = request->max_time();
      auto status = library_->WaitUntilDone(vi, max_time);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WriteBinary16Waveform(::grpc::ServerContext* context, const WriteBinary16WaveformRequest* request, WriteBinary16WaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 waveform_handle = request->waveform_handle();
      ViInt32 size = static_cast<ViInt32>(request->data().size());
      auto data_request = request->data();
      std::vector<ViInt16> data;
      std::transform(
        data_request.begin(),
        data_request.end(),
        std::back_inserter(data),
        [](auto x) { return (ViInt16)x; }); 
      auto status = library_->WriteBinary16Waveform(vi, channel_name, waveform_handle, size, data.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WriteComplexBinary16Waveform(::grpc::ServerContext* context, const WriteComplexBinary16WaveformRequest* request, WriteComplexBinary16WaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 waveform_handle = request->waveform_handle();
      ViInt32 size = static_cast<ViInt32>(request->data().size());
      auto data = convert_from_grpc<NIComplexI16_struct>(request->data());
      auto status = library_->WriteComplexBinary16Waveform(vi, channel_name, waveform_handle, size, data.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WriteNamedWaveformComplexF64(::grpc::ServerContext* context, const WriteNamedWaveformComplexF64Request* request, WriteNamedWaveformComplexF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto waveform_name_mbcs = convert_from_grpc<std::string>(request->waveform_name());
      auto waveform_name = waveform_name_mbcs.c_str();
      ViInt32 size = static_cast<ViInt32>(request->data().size());
      auto data = convert_from_grpc<NIComplexNumber_struct>(request->data());
      auto status = library_->WriteNamedWaveformComplexF64(vi, channel_name, waveform_name, size, data.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WriteNamedWaveformComplexI16(::grpc::ServerContext* context, const WriteNamedWaveformComplexI16Request* request, WriteNamedWaveformComplexI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto waveform_name_mbcs = convert_from_grpc<std::string>(request->waveform_name());
      auto waveform_name = waveform_name_mbcs.c_str();
      ViInt32 size = static_cast<ViInt32>(request->data().size());
      auto data = convert_from_grpc<NIComplexI16_struct>(request->data());
      auto status = library_->WriteNamedWaveformComplexI16(vi, channel_name, waveform_name, size, data.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WriteNamedWaveformF64(::grpc::ServerContext* context, const WriteNamedWaveformF64Request* request, WriteNamedWaveformF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto waveform_name_mbcs = convert_from_grpc<std::string>(request->waveform_name());
      auto waveform_name = waveform_name_mbcs.c_str();
      ViInt32 size = static_cast<ViInt32>(request->data().size());
      auto data = const_cast<ViReal64*>(request->data().data());
      auto status = library_->WriteNamedWaveformF64(vi, channel_name, waveform_name, size, data);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WriteNamedWaveformI16(::grpc::ServerContext* context, const WriteNamedWaveformI16Request* request, WriteNamedWaveformI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto waveform_name_mbcs = convert_from_grpc<std::string>(request->waveform_name());
      auto waveform_name = waveform_name_mbcs.c_str();
      ViInt32 size = static_cast<ViInt32>(request->data().size());
      auto data_request = request->data();
      std::vector<ViInt16> data;
      std::transform(
        data_request.begin(),
        data_request.end(),
        std::back_inserter(data),
        [](auto x) { return (ViInt16)x; }); 
      auto status = library_->WriteNamedWaveformI16(vi, channel_name, waveform_name, size, data.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WriteP2PEndpointI16(::grpc::ServerContext* context, const WriteP2PEndpointI16Request* request, WriteP2PEndpointI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto endpoint_name_mbcs = convert_from_grpc<std::string>(request->endpoint_name());
      auto endpoint_name = endpoint_name_mbcs.c_str();
      ViInt32 number_of_samples = static_cast<ViInt32>(request->endpoint_data().size());
      auto endpoint_data_request = request->endpoint_data();
      std::vector<ViInt16> endpoint_data;
      std::transform(
        endpoint_data_request.begin(),
        endpoint_data_request.end(),
        std::back_inserter(endpoint_data),
        [](auto x) { return (ViInt16)x; }); 
      auto status = library_->WriteP2PEndpointI16(vi, endpoint_name, number_of_samples, endpoint_data.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WriteScript(::grpc::ServerContext* context, const WriteScriptRequest* request, WriteScriptResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto script_mbcs = convert_from_grpc<std::string>(request->script());
      auto script = script_mbcs.c_str();
      auto status = library_->WriteScript(vi, channel_name, script);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WriteWaveform(::grpc::ServerContext* context, const WriteWaveformRequest* request, WriteWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 waveform_handle = request->waveform_handle();
      ViInt32 size = static_cast<ViInt32>(request->data().size());
      auto data = const_cast<ViReal64*>(request->data().data());
      auto status = library_->WriteWaveform(vi, channel_name, waveform_handle, size, data);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiFgenService::WriteWaveformComplexF64(::grpc::ServerContext* context, const WriteWaveformComplexF64Request* request, WriteWaveformComplexF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 number_of_samples = static_cast<ViInt32>(request->data().size());
      auto data = convert_from_grpc<NIComplexNumber_struct>(request->data());
      ViInt32 waveform_handle = request->waveform_handle();
      auto status = library_->WriteWaveformComplexF64(vi, channel_name, number_of_samples, data.data(), waveform_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  NiFgenFeatureToggles::NiFgenFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nifgen", CodeReadiness::kRelease))
  {
  }
} // namespace nifgen_grpc

namespace nidevice_grpc {
namespace converters {
} // converters
} // nidevice_grpc

