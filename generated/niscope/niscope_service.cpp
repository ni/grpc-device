
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-SCOPE Metadata
//---------------------------------------------------------------------
#include "niscope_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/ivi_errors.h"
#include <server/converters.h>

namespace niscope_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiScopeService::NiScopeService(
      NiScopeLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      const NiScopeFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiScopeService::~NiScopeService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::Abort(::grpc::ServerContext* context, const AbortRequest* request, AbortResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Abort(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::AcquisitionStatus(::grpc::ServerContext* context, const AcquisitionStatusRequest* request, AcquisitionStatusResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 acquisition_status {};
      auto status = library_->AcquisitionStatus(vi, &acquisition_status);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_acquisition_status(static_cast<niscope_grpc::AcquisitionStatus>(acquisition_status));
      response->set_acquisition_status_raw(acquisition_status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ActualMeasWfmSize(::grpc::ServerContext* context, const ActualMeasWfmSizeRequest* request, ActualMeasWfmSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 array_meas_function;
      switch (request->array_meas_function_enum_case()) {
        case niscope_grpc::ActualMeasWfmSizeRequest::ArrayMeasFunctionEnumCase::kArrayMeasFunction: {
          array_meas_function = static_cast<ViInt32>(request->array_meas_function());
          break;
        }
        case niscope_grpc::ActualMeasWfmSizeRequest::ArrayMeasFunctionEnumCase::kArrayMeasFunctionRaw: {
          array_meas_function = static_cast<ViInt32>(request->array_meas_function_raw());
          break;
        }
        case niscope_grpc::ActualMeasWfmSizeRequest::ArrayMeasFunctionEnumCase::ARRAY_MEAS_FUNCTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for array_meas_function was not specified or out of range");
          break;
        }
      }

      ViInt32 meas_waveform_size {};
      auto status = library_->ActualMeasWfmSize(vi, array_meas_function, &meas_waveform_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_meas_waveform_size(meas_waveform_size);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ActualNumWfms(::grpc::ServerContext* context, const ActualNumWfmsRequest* request, ActualNumWfmsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 num_wfms {};
      auto status = library_->ActualNumWfms(vi, channel_list, &num_wfms);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_num_wfms(num_wfms);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ActualRecordLength(::grpc::ServerContext* context, const ActualRecordLengthRequest* request, ActualRecordLengthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 record_length {};
      auto status = library_->ActualRecordLength(vi, &record_length);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_record_length(record_length);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::AddWaveformProcessing(::grpc::ServerContext* context, const AddWaveformProcessingRequest* request, AddWaveformProcessingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 meas_function;
      switch (request->meas_function_enum_case()) {
        case niscope_grpc::AddWaveformProcessingRequest::MeasFunctionEnumCase::kMeasFunction: {
          meas_function = static_cast<ViInt32>(request->meas_function());
          break;
        }
        case niscope_grpc::AddWaveformProcessingRequest::MeasFunctionEnumCase::kMeasFunctionRaw: {
          meas_function = static_cast<ViInt32>(request->meas_function_raw());
          break;
        }
        case niscope_grpc::AddWaveformProcessingRequest::MeasFunctionEnumCase::MEAS_FUNCTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for meas_function was not specified or out of range");
          break;
        }
      }

      auto status = library_->AddWaveformProcessing(vi, channel_list, meas_function);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::AdjustSampleClockRelativeDelay(::grpc::ServerContext* context, const AdjustSampleClockRelativeDelayRequest* request, AdjustSampleClockRelativeDelayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViReal64 delay = request->delay();
      auto status = library_->AdjustSampleClockRelativeDelay(vi, delay);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::AutoSetup(::grpc::ServerContext* context, const AutoSetupRequest* request, AutoSetupResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->AutoSetup(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CableSenseSignalStart(::grpc::ServerContext* context, const CableSenseSignalStartRequest* request, CableSenseSignalStartResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->CableSenseSignalStart(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CableSenseSignalStop(::grpc::ServerContext* context, const CableSenseSignalStopRequest* request, CableSenseSignalStopResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->CableSenseSignalStop(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CalFetchDate(::grpc::ServerContext* context, const CalFetchDateRequest* request, CalFetchDateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 which_one;
      switch (request->which_one_enum_case()) {
        case niscope_grpc::CalFetchDateRequest::WhichOneEnumCase::kWhichOne: {
          which_one = static_cast<ViInt32>(request->which_one());
          break;
        }
        case niscope_grpc::CalFetchDateRequest::WhichOneEnumCase::kWhichOneRaw: {
          which_one = static_cast<ViInt32>(request->which_one_raw());
          break;
        }
        case niscope_grpc::CalFetchDateRequest::WhichOneEnumCase::WHICH_ONE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for which_one was not specified or out of range");
          break;
        }
      }

      ViInt32 year {};
      ViInt32 month {};
      ViInt32 day {};
      auto status = library_->CalFetchDate(vi, which_one, &year, &month, &day);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_year(year);
      response->set_month(month);
      response->set_day(day);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CalFetchTemperature(::grpc::ServerContext* context, const CalFetchTemperatureRequest* request, CalFetchTemperatureResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 which_one;
      switch (request->which_one_enum_case()) {
        case niscope_grpc::CalFetchTemperatureRequest::WhichOneEnumCase::kWhichOne: {
          which_one = static_cast<ViInt32>(request->which_one());
          break;
        }
        case niscope_grpc::CalFetchTemperatureRequest::WhichOneEnumCase::kWhichOneRaw: {
          which_one = static_cast<ViInt32>(request->which_one_raw());
          break;
        }
        case niscope_grpc::CalFetchTemperatureRequest::WhichOneEnumCase::WHICH_ONE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for which_one was not specified or out of range");
          break;
        }
      }

      ViReal64 temperature {};
      auto status = library_->CalFetchTemperature(vi, which_one, &temperature);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_temperature(temperature);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CalSelfCalibrate(::grpc::ServerContext* context, const CalSelfCalibrateRequest* request, CalSelfCalibrateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 option;
      switch (request->option_enum_case()) {
        case niscope_grpc::CalSelfCalibrateRequest::OptionEnumCase::kOption: {
          option = static_cast<ViInt32>(request->option());
          break;
        }
        case niscope_grpc::CalSelfCalibrateRequest::OptionEnumCase::kOptionRaw: {
          option = static_cast<ViInt32>(request->option_raw());
          break;
        }
        case niscope_grpc::CalSelfCalibrateRequest::OptionEnumCase::OPTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for option was not specified or out of range");
          break;
        }
      }

      auto status = library_->CalSelfCalibrate(vi, channel_list, option);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CheckAttributeViBoolean(::grpc::ServerContext* context, const CheckAttributeViBooleanRequest* request, CheckAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViBoolean value = request->value();
      auto status = library_->CheckAttributeViBoolean(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CheckAttributeViInt32(::grpc::ServerContext* context, const CheckAttributeViInt32Request* request, CheckAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt32 value;
      switch (request->value_enum_case()) {
        case niscope_grpc::CheckAttributeViInt32Request::ValueEnumCase::kValue: {
          value = static_cast<ViInt32>(request->value());
          break;
        }
        case niscope_grpc::CheckAttributeViInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<ViInt32>(request->value_raw());
          break;
        }
        case niscope_grpc::CheckAttributeViInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto status = library_->CheckAttributeViInt32(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CheckAttributeViInt64(::grpc::ServerContext* context, const CheckAttributeViInt64Request* request, CheckAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt64 value = request->value_raw();
      auto status = library_->CheckAttributeViInt64(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CheckAttributeViReal64(::grpc::ServerContext* context, const CheckAttributeViReal64Request* request, CheckAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViReal64 value;
      switch (request->value_enum_case()) {
        case niscope_grpc::CheckAttributeViReal64Request::ValueEnumCase::kValue: {
          value = static_cast<ViReal64>(request->value());
          break;
        }
        case niscope_grpc::CheckAttributeViReal64Request::ValueEnumCase::kValueMapped: {
          auto value_imap_it = niscopereal64attributevaluesmapped_input_map_.find(request->value_mapped());
          if (value_imap_it == niscopereal64attributevaluesmapped_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value_mapped was not specified or out of range.");
          }
          value = static_cast<ViReal64>(value_imap_it->second);
          break;
        }
        case niscope_grpc::CheckAttributeViReal64Request::ValueEnumCase::kValueRaw: {
          value = static_cast<ViReal64>(request->value_raw());
          break;
        }
        case niscope_grpc::CheckAttributeViReal64Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto status = library_->CheckAttributeViReal64(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CheckAttributeViSession(::grpc::ServerContext* context, const CheckAttributeViSessionRequest* request, CheckAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      auto value_grpc_session = request->value();
      ViSession value = session_repository_->access_session(value_grpc_session.id(), value_grpc_session.name());
      auto status = library_->CheckAttributeViSession(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::CheckAttributeViString(::grpc::ServerContext* context, const CheckAttributeViStringRequest* request, CheckAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViConstString value;
      switch (request->value_enum_case()) {
        case niscope_grpc::CheckAttributeViStringRequest::ValueEnumCase::kValueMapped: {
          auto value_imap_it = niscopestringattributevaluesmapped_input_map_.find(request->value_mapped());
          if (value_imap_it == niscopestringattributevaluesmapped_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value_mapped was not specified or out of range.");
          }
          value = const_cast<ViConstString>((value_imap_it->second).c_str());
          break;
        }
        case niscope_grpc::CheckAttributeViStringRequest::ValueEnumCase::kValueRaw: {
          value = const_cast<ViConstString>(request->value_raw().c_str());
          break;
        }
        case niscope_grpc::CheckAttributeViStringRequest::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto status = library_->CheckAttributeViString(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ClearWaveformMeasurementStats(::grpc::ServerContext* context, const ClearWaveformMeasurementStatsRequest* request, ClearWaveformMeasurementStatsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 clearable_measurement_function;
      switch (request->clearable_measurement_function_enum_case()) {
        case niscope_grpc::ClearWaveformMeasurementStatsRequest::ClearableMeasurementFunctionEnumCase::kClearableMeasurementFunction: {
          clearable_measurement_function = static_cast<ViInt32>(request->clearable_measurement_function());
          break;
        }
        case niscope_grpc::ClearWaveformMeasurementStatsRequest::ClearableMeasurementFunctionEnumCase::kClearableMeasurementFunctionRaw: {
          clearable_measurement_function = static_cast<ViInt32>(request->clearable_measurement_function_raw());
          break;
        }
        case niscope_grpc::ClearWaveformMeasurementStatsRequest::ClearableMeasurementFunctionEnumCase::CLEARABLE_MEASUREMENT_FUNCTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for clearable_measurement_function was not specified or out of range");
          break;
        }
      }

      auto status = library_->ClearWaveformMeasurementStats(vi, channel_list, clearable_measurement_function);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ClearWaveformProcessing(::grpc::ServerContext* context, const ClearWaveformProcessingRequest* request, ClearWaveformProcessingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      auto status = library_->ClearWaveformProcessing(vi, channel_list);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      session_repository_->remove_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Close(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::Commit(::grpc::ServerContext* context, const CommitRequest* request, CommitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Commit(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureAcquisition(::grpc::ServerContext* context, const ConfigureAcquisitionRequest* request, ConfigureAcquisitionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 acquisition_type = request->acquisition_type();
      auto status = library_->ConfigureAcquisition(vi, acquisition_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureChanCharacteristics(::grpc::ServerContext* context, const ConfigureChanCharacteristicsRequest* request, ConfigureChanCharacteristicsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 input_impedance = request->input_impedance();
      ViReal64 max_input_frequency = request->max_input_frequency();
      auto status = library_->ConfigureChanCharacteristics(vi, channel_list, input_impedance, max_input_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureClock(::grpc::ServerContext* context, const ConfigureClockRequest* request, ConfigureClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViConstString input_clock_source;
      switch (request->input_clock_source_enum_case()) {
        case niscope_grpc::ConfigureClockRequest::InputClockSourceEnumCase::kInputClockSourceMapped: {
          auto input_clock_source_imap_it = clockingterminalvalues_input_map_.find(request->input_clock_source_mapped());
          if (input_clock_source_imap_it == clockingterminalvalues_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for input_clock_source_mapped was not specified or out of range.");
          }
          input_clock_source = const_cast<ViConstString>((input_clock_source_imap_it->second).c_str());
          break;
        }
        case niscope_grpc::ConfigureClockRequest::InputClockSourceEnumCase::kInputClockSourceRaw: {
          input_clock_source = const_cast<ViConstString>(request->input_clock_source_raw().c_str());
          break;
        }
        case niscope_grpc::ConfigureClockRequest::InputClockSourceEnumCase::INPUT_CLOCK_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for input_clock_source was not specified or out of range");
          break;
        }
      }

      ViConstString output_clock_source;
      switch (request->output_clock_source_enum_case()) {
        case niscope_grpc::ConfigureClockRequest::OutputClockSourceEnumCase::kOutputClockSourceMapped: {
          auto output_clock_source_imap_it = clockingterminalvalues_input_map_.find(request->output_clock_source_mapped());
          if (output_clock_source_imap_it == clockingterminalvalues_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for output_clock_source_mapped was not specified or out of range.");
          }
          output_clock_source = const_cast<ViConstString>((output_clock_source_imap_it->second).c_str());
          break;
        }
        case niscope_grpc::ConfigureClockRequest::OutputClockSourceEnumCase::kOutputClockSourceRaw: {
          output_clock_source = const_cast<ViConstString>(request->output_clock_source_raw().c_str());
          break;
        }
        case niscope_grpc::ConfigureClockRequest::OutputClockSourceEnumCase::OUTPUT_CLOCK_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for output_clock_source was not specified or out of range");
          break;
        }
      }

      ViConstString clock_sync_pulse_source;
      switch (request->clock_sync_pulse_source_enum_case()) {
        case niscope_grpc::ConfigureClockRequest::ClockSyncPulseSourceEnumCase::kClockSyncPulseSourceMapped: {
          auto clock_sync_pulse_source_imap_it = clockingterminalvalues_input_map_.find(request->clock_sync_pulse_source_mapped());
          if (clock_sync_pulse_source_imap_it == clockingterminalvalues_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for clock_sync_pulse_source_mapped was not specified or out of range.");
          }
          clock_sync_pulse_source = const_cast<ViConstString>((clock_sync_pulse_source_imap_it->second).c_str());
          break;
        }
        case niscope_grpc::ConfigureClockRequest::ClockSyncPulseSourceEnumCase::kClockSyncPulseSourceRaw: {
          clock_sync_pulse_source = const_cast<ViConstString>(request->clock_sync_pulse_source_raw().c_str());
          break;
        }
        case niscope_grpc::ConfigureClockRequest::ClockSyncPulseSourceEnumCase::CLOCK_SYNC_PULSE_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for clock_sync_pulse_source was not specified or out of range");
          break;
        }
      }

      ViBoolean master_enabled = request->master_enabled();
      auto status = library_->ConfigureClock(vi, input_clock_source, output_clock_source, clock_sync_pulse_source, master_enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureEqualizationFilterCoefficients(::grpc::ServerContext* context, const ConfigureEqualizationFilterCoefficientsRequest* request, ConfigureEqualizationFilterCoefficientsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 number_of_coefficients = static_cast<ViInt32>(request->coefficients().size());
      auto coefficients = const_cast<ViReal64*>(request->coefficients().data());
      auto status = library_->ConfigureEqualizationFilterCoefficients(vi, channel_list, number_of_coefficients, coefficients);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureHorizontalTiming(::grpc::ServerContext* context, const ConfigureHorizontalTimingRequest* request, ConfigureHorizontalTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViReal64 min_sample_rate = request->min_sample_rate();
      ViInt32 min_num_pts = request->min_num_pts();
      ViReal64 ref_position = request->ref_position();
      ViInt32 num_records = request->num_records();
      ViBoolean enforce_realtime = request->enforce_realtime();
      auto status = library_->ConfigureHorizontalTiming(vi, min_sample_rate, min_num_pts, ref_position, num_records, enforce_realtime);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureTriggerDigital(::grpc::ServerContext* context, const ConfigureTriggerDigitalRequest* request, ConfigureTriggerDigitalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      ViInt32 slope;
      switch (request->slope_enum_case()) {
        case niscope_grpc::ConfigureTriggerDigitalRequest::SlopeEnumCase::kSlope: {
          slope = static_cast<ViInt32>(request->slope());
          break;
        }
        case niscope_grpc::ConfigureTriggerDigitalRequest::SlopeEnumCase::kSlopeRaw: {
          slope = static_cast<ViInt32>(request->slope_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerDigitalRequest::SlopeEnumCase::SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for slope was not specified or out of range");
          break;
        }
      }

      ViReal64 holdoff = request->holdoff();
      ViReal64 delay = request->delay();
      auto status = library_->ConfigureTriggerDigital(vi, trigger_source, slope, holdoff, delay);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureTriggerEdge(::grpc::ServerContext* context, const ConfigureTriggerEdgeRequest* request, ConfigureTriggerEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      ViReal64 level = request->level();
      ViInt32 slope;
      switch (request->slope_enum_case()) {
        case niscope_grpc::ConfigureTriggerEdgeRequest::SlopeEnumCase::kSlope: {
          slope = static_cast<ViInt32>(request->slope());
          break;
        }
        case niscope_grpc::ConfigureTriggerEdgeRequest::SlopeEnumCase::kSlopeRaw: {
          slope = static_cast<ViInt32>(request->slope_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerEdgeRequest::SlopeEnumCase::SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for slope was not specified or out of range");
          break;
        }
      }

      ViInt32 trigger_coupling;
      switch (request->trigger_coupling_enum_case()) {
        case niscope_grpc::ConfigureTriggerEdgeRequest::TriggerCouplingEnumCase::kTriggerCoupling: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling());
          break;
        }
        case niscope_grpc::ConfigureTriggerEdgeRequest::TriggerCouplingEnumCase::kTriggerCouplingRaw: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerEdgeRequest::TriggerCouplingEnumCase::TRIGGER_COUPLING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_coupling was not specified or out of range");
          break;
        }
      }

      ViReal64 holdoff = request->holdoff();
      ViReal64 delay = request->delay();
      auto status = library_->ConfigureTriggerEdge(vi, trigger_source, level, slope, trigger_coupling, holdoff, delay);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureTriggerGlitch(::grpc::ServerContext* context, const ConfigureTriggerGlitchRequest* request, ConfigureTriggerGlitchResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      ViReal64 level = request->level();
      ViReal64 width = request->width();
      ViInt32 polarity;
      switch (request->polarity_enum_case()) {
        case niscope_grpc::ConfigureTriggerGlitchRequest::PolarityEnumCase::kPolarity: {
          polarity = static_cast<ViInt32>(request->polarity());
          break;
        }
        case niscope_grpc::ConfigureTriggerGlitchRequest::PolarityEnumCase::kPolarityRaw: {
          polarity = static_cast<ViInt32>(request->polarity_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerGlitchRequest::PolarityEnumCase::POLARITY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for polarity was not specified or out of range");
          break;
        }
      }

      ViInt32 glitch_condition;
      switch (request->glitch_condition_enum_case()) {
        case niscope_grpc::ConfigureTriggerGlitchRequest::GlitchConditionEnumCase::kGlitchCondition: {
          glitch_condition = static_cast<ViInt32>(request->glitch_condition());
          break;
        }
        case niscope_grpc::ConfigureTriggerGlitchRequest::GlitchConditionEnumCase::kGlitchConditionRaw: {
          glitch_condition = static_cast<ViInt32>(request->glitch_condition_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerGlitchRequest::GlitchConditionEnumCase::GLITCH_CONDITION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for glitch_condition was not specified or out of range");
          break;
        }
      }

      ViInt32 trigger_coupling;
      switch (request->trigger_coupling_enum_case()) {
        case niscope_grpc::ConfigureTriggerGlitchRequest::TriggerCouplingEnumCase::kTriggerCoupling: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling());
          break;
        }
        case niscope_grpc::ConfigureTriggerGlitchRequest::TriggerCouplingEnumCase::kTriggerCouplingRaw: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerGlitchRequest::TriggerCouplingEnumCase::TRIGGER_COUPLING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_coupling was not specified or out of range");
          break;
        }
      }

      ViReal64 holdoff = request->holdoff();
      ViReal64 delay = request->delay();
      auto status = library_->ConfigureTriggerGlitch(vi, trigger_source, level, width, polarity, glitch_condition, trigger_coupling, holdoff, delay);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureTriggerHysteresis(::grpc::ServerContext* context, const ConfigureTriggerHysteresisRequest* request, ConfigureTriggerHysteresisResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      ViReal64 level = request->level();
      ViReal64 hysteresis = request->hysteresis();
      ViInt32 slope;
      switch (request->slope_enum_case()) {
        case niscope_grpc::ConfigureTriggerHysteresisRequest::SlopeEnumCase::kSlope: {
          slope = static_cast<ViInt32>(request->slope());
          break;
        }
        case niscope_grpc::ConfigureTriggerHysteresisRequest::SlopeEnumCase::kSlopeRaw: {
          slope = static_cast<ViInt32>(request->slope_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerHysteresisRequest::SlopeEnumCase::SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for slope was not specified or out of range");
          break;
        }
      }

      ViInt32 trigger_coupling;
      switch (request->trigger_coupling_enum_case()) {
        case niscope_grpc::ConfigureTriggerHysteresisRequest::TriggerCouplingEnumCase::kTriggerCoupling: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling());
          break;
        }
        case niscope_grpc::ConfigureTriggerHysteresisRequest::TriggerCouplingEnumCase::kTriggerCouplingRaw: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerHysteresisRequest::TriggerCouplingEnumCase::TRIGGER_COUPLING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_coupling was not specified or out of range");
          break;
        }
      }

      ViReal64 holdoff = request->holdoff();
      ViReal64 delay = request->delay();
      auto status = library_->ConfigureTriggerHysteresis(vi, trigger_source, level, hysteresis, slope, trigger_coupling, holdoff, delay);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureTriggerImmediate(::grpc::ServerContext* context, const ConfigureTriggerImmediateRequest* request, ConfigureTriggerImmediateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->ConfigureTriggerImmediate(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureTriggerRunt(::grpc::ServerContext* context, const ConfigureTriggerRuntRequest* request, ConfigureTriggerRuntResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      ViReal64 low_threshold = request->low_threshold();
      ViReal64 high_threshold = request->high_threshold();
      ViInt32 polarity;
      switch (request->polarity_enum_case()) {
        case niscope_grpc::ConfigureTriggerRuntRequest::PolarityEnumCase::kPolarity: {
          polarity = static_cast<ViInt32>(request->polarity());
          break;
        }
        case niscope_grpc::ConfigureTriggerRuntRequest::PolarityEnumCase::kPolarityRaw: {
          polarity = static_cast<ViInt32>(request->polarity_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerRuntRequest::PolarityEnumCase::POLARITY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for polarity was not specified or out of range");
          break;
        }
      }

      ViInt32 trigger_coupling;
      switch (request->trigger_coupling_enum_case()) {
        case niscope_grpc::ConfigureTriggerRuntRequest::TriggerCouplingEnumCase::kTriggerCoupling: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling());
          break;
        }
        case niscope_grpc::ConfigureTriggerRuntRequest::TriggerCouplingEnumCase::kTriggerCouplingRaw: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerRuntRequest::TriggerCouplingEnumCase::TRIGGER_COUPLING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_coupling was not specified or out of range");
          break;
        }
      }

      ViReal64 holdoff = request->holdoff();
      ViReal64 delay = request->delay();
      auto status = library_->ConfigureTriggerRunt(vi, trigger_source, low_threshold, high_threshold, polarity, trigger_coupling, holdoff, delay);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureTriggerSoftware(::grpc::ServerContext* context, const ConfigureTriggerSoftwareRequest* request, ConfigureTriggerSoftwareResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViReal64 holdoff = request->holdoff();
      ViReal64 delay = request->delay();
      auto status = library_->ConfigureTriggerSoftware(vi, holdoff, delay);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureTriggerVideo(::grpc::ServerContext* context, const ConfigureTriggerVideoRequest* request, ConfigureTriggerVideoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      ViBoolean enable_dc_restore = request->enable_dc_restore();
      ViInt32 signal_format;
      switch (request->signal_format_enum_case()) {
        case niscope_grpc::ConfigureTriggerVideoRequest::SignalFormatEnumCase::kSignalFormat: {
          signal_format = static_cast<ViInt32>(request->signal_format());
          break;
        }
        case niscope_grpc::ConfigureTriggerVideoRequest::SignalFormatEnumCase::kSignalFormatRaw: {
          signal_format = static_cast<ViInt32>(request->signal_format_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerVideoRequest::SignalFormatEnumCase::SIGNAL_FORMAT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_format was not specified or out of range");
          break;
        }
      }

      ViInt32 event_parameter;
      switch (request->event_enum_case()) {
        case niscope_grpc::ConfigureTriggerVideoRequest::EventEnumCase::kEvent: {
          event_parameter = static_cast<ViInt32>(request->event());
          break;
        }
        case niscope_grpc::ConfigureTriggerVideoRequest::EventEnumCase::kEventRaw: {
          event_parameter = static_cast<ViInt32>(request->event_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerVideoRequest::EventEnumCase::EVENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_parameter was not specified or out of range");
          break;
        }
      }

      ViInt32 line_number = request->line_number();
      ViInt32 polarity;
      switch (request->polarity_enum_case()) {
        case niscope_grpc::ConfigureTriggerVideoRequest::PolarityEnumCase::kPolarity: {
          polarity = static_cast<ViInt32>(request->polarity());
          break;
        }
        case niscope_grpc::ConfigureTriggerVideoRequest::PolarityEnumCase::kPolarityRaw: {
          polarity = static_cast<ViInt32>(request->polarity_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerVideoRequest::PolarityEnumCase::POLARITY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for polarity was not specified or out of range");
          break;
        }
      }

      ViInt32 trigger_coupling;
      switch (request->trigger_coupling_enum_case()) {
        case niscope_grpc::ConfigureTriggerVideoRequest::TriggerCouplingEnumCase::kTriggerCoupling: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling());
          break;
        }
        case niscope_grpc::ConfigureTriggerVideoRequest::TriggerCouplingEnumCase::kTriggerCouplingRaw: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerVideoRequest::TriggerCouplingEnumCase::TRIGGER_COUPLING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_coupling was not specified or out of range");
          break;
        }
      }

      ViReal64 holdoff = request->holdoff();
      ViReal64 delay = request->delay();
      auto status = library_->ConfigureTriggerVideo(vi, trigger_source, enable_dc_restore, signal_format, event_parameter, line_number, polarity, trigger_coupling, holdoff, delay);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureTriggerWidth(::grpc::ServerContext* context, const ConfigureTriggerWidthRequest* request, ConfigureTriggerWidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      ViReal64 level = request->level();
      ViReal64 low_threshold = request->low_threshold();
      ViReal64 high_threshold = request->high_threshold();
      ViInt32 polarity;
      switch (request->polarity_enum_case()) {
        case niscope_grpc::ConfigureTriggerWidthRequest::PolarityEnumCase::kPolarity: {
          polarity = static_cast<ViInt32>(request->polarity());
          break;
        }
        case niscope_grpc::ConfigureTriggerWidthRequest::PolarityEnumCase::kPolarityRaw: {
          polarity = static_cast<ViInt32>(request->polarity_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerWidthRequest::PolarityEnumCase::POLARITY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for polarity was not specified or out of range");
          break;
        }
      }

      ViInt32 condition;
      switch (request->condition_enum_case()) {
        case niscope_grpc::ConfigureTriggerWidthRequest::ConditionEnumCase::kCondition: {
          condition = static_cast<ViInt32>(request->condition());
          break;
        }
        case niscope_grpc::ConfigureTriggerWidthRequest::ConditionEnumCase::kConditionRaw: {
          condition = static_cast<ViInt32>(request->condition_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerWidthRequest::ConditionEnumCase::CONDITION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for condition was not specified or out of range");
          break;
        }
      }

      ViInt32 trigger_coupling;
      switch (request->trigger_coupling_enum_case()) {
        case niscope_grpc::ConfigureTriggerWidthRequest::TriggerCouplingEnumCase::kTriggerCoupling: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling());
          break;
        }
        case niscope_grpc::ConfigureTriggerWidthRequest::TriggerCouplingEnumCase::kTriggerCouplingRaw: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerWidthRequest::TriggerCouplingEnumCase::TRIGGER_COUPLING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_coupling was not specified or out of range");
          break;
        }
      }

      ViReal64 holdoff = request->holdoff();
      ViReal64 delay = request->delay();
      auto status = library_->ConfigureTriggerWidth(vi, trigger_source, level, low_threshold, high_threshold, polarity, condition, trigger_coupling, holdoff, delay);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureTriggerWindow(::grpc::ServerContext* context, const ConfigureTriggerWindowRequest* request, ConfigureTriggerWindowResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_source = request->trigger_source().c_str();
      ViReal64 low_level = request->low_level();
      ViReal64 high_level = request->high_level();
      ViInt32 window_mode;
      switch (request->window_mode_enum_case()) {
        case niscope_grpc::ConfigureTriggerWindowRequest::WindowModeEnumCase::kWindowMode: {
          window_mode = static_cast<ViInt32>(request->window_mode());
          break;
        }
        case niscope_grpc::ConfigureTriggerWindowRequest::WindowModeEnumCase::kWindowModeRaw: {
          window_mode = static_cast<ViInt32>(request->window_mode_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerWindowRequest::WindowModeEnumCase::WINDOW_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for window_mode was not specified or out of range");
          break;
        }
      }

      ViInt32 trigger_coupling;
      switch (request->trigger_coupling_enum_case()) {
        case niscope_grpc::ConfigureTriggerWindowRequest::TriggerCouplingEnumCase::kTriggerCoupling: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling());
          break;
        }
        case niscope_grpc::ConfigureTriggerWindowRequest::TriggerCouplingEnumCase::kTriggerCouplingRaw: {
          trigger_coupling = static_cast<ViInt32>(request->trigger_coupling_raw());
          break;
        }
        case niscope_grpc::ConfigureTriggerWindowRequest::TriggerCouplingEnumCase::TRIGGER_COUPLING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_coupling was not specified or out of range");
          break;
        }
      }

      ViReal64 holdoff = request->holdoff();
      ViReal64 delay = request->delay();
      auto status = library_->ConfigureTriggerWindow(vi, trigger_source, low_level, high_level, window_mode, trigger_coupling, holdoff, delay);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ConfigureVertical(::grpc::ServerContext* context, const ConfigureVerticalRequest* request, ConfigureVerticalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 range = request->range();
      ViReal64 offset = request->offset();
      ViInt32 coupling;
      switch (request->coupling_enum_case()) {
        case niscope_grpc::ConfigureVerticalRequest::CouplingEnumCase::kCoupling: {
          coupling = static_cast<ViInt32>(request->coupling());
          break;
        }
        case niscope_grpc::ConfigureVerticalRequest::CouplingEnumCase::kCouplingRaw: {
          coupling = static_cast<ViInt32>(request->coupling_raw());
          break;
        }
        case niscope_grpc::ConfigureVerticalRequest::CouplingEnumCase::COUPLING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for coupling was not specified or out of range");
          break;
        }
      }

      ViReal64 probe_attenuation = request->probe_attenuation();
      ViBoolean enabled = request->enabled();
      auto status = library_->ConfigureVertical(vi, channel_list, range, offset, coupling, probe_attenuation, enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::Disable(::grpc::ServerContext* context, const DisableRequest* request, DisableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Disable(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ErrorHandler(::grpc::ServerContext* context, const ErrorHandlerRequest* request, ErrorHandlerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViStatus error_code = request->error_code();
      ViChar* error_source = (ViChar*)request->error_source().c_str();
      std::string error_description(642 - 1, '\0');
      auto status = library_->ErrorHandler(vi, error_code, error_source, (ViChar*)error_description.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_error_description(error_description);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_description()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ExportAttributeConfigurationBuffer(::grpc::ServerContext* context, const ExportAttributeConfigurationBufferRequest* request, ExportAttributeConfigurationBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());

      while (true) {
        auto status = library_->ExportAttributeConfigurationBuffer(vi, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 size_in_bytes = status;

        std::string configuration(size_in_bytes, '\0');
        status = library_->ExportAttributeConfigurationBuffer(vi, size_in_bytes, (ViInt8*)configuration.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size_in_bytes)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_configuration(configuration);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ExportAttributeConfigurationFile(::grpc::ServerContext* context, const ExportAttributeConfigurationFileRequest* request, ExportAttributeConfigurationFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->ExportAttributeConfigurationFile(vi, file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ExportSignal(::grpc::ServerContext* context, const ExportSignalRequest* request, ExportSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 signal;
      switch (request->signal_enum_case()) {
        case niscope_grpc::ExportSignalRequest::SignalEnumCase::kSignal: {
          signal = static_cast<ViInt32>(request->signal());
          break;
        }
        case niscope_grpc::ExportSignalRequest::SignalEnumCase::kSignalRaw: {
          signal = static_cast<ViInt32>(request->signal_raw());
          break;
        }
        case niscope_grpc::ExportSignalRequest::SignalEnumCase::SIGNAL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal was not specified or out of range");
          break;
        }
      }

      auto signal_identifier = request->signal_identifier().c_str();
      ViConstString output_terminal;
      switch (request->output_terminal_enum_case()) {
        case niscope_grpc::ExportSignalRequest::OutputTerminalEnumCase::kOutputTerminalMapped: {
          auto output_terminal_imap_it = clockingterminalvalues_input_map_.find(request->output_terminal_mapped());
          if (output_terminal_imap_it == clockingterminalvalues_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for output_terminal_mapped was not specified or out of range.");
          }
          output_terminal = const_cast<ViConstString>((output_terminal_imap_it->second).c_str());
          break;
        }
        case niscope_grpc::ExportSignalRequest::OutputTerminalEnumCase::kOutputTerminalRaw: {
          output_terminal = const_cast<ViConstString>(request->output_terminal_raw().c_str());
          break;
        }
        case niscope_grpc::ExportSignalRequest::OutputTerminalEnumCase::OUTPUT_TERMINAL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for output_terminal was not specified or out of range");
          break;
        }
      }

      auto status = library_->ExportSignal(vi, signal, signal_identifier, output_terminal);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetAttributeViBoolean(::grpc::ServerContext* context, const GetAttributeViBooleanRequest* request, GetAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViBoolean value {};
      auto status = library_->GetAttributeViBoolean(vi, channel_list, attribute_id, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetAttributeViInt32(::grpc::ServerContext* context, const GetAttributeViInt32Request* request, GetAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt32 value {};
      auto status = library_->GetAttributeViInt32(vi, channel_list, attribute_id, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetAttributeViInt64(::grpc::ServerContext* context, const GetAttributeViInt64Request* request, GetAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt64 value {};
      auto status = library_->GetAttributeViInt64(vi, channel_list, attribute_id, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetAttributeViReal64(::grpc::ServerContext* context, const GetAttributeViReal64Request* request, GetAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViReal64 value {};
      auto status = library_->GetAttributeViReal64(vi, channel_list, attribute_id, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetAttributeViSession(::grpc::ServerContext* context, const GetAttributeViSessionRequest* request, GetAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViSession value {};
      auto status = library_->GetAttributeViSession(vi, channel_list, attribute_id, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      auto session_id = session_repository_->resolve_session_id(value);
      response->mutable_value()->set_id(session_id);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetAttributeViString(::grpc::ServerContext* context, const GetAttributeViStringRequest* request, GetAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();

      while (true) {
        auto status = library_->GetAttributeViString(vi, channel_list, attribute_id, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buf_size = status;

        std::string value;
        if (buf_size > 0) {
            value.resize(buf_size - 1);
        }
        status = library_->GetAttributeViString(vi, channel_list, attribute_id, buf_size, (ViChar*)value.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buf_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_value(value);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetChannelName(::grpc::ServerContext* context, const GetChannelNameRequest* request, GetChannelNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 index = request->index();

      while (true) {
        auto status = library_->GetChannelName(vi, index, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string channel_string;
        if (buffer_size > 0) {
            channel_string.resize(buffer_size - 1);
        }
        status = library_->GetChannelName(vi, index, buffer_size, (ViChar*)channel_string.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_channel_string(channel_string);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_channel_string()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetChannelNameFromString(::grpc::ServerContext* context, const GetChannelNameFromStringRequest* request, GetChannelNameFromStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto index = request->index().c_str();

      while (true) {
        auto status = library_->GetChannelNameFromString(vi, index, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string name;
        if (buffer_size > 0) {
            name.resize(buffer_size - 1);
        }
        status = library_->GetChannelNameFromString(vi, index, buffer_size, (ViChar*)name.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_name(name);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_name()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetEqualizationFilterCoefficients(::grpc::ServerContext* context, const GetEqualizationFilterCoefficientsRequest* request, GetEqualizationFilterCoefficientsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel = request->channel().c_str();
      ViInt32 number_of_coefficients = request->number_of_coefficients();
      response->mutable_coefficients()->Resize(number_of_coefficients, 0);
      ViReal64* coefficients = response->mutable_coefficients()->mutable_data();
      auto status = library_->GetEqualizationFilterCoefficients(vi, channel, number_of_coefficients, coefficients);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetError(::grpc::ServerContext* context, const GetErrorRequest* request, GetErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());

      while (true) {
        auto status = library_->GetError(vi, nullptr, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        ViStatus error_code {};
        std::string description;
        if (buffer_size > 0) {
            description.resize(buffer_size - 1);
        }
        status = library_->GetError(vi, &error_code, buffer_size, (ViChar*)description.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_error_code(error_code);
        response->set_description(description);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_description()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetErrorMessage(::grpc::ServerContext* context, const GetErrorMessageRequest* request, GetErrorMessageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViStatus error_code = request->error_code();

      while (true) {
        auto status = library_->GetErrorMessage(vi, error_code, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string error_message;
        if (buffer_size > 0) {
            error_message.resize(buffer_size - 1);
        }
        status = library_->GetErrorMessage(vi, error_code, buffer_size, (ViChar*)error_message.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_error_message(error_message);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_message()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetFrequencyResponse(::grpc::ServerContext* context, const GetFrequencyResponseRequest* request, GetFrequencyResponseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel = request->channel().c_str();
      ViInt32 buffer_size = request->buffer_size();
      response->mutable_frequencies()->Resize(buffer_size, 0);
      ViReal64* frequencies = response->mutable_frequencies()->mutable_data();
      response->mutable_amplitudes()->Resize(buffer_size, 0);
      ViReal64* amplitudes = response->mutable_amplitudes()->mutable_data();
      response->mutable_phases()->Resize(buffer_size, 0);
      ViReal64* phases = response->mutable_phases()->mutable_data();
      ViInt32 number_of_frequencies {};
      auto status = library_->GetFrequencyResponse(vi, channel, buffer_size, frequencies, amplitudes, phases, &number_of_frequencies);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_number_of_frequencies(number_of_frequencies);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetNormalizationCoefficients(::grpc::ServerContext* context, const GetNormalizationCoefficientsRequest* request, GetNormalizationCoefficientsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 number_of_coefficient_sets {};
      while (true) {
        auto status = library_->GetNormalizationCoefficients(vi, channel_list, 0, nullptr, &number_of_coefficient_sets);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        std::vector<niScope_coefficientInfo> coefficient_info(number_of_coefficient_sets, niScope_coefficientInfo());
        auto buffer_size = number_of_coefficient_sets;
        status = library_->GetNormalizationCoefficients(vi, channel_list, buffer_size, coefficient_info.data(), &number_of_coefficient_sets);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        convert_to_grpc(coefficient_info, response->mutable_coefficient_info());
        {
          auto shrunk_size = number_of_coefficient_sets;
          auto current_size = response->mutable_coefficient_info()->size();
          if (shrunk_size != current_size) {
            response->mutable_coefficient_info()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_number_of_coefficient_sets(number_of_coefficient_sets);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetScalingCoefficients(::grpc::ServerContext* context, const GetScalingCoefficientsRequest* request, GetScalingCoefficientsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 number_of_coefficient_sets {};
      while (true) {
        auto status = library_->GetScalingCoefficients(vi, channel_list, 0, nullptr, &number_of_coefficient_sets);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        std::vector<niScope_coefficientInfo> coefficient_info(number_of_coefficient_sets, niScope_coefficientInfo());
        auto buffer_size = number_of_coefficient_sets;
        status = library_->GetScalingCoefficients(vi, channel_list, buffer_size, coefficient_info.data(), &number_of_coefficient_sets);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        convert_to_grpc(coefficient_info, response->mutable_coefficient_info());
        {
          auto shrunk_size = number_of_coefficient_sets;
          auto current_size = response->mutable_coefficient_info()->size();
          if (shrunk_size != current_size) {
            response->mutable_coefficient_info()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_number_of_coefficient_sets(number_of_coefficient_sets);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::GetStreamEndpointHandle(::grpc::ServerContext* context, const GetStreamEndpointHandleRequest* request, GetStreamEndpointHandleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto stream_name = request->stream_name().c_str();
      ViUInt32 writer_handle {};
      auto status = library_->GetStreamEndpointHandle(vi, stream_name, &writer_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_writer_handle(writer_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ImportAttributeConfigurationBuffer(::grpc::ServerContext* context, const ImportAttributeConfigurationBufferRequest* request, ImportAttributeConfigurationBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 size_in_bytes = static_cast<ViInt32>(request->configuration().size());
      ViInt8* configuration = (ViInt8*)request->configuration().c_str();
      auto status = library_->ImportAttributeConfigurationBuffer(vi, size_in_bytes, configuration);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ImportAttributeConfigurationFile(::grpc::ServerContext* context, const ImportAttributeConfigurationFileRequest* request, ImportAttributeConfigurationFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->ImportAttributeConfigurationFile(vi, file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::Init(::grpc::ServerContext* context, const InitRequest* request, InitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViRsrc resource_name = (ViRsrc)request->resource_name().c_str();
      ViBoolean id_query = request->id_query();
      ViBoolean reset_device = request->reset_device();
      auto initialization_behavior = request->initialization_behavior();

      bool new_session_initialized {};
      auto init_lambda = [&] () {
        ViSession vi;
        auto status = library_->Init(resource_name, id_query, reset_device, &vi);
        return std::make_tuple(status, vi);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->mutable_vi()->set_id(session_id);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::InitWithOptions(::grpc::ServerContext* context, const InitWithOptionsRequest* request, InitWithOptionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViRsrc resource_name = (ViRsrc)request->resource_name().c_str();
      ViBoolean id_query = request->id_query();
      ViBoolean reset_device = request->reset_device();
      auto option_string = request->option_string().c_str();
      auto initialization_behavior = request->initialization_behavior();

      bool new_session_initialized {};
      auto init_lambda = [&] () {
        ViSession vi;
        auto status = library_->InitWithOptions(resource_name, id_query, reset_device, option_string, &vi);
        return std::make_tuple(status, vi);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->mutable_vi()->set_id(session_id);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::InitiateAcquisition(::grpc::ServerContext* context, const InitiateAcquisitionRequest* request, InitiateAcquisitionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->InitiateAcquisition(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ProbeCompensationSignalStart(::grpc::ServerContext* context, const ProbeCompensationSignalStartRequest* request, ProbeCompensationSignalStartResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->ProbeCompensationSignalStart(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ProbeCompensationSignalStop(::grpc::ServerContext* context, const ProbeCompensationSignalStopRequest* request, ProbeCompensationSignalStopResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->ProbeCompensationSignalStop(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::Reset(::grpc::ServerContext* context, const ResetRequest* request, ResetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Reset(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::ResetDevice(::grpc::ServerContext* context, const ResetDeviceRequest* request, ResetDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->ResetDevice(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::RevisionQuery(::grpc::ServerContext* context, const RevisionQueryRequest* request, RevisionQueryResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      std::string driver_revision(256 - 1, '\0');
      std::string firmware_revision(256 - 1, '\0');
      auto status = library_->RevisionQuery(vi, (ViChar*)driver_revision.data(), (ViChar*)firmware_revision.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_driver_revision(driver_revision);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_driver_revision()));
      response->set_firmware_revision(firmware_revision);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_firmware_revision()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::SampleMode(::grpc::ServerContext* context, const SampleModeRequest* request, SampleModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 sample_mode {};
      auto status = library_->SampleMode(vi, &sample_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_sample_mode(sample_mode);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::SampleRate(::grpc::ServerContext* context, const SampleRateRequest* request, SampleRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViReal64 sample_rate {};
      auto status = library_->SampleRate(vi, &sample_rate);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_sample_rate(sample_rate);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::SelfTest(::grpc::ServerContext* context, const SelfTestRequest* request, SelfTestResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt16 self_test_result {};
      std::string self_test_message(256 - 1, '\0');
      auto status = library_->SelfTest(vi, &self_test_result, (ViChar*)self_test_message.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_self_test_result(self_test_result);
      response->set_self_test_message(self_test_message);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_self_test_message()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::SendSoftwareTriggerEdge(::grpc::ServerContext* context, const SendSoftwareTriggerEdgeRequest* request, SendSoftwareTriggerEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 which_trigger;
      switch (request->which_trigger_enum_case()) {
        case niscope_grpc::SendSoftwareTriggerEdgeRequest::WhichTriggerEnumCase::kWhichTrigger: {
          which_trigger = static_cast<ViInt32>(request->which_trigger());
          break;
        }
        case niscope_grpc::SendSoftwareTriggerEdgeRequest::WhichTriggerEnumCase::kWhichTriggerRaw: {
          which_trigger = static_cast<ViInt32>(request->which_trigger_raw());
          break;
        }
        case niscope_grpc::SendSoftwareTriggerEdgeRequest::WhichTriggerEnumCase::WHICH_TRIGGER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for which_trigger was not specified or out of range");
          break;
        }
      }

      auto status = library_->SendSoftwareTriggerEdge(vi, which_trigger);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::SetAttributeViBoolean(::grpc::ServerContext* context, const SetAttributeViBooleanRequest* request, SetAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViBoolean value = request->value();
      auto status = library_->SetAttributeViBoolean(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::SetAttributeViInt32(::grpc::ServerContext* context, const SetAttributeViInt32Request* request, SetAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt32 value;
      switch (request->value_enum_case()) {
        case niscope_grpc::SetAttributeViInt32Request::ValueEnumCase::kValue: {
          value = static_cast<ViInt32>(request->value());
          break;
        }
        case niscope_grpc::SetAttributeViInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<ViInt32>(request->value_raw());
          break;
        }
        case niscope_grpc::SetAttributeViInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeViInt32(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::SetAttributeViInt64(::grpc::ServerContext* context, const SetAttributeViInt64Request* request, SetAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt64 value = request->value_raw();
      auto status = library_->SetAttributeViInt64(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::SetAttributeViReal64(::grpc::ServerContext* context, const SetAttributeViReal64Request* request, SetAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViReal64 value;
      switch (request->value_enum_case()) {
        case niscope_grpc::SetAttributeViReal64Request::ValueEnumCase::kValue: {
          value = static_cast<ViReal64>(request->value());
          break;
        }
        case niscope_grpc::SetAttributeViReal64Request::ValueEnumCase::kValueMapped: {
          auto value_imap_it = niscopereal64attributevaluesmapped_input_map_.find(request->value_mapped());
          if (value_imap_it == niscopereal64attributevaluesmapped_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value_mapped was not specified or out of range.");
          }
          value = static_cast<ViReal64>(value_imap_it->second);
          break;
        }
        case niscope_grpc::SetAttributeViReal64Request::ValueEnumCase::kValueRaw: {
          value = static_cast<ViReal64>(request->value_raw());
          break;
        }
        case niscope_grpc::SetAttributeViReal64Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeViReal64(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::SetAttributeViSession(::grpc::ServerContext* context, const SetAttributeViSessionRequest* request, SetAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      auto value_grpc_session = request->value();
      ViSession value = session_repository_->access_session(value_grpc_session.id(), value_grpc_session.name());
      auto status = library_->SetAttributeViSession(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiScopeService::SetAttributeViString(::grpc::ServerContext* context, const SetAttributeViStringRequest* request, SetAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      ViConstString value;
      switch (request->value_enum_case()) {
        case niscope_grpc::SetAttributeViStringRequest::ValueEnumCase::kValueMapped: {
          auto value_imap_it = niscopestringattributevaluesmapped_input_map_.find(request->value_mapped());
          if (value_imap_it == niscopestringattributevaluesmapped_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value_mapped was not specified or out of range.");
          }
          value = const_cast<ViConstString>((value_imap_it->second).c_str());
          break;
        }
        case niscope_grpc::SetAttributeViStringRequest::ValueEnumCase::kValueRaw: {
          value = const_cast<ViConstString>(request->value_raw().c_str());
          break;
        }
        case niscope_grpc::SetAttributeViStringRequest::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeViString(vi, channel_list, attribute_id, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  NiScopeFeatureToggles::NiScopeFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("niscope", CodeReadiness::kRelease))
  {
  }
} // namespace niscope_grpc

namespace nidevice_grpc {
namespace converters {
template <>
void convert_to_grpc(const niScope_coefficientInfo& input, niscope_grpc::CoefficientInfo* output) 
{
  output->set_offset(input.offset);
  output->set_gain(input.gain);
  output->set_reserved1(input.reserved1);
  output->set_reserved2(input.reserved2);
}

template <>
void convert_to_grpc(const niScope_wfmInfo& input, niscope_grpc::WaveformInfo* output) 
{
  output->set_absolute_initial_x(input.absoluteInitialX);
  output->set_relative_initial_x(input.relativeInitialX);
  output->set_x_increment(input.xIncrement);
  output->set_actual_samples(input.actualSamples);
  output->set_offset(input.offset);
  output->set_gain(input.gain);
  output->set_reserved1(input.reserved1);
  output->set_reserved2(input.reserved2);
}

} // converters
} // nidevice_grpc

