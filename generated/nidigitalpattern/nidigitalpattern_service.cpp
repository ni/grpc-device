
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-Digital Pattern Driver Metadata
//---------------------------------------------------------------------
#include "nidigitalpattern_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>

namespace nidigitalpattern_grpc {

  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiDigitalService::NiDigitalService(
      NiDigitalLibraryInterface* library,
      ResourceRepositorySharedPtr session_repository, 
      const NiDigitalFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(session_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiDigitalService::~NiDigitalService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  template <typename TEnum>
  void NiDigitalService::CopyBytesToEnums(const std::string& input, google::protobuf::RepeatedField<TEnum>* output)
  {
    for (auto item : input)
    {
      output->Add(item);
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::Abort(::grpc::ServerContext* context, const AbortRequest* request, AbortResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Abort(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::AbortKeepAlive(::grpc::ServerContext* context, const AbortKeepAliveRequest* request, AbortKeepAliveResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->AbortKeepAlive(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ApplyLevelsAndTiming(::grpc::ServerContext* context, const ApplyLevelsAndTimingRequest* request, ApplyLevelsAndTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto levels_sheet = request->levels_sheet().c_str();
      auto timing_sheet = request->timing_sheet().c_str();
      auto initial_state_high_pins = request->initial_state_high_pins().c_str();
      auto initial_state_low_pins = request->initial_state_low_pins().c_str();
      auto initial_state_tristate_pins = request->initial_state_tristate_pins().c_str();
      auto status = library_->ApplyLevelsAndTiming(vi, site_list, levels_sheet, timing_sheet, initial_state_high_pins, initial_state_low_pins, initial_state_tristate_pins);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ApplyTDROffsets(::grpc::ServerContext* context, const ApplyTDROffsetsRequest* request, ApplyTDROffsetsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 num_offsets = static_cast<ViInt32>(request->offsets().size());
      auto offsets = const_cast<ViReal64*>(request->offsets().data());
      auto status = library_->ApplyTDROffsets(vi, channel_list, num_offsets, offsets);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::BurstPattern(::grpc::ServerContext* context, const BurstPatternRequest* request, BurstPatternResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto start_label = request->start_label().c_str();
      ViBoolean select_digital_function = request->select_digital_function();
      ViBoolean wait_until_done = request->wait_until_done();
      ViReal64 timeout = request->timeout();
      auto status = library_->BurstPattern(vi, site_list, start_label, select_digital_function, wait_until_done, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::BurstPatternSynchronized(::grpc::ServerContext* context, const BurstPatternSynchronizedRequest* request, BurstPatternSynchronizedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = request->session_count();
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      auto site_list = request->site_list().c_str();
      auto start_label = request->start_label().c_str();
      ViBoolean select_digital_function = request->select_digital_function();
      ViBoolean wait_until_done = request->wait_until_done();
      ViReal64 timeout = request->timeout();
      auto status = library_->BurstPatternSynchronized(session_count, sessions.data(), site_list, start_label, select_digital_function, wait_until_done, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ClearError(::grpc::ServerContext* context, const ClearErrorRequest* request, ClearErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->ClearError(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ClockGeneratorAbort(::grpc::ServerContext* context, const ClockGeneratorAbortRequest* request, ClockGeneratorAbortResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      auto status = library_->ClockGeneratorAbort(vi, channel_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ClockGeneratorGenerateClock(::grpc::ServerContext* context, const ClockGeneratorGenerateClockRequest* request, ClockGeneratorGenerateClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 frequency = request->frequency();
      ViBoolean select_digital_function = request->select_digital_function();
      auto status = library_->ClockGeneratorGenerateClock(vi, channel_list, frequency, select_digital_function);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ClockGeneratorInitiate(::grpc::ServerContext* context, const ClockGeneratorInitiateRequest* request, ClockGeneratorInitiateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      auto status = library_->ClockGeneratorInitiate(vi, channel_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      session_repository_->remove_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Close(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::Commit(::grpc::ServerContext* context, const CommitRequest* request, CommitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Commit(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureActiveLoadLevels(::grpc::ServerContext* context, const ConfigureActiveLoadLevelsRequest* request, ConfigureActiveLoadLevelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 iol = request->iol();
      ViReal64 ioh = request->ioh();
      ViReal64 vcom = request->vcom();
      auto status = library_->ConfigureActiveLoadLevels(vi, channel_list, iol, ioh, vcom);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureCycleNumberHistoryRAMTrigger(::grpc::ServerContext* context, const ConfigureCycleNumberHistoryRAMTriggerRequest* request, ConfigureCycleNumberHistoryRAMTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt64 cycle_number = request->cycle_number();
      ViInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->ConfigureCycleNumberHistoryRAMTrigger(vi, cycle_number, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureDigitalEdgeConditionalJumpTrigger(::grpc::ServerContext* context, const ConfigureDigitalEdgeConditionalJumpTriggerRequest* request, ConfigureDigitalEdgeConditionalJumpTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_identifier = request->trigger_identifier().c_str();
      auto source = request->source().c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidigitalpattern_grpc::ConfigureDigitalEdgeConditionalJumpTriggerRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidigitalpattern_grpc::ConfigureDigitalEdgeConditionalJumpTriggerRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureDigitalEdgeConditionalJumpTriggerRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeConditionalJumpTrigger(vi, trigger_identifier, source, edge);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureDigitalEdgeStartTrigger(::grpc::ServerContext* context, const ConfigureDigitalEdgeStartTriggerRequest* request, ConfigureDigitalEdgeStartTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto source = request->source().c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidigitalpattern_grpc::ConfigureDigitalEdgeStartTriggerRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidigitalpattern_grpc::ConfigureDigitalEdgeStartTriggerRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureDigitalEdgeStartTriggerRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeStartTrigger(vi, source, edge);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureFirstFailureHistoryRAMTrigger(::grpc::ServerContext* context, const ConfigureFirstFailureHistoryRAMTriggerRequest* request, ConfigureFirstFailureHistoryRAMTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->ConfigureFirstFailureHistoryRAMTrigger(vi, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureHistoryRAMCyclesToAcquire(::grpc::ServerContext* context, const ConfigureHistoryRAMCyclesToAcquireRequest* request, ConfigureHistoryRAMCyclesToAcquireResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 cycles_to_acquire;
      switch (request->cycles_to_acquire_enum_case()) {
        case nidigitalpattern_grpc::ConfigureHistoryRAMCyclesToAcquireRequest::CyclesToAcquireEnumCase::kCyclesToAcquire: {
          cycles_to_acquire = static_cast<ViInt32>(request->cycles_to_acquire());
          break;
        }
        case nidigitalpattern_grpc::ConfigureHistoryRAMCyclesToAcquireRequest::CyclesToAcquireEnumCase::kCyclesToAcquireRaw: {
          cycles_to_acquire = static_cast<ViInt32>(request->cycles_to_acquire_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureHistoryRAMCyclesToAcquireRequest::CyclesToAcquireEnumCase::CYCLES_TO_ACQUIRE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for cycles_to_acquire was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureHistoryRAMCyclesToAcquire(vi, cycles_to_acquire);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigurePatternBurstSites(::grpc::ServerContext* context, const ConfigurePatternBurstSitesRequest* request, ConfigurePatternBurstSitesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto status = library_->ConfigurePatternBurstSites(vi, site_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigurePatternLabelHistoryRAMTrigger(::grpc::ServerContext* context, const ConfigurePatternLabelHistoryRAMTriggerRequest* request, ConfigurePatternLabelHistoryRAMTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto label = request->label().c_str();
      ViInt64 vector_offset = request->vector_offset();
      ViInt64 cycle_offset = request->cycle_offset();
      ViInt32 pretrigger_samples = request->pretrigger_samples();
      auto status = library_->ConfigurePatternLabelHistoryRAMTrigger(vi, label, vector_offset, cycle_offset, pretrigger_samples);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureStartLabel(::grpc::ServerContext* context, const ConfigureStartLabelRequest* request, ConfigureStartLabelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto label = request->label().c_str();
      auto status = library_->ConfigureStartLabel(vi, label);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureSoftwareEdgeConditionalJumpTrigger(::grpc::ServerContext* context, const ConfigureSoftwareEdgeConditionalJumpTriggerRequest* request, ConfigureSoftwareEdgeConditionalJumpTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_identifier = request->trigger_identifier().c_str();
      auto status = library_->ConfigureSoftwareEdgeConditionalJumpTrigger(vi, trigger_identifier);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureSoftwareEdgeStartTrigger(::grpc::ServerContext* context, const ConfigureSoftwareEdgeStartTriggerRequest* request, ConfigureSoftwareEdgeStartTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->ConfigureSoftwareEdgeStartTrigger(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTerminationMode(::grpc::ServerContext* context, const ConfigureTerminationModeRequest* request, ConfigureTerminationModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 mode;
      switch (request->mode_enum_case()) {
        case nidigitalpattern_grpc::ConfigureTerminationModeRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViInt32>(request->mode());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTerminationModeRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViInt32>(request->mode_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTerminationModeRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureTerminationMode(vi, channel_list, mode);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetCompareEdgesStrobe(::grpc::ServerContext* context, const ConfigureTimeSetCompareEdgesStrobeRequest* request, ConfigureTimeSetCompareEdgesStrobeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set_name = request->time_set_name().c_str();
      ViReal64 strobe_edge = request->strobe_edge();
      auto status = library_->ConfigureTimeSetCompareEdgesStrobe(vi, pin_list, time_set_name, strobe_edge);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetCompareEdgesStrobe2x(::grpc::ServerContext* context, const ConfigureTimeSetCompareEdgesStrobe2xRequest* request, ConfigureTimeSetCompareEdgesStrobe2xResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set_name = request->time_set_name().c_str();
      ViReal64 strobe_edge = request->strobe_edge();
      ViReal64 strobe2_edge = request->strobe2_edge();
      auto status = library_->ConfigureTimeSetCompareEdgesStrobe2x(vi, pin_list, time_set_name, strobe_edge, strobe2_edge);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetDriveEdges(::grpc::ServerContext* context, const ConfigureTimeSetDriveEdgesRequest* request, ConfigureTimeSetDriveEdgesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set_name = request->time_set_name().c_str();
      ViInt32 format;
      switch (request->format_enum_case()) {
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdgesRequest::FormatEnumCase::kFormat: {
          format = static_cast<ViInt32>(request->format());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdgesRequest::FormatEnumCase::kFormatRaw: {
          format = static_cast<ViInt32>(request->format_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdgesRequest::FormatEnumCase::FORMAT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for format was not specified or out of range");
          break;
        }
      }

      ViReal64 drive_on_edge = request->drive_on_edge();
      ViReal64 drive_data_edge = request->drive_data_edge();
      ViReal64 drive_return_edge = request->drive_return_edge();
      ViReal64 drive_off_edge = request->drive_off_edge();
      auto status = library_->ConfigureTimeSetDriveEdges(vi, pin_list, time_set_name, format, drive_on_edge, drive_data_edge, drive_return_edge, drive_off_edge);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetDriveEdges2x(::grpc::ServerContext* context, const ConfigureTimeSetDriveEdges2xRequest* request, ConfigureTimeSetDriveEdges2xResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set_name = request->time_set_name().c_str();
      ViInt32 format;
      switch (request->format_enum_case()) {
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdges2xRequest::FormatEnumCase::kFormat: {
          format = static_cast<ViInt32>(request->format());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdges2xRequest::FormatEnumCase::kFormatRaw: {
          format = static_cast<ViInt32>(request->format_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdges2xRequest::FormatEnumCase::FORMAT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for format was not specified or out of range");
          break;
        }
      }

      ViReal64 drive_on_edge = request->drive_on_edge();
      ViReal64 drive_data_edge = request->drive_data_edge();
      ViReal64 drive_return_edge = request->drive_return_edge();
      ViReal64 drive_off_edge = request->drive_off_edge();
      ViReal64 drive_data2_edge = request->drive_data2_edge();
      ViReal64 drive_return2_edge = request->drive_return2_edge();
      auto status = library_->ConfigureTimeSetDriveEdges2x(vi, pin_list, time_set_name, format, drive_on_edge, drive_data_edge, drive_return_edge, drive_off_edge, drive_data2_edge, drive_return2_edge);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetDriveFormat(::grpc::ServerContext* context, const ConfigureTimeSetDriveFormatRequest* request, ConfigureTimeSetDriveFormatResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set_name = request->time_set_name().c_str();
      ViInt32 drive_format;
      switch (request->drive_format_enum_case()) {
        case nidigitalpattern_grpc::ConfigureTimeSetDriveFormatRequest::DriveFormatEnumCase::kDriveFormat: {
          drive_format = static_cast<ViInt32>(request->drive_format());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveFormatRequest::DriveFormatEnumCase::kDriveFormatRaw: {
          drive_format = static_cast<ViInt32>(request->drive_format_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveFormatRequest::DriveFormatEnumCase::DRIVE_FORMAT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for drive_format was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureTimeSetDriveFormat(vi, pin_list, time_set_name, drive_format);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetEdge(::grpc::ServerContext* context, const ConfigureTimeSetEdgeRequest* request, ConfigureTimeSetEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set_name = request->time_set_name().c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidigitalpattern_grpc::ConfigureTimeSetEdgeRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetEdgeRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetEdgeRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      ViReal64 time = request->time();
      auto status = library_->ConfigureTimeSetEdge(vi, pin_list, time_set_name, edge, time);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetEdgeMultiplier(::grpc::ServerContext* context, const ConfigureTimeSetEdgeMultiplierRequest* request, ConfigureTimeSetEdgeMultiplierResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set_name = request->time_set_name().c_str();
      ViInt32 edge_multiplier = request->edge_multiplier();
      auto status = library_->ConfigureTimeSetEdgeMultiplier(vi, pin_list, time_set_name, edge_multiplier);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetPeriod(::grpc::ServerContext* context, const ConfigureTimeSetPeriodRequest* request, ConfigureTimeSetPeriodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto time_set_name = request->time_set_name().c_str();
      ViReal64 period = request->period();
      auto status = library_->ConfigureTimeSetPeriod(vi, time_set_name, period);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureVoltageLevels(::grpc::ServerContext* context, const ConfigureVoltageLevelsRequest* request, ConfigureVoltageLevelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 vil = request->vil();
      ViReal64 vih = request->vih();
      ViReal64 vol = request->vol();
      ViReal64 voh = request->voh();
      ViReal64 vterm = request->vterm();
      auto status = library_->ConfigureVoltageLevels(vi, channel_list, vil, vih, vol, voh, vterm);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateCaptureWaveformFromFileDigicapture(::grpc::ServerContext* context, const CreateCaptureWaveformFromFileDigicaptureRequest* request, CreateCaptureWaveformFromFileDigicaptureResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto waveform_name = request->waveform_name().c_str();
      auto waveform_file_path = request->waveform_file_path().c_str();
      auto status = library_->CreateCaptureWaveformFromFileDigicapture(vi, waveform_name, waveform_file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateCaptureWaveformParallel(::grpc::ServerContext* context, const CreateCaptureWaveformParallelRequest* request, CreateCaptureWaveformParallelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      auto status = library_->CreateCaptureWaveformParallel(vi, pin_list, waveform_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateCaptureWaveformSerial(::grpc::ServerContext* context, const CreateCaptureWaveformSerialRequest* request, CreateCaptureWaveformSerialResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      ViUInt32 sample_width = request->sample_width();
      ViInt32 bit_order;
      switch (request->bit_order_enum_case()) {
        case nidigitalpattern_grpc::CreateCaptureWaveformSerialRequest::BitOrderEnumCase::kBitOrder: {
          bit_order = static_cast<ViInt32>(request->bit_order());
          break;
        }
        case nidigitalpattern_grpc::CreateCaptureWaveformSerialRequest::BitOrderEnumCase::kBitOrderRaw: {
          bit_order = static_cast<ViInt32>(request->bit_order_raw());
          break;
        }
        case nidigitalpattern_grpc::CreateCaptureWaveformSerialRequest::BitOrderEnumCase::BIT_ORDER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bit_order was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCaptureWaveformSerial(vi, pin_list, waveform_name, sample_width, bit_order);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateChannelMap(::grpc::ServerContext* context, const CreateChannelMapRequest* request, CreateChannelMapResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 num_sites = request->num_sites();
      auto status = library_->CreateChannelMap(vi, num_sites);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateSourceWaveformFromFileTDMS(::grpc::ServerContext* context, const CreateSourceWaveformFromFileTDMSRequest* request, CreateSourceWaveformFromFileTDMSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto waveform_name = request->waveform_name().c_str();
      auto waveform_file_path = request->waveform_file_path().c_str();
      ViBoolean write_waveform_data = request->write_waveform_data();
      auto status = library_->CreateSourceWaveformFromFileTDMS(vi, waveform_name, waveform_file_path, write_waveform_data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreatePinMap(::grpc::ServerContext* context, const CreatePinMapRequest* request, CreatePinMapResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto dut_pin_list = request->dut_pin_list().c_str();
      auto system_pin_list = request->system_pin_list().c_str();
      auto status = library_->CreatePinMap(vi, dut_pin_list, system_pin_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreatePinGroup(::grpc::ServerContext* context, const CreatePinGroupRequest* request, CreatePinGroupResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_group_name = request->pin_group_name().c_str();
      auto pin_list = request->pin_list().c_str();
      auto status = library_->CreatePinGroup(vi, pin_group_name, pin_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateSourceWaveformParallel(::grpc::ServerContext* context, const CreateSourceWaveformParallelRequest* request, CreateSourceWaveformParallelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      ViInt32 data_mapping;
      switch (request->data_mapping_enum_case()) {
        case nidigitalpattern_grpc::CreateSourceWaveformParallelRequest::DataMappingEnumCase::kDataMapping: {
          data_mapping = static_cast<ViInt32>(request->data_mapping());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformParallelRequest::DataMappingEnumCase::kDataMappingRaw: {
          data_mapping = static_cast<ViInt32>(request->data_mapping_raw());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformParallelRequest::DataMappingEnumCase::DATA_MAPPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_mapping was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateSourceWaveformParallel(vi, pin_list, waveform_name, data_mapping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateSourceWaveformSerial(::grpc::ServerContext* context, const CreateSourceWaveformSerialRequest* request, CreateSourceWaveformSerialResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      ViInt32 data_mapping;
      switch (request->data_mapping_enum_case()) {
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::DataMappingEnumCase::kDataMapping: {
          data_mapping = static_cast<ViInt32>(request->data_mapping());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::DataMappingEnumCase::kDataMappingRaw: {
          data_mapping = static_cast<ViInt32>(request->data_mapping_raw());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::DataMappingEnumCase::DATA_MAPPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_mapping was not specified or out of range");
          break;
        }
      }

      ViUInt32 sample_width = request->sample_width();
      ViInt32 bit_order;
      switch (request->bit_order_enum_case()) {
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::BitOrderEnumCase::kBitOrder: {
          bit_order = static_cast<ViInt32>(request->bit_order());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::BitOrderEnumCase::kBitOrderRaw: {
          bit_order = static_cast<ViInt32>(request->bit_order_raw());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::BitOrderEnumCase::BIT_ORDER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bit_order was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateSourceWaveformSerial(vi, pin_list, waveform_name, data_mapping, sample_width, bit_order);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateTimeSet(::grpc::ServerContext* context, const CreateTimeSetRequest* request, CreateTimeSetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto name = request->name().c_str();
      auto status = library_->CreateTimeSet(vi, name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::DeleteAllTimeSets(::grpc::ServerContext* context, const DeleteAllTimeSetsRequest* request, DeleteAllTimeSetsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->DeleteAllTimeSets(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::DisableConditionalJumpTrigger(::grpc::ServerContext* context, const DisableConditionalJumpTriggerRequest* request, DisableConditionalJumpTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto trigger_identifier = request->trigger_identifier().c_str();
      auto status = library_->DisableConditionalJumpTrigger(vi, trigger_identifier);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::DisableSites(::grpc::ServerContext* context, const DisableSitesRequest* request, DisableSitesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto status = library_->DisableSites(vi, site_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::DisableStartTrigger(::grpc::ServerContext* context, const DisableStartTriggerRequest* request, DisableStartTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->DisableStartTrigger(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::EnableMatchFailCombination(::grpc::ServerContext* context, const EnableMatchFailCombinationRequest* request, EnableMatchFailCombinationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = request->session_count();
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      auto sync_session_grpc_session = request->sync_session();
      ViSession sync_session = session_repository_->access_session(sync_session_grpc_session.id(), sync_session_grpc_session.name());
      auto status = library_->EnableMatchFailCombination(session_count, sessions.data(), sync_session);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::EnableSites(::grpc::ServerContext* context, const EnableSitesRequest* request, EnableSitesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto status = library_->EnableSites(vi, site_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::EndChannelMap(::grpc::ServerContext* context, const EndChannelMapRequest* request, EndChannelMapResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->EndChannelMap(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ErrorMessage(::grpc::ServerContext* context, const ErrorMessageRequest* request, ErrorMessageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViStatus error_code = request->error_code();
      std::string error_message(256 - 1, '\0');
      auto status = library_->ErrorMessage(vi, error_code, (ViChar*)error_message.data());
      response->set_status(status);
      if (status_ok(status)) {
        response->set_error_message(error_message);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_message()));
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ExportSignal(::grpc::ServerContext* context, const ExportSignalRequest* request, ExportSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 signal;
      switch (request->signal_enum_case()) {
        case nidigitalpattern_grpc::ExportSignalRequest::SignalEnumCase::kSignal: {
          signal = static_cast<ViInt32>(request->signal());
          break;
        }
        case nidigitalpattern_grpc::ExportSignalRequest::SignalEnumCase::kSignalRaw: {
          signal = static_cast<ViInt32>(request->signal_raw());
          break;
        }
        case nidigitalpattern_grpc::ExportSignalRequest::SignalEnumCase::SIGNAL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal was not specified or out of range");
          break;
        }
      }

      auto signal_identifier = request->signal_identifier().c_str();
      auto output_terminal = request->output_terminal().c_str();
      auto status = library_->ExportSignal(vi, signal, signal_identifier, output_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::FetchCaptureWaveformU32(::grpc::ServerContext* context, const FetchCaptureWaveformU32Request* request, FetchCaptureWaveformU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      ViInt32 samples_to_read = request->samples_to_read();
      ViReal64 timeout = request->timeout();
      ViInt32 actual_num_waveforms {};
      ViInt32 actual_samples_per_waveform {};
      while (true) {
        auto status = library_->FetchCaptureWaveformU32(vi, site_list, waveform_name, samples_to_read, timeout, 0, nullptr, &actual_num_waveforms, &actual_samples_per_waveform);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_data()->Resize(actual_num_waveforms, 0);
        ViUInt32* data = reinterpret_cast<ViUInt32*>(response->mutable_data()->mutable_data());
        auto data_buffer_size = actual_num_waveforms;
        status = library_->FetchCaptureWaveformU32(vi, site_list, waveform_name, samples_to_read, timeout, data_buffer_size, data, &actual_num_waveforms, &actual_samples_per_waveform);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_data()->Resize(actual_num_waveforms, 0);
          response->set_actual_num_waveforms(actual_num_waveforms);
          response->set_actual_samples_per_waveform(actual_samples_per_waveform);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::FetchHistoryRAMCycleInformation(::grpc::ServerContext* context, const FetchHistoryRAMCycleInformationRequest* request, FetchHistoryRAMCycleInformationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site = request->site().c_str();
      ViInt64 sample_index = request->sample_index();
      ViInt32 pattern_index {};
      ViInt32 time_set_index {};
      ViInt64 vector_number {};
      ViInt64 cycle_number {};
      ViInt32 num_dut_cycles {};
      auto status = library_->FetchHistoryRAMCycleInformation(vi, site, sample_index, &pattern_index, &time_set_index, &vector_number, &cycle_number, &num_dut_cycles);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_pattern_index(pattern_index);
        response->set_time_set_index(time_set_index);
        response->set_vector_number(vector_number);
        response->set_cycle_number(cycle_number);
        response->set_num_dut_cycles(num_dut_cycles);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::FetchHistoryRAMCyclePinData(::grpc::ServerContext* context, const FetchHistoryRAMCyclePinDataRequest* request, FetchHistoryRAMCyclePinDataResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site = request->site().c_str();
      auto pin_list = request->pin_list().c_str();
      ViInt64 sample_index = request->sample_index();
      ViInt32 dut_cycle_index = request->dut_cycle_index();
      ViInt32 actual_num_pin_data {};
      while (true) {
        auto status = library_->FetchHistoryRAMCyclePinData(vi, site, pin_list, sample_index, dut_cycle_index, 0, nullptr, nullptr, nullptr, &actual_num_pin_data);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        std::string expected_pin_states(actual_num_pin_data, '\0');
        std::string actual_pin_states(actual_num_pin_data, '\0');
        std::vector<ViBoolean> per_pin_pass_fail(actual_num_pin_data, ViBoolean());
        auto pin_data_buffer_size = actual_num_pin_data;
        status = library_->FetchHistoryRAMCyclePinData(vi, site, pin_list, sample_index, dut_cycle_index, pin_data_buffer_size, (ViUInt8*)expected_pin_states.data(), (ViUInt8*)actual_pin_states.data(), per_pin_pass_fail.data(), &actual_num_pin_data);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          CopyBytesToEnums(expected_pin_states, response->mutable_expected_pin_states());
          response->set_expected_pin_states_raw(expected_pin_states);
          response->mutable_expected_pin_states()->Resize(actual_num_pin_data, 0);
          CopyBytesToEnums(actual_pin_states, response->mutable_actual_pin_states());
          response->set_actual_pin_states_raw(actual_pin_states);
          response->mutable_actual_pin_states()->Resize(actual_num_pin_data, 0);
          convert_to_grpc(per_pin_pass_fail, response->mutable_per_pin_pass_fail());
          response->mutable_per_pin_pass_fail()->Resize(actual_num_pin_data, 0);
          response->set_actual_num_pin_data(actual_num_pin_data);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::FetchHistoryRAMScanCycleNumber(::grpc::ServerContext* context, const FetchHistoryRAMScanCycleNumberRequest* request, FetchHistoryRAMScanCycleNumberResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site = request->site().c_str();
      ViInt64 sample_index = request->sample_index();
      ViInt64 scan_cycle_number {};
      auto status = library_->FetchHistoryRAMScanCycleNumber(vi, site, sample_index, &scan_cycle_number);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_scan_cycle_number(scan_cycle_number);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::FrequencyCounterConfigureMeasurementMode(::grpc::ServerContext* context, const FrequencyCounterConfigureMeasurementModeRequest* request, FrequencyCounterConfigureMeasurementModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 measurement_mode;
      switch (request->measurement_mode_enum_case()) {
        case nidigitalpattern_grpc::FrequencyCounterConfigureMeasurementModeRequest::MeasurementModeEnumCase::kMeasurementMode: {
          measurement_mode = static_cast<ViInt32>(request->measurement_mode());
          break;
        }
        case nidigitalpattern_grpc::FrequencyCounterConfigureMeasurementModeRequest::MeasurementModeEnumCase::kMeasurementModeRaw: {
          measurement_mode = static_cast<ViInt32>(request->measurement_mode_raw());
          break;
        }
        case nidigitalpattern_grpc::FrequencyCounterConfigureMeasurementModeRequest::MeasurementModeEnumCase::MEASUREMENT_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurement_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->FrequencyCounterConfigureMeasurementMode(vi, measurement_mode);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::FrequencyCounterConfigureMeasurementTime(::grpc::ServerContext* context, const FrequencyCounterConfigureMeasurementTimeRequest* request, FrequencyCounterConfigureMeasurementTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 measurement_time = request->measurement_time();
      auto status = library_->FrequencyCounterConfigureMeasurementTime(vi, channel_list, measurement_time);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::FrequencyCounterMeasureFrequency(::grpc::ServerContext* context, const FrequencyCounterMeasureFrequencyRequest* request, FrequencyCounterMeasureFrequencyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 actual_num_frequencies {};
      while (true) {
        auto status = library_->FrequencyCounterMeasureFrequency(vi, channel_list, 0, nullptr, &actual_num_frequencies);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_frequencies()->Resize(actual_num_frequencies, 0);
        ViReal64* frequencies = response->mutable_frequencies()->mutable_data();
        auto frequencies_buffer_size = actual_num_frequencies;
        status = library_->FrequencyCounterMeasureFrequency(vi, channel_list, frequencies_buffer_size, frequencies, &actual_num_frequencies);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_frequencies()->Resize(actual_num_frequencies, 0);
          response->set_actual_num_frequencies(actual_num_frequencies);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetAttributeViBoolean(::grpc::ServerContext* context, const GetAttributeViBooleanRequest* request, GetAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute = request->attribute();
      ViBoolean value {};
      auto status = library_->GetAttributeViBoolean(vi, channel_name, attribute, &value);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetAttributeViInt32(::grpc::ServerContext* context, const GetAttributeViInt32Request* request, GetAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute = request->attribute();
      ViInt32 value {};
      auto status = library_->GetAttributeViInt32(vi, channel_name, attribute, &value);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetAttributeViInt64(::grpc::ServerContext* context, const GetAttributeViInt64Request* request, GetAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute = request->attribute();
      ViInt64 value {};
      auto status = library_->GetAttributeViInt64(vi, channel_name, attribute, &value);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetAttributeViReal64(::grpc::ServerContext* context, const GetAttributeViReal64Request* request, GetAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute = request->attribute();
      ViReal64 value {};
      auto status = library_->GetAttributeViReal64(vi, channel_name, attribute, &value);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetAttributeViSession(::grpc::ServerContext* context, const GetAttributeViSessionRequest* request, GetAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute = request->attribute();
      ViSession value {};
      auto status = library_->GetAttributeViSession(vi, channel_list, attribute, &value);
      response->set_status(status);
      if (status_ok(status)) {
        auto session_id = session_repository_->resolve_session_id(value);
        response->mutable_value()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetAttributeViString(::grpc::ServerContext* context, const GetAttributeViStringRequest* request, GetAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute = request->attribute();

      while (true) {
        auto status = library_->GetAttributeViString(vi, channel_name, attribute, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        ViInt32 buffer_size = status;
      
        std::string value;
        if (buffer_size > 0) {
            value.resize(buffer_size - 1);
        }
        status = library_->GetAttributeViString(vi, channel_name, attribute, buffer_size, (ViChar*)value.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_value(value);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_value()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetChannelName(::grpc::ServerContext* context, const GetChannelNameRequest* request, GetChannelNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 index = request->index();

      while (true) {
        auto status = library_->GetChannelName(vi, index, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        ViInt32 name_buffer_size = status;
      
        std::string name;
        if (name_buffer_size > 0) {
            name.resize(name_buffer_size - 1);
        }
        status = library_->GetChannelName(vi, index, name_buffer_size, (ViChar*)name.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(name_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_name(name);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_name()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetChannelNameFromString(::grpc::ServerContext* context, const GetChannelNameFromStringRequest* request, GetChannelNameFromStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto indices = request->indices().c_str();

      while (true) {
        auto status = library_->GetChannelNameFromString(vi, indices, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        ViInt32 name_buffer_size = status;
      
        std::string names;
        if (name_buffer_size > 0) {
            names.resize(name_buffer_size - 1);
        }
        status = library_->GetChannelNameFromString(vi, indices, name_buffer_size, (ViChar*)names.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(name_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_names(names);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_names()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetError(::grpc::ServerContext* context, const GetErrorRequest* request, GetErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());

      while (true) {
        auto status = library_->GetError(vi, nullptr, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        ViInt32 error_description_buffer_size = status;
      
        ViStatus error_code {};
        std::string error_description;
        if (error_description_buffer_size > 0) {
            error_description.resize(error_description_buffer_size - 1);
        }
        status = library_->GetError(vi, &error_code, error_description_buffer_size, (ViChar*)error_description.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(error_description_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_error_code(error_code);
          response->set_error_description(error_description);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_description()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetFailCount(::grpc::ServerContext* context, const GetFailCountRequest* request, GetFailCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 actual_num_read {};
      while (true) {
        auto status = library_->GetFailCount(vi, channel_list, 0, nullptr, &actual_num_read);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_failure_count()->Resize(actual_num_read, 0);
        ViInt64* failure_count = response->mutable_failure_count()->mutable_data();
        auto buffer_size = actual_num_read;
        status = library_->GetFailCount(vi, channel_list, buffer_size, failure_count, &actual_num_read);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_failure_count()->Resize(actual_num_read, 0);
          response->set_actual_num_read(actual_num_read);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetHistoryRAMSampleCount(::grpc::ServerContext* context, const GetHistoryRAMSampleCountRequest* request, GetHistoryRAMSampleCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site = request->site().c_str();
      ViInt64 sample_count {};
      auto status = library_->GetHistoryRAMSampleCount(vi, site, &sample_count);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_sample_count(sample_count);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetPatternPinIndexes(::grpc::ServerContext* context, const GetPatternPinIndexesRequest* request, GetPatternPinIndexesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto start_label = request->start_label().c_str();
      ViInt32 actual_num_pins {};
      while (true) {
        auto status = library_->GetPatternPinIndexes(vi, start_label, 0, nullptr, &actual_num_pins);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_pin_indexes()->Resize(actual_num_pins, 0);
        ViInt32* pin_indexes = reinterpret_cast<ViInt32*>(response->mutable_pin_indexes()->mutable_data());
        auto pin_indexes_buffer_size = actual_num_pins;
        status = library_->GetPatternPinIndexes(vi, start_label, pin_indexes_buffer_size, pin_indexes, &actual_num_pins);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_pin_indexes()->Resize(actual_num_pins, 0);
          response->set_actual_num_pins(actual_num_pins);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetPatternName(::grpc::ServerContext* context, const GetPatternNameRequest* request, GetPatternNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 pattern_index = request->pattern_index();

      while (true) {
        auto status = library_->GetPatternName(vi, pattern_index, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        ViInt32 name_buffer_size = status;
      
        std::string name;
        if (name_buffer_size > 0) {
            name.resize(name_buffer_size - 1);
        }
        status = library_->GetPatternName(vi, pattern_index, name_buffer_size, (ViChar*)name.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(name_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_name(name);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_name()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetPatternPinList(::grpc::ServerContext* context, const GetPatternPinListRequest* request, GetPatternPinListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto start_label = request->start_label().c_str();

      while (true) {
        auto status = library_->GetPatternPinList(vi, start_label, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        ViInt32 pin_list_buffer_size = status;
      
        std::string pin_list;
        if (pin_list_buffer_size > 0) {
            pin_list.resize(pin_list_buffer_size - 1);
        }
        status = library_->GetPatternPinList(vi, start_label, pin_list_buffer_size, (ViChar*)pin_list.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(pin_list_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_pin_list(pin_list);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_pin_list()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetPinName(::grpc::ServerContext* context, const GetPinNameRequest* request, GetPinNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 pin_index = request->pin_index();

      while (true) {
        auto status = library_->GetPinName(vi, pin_index, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        ViInt32 name_buffer_size = status;
      
        std::string name;
        if (name_buffer_size > 0) {
            name.resize(name_buffer_size - 1);
        }
        status = library_->GetPinName(vi, pin_index, name_buffer_size, (ViChar*)name.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(name_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_name(name);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_name()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetPinResultsPinInformation(::grpc::ServerContext* context, const GetPinResultsPinInformationRequest* request, GetPinResultsPinInformationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 actual_num_values {};
      while (true) {
        auto status = library_->GetPinResultsPinInformation(vi, channel_list, 0, nullptr, nullptr, nullptr, &actual_num_values);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_pin_indexes()->Resize(actual_num_values, 0);
        ViInt32* pin_indexes = reinterpret_cast<ViInt32*>(response->mutable_pin_indexes()->mutable_data());
        response->mutable_site_numbers()->Resize(actual_num_values, 0);
        ViInt32* site_numbers = reinterpret_cast<ViInt32*>(response->mutable_site_numbers()->mutable_data());
        response->mutable_channel_indexes()->Resize(actual_num_values, 0);
        ViInt32* channel_indexes = reinterpret_cast<ViInt32*>(response->mutable_channel_indexes()->mutable_data());
        auto buffer_size = actual_num_values;
        status = library_->GetPinResultsPinInformation(vi, channel_list, buffer_size, pin_indexes, site_numbers, channel_indexes, &actual_num_values);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_pin_indexes()->Resize(actual_num_values, 0);
          response->mutable_site_numbers()->Resize(actual_num_values, 0);
          response->mutable_channel_indexes()->Resize(actual_num_values, 0);
          response->set_actual_num_values(actual_num_values);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetSitePassFail(::grpc::ServerContext* context, const GetSitePassFailRequest* request, GetSitePassFailResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      ViInt32 actual_num_sites {};
      while (true) {
        auto status = library_->GetSitePassFail(vi, site_list, 0, nullptr, &actual_num_sites);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        std::vector<ViBoolean> pass_fail(actual_num_sites, ViBoolean());
        auto pass_fail_buffer_size = actual_num_sites;
        status = library_->GetSitePassFail(vi, site_list, pass_fail_buffer_size, pass_fail.data(), &actual_num_sites);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          convert_to_grpc(pass_fail, response->mutable_pass_fail());
          response->mutable_pass_fail()->Resize(actual_num_sites, 0);
          response->set_actual_num_sites(actual_num_sites);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetSiteResultsSiteNumbers(::grpc::ServerContext* context, const GetSiteResultsSiteNumbersRequest* request, GetSiteResultsSiteNumbersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      ViInt32 site_result_type;
      switch (request->site_result_type_enum_case()) {
        case nidigitalpattern_grpc::GetSiteResultsSiteNumbersRequest::SiteResultTypeEnumCase::kSiteResultType: {
          site_result_type = static_cast<ViInt32>(request->site_result_type());
          break;
        }
        case nidigitalpattern_grpc::GetSiteResultsSiteNumbersRequest::SiteResultTypeEnumCase::kSiteResultTypeRaw: {
          site_result_type = static_cast<ViInt32>(request->site_result_type_raw());
          break;
        }
        case nidigitalpattern_grpc::GetSiteResultsSiteNumbersRequest::SiteResultTypeEnumCase::SITE_RESULT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for site_result_type was not specified or out of range");
          break;
        }
      }

      ViInt32 actual_num_site_numbers {};
      while (true) {
        auto status = library_->GetSiteResultsSiteNumbers(vi, site_list, site_result_type, 0, nullptr, &actual_num_site_numbers);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_site_numbers()->Resize(actual_num_site_numbers, 0);
        ViInt32* site_numbers = reinterpret_cast<ViInt32*>(response->mutable_site_numbers()->mutable_data());
        auto site_numbers_buffer_size = actual_num_site_numbers;
        status = library_->GetSiteResultsSiteNumbers(vi, site_list, site_result_type, site_numbers_buffer_size, site_numbers, &actual_num_site_numbers);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_site_numbers()->Resize(actual_num_site_numbers, 0);
          response->set_actual_num_site_numbers(actual_num_site_numbers);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetTimeSetDriveFormat(::grpc::ServerContext* context, const GetTimeSetDriveFormatRequest* request, GetTimeSetDriveFormatResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin = request->pin().c_str();
      auto time_set_name = request->time_set_name().c_str();
      ViInt32 format {};
      auto status = library_->GetTimeSetDriveFormat(vi, pin, time_set_name, &format);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_format(static_cast<nidigitalpattern_grpc::DriveFormat>(format));
        response->set_format_raw(format);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetTimeSetEdge(::grpc::ServerContext* context, const GetTimeSetEdgeRequest* request, GetTimeSetEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin = request->pin().c_str();
      auto time_set_name = request->time_set_name().c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidigitalpattern_grpc::GetTimeSetEdgeRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidigitalpattern_grpc::GetTimeSetEdgeRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidigitalpattern_grpc::GetTimeSetEdgeRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      ViReal64 time {};
      auto status = library_->GetTimeSetEdge(vi, pin, time_set_name, edge, &time);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_time(time);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetTimeSetEdgeMultiplier(::grpc::ServerContext* context, const GetTimeSetEdgeMultiplierRequest* request, GetTimeSetEdgeMultiplierResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin = request->pin().c_str();
      auto time_set_name = request->time_set_name().c_str();
      ViInt32 edge_multiplier {};
      auto status = library_->GetTimeSetEdgeMultiplier(vi, pin, time_set_name, &edge_multiplier);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_edge_multiplier(edge_multiplier);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetTimeSetName(::grpc::ServerContext* context, const GetTimeSetNameRequest* request, GetTimeSetNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 time_set_index = request->time_set_index();

      while (true) {
        auto status = library_->GetTimeSetName(vi, time_set_index, 0, nullptr);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        ViInt32 name_buffer_size = status;
      
        std::string name;
        if (name_buffer_size > 0) {
            name.resize(name_buffer_size - 1);
        }
        status = library_->GetTimeSetName(vi, time_set_index, name_buffer_size, (ViChar*)name.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(name_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->set_name(name);
          nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_name()));
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetTimeSetPeriod(::grpc::ServerContext* context, const GetTimeSetPeriodRequest* request, GetTimeSetPeriodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto time_set_name = request->time_set_name().c_str();
      ViReal64 period {};
      auto status = library_->GetTimeSetPeriod(vi, time_set_name, &period);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_period(period);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::Init(::grpc::ServerContext* context, const InitRequest* request, InitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViRsrc resource_name = (ViRsrc)request->resource_name().c_str();
      ViBoolean id_query = request->id_query();
      ViBoolean reset_device = request->reset_device();

      auto init_lambda = [&] () {
        ViSession vi;
        int status = library_->Init(resource_name, id_query, reset_device, &vi);
        return std::make_tuple(status, vi);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_vi()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::InitWithOptions(::grpc::ServerContext* context, const InitWithOptionsRequest* request, InitWithOptionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViRsrc resource_name = (ViRsrc)request->resource_name().c_str();
      ViBoolean id_query = request->id_query();
      ViBoolean reset_device = request->reset_device();
      auto option_string = request->option_string().c_str();

      auto init_lambda = [&] () {
        ViSession vi;
        int status = library_->InitWithOptions(resource_name, id_query, reset_device, option_string, &vi);
        return std::make_tuple(status, vi);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_vi()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::Initiate(::grpc::ServerContext* context, const InitiateRequest* request, InitiateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Initiate(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::IsDone(::grpc::ServerContext* context, const IsDoneRequest* request, IsDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViBoolean done {};
      auto status = library_->IsDone(vi, &done);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_done(done);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::IsSiteEnabled(::grpc::ServerContext* context, const IsSiteEnabledRequest* request, IsSiteEnabledResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site = request->site().c_str();
      ViBoolean enable {};
      auto status = library_->IsSiteEnabled(vi, site, &enable);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_enable(enable);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LoadLevels(::grpc::ServerContext* context, const LoadLevelsRequest* request, LoadLevelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->LoadLevels(vi, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LoadPattern(::grpc::ServerContext* context, const LoadPatternRequest* request, LoadPatternResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->LoadPattern(vi, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LoadPinMap(::grpc::ServerContext* context, const LoadPinMapRequest* request, LoadPinMapResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->LoadPinMap(vi, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LoadSpecifications(::grpc::ServerContext* context, const LoadSpecificationsRequest* request, LoadSpecificationsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->LoadSpecifications(vi, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LoadTiming(::grpc::ServerContext* context, const LoadTimingRequest* request, LoadTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->LoadTiming(vi, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::MapPinToChannel(::grpc::ServerContext* context, const MapPinToChannelRequest* request, MapPinToChannelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin = request->pin().c_str();
      ViInt32 site = request->site();
      auto channel = request->channel().c_str();
      auto status = library_->MapPinToChannel(vi, pin, site, channel);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUConfigureApertureTime(::grpc::ServerContext* context, const PPMUConfigureApertureTimeRequest* request, PPMUConfigureApertureTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 aperture_time = request->aperture_time();
      ViInt32 units;
      switch (request->units_enum_case()) {
        case nidigitalpattern_grpc::PPMUConfigureApertureTimeRequest::UnitsEnumCase::kUnits: {
          units = static_cast<ViInt32>(request->units());
          break;
        }
        case nidigitalpattern_grpc::PPMUConfigureApertureTimeRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<ViInt32>(request->units_raw());
          break;
        }
        case nidigitalpattern_grpc::PPMUConfigureApertureTimeRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->PPMUConfigureApertureTime(vi, channel_list, aperture_time, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUConfigureCurrentLevel(::grpc::ServerContext* context, const PPMUConfigureCurrentLevelRequest* request, PPMUConfigureCurrentLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 current_level = request->current_level();
      auto status = library_->PPMUConfigureCurrentLevel(vi, channel_list, current_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUConfigureCurrentLevelRange(::grpc::ServerContext* context, const PPMUConfigureCurrentLevelRangeRequest* request, PPMUConfigureCurrentLevelRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 range = request->range();
      auto status = library_->PPMUConfigureCurrentLevelRange(vi, channel_list, range);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUConfigureCurrentLimit(::grpc::ServerContext* context, const PPMUConfigureCurrentLimitRequest* request, PPMUConfigureCurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 behavior;
      switch (request->behavior_enum_case()) {
        case nidigitalpattern_grpc::PPMUConfigureCurrentLimitRequest::BehaviorEnumCase::kBehavior: {
          behavior = static_cast<ViInt32>(request->behavior());
          break;
        }
        case nidigitalpattern_grpc::PPMUConfigureCurrentLimitRequest::BehaviorEnumCase::kBehaviorRaw: {
          behavior = static_cast<ViInt32>(request->behavior_raw());
          break;
        }
        case nidigitalpattern_grpc::PPMUConfigureCurrentLimitRequest::BehaviorEnumCase::BEHAVIOR_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for behavior was not specified or out of range");
          break;
        }
      }

      ViReal64 limit = request->limit();
      auto status = library_->PPMUConfigureCurrentLimit(vi, channel_list, behavior, limit);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUConfigureCurrentLimitRange(::grpc::ServerContext* context, const PPMUConfigureCurrentLimitRangeRequest* request, PPMUConfigureCurrentLimitRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 range = request->range();
      auto status = library_->PPMUConfigureCurrentLimitRange(vi, channel_list, range);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUConfigureOutputFunction(::grpc::ServerContext* context, const PPMUConfigureOutputFunctionRequest* request, PPMUConfigureOutputFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 output_function;
      switch (request->output_function_enum_case()) {
        case nidigitalpattern_grpc::PPMUConfigureOutputFunctionRequest::OutputFunctionEnumCase::kOutputFunction: {
          output_function = static_cast<ViInt32>(request->output_function());
          break;
        }
        case nidigitalpattern_grpc::PPMUConfigureOutputFunctionRequest::OutputFunctionEnumCase::kOutputFunctionRaw: {
          output_function = static_cast<ViInt32>(request->output_function_raw());
          break;
        }
        case nidigitalpattern_grpc::PPMUConfigureOutputFunctionRequest::OutputFunctionEnumCase::OUTPUT_FUNCTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for output_function was not specified or out of range");
          break;
        }
      }

      auto status = library_->PPMUConfigureOutputFunction(vi, channel_list, output_function);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUConfigureVoltageLevel(::grpc::ServerContext* context, const PPMUConfigureVoltageLevelRequest* request, PPMUConfigureVoltageLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 voltage_level = request->voltage_level();
      auto status = library_->PPMUConfigureVoltageLevel(vi, channel_list, voltage_level);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUConfigureVoltageLimits(::grpc::ServerContext* context, const PPMUConfigureVoltageLimitsRequest* request, PPMUConfigureVoltageLimitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 lower_voltage_limit = request->lower_voltage_limit();
      ViReal64 upper_voltage_limit = request->upper_voltage_limit();
      auto status = library_->PPMUConfigureVoltageLimits(vi, channel_list, lower_voltage_limit, upper_voltage_limit);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUMeasure(::grpc::ServerContext* context, const PPMUMeasureRequest* request, PPMUMeasureResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 measurement_type;
      switch (request->measurement_type_enum_case()) {
        case nidigitalpattern_grpc::PPMUMeasureRequest::MeasurementTypeEnumCase::kMeasurementType: {
          measurement_type = static_cast<ViInt32>(request->measurement_type());
          break;
        }
        case nidigitalpattern_grpc::PPMUMeasureRequest::MeasurementTypeEnumCase::kMeasurementTypeRaw: {
          measurement_type = static_cast<ViInt32>(request->measurement_type_raw());
          break;
        }
        case nidigitalpattern_grpc::PPMUMeasureRequest::MeasurementTypeEnumCase::MEASUREMENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurement_type was not specified or out of range");
          break;
        }
      }

      ViInt32 actual_num_read {};
      while (true) {
        auto status = library_->PPMUMeasure(vi, channel_list, measurement_type, 0, nullptr, &actual_num_read);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_measurements()->Resize(actual_num_read, 0);
        ViReal64* measurements = response->mutable_measurements()->mutable_data();
        auto buffer_size = actual_num_read;
        status = library_->PPMUMeasure(vi, channel_list, measurement_type, buffer_size, measurements, &actual_num_read);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_measurements()->Resize(actual_num_read, 0);
          response->set_actual_num_read(actual_num_read);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUSource(::grpc::ServerContext* context, const PPMUSourceRequest* request, PPMUSourceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      auto status = library_->PPMUSource(vi, channel_list);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ReadSequencerFlag(::grpc::ServerContext* context, const ReadSequencerFlagRequest* request, ReadSequencerFlagResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto flag = request->flag().c_str();
      ViBoolean value {};
      auto status = library_->ReadSequencerFlag(vi, flag, &value);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ReadSequencerRegister(::grpc::ServerContext* context, const ReadSequencerRegisterRequest* request, ReadSequencerRegisterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto reg = request->reg().c_str();
      ViInt32 value {};
      auto status = library_->ReadSequencerRegister(vi, reg, &value);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ReadStatic(::grpc::ServerContext* context, const ReadStaticRequest* request, ReadStaticResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 actual_num_read {};
      while (true) {
        auto status = library_->ReadStatic(vi, channel_list, 0, nullptr, &actual_num_read);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        std::string data(actual_num_read, '\0');
        auto buffer_size = actual_num_read;
        status = library_->ReadStatic(vi, channel_list, buffer_size, (ViUInt8*)data.data(), &actual_num_read);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          CopyBytesToEnums(data, response->mutable_data());
          response->set_data_raw(data);
          response->mutable_data()->Resize(actual_num_read, 0);
          response->set_actual_num_read(actual_num_read);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::Reset(::grpc::ServerContext* context, const ResetRequest* request, ResetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Reset(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ResetAttribute(::grpc::ServerContext* context, const ResetAttributeRequest* request, ResetAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute_id = request->attribute_id();
      auto status = library_->ResetAttribute(vi, channel_name, attribute_id);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ResetDevice(::grpc::ServerContext* context, const ResetDeviceRequest* request, ResetDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->ResetDevice(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SelectFunction(::grpc::ServerContext* context, const SelectFunctionRequest* request, SelectFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 function;
      switch (request->function_enum_case()) {
        case nidigitalpattern_grpc::SelectFunctionRequest::FunctionEnumCase::kFunction: {
          function = static_cast<ViInt32>(request->function());
          break;
        }
        case nidigitalpattern_grpc::SelectFunctionRequest::FunctionEnumCase::kFunctionRaw: {
          function = static_cast<ViInt32>(request->function_raw());
          break;
        }
        case nidigitalpattern_grpc::SelectFunctionRequest::FunctionEnumCase::FUNCTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for function was not specified or out of range");
          break;
        }
      }

      auto status = library_->SelectFunction(vi, channel_list, function);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SelfCalibrate(::grpc::ServerContext* context, const SelfCalibrateRequest* request, SelfCalibrateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->SelfCalibrate(vi);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SelfTest(::grpc::ServerContext* context, const SelfTestRequest* request, SelfTestResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt16 test_result {};
      std::string test_message(2048 - 1, '\0');
      auto status = library_->SelfTest(vi, &test_result, (ViChar*)test_message.data());
      response->set_status(status);
      if (status_ok(status)) {
        response->set_test_result(test_result);
        response->set_test_message(test_message);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_test_message()));
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SendSoftwareEdgeTrigger(::grpc::ServerContext* context, const SendSoftwareEdgeTriggerRequest* request, SendSoftwareEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 trigger;
      switch (request->trigger_enum_case()) {
        case nidigitalpattern_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::kTrigger: {
          trigger = static_cast<ViInt32>(request->trigger());
          break;
        }
        case nidigitalpattern_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::kTriggerRaw: {
          trigger = static_cast<ViInt32>(request->trigger_raw());
          break;
        }
        case nidigitalpattern_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::TRIGGER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger was not specified or out of range");
          break;
        }
      }

      auto trigger_identifier = request->trigger_identifier().c_str();
      auto status = library_->SendSoftwareEdgeTrigger(vi, trigger, trigger_identifier);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SetAttributeViBoolean(::grpc::ServerContext* context, const SetAttributeViBooleanRequest* request, SetAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute = request->attribute();
      ViBoolean value = request->value();
      auto status = library_->SetAttributeViBoolean(vi, channel_name, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SetAttributeViInt32(::grpc::ServerContext* context, const SetAttributeViInt32Request* request, SetAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute = request->attribute();
      ViInt32 value;
      switch (request->value_enum_case()) {
        case nidigitalpattern_grpc::SetAttributeViInt32Request::ValueEnumCase::kValue: {
          value = static_cast<ViInt32>(request->value());
          break;
        }
        case nidigitalpattern_grpc::SetAttributeViInt32Request::ValueEnumCase::kValueRaw: {
          value = static_cast<ViInt32>(request->value_raw());
          break;
        }
        case nidigitalpattern_grpc::SetAttributeViInt32Request::ValueEnumCase::VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for value was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeViInt32(vi, channel_name, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SetAttributeViInt64(::grpc::ServerContext* context, const SetAttributeViInt64Request* request, SetAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute = request->attribute();
      ViInt64 value = request->value_raw();
      auto status = library_->SetAttributeViInt64(vi, channel_name, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SetAttributeViReal64(::grpc::ServerContext* context, const SetAttributeViReal64Request* request, SetAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute = request->attribute();
      ViReal64 value = request->value_raw();
      auto status = library_->SetAttributeViReal64(vi, channel_name, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SetAttributeViSession(::grpc::ServerContext* context, const SetAttributeViSessionRequest* request, SetAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute = request->attribute();
      auto value_grpc_session = request->value();
      ViSession value = session_repository_->access_session(value_grpc_session.id(), value_grpc_session.name());
      auto status = library_->SetAttributeViSession(vi, channel_list, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SetAttributeViString(::grpc::ServerContext* context, const SetAttributeViStringRequest* request, SetAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_name = request->channel_name().c_str();
      ViAttr attribute = request->attribute();
      auto value = request->value_raw().c_str();
      auto status = library_->SetAttributeViString(vi, channel_name, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::TDR(::grpc::ServerContext* context, const TDRRequest* request, TDRResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViBoolean apply_offsets = request->apply_offsets();
      ViInt32 actual_num_offsets {};
      while (true) {
        auto status = library_->TDR(vi, channel_list, apply_offsets, 0, nullptr, &actual_num_offsets);
        if (status < 0) {
          response->set_status(status);
          return ::grpc::Status::OK;
        }
        response->mutable_offsets()->Resize(actual_num_offsets, 0);
        ViReal64* offsets = response->mutable_offsets()->mutable_data();
        auto offsets_buffer_size = actual_num_offsets;
        status = library_->TDR(vi, channel_list, apply_offsets, offsets_buffer_size, offsets, &actual_num_offsets);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        response->set_status(status);
        if (status_ok(status)) {
          response->mutable_offsets()->Resize(actual_num_offsets, 0);
          response->set_actual_num_offsets(actual_num_offsets);
        }
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::UnloadAllPatterns(::grpc::ServerContext* context, const UnloadAllPatternsRequest* request, UnloadAllPatternsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViBoolean unload_keep_alive_pattern = request->unload_keep_alive_pattern();
      auto status = library_->UnloadAllPatterns(vi, unload_keep_alive_pattern);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::UnloadSpecifications(::grpc::ServerContext* context, const UnloadSpecificationsRequest* request, UnloadSpecificationsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->UnloadSpecifications(vi, file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WaitUntilDone(::grpc::ServerContext* context, const WaitUntilDoneRequest* request, WaitUntilDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViReal64 timeout = request->timeout();
      auto status = library_->WaitUntilDone(vi, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteSequencerFlag(::grpc::ServerContext* context, const WriteSequencerFlagRequest* request, WriteSequencerFlagResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto flag = request->flag().c_str();
      ViBoolean value = request->value();
      auto status = library_->WriteSequencerFlag(vi, flag, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteSequencerFlagSynchronized(::grpc::ServerContext* context, const WriteSequencerFlagSynchronizedRequest* request, WriteSequencerFlagSynchronizedResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ViUInt32 session_count = request->session_count();
      auto sessions_request = request->sessions();
      std::vector<ViSession> sessions;
      std::transform(
        sessions_request.begin(),
        sessions_request.end(),
        std::back_inserter(sessions),
        [&](auto session) { return session_repository_->access_session(session.id(), session.name()); }); 
      auto flag = request->flag().c_str();
      ViBoolean value = request->value();
      auto status = library_->WriteSequencerFlagSynchronized(session_count, sessions.data(), flag, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteSequencerRegister(::grpc::ServerContext* context, const WriteSequencerRegisterRequest* request, WriteSequencerRegisterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto reg = request->reg().c_str();
      ViInt32 value = request->value();
      auto status = library_->WriteSequencerRegister(vi, reg, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteSourceWaveformBroadcastU32(::grpc::ServerContext* context, const WriteSourceWaveformBroadcastU32Request* request, WriteSourceWaveformBroadcastU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto waveform_name = request->waveform_name().c_str();
      ViInt32 waveform_size = static_cast<ViInt32>(request->waveform_data().size());
      auto waveform_data = const_cast<ViUInt32*>(reinterpret_cast<const ViUInt32*>(request->waveform_data().data()));
      auto status = library_->WriteSourceWaveformBroadcastU32(vi, waveform_name, waveform_size, waveform_data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteSourceWaveformDataFromFileTDMS(::grpc::ServerContext* context, const WriteSourceWaveformDataFromFileTDMSRequest* request, WriteSourceWaveformDataFromFileTDMSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto waveform_name = request->waveform_name().c_str();
      auto waveform_file_path = request->waveform_file_path().c_str();
      auto status = library_->WriteSourceWaveformDataFromFileTDMS(vi, waveform_name, waveform_file_path);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteStatic(::grpc::ServerContext* context, const WriteStaticRequest* request, WriteStaticResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViUInt8 state;
      switch (request->state_enum_case()) {
        case nidigitalpattern_grpc::WriteStaticRequest::StateEnumCase::kState: {
          state = static_cast<ViUInt8>(request->state());
          break;
        }
        case nidigitalpattern_grpc::WriteStaticRequest::StateEnumCase::kStateRaw: {
          state = static_cast<ViUInt8>(request->state_raw());
          break;
        }
        case nidigitalpattern_grpc::WriteStaticRequest::StateEnumCase::STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for state was not specified or out of range");
          break;
        }
      }

      auto status = library_->WriteStatic(vi, channel_list, state);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteSourceWaveformSiteUniqueU32(::grpc::ServerContext* context, const WriteSourceWaveformSiteUniqueU32Request* request, WriteSourceWaveformSiteUniqueU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      ViInt32 num_waveforms = request->num_waveforms();
      ViInt32 samples_per_waveform = request->samples_per_waveform();
      auto waveform_data = const_cast<ViUInt32*>(reinterpret_cast<const ViUInt32*>(request->waveform_data().data()));
      auto status = library_->WriteSourceWaveformSiteUniqueU32(vi, site_list, waveform_name, num_waveforms, samples_per_waveform, waveform_data);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  NiDigitalFeatureToggles::NiDigitalFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nidigitalpattern", CodeReadiness::kRelease))
  {
  }
} // namespace nidigitalpattern_grpc

