
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-Digital Pattern Driver Metadata
//---------------------------------------------------------------------
#include "nidigitalpattern_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>

namespace nidigitalpattern_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiDigitalService::NiDigitalService(
      NiDigitalLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      const NiDigitalFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiDigitalService::~NiDigitalService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  template <typename TEnum>
  void NiDigitalService::CopyBytesToEnums(const std::string& input, google::protobuf::RepeatedField<TEnum>* output)
  {
    for (auto item : input)
    {
      output->Add(item);
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::Abort(::grpc::ServerContext* context, const AbortRequest* request, AbortResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Abort(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::AbortKeepAlive(::grpc::ServerContext* context, const AbortKeepAliveRequest* request, AbortKeepAliveResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->AbortKeepAlive(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ApplyLevelsAndTiming(::grpc::ServerContext* context, const ApplyLevelsAndTimingRequest* request, ApplyLevelsAndTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto levels_sheet = request->levels_sheet().c_str();
      auto timing_sheet = request->timing_sheet().c_str();
      auto initial_state_high_pins = request->initial_state_high_pins().c_str();
      auto initial_state_low_pins = request->initial_state_low_pins().c_str();
      auto initial_state_tristate_pins = request->initial_state_tristate_pins().c_str();
      auto status = library_->ApplyLevelsAndTiming(vi, site_list, levels_sheet, timing_sheet, initial_state_high_pins, initial_state_low_pins, initial_state_tristate_pins);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ApplyTDROffsets(::grpc::ServerContext* context, const ApplyTDROffsetsRequest* request, ApplyTDROffsetsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 num_offsets = static_cast<ViInt32>(request->offsets().size());
      auto offsets = const_cast<ViReal64*>(request->offsets().data());
      auto status = library_->ApplyTDROffsets(vi, channel_list, num_offsets, offsets);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::BurstPattern(::grpc::ServerContext* context, const BurstPatternRequest* request, BurstPatternResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto start_label = request->start_label().c_str();
      ViBoolean select_digital_function = request->select_digital_function();
      ViBoolean wait_until_done = request->wait_until_done();
      ViReal64 timeout = request->timeout();
      auto status = library_->BurstPattern(vi, site_list, start_label, select_digital_function, wait_until_done, timeout);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ClearError(::grpc::ServerContext* context, const ClearErrorRequest* request, ClearErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->ClearError(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ClockGeneratorAbort(::grpc::ServerContext* context, const ClockGeneratorAbortRequest* request, ClockGeneratorAbortResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      auto status = library_->ClockGeneratorAbort(vi, channel_list);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ClockGeneratorGenerateClock(::grpc::ServerContext* context, const ClockGeneratorGenerateClockRequest* request, ClockGeneratorGenerateClockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 frequency = request->frequency();
      ViBoolean select_digital_function = request->select_digital_function();
      auto status = library_->ClockGeneratorGenerateClock(vi, channel_list, frequency, select_digital_function);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ClockGeneratorInitiate(::grpc::ServerContext* context, const ClockGeneratorInitiateRequest* request, ClockGeneratorInitiateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      auto status = library_->ClockGeneratorInitiate(vi, channel_list);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::Commit(::grpc::ServerContext* context, const CommitRequest* request, CommitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Commit(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureActiveLoadLevels(::grpc::ServerContext* context, const ConfigureActiveLoadLevelsRequest* request, ConfigureActiveLoadLevelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 iol = request->iol();
      ViReal64 ioh = request->ioh();
      ViReal64 vcom = request->vcom();
      auto status = library_->ConfigureActiveLoadLevels(vi, channel_list, iol, ioh, vcom);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigurePatternBurstSites(::grpc::ServerContext* context, const ConfigurePatternBurstSitesRequest* request, ConfigurePatternBurstSitesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto status = library_->ConfigurePatternBurstSites(vi, site_list);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetCompareEdgesStrobe(::grpc::ServerContext* context, const ConfigureTimeSetCompareEdgesStrobeRequest* request, ConfigureTimeSetCompareEdgesStrobeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set = request->time_set().c_str();
      ViReal64 strobe_edge = request->strobe_edge();
      auto status = library_->ConfigureTimeSetCompareEdgesStrobe(vi, pin_list, time_set, strobe_edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetCompareEdgesStrobe2X(::grpc::ServerContext* context, const ConfigureTimeSetCompareEdgesStrobe2XRequest* request, ConfigureTimeSetCompareEdgesStrobe2XResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set = request->time_set().c_str();
      ViReal64 strobe_edge = request->strobe_edge();
      ViReal64 strobe2_edge = request->strobe2_edge();
      auto status = library_->ConfigureTimeSetCompareEdgesStrobe2X(vi, pin_list, time_set, strobe_edge, strobe2_edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetDriveEdges(::grpc::ServerContext* context, const ConfigureTimeSetDriveEdgesRequest* request, ConfigureTimeSetDriveEdgesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set = request->time_set().c_str();
      ViInt32 format;
      switch (request->format_enum_case()) {
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdgesRequest::FormatEnumCase::kFormat: {
          format = static_cast<ViInt32>(request->format());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdgesRequest::FormatEnumCase::kFormatRaw: {
          format = static_cast<ViInt32>(request->format_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdgesRequest::FormatEnumCase::FORMAT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for format was not specified or out of range");
          break;
        }
      }

      ViReal64 drive_on_edge = request->drive_on_edge();
      ViReal64 drive_data_edge = request->drive_data_edge();
      ViReal64 drive_return_edge = request->drive_return_edge();
      ViReal64 drive_off_edge = request->drive_off_edge();
      auto status = library_->ConfigureTimeSetDriveEdges(vi, pin_list, time_set, format, drive_on_edge, drive_data_edge, drive_return_edge, drive_off_edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetDriveEdges2X(::grpc::ServerContext* context, const ConfigureTimeSetDriveEdges2XRequest* request, ConfigureTimeSetDriveEdges2XResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set = request->time_set().c_str();
      ViInt32 format;
      switch (request->format_enum_case()) {
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdges2XRequest::FormatEnumCase::kFormat: {
          format = static_cast<ViInt32>(request->format());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdges2XRequest::FormatEnumCase::kFormatRaw: {
          format = static_cast<ViInt32>(request->format_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveEdges2XRequest::FormatEnumCase::FORMAT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for format was not specified or out of range");
          break;
        }
      }

      ViReal64 drive_on_edge = request->drive_on_edge();
      ViReal64 drive_data_edge = request->drive_data_edge();
      ViReal64 drive_return_edge = request->drive_return_edge();
      ViReal64 drive_off_edge = request->drive_off_edge();
      ViReal64 drive_data2_edge = request->drive_data2_edge();
      ViReal64 drive_return2_edge = request->drive_return2_edge();
      auto status = library_->ConfigureTimeSetDriveEdges2X(vi, pin_list, time_set, format, drive_on_edge, drive_data_edge, drive_return_edge, drive_off_edge, drive_data2_edge, drive_return2_edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetDriveFormat(::grpc::ServerContext* context, const ConfigureTimeSetDriveFormatRequest* request, ConfigureTimeSetDriveFormatResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set = request->time_set().c_str();
      ViInt32 drive_format;
      switch (request->drive_format_enum_case()) {
        case nidigitalpattern_grpc::ConfigureTimeSetDriveFormatRequest::DriveFormatEnumCase::kDriveFormat: {
          drive_format = static_cast<ViInt32>(request->drive_format());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveFormatRequest::DriveFormatEnumCase::kDriveFormatRaw: {
          drive_format = static_cast<ViInt32>(request->drive_format_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetDriveFormatRequest::DriveFormatEnumCase::DRIVE_FORMAT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for drive_format was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureTimeSetDriveFormat(vi, pin_list, time_set, drive_format);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetEdge(::grpc::ServerContext* context, const ConfigureTimeSetEdgeRequest* request, ConfigureTimeSetEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set = request->time_set().c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidigitalpattern_grpc::ConfigureTimeSetEdgeRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetEdgeRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidigitalpattern_grpc::ConfigureTimeSetEdgeRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      ViReal64 time = request->time();
      auto status = library_->ConfigureTimeSetEdge(vi, pin_list, time_set, edge, time);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetEdgeMultiplier(::grpc::ServerContext* context, const ConfigureTimeSetEdgeMultiplierRequest* request, ConfigureTimeSetEdgeMultiplierResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto time_set = request->time_set().c_str();
      ViInt32 edge_multiplier = request->edge_multiplier();
      auto status = library_->ConfigureTimeSetEdgeMultiplier(vi, pin_list, time_set, edge_multiplier);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureTimeSetPeriod(::grpc::ServerContext* context, const ConfigureTimeSetPeriodRequest* request, ConfigureTimeSetPeriodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto time_set = request->time_set().c_str();
      ViReal64 period = request->period();
      auto status = library_->ConfigureTimeSetPeriod(vi, time_set, period);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ConfigureVoltageLevels(::grpc::ServerContext* context, const ConfigureVoltageLevelsRequest* request, ConfigureVoltageLevelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViReal64 vil = request->vil();
      ViReal64 vih = request->vih();
      ViReal64 vol = request->vol();
      ViReal64 voh = request->voh();
      ViReal64 vterm = request->vterm();
      auto status = library_->ConfigureVoltageLevels(vi, channel_list, vil, vih, vol, voh, vterm);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateCaptureWaveformFromFileDigicapture(::grpc::ServerContext* context, const CreateCaptureWaveformFromFileDigicaptureRequest* request, CreateCaptureWaveformFromFileDigicaptureResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto waveform_name = request->waveform_name().c_str();
      auto waveform_file_path = request->waveform_file_path().c_str();
      auto status = library_->CreateCaptureWaveformFromFileDigicapture(vi, waveform_name, waveform_file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateCaptureWaveformParallel(::grpc::ServerContext* context, const CreateCaptureWaveformParallelRequest* request, CreateCaptureWaveformParallelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      auto status = library_->CreateCaptureWaveformParallel(vi, pin_list, waveform_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateCaptureWaveformSerial(::grpc::ServerContext* context, const CreateCaptureWaveformSerialRequest* request, CreateCaptureWaveformSerialResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      ViUInt32 sample_width = request->sample_width();
      ViInt32 bit_order;
      switch (request->bit_order_enum_case()) {
        case nidigitalpattern_grpc::CreateCaptureWaveformSerialRequest::BitOrderEnumCase::kBitOrder: {
          bit_order = static_cast<ViInt32>(request->bit_order());
          break;
        }
        case nidigitalpattern_grpc::CreateCaptureWaveformSerialRequest::BitOrderEnumCase::kBitOrderRaw: {
          bit_order = static_cast<ViInt32>(request->bit_order_raw());
          break;
        }
        case nidigitalpattern_grpc::CreateCaptureWaveformSerialRequest::BitOrderEnumCase::BIT_ORDER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bit_order was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateCaptureWaveformSerial(vi, pin_list, waveform_name, sample_width, bit_order);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateSourceWaveformFromFileTDMS(::grpc::ServerContext* context, const CreateSourceWaveformFromFileTDMSRequest* request, CreateSourceWaveformFromFileTDMSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto waveform_name = request->waveform_name().c_str();
      auto waveform_file_path = request->waveform_file_path().c_str();
      ViBoolean write_waveform_data = request->write_waveform_data();
      auto status = library_->CreateSourceWaveformFromFileTDMS(vi, waveform_name, waveform_file_path, write_waveform_data);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateSourceWaveformParallel(::grpc::ServerContext* context, const CreateSourceWaveformParallelRequest* request, CreateSourceWaveformParallelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      ViInt32 data_mapping;
      switch (request->data_mapping_enum_case()) {
        case nidigitalpattern_grpc::CreateSourceWaveformParallelRequest::DataMappingEnumCase::kDataMapping: {
          data_mapping = static_cast<ViInt32>(request->data_mapping());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformParallelRequest::DataMappingEnumCase::kDataMappingRaw: {
          data_mapping = static_cast<ViInt32>(request->data_mapping_raw());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformParallelRequest::DataMappingEnumCase::DATA_MAPPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_mapping was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateSourceWaveformParallel(vi, pin_list, waveform_name, data_mapping);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateSourceWaveformSerial(::grpc::ServerContext* context, const CreateSourceWaveformSerialRequest* request, CreateSourceWaveformSerialResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_list = request->pin_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      ViInt32 data_mapping;
      switch (request->data_mapping_enum_case()) {
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::DataMappingEnumCase::kDataMapping: {
          data_mapping = static_cast<ViInt32>(request->data_mapping());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::DataMappingEnumCase::kDataMappingRaw: {
          data_mapping = static_cast<ViInt32>(request->data_mapping_raw());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::DataMappingEnumCase::DATA_MAPPING_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for data_mapping was not specified or out of range");
          break;
        }
      }

      ViUInt32 sample_width = request->sample_width();
      ViInt32 bit_order;
      switch (request->bit_order_enum_case()) {
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::BitOrderEnumCase::kBitOrder: {
          bit_order = static_cast<ViInt32>(request->bit_order());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::BitOrderEnumCase::kBitOrderRaw: {
          bit_order = static_cast<ViInt32>(request->bit_order_raw());
          break;
        }
        case nidigitalpattern_grpc::CreateSourceWaveformSerialRequest::BitOrderEnumCase::BIT_ORDER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bit_order was not specified or out of range");
          break;
        }
      }

      auto status = library_->CreateSourceWaveformSerial(vi, pin_list, waveform_name, data_mapping, sample_width, bit_order);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::CreateTimeSet(::grpc::ServerContext* context, const CreateTimeSetRequest* request, CreateTimeSetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto name = request->name().c_str();
      auto status = library_->CreateTimeSet(vi, name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::DeleteAllTimeSets(::grpc::ServerContext* context, const DeleteAllTimeSetsRequest* request, DeleteAllTimeSetsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->DeleteAllTimeSets(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::DisableSites(::grpc::ServerContext* context, const DisableSitesRequest* request, DisableSitesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto status = library_->DisableSites(vi, site_list);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::EnableSites(::grpc::ServerContext* context, const EnableSitesRequest* request, EnableSitesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto status = library_->EnableSites(vi, site_list);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::FetchCaptureWaveformU32(::grpc::ServerContext* context, const FetchCaptureWaveformU32Request* request, FetchCaptureWaveformU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      auto waveform_name = request->waveform_name().c_str();
      ViInt32 samples_to_read = request->samples_to_read();
      ViReal64 timeout = request->timeout();
      ViInt32 actual_num_waveforms {};
      ViInt32 actual_samples_per_waveform {};
      while (true) {
        auto status = library_->FetchCaptureWaveformU32(vi, site_list, waveform_name, samples_to_read, timeout, 0, nullptr, &actual_num_waveforms, &actual_samples_per_waveform);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->mutable_data()->Resize(actual_num_waveforms, 0);
        ViUInt32* data = reinterpret_cast<ViUInt32*>(response->mutable_data()->mutable_data());
        auto data_buffer_size = actual_num_waveforms;
        status = library_->FetchCaptureWaveformU32(vi, site_list, waveform_name, samples_to_read, timeout, data_buffer_size, data, &actual_num_waveforms, &actual_samples_per_waveform);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->mutable_data()->Resize(actual_num_waveforms, 0);
        response->set_actual_num_waveforms(actual_num_waveforms);
        response->set_actual_samples_per_waveform(actual_samples_per_waveform);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::FrequencyCounterMeasureFrequency(::grpc::ServerContext* context, const FrequencyCounterMeasureFrequencyRequest* request, FrequencyCounterMeasureFrequencyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 actual_num_frequencies {};
      while (true) {
        auto status = library_->FrequencyCounterMeasureFrequency(vi, channel_list, 0, nullptr, &actual_num_frequencies);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->mutable_frequencies()->Resize(actual_num_frequencies, 0);
        ViReal64* frequencies = response->mutable_frequencies()->mutable_data();
        auto frequencies_buffer_size = actual_num_frequencies;
        status = library_->FrequencyCounterMeasureFrequency(vi, channel_list, frequencies_buffer_size, frequencies, &actual_num_frequencies);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->mutable_frequencies()->Resize(actual_num_frequencies, 0);
        response->set_actual_num_frequencies(actual_num_frequencies);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetChannelName(::grpc::ServerContext* context, const GetChannelNameRequest* request, GetChannelNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 index = request->index();

      while (true) {
        auto status = library_->GetChannelName(vi, index, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 name_buffer_size = status;

        std::string name;
        if (name_buffer_size > 0) {
            name.resize(name_buffer_size - 1);
        }
        status = library_->GetChannelName(vi, index, name_buffer_size, (ViChar*)name.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(name_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_name(name);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_name()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetChannelNameFromString(::grpc::ServerContext* context, const GetChannelNameFromStringRequest* request, GetChannelNameFromStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto index = request->index().c_str();

      while (true) {
        auto status = library_->GetChannelNameFromString(vi, index, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 name_buffer_size = status;

        std::string name;
        if (name_buffer_size > 0) {
            name.resize(name_buffer_size - 1);
        }
        status = library_->GetChannelNameFromString(vi, index, name_buffer_size, (ViChar*)name.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(name_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_name(name);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_name()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetFailCount(::grpc::ServerContext* context, const GetFailCountRequest* request, GetFailCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 actual_num_read {};
      while (true) {
        auto status = library_->GetFailCount(vi, channel_list, 0, nullptr, &actual_num_read);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->mutable_failure_count()->Resize(actual_num_read, 0);
        ViInt64* failure_count = response->mutable_failure_count()->mutable_data();
        auto buffer_size = actual_num_read;
        status = library_->GetFailCount(vi, channel_list, buffer_size, failure_count, &actual_num_read);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->mutable_failure_count()->Resize(actual_num_read, 0);
        response->set_actual_num_read(actual_num_read);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetHistoryRAMSampleCount(::grpc::ServerContext* context, const GetHistoryRAMSampleCountRequest* request, GetHistoryRAMSampleCountResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site = request->site().c_str();
      ViInt64 sample_count {};
      auto status = library_->GetHistoryRAMSampleCount(vi, site, &sample_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_sample_count(sample_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetPatternPinList(::grpc::ServerContext* context, const GetPatternPinListRequest* request, GetPatternPinListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto start_label = request->start_label().c_str();

      while (true) {
        auto status = library_->GetPatternPinList(vi, start_label, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 pin_list_buffer_size = status;

        std::string pin_list;
        if (pin_list_buffer_size > 0) {
            pin_list.resize(pin_list_buffer_size - 1);
        }
        status = library_->GetPatternPinList(vi, start_label, pin_list_buffer_size, (ViChar*)pin_list.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(pin_list_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_pin_list(pin_list);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_pin_list()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetSitePassFail(::grpc::ServerContext* context, const GetSitePassFailRequest* request, GetSitePassFailResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      ViInt32 actual_num_sites {};
      while (true) {
        auto status = library_->GetSitePassFail(vi, site_list, 0, nullptr, &actual_num_sites);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        std::vector<ViBoolean> pass_fail(actual_num_sites, ViBoolean());
        auto pass_fail_buffer_size = actual_num_sites;
        status = library_->GetSitePassFail(vi, site_list, pass_fail_buffer_size, pass_fail.data(), &actual_num_sites);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        convert_to_grpc(pass_fail, response->mutable_pass_fail());
        response->mutable_pass_fail()->Resize(actual_num_sites, 0);
        response->set_actual_num_sites(actual_num_sites);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetSiteResultsSiteNumbers(::grpc::ServerContext* context, const GetSiteResultsSiteNumbersRequest* request, GetSiteResultsSiteNumbersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site_list = request->site_list().c_str();
      ViInt32 site_result_type;
      switch (request->site_result_type_enum_case()) {
        case nidigitalpattern_grpc::GetSiteResultsSiteNumbersRequest::SiteResultTypeEnumCase::kSiteResultType: {
          site_result_type = static_cast<ViInt32>(request->site_result_type());
          break;
        }
        case nidigitalpattern_grpc::GetSiteResultsSiteNumbersRequest::SiteResultTypeEnumCase::kSiteResultTypeRaw: {
          site_result_type = static_cast<ViInt32>(request->site_result_type_raw());
          break;
        }
        case nidigitalpattern_grpc::GetSiteResultsSiteNumbersRequest::SiteResultTypeEnumCase::SITE_RESULT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for site_result_type was not specified or out of range");
          break;
        }
      }

      ViInt32 actual_num_site_numbers {};
      while (true) {
        auto status = library_->GetSiteResultsSiteNumbers(vi, site_list, site_result_type, 0, nullptr, &actual_num_site_numbers);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->mutable_site_numbers()->Resize(actual_num_site_numbers, 0);
        ViInt32* site_numbers = reinterpret_cast<ViInt32*>(response->mutable_site_numbers()->mutable_data());
        auto site_numbers_buffer_size = actual_num_site_numbers;
        status = library_->GetSiteResultsSiteNumbers(vi, site_list, site_result_type, site_numbers_buffer_size, site_numbers, &actual_num_site_numbers);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->mutable_site_numbers()->Resize(actual_num_site_numbers, 0);
        response->set_actual_num_site_numbers(actual_num_site_numbers);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetTimeSetDriveFormat(::grpc::ServerContext* context, const GetTimeSetDriveFormatRequest* request, GetTimeSetDriveFormatResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin = request->pin().c_str();
      auto time_set = request->time_set().c_str();
      ViInt32 format {};
      auto status = library_->GetTimeSetDriveFormat(vi, pin, time_set, &format);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_format(static_cast<nidigitalpattern_grpc::DriveFormat>(format));
      response->set_format_raw(format);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetTimeSetEdge(::grpc::ServerContext* context, const GetTimeSetEdgeRequest* request, GetTimeSetEdgeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin = request->pin().c_str();
      auto time_set = request->time_set().c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidigitalpattern_grpc::GetTimeSetEdgeRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidigitalpattern_grpc::GetTimeSetEdgeRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidigitalpattern_grpc::GetTimeSetEdgeRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      ViReal64 time {};
      auto status = library_->GetTimeSetEdge(vi, pin, time_set, edge, &time);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_time(time);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetTimeSetEdgeMultiplier(::grpc::ServerContext* context, const GetTimeSetEdgeMultiplierRequest* request, GetTimeSetEdgeMultiplierResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin = request->pin().c_str();
      auto time_set = request->time_set().c_str();
      ViInt32 edge_multiplier {};
      auto status = library_->GetTimeSetEdgeMultiplier(vi, pin, time_set, &edge_multiplier);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_edge_multiplier(edge_multiplier);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::GetTimeSetPeriod(::grpc::ServerContext* context, const GetTimeSetPeriodRequest* request, GetTimeSetPeriodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto time_set = request->time_set().c_str();
      ViReal64 period {};
      auto status = library_->GetTimeSetPeriod(vi, time_set, &period);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_period(period);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::InitWithOptions(::grpc::ServerContext* context, const InitWithOptionsRequest* request, InitWithOptionsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto resource_name = request->resource_name().c_str();
      ViBoolean id_query = request->id_query();
      ViBoolean reset_device = request->reset_device();
      auto option_string = request->option_string().c_str();
      ViSession new_vi {};
      auto status = library_->InitWithOptions(resource_name, id_query, reset_device, option_string, &new_vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      auto session_id = session_repository_->resolve_session_id(new_vi);
      response->mutable_new_vi()->set_id(session_id);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::IsDone(::grpc::ServerContext* context, const IsDoneRequest* request, IsDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViBoolean done {};
      auto status = library_->IsDone(vi, &done);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_done(done);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::IsSiteEnabled(::grpc::ServerContext* context, const IsSiteEnabledRequest* request, IsSiteEnabledResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto site = request->site().c_str();
      ViBoolean enable {};
      auto status = library_->IsSiteEnabled(vi, site, &enable);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_enable(enable);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LoadLevels(::grpc::ServerContext* context, const LoadLevelsRequest* request, LoadLevelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto levels_file_path = request->levels_file_path().c_str();
      auto status = library_->LoadLevels(vi, levels_file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LoadPattern(::grpc::ServerContext* context, const LoadPatternRequest* request, LoadPatternResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto file_path = request->file_path().c_str();
      auto status = library_->LoadPattern(vi, file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LoadPinMap(::grpc::ServerContext* context, const LoadPinMapRequest* request, LoadPinMapResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto pin_map_file_path = request->pin_map_file_path().c_str();
      auto status = library_->LoadPinMap(vi, pin_map_file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LoadSpecifications(::grpc::ServerContext* context, const LoadSpecificationsRequest* request, LoadSpecificationsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto specifications_file_path = request->specifications_file_path().c_str();
      auto status = library_->LoadSpecifications(vi, specifications_file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LoadTiming(::grpc::ServerContext* context, const LoadTimingRequest* request, LoadTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto timing_file_path = request->timing_file_path().c_str();
      auto status = library_->LoadTiming(vi, timing_file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::LockSession(::grpc::ServerContext* context, const LockSessionRequest* request, LockSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViBoolean caller_has_lock {};
      auto status = library_->LockSession(vi, &caller_has_lock);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_caller_has_lock(caller_has_lock);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUMeasure(::grpc::ServerContext* context, const PPMUMeasureRequest* request, PPMUMeasureResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 measurement_type;
      switch (request->measurement_type_enum_case()) {
        case nidigitalpattern_grpc::PPMUMeasureRequest::MeasurementTypeEnumCase::kMeasurementType: {
          measurement_type = static_cast<ViInt32>(request->measurement_type());
          break;
        }
        case nidigitalpattern_grpc::PPMUMeasureRequest::MeasurementTypeEnumCase::kMeasurementTypeRaw: {
          measurement_type = static_cast<ViInt32>(request->measurement_type_raw());
          break;
        }
        case nidigitalpattern_grpc::PPMUMeasureRequest::MeasurementTypeEnumCase::MEASUREMENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurement_type was not specified or out of range");
          break;
        }
      }

      ViInt32 actual_num_read {};
      while (true) {
        auto status = library_->PPMUMeasure(vi, channel_list, measurement_type, 0, nullptr, &actual_num_read);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->mutable_measurements()->Resize(actual_num_read, 0);
        ViReal64* measurements = response->mutable_measurements()->mutable_data();
        auto buffer_size = actual_num_read;
        status = library_->PPMUMeasure(vi, channel_list, measurement_type, buffer_size, measurements, &actual_num_read);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->mutable_measurements()->Resize(actual_num_read, 0);
        response->set_actual_num_read(actual_num_read);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::PPMUSource(::grpc::ServerContext* context, const PPMUSourceRequest* request, PPMUSourceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      auto status = library_->PPMUSource(vi, channel_list);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ReadSequencerFlag(::grpc::ServerContext* context, const ReadSequencerFlagRequest* request, ReadSequencerFlagResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViConstString flag;
      switch (request->flag_enum_case()) {
        case nidigitalpattern_grpc::ReadSequencerFlagRequest::FlagEnumCase::kFlagMapped: {
          auto flag_imap_it = sequencerflag_input_map_.find(request->flag_mapped());
          if (flag_imap_it == sequencerflag_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for flag_mapped was not specified or out of range.");
          }
          flag = const_cast<ViConstString>((flag_imap_it->second).c_str());
          break;
        }
        case nidigitalpattern_grpc::ReadSequencerFlagRequest::FlagEnumCase::kFlagRaw: {
          flag = const_cast<ViConstString>(request->flag_raw().c_str());
          break;
        }
        case nidigitalpattern_grpc::ReadSequencerFlagRequest::FlagEnumCase::FLAG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for flag was not specified or out of range");
          break;
        }
      }

      ViBoolean value {};
      auto status = library_->ReadSequencerFlag(vi, flag, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ReadSequencerRegister(::grpc::ServerContext* context, const ReadSequencerRegisterRequest* request, ReadSequencerRegisterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViConstString reg;
      switch (request->reg_enum_case()) {
        case nidigitalpattern_grpc::ReadSequencerRegisterRequest::RegEnumCase::kRegMapped: {
          auto reg_imap_it = sequencerregister_input_map_.find(request->reg_mapped());
          if (reg_imap_it == sequencerregister_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for reg_mapped was not specified or out of range.");
          }
          reg = const_cast<ViConstString>((reg_imap_it->second).c_str());
          break;
        }
        case nidigitalpattern_grpc::ReadSequencerRegisterRequest::RegEnumCase::kRegRaw: {
          reg = const_cast<ViConstString>(request->reg_raw().c_str());
          break;
        }
        case nidigitalpattern_grpc::ReadSequencerRegisterRequest::RegEnumCase::REG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for reg was not specified or out of range");
          break;
        }
      }

      ViInt32 value {};
      auto status = library_->ReadSequencerRegister(vi, reg, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ReadStatic(::grpc::ServerContext* context, const ReadStaticRequest* request, ReadStaticResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 actual_num_read {};
      while (true) {
        auto status = library_->ReadStatic(vi, channel_list, 0, nullptr, &actual_num_read);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        std::string data(actual_num_read, '\0');
        auto buffer_size = actual_num_read;
        status = library_->ReadStatic(vi, channel_list, buffer_size, (ViUInt8*)data.data(), &actual_num_read);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        CopyBytesToEnums(data, response->mutable_data());
        response->set_data_raw(data);
        response->mutable_data()->Resize(actual_num_read, 0);
        response->set_actual_num_read(actual_num_read);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::Reset(::grpc::ServerContext* context, const ResetRequest* request, ResetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->Reset(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ResetAttribute(::grpc::ServerContext* context, const ResetAttributeRequest* request, ResetAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViAttr attribute_id = request->attribute_id();
      auto status = library_->ResetAttribute(vi, channel_list, attribute_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::ResetDevice(::grpc::ServerContext* context, const ResetDeviceRequest* request, ResetDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->ResetDevice(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SelectFunction(::grpc::ServerContext* context, const SelectFunctionRequest* request, SelectFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViInt32 function;
      switch (request->function_enum_case()) {
        case nidigitalpattern_grpc::SelectFunctionRequest::FunctionEnumCase::kFunction: {
          function = static_cast<ViInt32>(request->function());
          break;
        }
        case nidigitalpattern_grpc::SelectFunctionRequest::FunctionEnumCase::kFunctionRaw: {
          function = static_cast<ViInt32>(request->function_raw());
          break;
        }
        case nidigitalpattern_grpc::SelectFunctionRequest::FunctionEnumCase::FUNCTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for function was not specified or out of range");
          break;
        }
      }

      auto status = library_->SelectFunction(vi, channel_list, function);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SelfCalibrate(::grpc::ServerContext* context, const SelfCalibrateRequest* request, SelfCalibrateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto status = library_->SelfCalibrate(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::SendSoftwareEdgeTrigger(::grpc::ServerContext* context, const SendSoftwareEdgeTriggerRequest* request, SendSoftwareEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViInt32 trigger;
      switch (request->trigger_enum_case()) {
        case nidigitalpattern_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::kTrigger: {
          trigger = static_cast<ViInt32>(request->trigger());
          break;
        }
        case nidigitalpattern_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::kTriggerRaw: {
          trigger = static_cast<ViInt32>(request->trigger_raw());
          break;
        }
        case nidigitalpattern_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::TRIGGER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger was not specified or out of range");
          break;
        }
      }

      auto trigger_identifier = request->trigger_identifier().c_str();
      auto status = library_->SendSoftwareEdgeTrigger(vi, trigger, trigger_identifier);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::TDR(::grpc::ServerContext* context, const TDRRequest* request, TDRResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViBoolean apply_offsets = request->apply_offsets();
      ViInt32 actual_num_offsets {};
      while (true) {
        auto status = library_->TDR(vi, channel_list, apply_offsets, 0, nullptr, &actual_num_offsets);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->mutable_offsets()->Resize(actual_num_offsets, 0);
        ViReal64* offsets = response->mutable_offsets()->mutable_data();
        auto offsets_buffer_size = actual_num_offsets;
        status = library_->TDR(vi, channel_list, apply_offsets, offsets_buffer_size, offsets, &actual_num_offsets);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->mutable_offsets()->Resize(actual_num_offsets, 0);
        response->set_actual_num_offsets(actual_num_offsets);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::UnloadAllPatterns(::grpc::ServerContext* context, const UnloadAllPatternsRequest* request, UnloadAllPatternsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViBoolean unload_keep_alive_pattern = request->unload_keep_alive_pattern();
      auto status = library_->UnloadAllPatterns(vi, unload_keep_alive_pattern);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::UnloadSpecifications(::grpc::ServerContext* context, const UnloadSpecificationsRequest* request, UnloadSpecificationsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto specifications_file_path = request->specifications_file_path().c_str();
      auto status = library_->UnloadSpecifications(vi, specifications_file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::UnlockSession(::grpc::ServerContext* context, const UnlockSessionRequest* request, UnlockSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViBoolean caller_has_lock {};
      auto status = library_->UnlockSession(vi, &caller_has_lock);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_caller_has_lock(caller_has_lock);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WaitUntilDone(::grpc::ServerContext* context, const WaitUntilDoneRequest* request, WaitUntilDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViReal64 timeout = request->timeout();
      auto status = library_->WaitUntilDone(vi, timeout);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteSequencerFlag(::grpc::ServerContext* context, const WriteSequencerFlagRequest* request, WriteSequencerFlagResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViConstString flag;
      switch (request->flag_enum_case()) {
        case nidigitalpattern_grpc::WriteSequencerFlagRequest::FlagEnumCase::kFlagMapped: {
          auto flag_imap_it = sequencerflag_input_map_.find(request->flag_mapped());
          if (flag_imap_it == sequencerflag_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for flag_mapped was not specified or out of range.");
          }
          flag = const_cast<ViConstString>((flag_imap_it->second).c_str());
          break;
        }
        case nidigitalpattern_grpc::WriteSequencerFlagRequest::FlagEnumCase::kFlagRaw: {
          flag = const_cast<ViConstString>(request->flag_raw().c_str());
          break;
        }
        case nidigitalpattern_grpc::WriteSequencerFlagRequest::FlagEnumCase::FLAG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for flag was not specified or out of range");
          break;
        }
      }

      ViBoolean value = request->value();
      auto status = library_->WriteSequencerFlag(vi, flag, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteSequencerRegister(::grpc::ServerContext* context, const WriteSequencerRegisterRequest* request, WriteSequencerRegisterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      ViConstString reg;
      switch (request->reg_enum_case()) {
        case nidigitalpattern_grpc::WriteSequencerRegisterRequest::RegEnumCase::kRegMapped: {
          auto reg_imap_it = sequencerregister_input_map_.find(request->reg_mapped());
          if (reg_imap_it == sequencerregister_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for reg_mapped was not specified or out of range.");
          }
          reg = const_cast<ViConstString>((reg_imap_it->second).c_str());
          break;
        }
        case nidigitalpattern_grpc::WriteSequencerRegisterRequest::RegEnumCase::kRegRaw: {
          reg = const_cast<ViConstString>(request->reg_raw().c_str());
          break;
        }
        case nidigitalpattern_grpc::WriteSequencerRegisterRequest::RegEnumCase::REG_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for reg was not specified or out of range");
          break;
        }
      }

      ViInt32 value = request->value();
      auto status = library_->WriteSequencerRegister(vi, reg, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteSourceWaveformBroadcastU32(::grpc::ServerContext* context, const WriteSourceWaveformBroadcastU32Request* request, WriteSourceWaveformBroadcastU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto waveform_name = request->waveform_name().c_str();
      ViInt32 waveform_size = static_cast<ViInt32>(request->waveform_data().size());
      auto waveform_data = const_cast<ViUInt32*>(reinterpret_cast<const ViUInt32*>(request->waveform_data().data()));
      auto status = library_->WriteSourceWaveformBroadcastU32(vi, waveform_name, waveform_size, waveform_data);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteSourceWaveformDataFromFileTDMS(::grpc::ServerContext* context, const WriteSourceWaveformDataFromFileTDMSRequest* request, WriteSourceWaveformDataFromFileTDMSResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto waveform_name = request->waveform_name().c_str();
      auto waveform_file_path = request->waveform_file_path().c_str();
      auto status = library_->WriteSourceWaveformDataFromFileTDMS(vi, waveform_name, waveform_file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDigitalService::WriteStatic(::grpc::ServerContext* context, const WriteStaticRequest* request, WriteStaticResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.id(), vi_grpc_session.name());
      auto channel_list = request->channel_list().c_str();
      ViUInt8 state;
      switch (request->state_enum_case()) {
        case nidigitalpattern_grpc::WriteStaticRequest::StateEnumCase::kState: {
          state = static_cast<ViUInt8>(request->state());
          break;
        }
        case nidigitalpattern_grpc::WriteStaticRequest::StateEnumCase::kStateRaw: {
          state = static_cast<ViUInt8>(request->state_raw());
          break;
        }
        case nidigitalpattern_grpc::WriteStaticRequest::StateEnumCase::STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for state was not specified or out of range");
          break;
        }
      }

      auto status = library_->WriteStatic(vi, channel_list, state);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  NiDigitalFeatureToggles::NiDigitalFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nidigitalpattern", CodeReadiness::kRelease))
  {
  }
} // namespace nidigitalpattern_grpc

