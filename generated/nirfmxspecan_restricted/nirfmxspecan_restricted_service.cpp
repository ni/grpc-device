
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-RFMXSPECAN-RESTRICTED Metadata
//---------------------------------------------------------------------
#include "nirfmxspecan_restricted_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>

namespace nirfmxspecan_restricted_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiRFmxSpecAnRestrictedService::NiRFmxSpecAnRestrictedService(
      LibrarySharedPtr library,
      ResourceRepositorySharedPtr resource_repository,
      const NiRFmxSpecAnRestrictedFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiRFmxSpecAnRestrictedService::~NiRFmxSpecAnRestrictedService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnRestrictedService::AMPMLoadReferenceWaveformFromTDMSFile(::grpc::ServerContext* context, const AMPMLoadReferenceWaveformFromTDMSFileRequest* request, AMPMLoadReferenceWaveformFromTDMSFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto waveform_file_path_mbcs = convert_from_grpc<std::string>(request->waveform_file_path());
      char* waveform_file_path = (char*)waveform_file_path_mbcs.c_str();
      int32 idle_duration_present;
      switch (request->idle_duration_present_enum_case()) {
        case nirfmxspecan_restricted_grpc::AMPMLoadReferenceWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::kIdleDurationPresent: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present());
          break;
        }
        case nirfmxspecan_restricted_grpc::AMPMLoadReferenceWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::kIdleDurationPresentRaw: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present_raw());
          break;
        }
        case nirfmxspecan_restricted_grpc::AMPMLoadReferenceWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::IDLE_DURATION_PRESENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_duration_present was not specified or out of range");
          break;
        }
      }

      int32 signal_type;
      switch (request->signal_type_enum_case()) {
        case nirfmxspecan_restricted_grpc::AMPMLoadReferenceWaveformFromTDMSFileRequest::SignalTypeEnumCase::kSignalType: {
          signal_type = static_cast<int32>(request->signal_type());
          break;
        }
        case nirfmxspecan_restricted_grpc::AMPMLoadReferenceWaveformFromTDMSFileRequest::SignalTypeEnumCase::kSignalTypeRaw: {
          signal_type = static_cast<int32>(request->signal_type_raw());
          break;
        }
        case nirfmxspecan_restricted_grpc::AMPMLoadReferenceWaveformFromTDMSFileRequest::SignalTypeEnumCase::SIGNAL_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_type was not specified or out of range");
          break;
        }
      }

      int32 waveform_index = request->waveform_index();
      auto status = library_->AMPMLoadReferenceWaveformFromTDMSFile(instrument, selector_string, waveform_file_path, idle_duration_present, signal_type, waveform_index);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnRestrictedService::CacheResult(::grpc::ServerContext* context, const CacheResultRequest* request, CacheResultResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 selector_string_out_size = request->selector_string_out_size();
      std::string selector_string_out;
      if (selector_string_out_size > 0) {
          selector_string_out.resize(selector_string_out_size - 1);
      }
      auto status = library_->CacheResult(instrument, selector_string, selector_string_out_size, (char*)selector_string_out.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      std::string selector_string_out_utf8;
      convert_to_grpc(selector_string_out, &selector_string_out_utf8);
      response->set_selector_string_out(selector_string_out_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string_out()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnRestrictedService::IQFetchDataOverrideBehavior(::grpc::ServerContext* context, const IQFetchDataOverrideBehaviorRequest* request, IQFetchDataOverrideBehaviorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 record_to_fetch = request->record_to_fetch();
      int64 samples_to_read = request->samples_to_read();
      int32 delete_on_fetch;
      switch (request->delete_on_fetch_enum_case()) {
        case nirfmxspecan_restricted_grpc::IQFetchDataOverrideBehaviorRequest::DeleteOnFetchEnumCase::kDeleteOnFetch: {
          delete_on_fetch = static_cast<int32>(request->delete_on_fetch());
          break;
        }
        case nirfmxspecan_restricted_grpc::IQFetchDataOverrideBehaviorRequest::DeleteOnFetchEnumCase::kDeleteOnFetchRaw: {
          delete_on_fetch = static_cast<int32>(request->delete_on_fetch_raw());
          break;
        }
        case nirfmxspecan_restricted_grpc::IQFetchDataOverrideBehaviorRequest::DeleteOnFetchEnumCase::DELETE_ON_FETCH_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for delete_on_fetch was not specified or out of range");
          break;
        }
      }

      float64 t0 {};
      float64 dt {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->IQFetchDataOverrideBehavior(instrument, selector_string, timeout, record_to_fetch, samples_to_read, delete_on_fetch, &t0, &dt, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> data(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->IQFetchDataOverrideBehavior(instrument, selector_string, timeout, record_to_fetch, samples_to_read, delete_on_fetch, &t0, &dt, data.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_t0(t0);
        response->set_dt(dt);
        convert_to_grpc(data, response->mutable_data());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_data()->size();
          if (shrunk_size != current_size) {
            response->mutable_data()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnRestrictedService::DPDApplyDigitalPredistortionToWaveformFromTDMSFile(::grpc::ServerContext* context, const DPDApplyDigitalPredistortionToWaveformFromTDMSFileRequest* request, DPDApplyDigitalPredistortionToWaveformFromTDMSFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto waveform_file_path_mbcs = convert_from_grpc<std::string>(request->waveform_file_path());
      char* waveform_file_path = (char*)waveform_file_path_mbcs.c_str();
      int32 idle_duration_present;
      switch (request->idle_duration_present_enum_case()) {
        case nirfmxspecan_restricted_grpc::DPDApplyDigitalPredistortionToWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::kIdleDurationPresent: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present());
          break;
        }
        case nirfmxspecan_restricted_grpc::DPDApplyDigitalPredistortionToWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::kIdleDurationPresentRaw: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present_raw());
          break;
        }
        case nirfmxspecan_restricted_grpc::DPDApplyDigitalPredistortionToWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::IDLE_DURATION_PRESENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_duration_present was not specified or out of range");
          break;
        }
      }

      float64 measurement_timeout = request->measurement_timeout();
      int32 waveform_index = request->waveform_index();
      float64 x0_out {};
      float64 dx_out {};
      int32 actual_array_size {};
      float64 papr {};
      float64 power_offset {};
      while (true) {
        auto status = library_->DPDApplyDigitalPredistortionToWaveformFromTDMSFile(instrument, selector_string, waveform_file_path, idle_duration_present, measurement_timeout, waveform_index, &x0_out, &dx_out, nullptr, 0, &actual_array_size, &papr, &power_offset);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> waveform_out(actual_array_size, NIComplexSingle());
        auto array_size_out = actual_array_size;
        status = library_->DPDApplyDigitalPredistortionToWaveformFromTDMSFile(instrument, selector_string, waveform_file_path, idle_duration_present, measurement_timeout, waveform_index, &x0_out, &dx_out, waveform_out.data(), array_size_out, &actual_array_size, &papr, &power_offset);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0_out(x0_out);
        response->set_dx_out(dx_out);
        convert_to_grpc(waveform_out, response->mutable_waveform_out());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_waveform_out()->size();
          if (shrunk_size != current_size) {
            response->mutable_waveform_out()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        response->set_papr(papr);
        response->set_power_offset(power_offset);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnRestrictedService::DPDApplyPreDPDSignalConditioningToWaveformFromTDMSFile(::grpc::ServerContext* context, const DPDApplyPreDPDSignalConditioningToWaveformFromTDMSFileRequest* request, DPDApplyPreDPDSignalConditioningToWaveformFromTDMSFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto waveform_file_path_mbcs = convert_from_grpc<std::string>(request->waveform_file_path());
      char* waveform_file_path = (char*)waveform_file_path_mbcs.c_str();
      int32 idle_duration_present;
      switch (request->idle_duration_present_enum_case()) {
        case nirfmxspecan_restricted_grpc::DPDApplyPreDPDSignalConditioningToWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::kIdleDurationPresent: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present());
          break;
        }
        case nirfmxspecan_restricted_grpc::DPDApplyPreDPDSignalConditioningToWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::kIdleDurationPresentRaw: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present_raw());
          break;
        }
        case nirfmxspecan_restricted_grpc::DPDApplyPreDPDSignalConditioningToWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::IDLE_DURATION_PRESENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_duration_present was not specified or out of range");
          break;
        }
      }

      int32 waveform_index = request->waveform_index();
      float64 x0_out {};
      float64 dx_out {};
      int32 actual_array_size {};
      float64 papr {};
      while (true) {
        auto status = library_->DPDApplyPreDPDSignalConditioningToWaveformFromTDMSFile(instrument, selector_string, waveform_file_path, idle_duration_present, waveform_index, &x0_out, &dx_out, nullptr, 0, &actual_array_size, &papr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> waveform_out(actual_array_size, NIComplexSingle());
        auto array_size_out = actual_array_size;
        status = library_->DPDApplyPreDPDSignalConditioningToWaveformFromTDMSFile(instrument, selector_string, waveform_file_path, idle_duration_present, waveform_index, &x0_out, &dx_out, waveform_out.data(), array_size_out, &actual_array_size, &papr);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0_out(x0_out);
        response->set_dx_out(dx_out);
        convert_to_grpc(waveform_out, response->mutable_waveform_out());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_waveform_out()->size();
          if (shrunk_size != current_size) {
            response->mutable_waveform_out()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        response->set_papr(papr);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnRestrictedService::DPDLoadReferenceWaveformFromTDMSFile(::grpc::ServerContext* context, const DPDLoadReferenceWaveformFromTDMSFileRequest* request, DPDLoadReferenceWaveformFromTDMSFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto waveform_file_path_mbcs = convert_from_grpc<std::string>(request->waveform_file_path());
      char* waveform_file_path = (char*)waveform_file_path_mbcs.c_str();
      int32 idle_duration_present;
      switch (request->idle_duration_present_enum_case()) {
        case nirfmxspecan_restricted_grpc::DPDLoadReferenceWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::kIdleDurationPresent: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present());
          break;
        }
        case nirfmxspecan_restricted_grpc::DPDLoadReferenceWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::kIdleDurationPresentRaw: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present_raw());
          break;
        }
        case nirfmxspecan_restricted_grpc::DPDLoadReferenceWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::IDLE_DURATION_PRESENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_duration_present was not specified or out of range");
          break;
        }
      }

      int32 signal_type;
      switch (request->signal_type_enum_case()) {
        case nirfmxspecan_restricted_grpc::DPDLoadReferenceWaveformFromTDMSFileRequest::SignalTypeEnumCase::kSignalType: {
          signal_type = static_cast<int32>(request->signal_type());
          break;
        }
        case nirfmxspecan_restricted_grpc::DPDLoadReferenceWaveformFromTDMSFileRequest::SignalTypeEnumCase::kSignalTypeRaw: {
          signal_type = static_cast<int32>(request->signal_type_raw());
          break;
        }
        case nirfmxspecan_restricted_grpc::DPDLoadReferenceWaveformFromTDMSFileRequest::SignalTypeEnumCase::SIGNAL_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_type was not specified or out of range");
          break;
        }
      }

      int32 waveform_index = request->waveform_index();
      auto status = library_->DPDLoadReferenceWaveformFromTDMSFile(instrument, selector_string, waveform_file_path, idle_duration_present, signal_type, waveform_index);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnRestrictedService::IDPDLoadReferenceWaveformFromTDMSFile(::grpc::ServerContext* context, const IDPDLoadReferenceWaveformFromTDMSFileRequest* request, IDPDLoadReferenceWaveformFromTDMSFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto waveform_file_path_mbcs = convert_from_grpc<std::string>(request->waveform_file_path());
      char* waveform_file_path = (char*)waveform_file_path_mbcs.c_str();
      int32 idle_duration_present;
      switch (request->idle_duration_present_enum_case()) {
        case nirfmxspecan_restricted_grpc::IDPDLoadReferenceWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::kIdleDurationPresent: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present());
          break;
        }
        case nirfmxspecan_restricted_grpc::IDPDLoadReferenceWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::kIdleDurationPresentRaw: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present_raw());
          break;
        }
        case nirfmxspecan_restricted_grpc::IDPDLoadReferenceWaveformFromTDMSFileRequest::IdleDurationPresentEnumCase::IDLE_DURATION_PRESENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_duration_present was not specified or out of range");
          break;
        }
      }

      int32 signal_type;
      switch (request->signal_type_enum_case()) {
        case nirfmxspecan_restricted_grpc::IDPDLoadReferenceWaveformFromTDMSFileRequest::SignalTypeEnumCase::kSignalType: {
          signal_type = static_cast<int32>(request->signal_type());
          break;
        }
        case nirfmxspecan_restricted_grpc::IDPDLoadReferenceWaveformFromTDMSFileRequest::SignalTypeEnumCase::kSignalTypeRaw: {
          signal_type = static_cast<int32>(request->signal_type_raw());
          break;
        }
        case nirfmxspecan_restricted_grpc::IDPDLoadReferenceWaveformFromTDMSFileRequest::SignalTypeEnumCase::SIGNAL_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_type was not specified or out of range");
          break;
        }
      }

      int32 waveform_index = request->waveform_index();
      auto status = library_->IDPDLoadReferenceWaveformFromTDMSFile(instrument, selector_string, waveform_file_path, idle_duration_present, signal_type, waveform_index);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  NiRFmxSpecAnRestrictedFeatureToggles::NiRFmxSpecAnRestrictedFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nirfmxspecan_restricted", CodeReadiness::kRelease))
  {
  }
} // namespace nirfmxspecan_restricted_grpc

