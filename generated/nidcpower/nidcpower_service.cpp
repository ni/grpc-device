
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-DCPower Metadata
//---------------------------------------------------------------------
#include "nidcpower_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/ivi_errors.h"
#include <server/converters.h>

namespace nidcpower_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiDCPowerService::NiDCPowerService(
      NiDCPowerLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      const NiDCPowerFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiDCPowerService::~NiDCPowerService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::Abort(::grpc::ServerContext* context, const AbortRequest* request, AbortResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Abort(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::AbortWithChannels(::grpc::ServerContext* context, const AbortWithChannelsRequest* request, AbortWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->AbortWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::CalSelfCalibrate(::grpc::ServerContext* context, const CalSelfCalibrateRequest* request, CalSelfCalibrateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->CalSelfCalibrate(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ClearError(::grpc::ServerContext* context, const ClearErrorRequest* request, ClearErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ClearError(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ClearInterchangeWarnings(::grpc::ServerContext* context, const ClearInterchangeWarningsRequest* request, ClearInterchangeWarningsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ClearInterchangeWarnings(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ClearLatchedOutputCutoffState(::grpc::ServerContext* context, const ClearLatchedOutputCutoffStateRequest* request, ClearLatchedOutputCutoffStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 output_cutoff_reason;
      switch (request->output_cutoff_reason_enum_case()) {
        case nidcpower_grpc::ClearLatchedOutputCutoffStateRequest::OutputCutoffReasonEnumCase::kOutputCutoffReason: {
          output_cutoff_reason = static_cast<ViInt32>(request->output_cutoff_reason());
          break;
        }
        case nidcpower_grpc::ClearLatchedOutputCutoffStateRequest::OutputCutoffReasonEnumCase::kOutputCutoffReasonRaw: {
          output_cutoff_reason = static_cast<ViInt32>(request->output_cutoff_reason_raw());
          break;
        }
        case nidcpower_grpc::ClearLatchedOutputCutoffStateRequest::OutputCutoffReasonEnumCase::OUTPUT_CUTOFF_REASON_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for output_cutoff_reason was not specified or out of range");
          break;
        }
      }

      auto status = library_->ClearLatchedOutputCutoffState(vi, channel_name, output_cutoff_reason);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      session_repository_->remove_session(vi_grpc_session.name());
      auto status = library_->Close(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::Commit(::grpc::ServerContext* context, const CommitRequest* request, CommitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Commit(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::CommitWithChannels(::grpc::ServerContext* context, const CommitWithChannelsRequest* request, CommitWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->CommitWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureApertureTime(::grpc::ServerContext* context, const ConfigureApertureTimeRequest* request, ConfigureApertureTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 aperture_time = request->aperture_time();
      ViInt32 units;
      switch (request->units_enum_case()) {
        case nidcpower_grpc::ConfigureApertureTimeRequest::UnitsEnumCase::kUnits: {
          units = static_cast<ViInt32>(request->units());
          break;
        }
        case nidcpower_grpc::ConfigureApertureTimeRequest::UnitsEnumCase::kUnitsRaw: {
          units = static_cast<ViInt32>(request->units_raw());
          break;
        }
        case nidcpower_grpc::ConfigureApertureTimeRequest::UnitsEnumCase::UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for units was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureApertureTime(vi, channel_name, aperture_time, units);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureAutoZero(::grpc::ServerContext* context, const ConfigureAutoZeroRequest* request, ConfigureAutoZeroResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 auto_zero;
      switch (request->auto_zero_enum_case()) {
        case nidcpower_grpc::ConfigureAutoZeroRequest::AutoZeroEnumCase::kAutoZero: {
          auto_zero = static_cast<ViInt32>(request->auto_zero());
          break;
        }
        case nidcpower_grpc::ConfigureAutoZeroRequest::AutoZeroEnumCase::kAutoZeroRaw: {
          auto_zero = static_cast<ViInt32>(request->auto_zero_raw());
          break;
        }
        case nidcpower_grpc::ConfigureAutoZeroRequest::AutoZeroEnumCase::AUTO_ZERO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for auto_zero was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureAutoZero(vi, channel_name, auto_zero);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureCurrentLevel(::grpc::ServerContext* context, const ConfigureCurrentLevelRequest* request, ConfigureCurrentLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 level = request->level();
      auto status = library_->ConfigureCurrentLevel(vi, channel_name, level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureCurrentLevelRange(::grpc::ServerContext* context, const ConfigureCurrentLevelRangeRequest* request, ConfigureCurrentLevelRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 range = request->range();
      auto status = library_->ConfigureCurrentLevelRange(vi, channel_name, range);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureCurrentLimit(::grpc::ServerContext* context, const ConfigureCurrentLimitRequest* request, ConfigureCurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 behavior;
      switch (request->behavior_enum_case()) {
        case nidcpower_grpc::ConfigureCurrentLimitRequest::BehaviorEnumCase::kBehavior: {
          behavior = static_cast<ViInt32>(request->behavior());
          break;
        }
        case nidcpower_grpc::ConfigureCurrentLimitRequest::BehaviorEnumCase::kBehaviorRaw: {
          behavior = static_cast<ViInt32>(request->behavior_raw());
          break;
        }
        case nidcpower_grpc::ConfigureCurrentLimitRequest::BehaviorEnumCase::BEHAVIOR_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for behavior was not specified or out of range");
          break;
        }
      }

      ViReal64 limit = request->limit();
      auto status = library_->ConfigureCurrentLimit(vi, channel_name, behavior, limit);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureCurrentLimitRange(::grpc::ServerContext* context, const ConfigureCurrentLimitRangeRequest* request, ConfigureCurrentLimitRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 range = request->range();
      auto status = library_->ConfigureCurrentLimitRange(vi, channel_name, range);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgeMeasureTrigger(::grpc::ServerContext* context, const ConfigureDigitalEdgeMeasureTriggerRequest* request, ConfigureDigitalEdgeMeasureTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgeMeasureTriggerRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeMeasureTriggerRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeMeasureTriggerRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeMeasureTrigger(vi, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgeMeasureTriggerWithChannels(::grpc::ServerContext* context, const ConfigureDigitalEdgeMeasureTriggerWithChannelsRequest* request, ConfigureDigitalEdgeMeasureTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgeMeasureTriggerWithChannelsRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeMeasureTriggerWithChannelsRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeMeasureTriggerWithChannelsRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeMeasureTriggerWithChannels(vi, channel_name, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgePulseTrigger(::grpc::ServerContext* context, const ConfigureDigitalEdgePulseTriggerRequest* request, ConfigureDigitalEdgePulseTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgePulseTriggerRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgePulseTriggerRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgePulseTriggerRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgePulseTrigger(vi, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgePulseTriggerWithChannels(::grpc::ServerContext* context, const ConfigureDigitalEdgePulseTriggerWithChannelsRequest* request, ConfigureDigitalEdgePulseTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgePulseTriggerWithChannelsRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgePulseTriggerWithChannelsRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgePulseTriggerWithChannelsRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgePulseTriggerWithChannels(vi, channel_name, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgeSequenceAdvanceTrigger(::grpc::ServerContext* context, const ConfigureDigitalEdgeSequenceAdvanceTriggerRequest* request, ConfigureDigitalEdgeSequenceAdvanceTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgeSequenceAdvanceTriggerRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeSequenceAdvanceTriggerRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeSequenceAdvanceTriggerRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeSequenceAdvanceTrigger(vi, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgeSequenceAdvanceTriggerWithChannels(::grpc::ServerContext* context, const ConfigureDigitalEdgeSequenceAdvanceTriggerWithChannelsRequest* request, ConfigureDigitalEdgeSequenceAdvanceTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgeSequenceAdvanceTriggerWithChannelsRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeSequenceAdvanceTriggerWithChannelsRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeSequenceAdvanceTriggerWithChannelsRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeSequenceAdvanceTriggerWithChannels(vi, channel_name, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgeShutdownTriggerWithChannels(::grpc::ServerContext* context, const ConfigureDigitalEdgeShutdownTriggerWithChannelsRequest* request, ConfigureDigitalEdgeShutdownTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgeShutdownTriggerWithChannelsRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeShutdownTriggerWithChannelsRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeShutdownTriggerWithChannelsRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeShutdownTriggerWithChannels(vi, channel_name, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgeSourceTrigger(::grpc::ServerContext* context, const ConfigureDigitalEdgeSourceTriggerRequest* request, ConfigureDigitalEdgeSourceTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgeSourceTriggerRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeSourceTriggerRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeSourceTriggerRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeSourceTrigger(vi, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgeSourceTriggerWithChannels(::grpc::ServerContext* context, const ConfigureDigitalEdgeSourceTriggerWithChannelsRequest* request, ConfigureDigitalEdgeSourceTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgeSourceTriggerWithChannelsRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeSourceTriggerWithChannelsRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeSourceTriggerWithChannelsRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeSourceTriggerWithChannels(vi, channel_name, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgeStartTrigger(::grpc::ServerContext* context, const ConfigureDigitalEdgeStartTriggerRequest* request, ConfigureDigitalEdgeStartTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgeStartTriggerRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeStartTriggerRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeStartTriggerRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeStartTrigger(vi, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureDigitalEdgeStartTriggerWithChannels(::grpc::ServerContext* context, const ConfigureDigitalEdgeStartTriggerWithChannelsRequest* request, ConfigureDigitalEdgeStartTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto input_terminal_mbcs = convert_from_grpc<std::string>(request->input_terminal());
      auto input_terminal = input_terminal_mbcs.c_str();
      ViInt32 edge;
      switch (request->edge_enum_case()) {
        case nidcpower_grpc::ConfigureDigitalEdgeStartTriggerWithChannelsRequest::EdgeEnumCase::kEdge: {
          edge = static_cast<ViInt32>(request->edge());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeStartTriggerWithChannelsRequest::EdgeEnumCase::kEdgeRaw: {
          edge = static_cast<ViInt32>(request->edge_raw());
          break;
        }
        case nidcpower_grpc::ConfigureDigitalEdgeStartTriggerWithChannelsRequest::EdgeEnumCase::EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for edge was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureDigitalEdgeStartTriggerWithChannels(vi, channel_name, input_terminal, edge);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureLCRCustomCableCompensation(::grpc::ServerContext* context, const ConfigureLCRCustomCableCompensationRequest* request, ConfigureLCRCustomCableCompensationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 custom_cable_compensation_data_size = static_cast<ViInt32>(request->custom_cable_compensation_data().size());
      ViInt8* custom_cable_compensation_data = (ViInt8*)request->custom_cable_compensation_data().c_str();
      auto status = library_->ConfigureLCRCustomCableCompensation(vi, channel_name, custom_cable_compensation_data_size, custom_cable_compensation_data);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureOutputEnabled(::grpc::ServerContext* context, const ConfigureOutputEnabledRequest* request, ConfigureOutputEnabledResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViBoolean enabled = request->enabled();
      auto status = library_->ConfigureOutputEnabled(vi, channel_name, enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureOutputFunction(::grpc::ServerContext* context, const ConfigureOutputFunctionRequest* request, ConfigureOutputFunctionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 function;
      switch (request->function_enum_case()) {
        case nidcpower_grpc::ConfigureOutputFunctionRequest::FunctionEnumCase::kFunction: {
          function = static_cast<ViInt32>(request->function());
          break;
        }
        case nidcpower_grpc::ConfigureOutputFunctionRequest::FunctionEnumCase::kFunctionRaw: {
          function = static_cast<ViInt32>(request->function_raw());
          break;
        }
        case nidcpower_grpc::ConfigureOutputFunctionRequest::FunctionEnumCase::FUNCTION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for function was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureOutputFunction(vi, channel_name, function);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureOutputRange(::grpc::ServerContext* context, const ConfigureOutputRangeRequest* request, ConfigureOutputRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 range_type = request->range_type();
      ViReal64 range = request->range();
      auto status = library_->ConfigureOutputRange(vi, channel_name, range_type, range);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureOutputResistance(::grpc::ServerContext* context, const ConfigureOutputResistanceRequest* request, ConfigureOutputResistanceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 resistance = request->resistance();
      auto status = library_->ConfigureOutputResistance(vi, channel_name, resistance);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureOvp(::grpc::ServerContext* context, const ConfigureOvpRequest* request, ConfigureOvpResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViBoolean enabled = request->enabled();
      ViReal64 limit = request->limit();
      auto status = library_->ConfigureOvp(vi, channel_name, enabled, limit);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePowerLineFrequency(::grpc::ServerContext* context, const ConfigurePowerLineFrequencyRequest* request, ConfigurePowerLineFrequencyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViReal64 powerline_frequency;
      switch (request->powerline_frequency_enum_case()) {
        case nidcpower_grpc::ConfigurePowerLineFrequencyRequest::PowerlineFrequencyEnumCase::kPowerlineFrequency: {
          powerline_frequency = static_cast<ViReal64>(request->powerline_frequency());
          break;
        }
        case nidcpower_grpc::ConfigurePowerLineFrequencyRequest::PowerlineFrequencyEnumCase::kPowerlineFrequencyRaw: {
          powerline_frequency = static_cast<ViReal64>(request->powerline_frequency_raw());
          break;
        }
        case nidcpower_grpc::ConfigurePowerLineFrequencyRequest::PowerlineFrequencyEnumCase::POWERLINE_FREQUENCY_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for powerline_frequency was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigurePowerLineFrequency(vi, powerline_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseBiasCurrentLevel(::grpc::ServerContext* context, const ConfigurePulseBiasCurrentLevelRequest* request, ConfigurePulseBiasCurrentLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 level = request->level();
      auto status = library_->ConfigurePulseBiasCurrentLevel(vi, channel_name, level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseBiasCurrentLimit(::grpc::ServerContext* context, const ConfigurePulseBiasCurrentLimitRequest* request, ConfigurePulseBiasCurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 limit = request->limit();
      auto status = library_->ConfigurePulseBiasCurrentLimit(vi, channel_name, limit);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseBiasVoltageLevel(::grpc::ServerContext* context, const ConfigurePulseBiasVoltageLevelRequest* request, ConfigurePulseBiasVoltageLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 level = request->level();
      auto status = library_->ConfigurePulseBiasVoltageLevel(vi, channel_name, level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseBiasVoltageLimit(::grpc::ServerContext* context, const ConfigurePulseBiasVoltageLimitRequest* request, ConfigurePulseBiasVoltageLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 limit = request->limit();
      auto status = library_->ConfigurePulseBiasVoltageLimit(vi, channel_name, limit);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseCurrentLevel(::grpc::ServerContext* context, const ConfigurePulseCurrentLevelRequest* request, ConfigurePulseCurrentLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 level = request->level();
      auto status = library_->ConfigurePulseCurrentLevel(vi, channel_name, level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseCurrentLevelRange(::grpc::ServerContext* context, const ConfigurePulseCurrentLevelRangeRequest* request, ConfigurePulseCurrentLevelRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 range = request->range();
      auto status = library_->ConfigurePulseCurrentLevelRange(vi, channel_name, range);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseCurrentLimit(::grpc::ServerContext* context, const ConfigurePulseCurrentLimitRequest* request, ConfigurePulseCurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 limit = request->limit();
      auto status = library_->ConfigurePulseCurrentLimit(vi, channel_name, limit);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseCurrentLimitRange(::grpc::ServerContext* context, const ConfigurePulseCurrentLimitRangeRequest* request, ConfigurePulseCurrentLimitRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 range = request->range();
      auto status = library_->ConfigurePulseCurrentLimitRange(vi, channel_name, range);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseVoltageLevel(::grpc::ServerContext* context, const ConfigurePulseVoltageLevelRequest* request, ConfigurePulseVoltageLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 level = request->level();
      auto status = library_->ConfigurePulseVoltageLevel(vi, channel_name, level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseVoltageLevelRange(::grpc::ServerContext* context, const ConfigurePulseVoltageLevelRangeRequest* request, ConfigurePulseVoltageLevelRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 range = request->range();
      auto status = library_->ConfigurePulseVoltageLevelRange(vi, channel_name, range);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseVoltageLimit(::grpc::ServerContext* context, const ConfigurePulseVoltageLimitRequest* request, ConfigurePulseVoltageLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 limit = request->limit();
      auto status = library_->ConfigurePulseVoltageLimit(vi, channel_name, limit);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigurePulseVoltageLimitRange(::grpc::ServerContext* context, const ConfigurePulseVoltageLimitRangeRequest* request, ConfigurePulseVoltageLimitRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 range = request->range();
      auto status = library_->ConfigurePulseVoltageLimitRange(vi, channel_name, range);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSense(::grpc::ServerContext* context, const ConfigureSenseRequest* request, ConfigureSenseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 sense;
      switch (request->sense_enum_case()) {
        case nidcpower_grpc::ConfigureSenseRequest::SenseEnumCase::kSense: {
          sense = static_cast<ViInt32>(request->sense());
          break;
        }
        case nidcpower_grpc::ConfigureSenseRequest::SenseEnumCase::kSenseRaw: {
          sense = static_cast<ViInt32>(request->sense_raw());
          break;
        }
        case nidcpower_grpc::ConfigureSenseRequest::SenseEnumCase::SENSE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sense was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureSense(vi, channel_name, sense);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgeMeasureTrigger(::grpc::ServerContext* context, const ConfigureSoftwareEdgeMeasureTriggerRequest* request, ConfigureSoftwareEdgeMeasureTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ConfigureSoftwareEdgeMeasureTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgeMeasureTriggerWithChannels(::grpc::ServerContext* context, const ConfigureSoftwareEdgeMeasureTriggerWithChannelsRequest* request, ConfigureSoftwareEdgeMeasureTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->ConfigureSoftwareEdgeMeasureTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgePulseTrigger(::grpc::ServerContext* context, const ConfigureSoftwareEdgePulseTriggerRequest* request, ConfigureSoftwareEdgePulseTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ConfigureSoftwareEdgePulseTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgePulseTriggerWithChannels(::grpc::ServerContext* context, const ConfigureSoftwareEdgePulseTriggerWithChannelsRequest* request, ConfigureSoftwareEdgePulseTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->ConfigureSoftwareEdgePulseTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgeSequenceAdvanceTrigger(::grpc::ServerContext* context, const ConfigureSoftwareEdgeSequenceAdvanceTriggerRequest* request, ConfigureSoftwareEdgeSequenceAdvanceTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ConfigureSoftwareEdgeSequenceAdvanceTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgeSequenceAdvanceTriggerWithChannels(::grpc::ServerContext* context, const ConfigureSoftwareEdgeSequenceAdvanceTriggerWithChannelsRequest* request, ConfigureSoftwareEdgeSequenceAdvanceTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->ConfigureSoftwareEdgeSequenceAdvanceTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgeShutdownTriggerWithChannels(::grpc::ServerContext* context, const ConfigureSoftwareEdgeShutdownTriggerWithChannelsRequest* request, ConfigureSoftwareEdgeShutdownTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->ConfigureSoftwareEdgeShutdownTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgeSourceTrigger(::grpc::ServerContext* context, const ConfigureSoftwareEdgeSourceTriggerRequest* request, ConfigureSoftwareEdgeSourceTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ConfigureSoftwareEdgeSourceTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgeSourceTriggerWithChannels(::grpc::ServerContext* context, const ConfigureSoftwareEdgeSourceTriggerWithChannelsRequest* request, ConfigureSoftwareEdgeSourceTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->ConfigureSoftwareEdgeSourceTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgeStartTrigger(::grpc::ServerContext* context, const ConfigureSoftwareEdgeStartTriggerRequest* request, ConfigureSoftwareEdgeStartTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ConfigureSoftwareEdgeStartTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSoftwareEdgeStartTriggerWithChannels(::grpc::ServerContext* context, const ConfigureSoftwareEdgeStartTriggerWithChannelsRequest* request, ConfigureSoftwareEdgeStartTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->ConfigureSoftwareEdgeStartTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSourceMode(::grpc::ServerContext* context, const ConfigureSourceModeRequest* request, ConfigureSourceModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 source_mode;
      switch (request->source_mode_enum_case()) {
        case nidcpower_grpc::ConfigureSourceModeRequest::SourceModeEnumCase::kSourceMode: {
          source_mode = static_cast<ViInt32>(request->source_mode());
          break;
        }
        case nidcpower_grpc::ConfigureSourceModeRequest::SourceModeEnumCase::kSourceModeRaw: {
          source_mode = static_cast<ViInt32>(request->source_mode_raw());
          break;
        }
        case nidcpower_grpc::ConfigureSourceModeRequest::SourceModeEnumCase::SOURCE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for source_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureSourceMode(vi, source_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureSourceModeWithChannels(::grpc::ServerContext* context, const ConfigureSourceModeWithChannelsRequest* request, ConfigureSourceModeWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 source_mode;
      switch (request->source_mode_enum_case()) {
        case nidcpower_grpc::ConfigureSourceModeWithChannelsRequest::SourceModeEnumCase::kSourceMode: {
          source_mode = static_cast<ViInt32>(request->source_mode());
          break;
        }
        case nidcpower_grpc::ConfigureSourceModeWithChannelsRequest::SourceModeEnumCase::kSourceModeRaw: {
          source_mode = static_cast<ViInt32>(request->source_mode_raw());
          break;
        }
        case nidcpower_grpc::ConfigureSourceModeWithChannelsRequest::SourceModeEnumCase::SOURCE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for source_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConfigureSourceModeWithChannels(vi, channel_name, source_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureVoltageLevel(::grpc::ServerContext* context, const ConfigureVoltageLevelRequest* request, ConfigureVoltageLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 level = request->level();
      auto status = library_->ConfigureVoltageLevel(vi, channel_name, level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureVoltageLevelRange(::grpc::ServerContext* context, const ConfigureVoltageLevelRangeRequest* request, ConfigureVoltageLevelRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 range = request->range();
      auto status = library_->ConfigureVoltageLevelRange(vi, channel_name, range);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureVoltageLimit(::grpc::ServerContext* context, const ConfigureVoltageLimitRequest* request, ConfigureVoltageLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 limit = request->limit();
      auto status = library_->ConfigureVoltageLimit(vi, channel_name, limit);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ConfigureVoltageLimitRange(::grpc::ServerContext* context, const ConfigureVoltageLimitRangeRequest* request, ConfigureVoltageLimitRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 range = request->range();
      auto status = library_->ConfigureVoltageLimitRange(vi, channel_name, range);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::CreateAdvancedSequence(::grpc::ServerContext* context, const CreateAdvancedSequenceRequest* request, CreateAdvancedSequenceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto sequence_name_mbcs = convert_from_grpc<std::string>(request->sequence_name());
      auto sequence_name = sequence_name_mbcs.c_str();
      ViInt32 attribute_id_count = static_cast<ViInt32>(request->attribute_ids().size());
      auto attribute_ids = const_cast<ViInt32*>(reinterpret_cast<const ViInt32*>(request->attribute_ids().data()));
      ViBoolean set_as_active_sequence = request->set_as_active_sequence();
      auto status = library_->CreateAdvancedSequence(vi, sequence_name, attribute_id_count, attribute_ids, set_as_active_sequence);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::CreateAdvancedSequenceCommitStepWithChannels(::grpc::ServerContext* context, const CreateAdvancedSequenceCommitStepWithChannelsRequest* request, CreateAdvancedSequenceCommitStepWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViBoolean set_as_active_step = request->set_as_active_step();
      auto status = library_->CreateAdvancedSequenceCommitStepWithChannels(vi, channel_name, set_as_active_step);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::CreateAdvancedSequenceStep(::grpc::ServerContext* context, const CreateAdvancedSequenceStepRequest* request, CreateAdvancedSequenceStepResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViBoolean set_as_active_step = request->set_as_active_step();
      auto status = library_->CreateAdvancedSequenceStep(vi, set_as_active_step);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::CreateAdvancedSequenceStepWithChannels(::grpc::ServerContext* context, const CreateAdvancedSequenceStepWithChannelsRequest* request, CreateAdvancedSequenceStepWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViBoolean set_as_active_step = request->set_as_active_step();
      auto status = library_->CreateAdvancedSequenceStepWithChannels(vi, channel_name, set_as_active_step);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::CreateAdvancedSequenceWithChannels(::grpc::ServerContext* context, const CreateAdvancedSequenceWithChannelsRequest* request, CreateAdvancedSequenceWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto sequence_name_mbcs = convert_from_grpc<std::string>(request->sequence_name());
      auto sequence_name = sequence_name_mbcs.c_str();
      ViInt32 attribute_id_count = static_cast<ViInt32>(request->attribute_ids().size());
      auto attribute_ids = const_cast<ViInt32*>(reinterpret_cast<const ViInt32*>(request->attribute_ids().data()));
      ViBoolean set_as_active_sequence = request->set_as_active_sequence();
      auto status = library_->CreateAdvancedSequenceWithChannels(vi, channel_name, sequence_name, attribute_id_count, attribute_ids, set_as_active_sequence);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DeleteAdvancedSequence(::grpc::ServerContext* context, const DeleteAdvancedSequenceRequest* request, DeleteAdvancedSequenceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto sequence_name_mbcs = convert_from_grpc<std::string>(request->sequence_name());
      auto sequence_name = sequence_name_mbcs.c_str();
      auto status = library_->DeleteAdvancedSequence(vi, sequence_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DeleteAdvancedSequenceWithChannels(::grpc::ServerContext* context, const DeleteAdvancedSequenceWithChannelsRequest* request, DeleteAdvancedSequenceWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto sequence_name_mbcs = convert_from_grpc<std::string>(request->sequence_name());
      auto sequence_name = sequence_name_mbcs.c_str();
      auto status = library_->DeleteAdvancedSequenceWithChannels(vi, channel_name, sequence_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::Disable(::grpc::ServerContext* context, const DisableRequest* request, DisableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Disable(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DisablePulseTrigger(::grpc::ServerContext* context, const DisablePulseTriggerRequest* request, DisablePulseTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->DisablePulseTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DisablePulseTriggerWithChannels(::grpc::ServerContext* context, const DisablePulseTriggerWithChannelsRequest* request, DisablePulseTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->DisablePulseTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DisableSequenceAdvanceTrigger(::grpc::ServerContext* context, const DisableSequenceAdvanceTriggerRequest* request, DisableSequenceAdvanceTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->DisableSequenceAdvanceTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DisableSequenceAdvanceTriggerWithChannels(::grpc::ServerContext* context, const DisableSequenceAdvanceTriggerWithChannelsRequest* request, DisableSequenceAdvanceTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->DisableSequenceAdvanceTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DisableShutdownTriggerWithChannels(::grpc::ServerContext* context, const DisableShutdownTriggerWithChannelsRequest* request, DisableShutdownTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->DisableShutdownTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DisableSourceTrigger(::grpc::ServerContext* context, const DisableSourceTriggerRequest* request, DisableSourceTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->DisableSourceTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DisableSourceTriggerWithChannels(::grpc::ServerContext* context, const DisableSourceTriggerWithChannelsRequest* request, DisableSourceTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->DisableSourceTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DisableStartTrigger(::grpc::ServerContext* context, const DisableStartTriggerRequest* request, DisableStartTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->DisableStartTrigger(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::DisableStartTriggerWithChannels(::grpc::ServerContext* context, const DisableStartTriggerWithChannelsRequest* request, DisableStartTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->DisableStartTriggerWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ErrorMessage(::grpc::ServerContext* context, const ErrorMessageRequest* request, ErrorMessageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViStatus error_code = request->error_code();
      std::string error_message(256 - 1, '\0');
      auto status = library_->ErrorMessage(vi, error_code, (ViChar*)error_message.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      std::string error_message_utf8;
      convert_to_grpc(error_message, &error_message_utf8);
      response->set_error_message(error_message_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_message()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ErrorQuery(::grpc::ServerContext* context, const ErrorQueryRequest* request, ErrorQueryResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 error_code {};
      std::string error_message(256 - 1, '\0');
      auto status = library_->ErrorQuery(vi, &error_code, (ViChar*)error_message.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_error_code(error_code);
      std::string error_message_utf8;
      convert_to_grpc(error_message, &error_message_utf8);
      response->set_error_message(error_message_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_message()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ExportAttributeConfigurationBuffer(::grpc::ServerContext* context, const ExportAttributeConfigurationBufferRequest* request, ExportAttributeConfigurationBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());

      while (true) {
        auto status = library_->ExportAttributeConfigurationBuffer(vi, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 size = status;

        std::string configuration(size, '\0');
        status = library_->ExportAttributeConfigurationBuffer(vi, size, (ViInt8*)configuration.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_configuration(configuration);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ExportAttributeConfigurationFile(::grpc::ServerContext* context, const ExportAttributeConfigurationFileRequest* request, ExportAttributeConfigurationFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto file_path_mbcs = convert_from_grpc<std::string>(request->file_path());
      auto file_path = file_path_mbcs.c_str();
      auto status = library_->ExportAttributeConfigurationFile(vi, file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ExportSignal(::grpc::ServerContext* context, const ExportSignalRequest* request, ExportSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 signal;
      switch (request->signal_enum_case()) {
        case nidcpower_grpc::ExportSignalRequest::SignalEnumCase::kSignal: {
          signal = static_cast<ViInt32>(request->signal());
          break;
        }
        case nidcpower_grpc::ExportSignalRequest::SignalEnumCase::kSignalRaw: {
          signal = static_cast<ViInt32>(request->signal_raw());
          break;
        }
        case nidcpower_grpc::ExportSignalRequest::SignalEnumCase::SIGNAL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal was not specified or out of range");
          break;
        }
      }

      auto signal_identifier_mbcs = convert_from_grpc<std::string>(request->signal_identifier());
      auto signal_identifier = signal_identifier_mbcs.c_str();
      auto output_terminal_mbcs = convert_from_grpc<std::string>(request->output_terminal());
      auto output_terminal = output_terminal_mbcs.c_str();
      auto status = library_->ExportSignal(vi, signal, signal_identifier, output_terminal);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ExportSignalWithChannels(::grpc::ServerContext* context, const ExportSignalWithChannelsRequest* request, ExportSignalWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 signal;
      switch (request->signal_enum_case()) {
        case nidcpower_grpc::ExportSignalWithChannelsRequest::SignalEnumCase::kSignal: {
          signal = static_cast<ViInt32>(request->signal());
          break;
        }
        case nidcpower_grpc::ExportSignalWithChannelsRequest::SignalEnumCase::kSignalRaw: {
          signal = static_cast<ViInt32>(request->signal_raw());
          break;
        }
        case nidcpower_grpc::ExportSignalWithChannelsRequest::SignalEnumCase::SIGNAL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal was not specified or out of range");
          break;
        }
      }

      auto signal_identifier_mbcs = convert_from_grpc<std::string>(request->signal_identifier());
      auto signal_identifier = signal_identifier_mbcs.c_str();
      auto output_terminal_mbcs = convert_from_grpc<std::string>(request->output_terminal());
      auto output_terminal = output_terminal_mbcs.c_str();
      auto status = library_->ExportSignalWithChannels(vi, channel_name, signal, signal_identifier, output_terminal);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::FetchMultiple(::grpc::ServerContext* context, const FetchMultipleRequest* request, FetchMultipleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 timeout = request->timeout();
      ViInt32 count = request->count();
      response->mutable_voltage_measurements()->Resize(count, 0);
      ViReal64* voltage_measurements = response->mutable_voltage_measurements()->mutable_data();
      response->mutable_current_measurements()->Resize(count, 0);
      ViReal64* current_measurements = response->mutable_current_measurements()->mutable_data();
      std::vector<ViBoolean> in_compliance(count, ViBoolean());
      ViInt32 actual_count {};
      auto status = library_->FetchMultiple(vi, channel_name, timeout, count, voltage_measurements, current_measurements, in_compliance.data(), &actual_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      convert_to_grpc(in_compliance, response->mutable_in_compliance());
      response->set_actual_count(actual_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::FetchMultipleLCR(::grpc::ServerContext* context, const FetchMultipleLCRRequest* request, FetchMultipleLCRResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 timeout = request->timeout();
      ViInt32 count = request->count();
      std::vector<NILCRMeasurement_struct> measurements(count, NILCRMeasurement_struct());
      ViInt32 actual_count {};
      auto status = library_->FetchMultipleLCR(vi, channel_name, timeout, count, measurements.data(), &actual_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      convert_to_grpc(measurements, response->mutable_measurements());
      response->set_actual_count(actual_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetAttributeViBoolean(::grpc::ServerContext* context, const GetAttributeViBooleanRequest* request, GetAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViBoolean attribute_value {};
      auto status = library_->GetAttributeViBoolean(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetAttributeViInt32(::grpc::ServerContext* context, const GetAttributeViInt32Request* request, GetAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt32 attribute_value {};
      auto status = library_->GetAttributeViInt32(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetAttributeViInt64(::grpc::ServerContext* context, const GetAttributeViInt64Request* request, GetAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt64 attribute_value {};
      auto status = library_->GetAttributeViInt64(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetAttributeViReal64(::grpc::ServerContext* context, const GetAttributeViReal64Request* request, GetAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViReal64 attribute_value {};
      auto status = library_->GetAttributeViReal64(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_attribute_value(attribute_value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetAttributeViSession(::grpc::ServerContext* context, const GetAttributeViSessionRequest* request, GetAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViSession attribute_value {};
      auto status = library_->GetAttributeViSession(vi, channel_name, attribute_id, &attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      auto grpc_device_session_name = session_repository_->resolve_session_name(attribute_value);
      response->mutable_attribute_value()->set_name(grpc_device_session_name);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetAttributeViString(::grpc::ServerContext* context, const GetAttributeViStringRequest* request, GetAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();

      while (true) {
        auto status = library_->GetAttributeViString(vi, channel_name, attribute_id, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string attribute_value;
        if (buffer_size > 0) {
            attribute_value.resize(buffer_size - 1);
        }
        status = library_->GetAttributeViString(vi, channel_name, attribute_id, buffer_size, (ViChar*)attribute_value.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        std::string attribute_value_utf8;
        convert_to_grpc(attribute_value, &attribute_value_utf8);
        response->set_attribute_value(attribute_value_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_attribute_value()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetChannelName(::grpc::ServerContext* context, const GetChannelNameRequest* request, GetChannelNameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 index = request->index();

      while (true) {
        auto status = library_->GetChannelName(vi, index, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string channel_name;
        if (buffer_size > 0) {
            channel_name.resize(buffer_size - 1);
        }
        status = library_->GetChannelName(vi, index, buffer_size, (ViChar*)channel_name.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        std::string channel_name_utf8;
        convert_to_grpc(channel_name, &channel_name_utf8);
        response->set_channel_name(channel_name_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_channel_name()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetChannelNameFromString(::grpc::ServerContext* context, const GetChannelNameFromStringRequest* request, GetChannelNameFromStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto index_mbcs = convert_from_grpc<std::string>(request->index());
      auto index = index_mbcs.c_str();

      while (true) {
        auto status = library_->GetChannelNameFromString(vi, index, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string channel_name;
        if (buffer_size > 0) {
            channel_name.resize(buffer_size - 1);
        }
        status = library_->GetChannelNameFromString(vi, index, buffer_size, (ViChar*)channel_name.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        std::string channel_name_utf8;
        convert_to_grpc(channel_name, &channel_name_utf8);
        response->set_channel_name(channel_name_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_channel_name()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetError(::grpc::ServerContext* context, const GetErrorRequest* request, GetErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());

      while (true) {
        auto status = library_->GetError(vi, nullptr, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        ViStatus code {};
        std::string description;
        if (buffer_size > 0) {
            description.resize(buffer_size - 1);
        }
        status = library_->GetError(vi, &code, buffer_size, (ViChar*)description.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_code(code);
        std::string description_utf8;
        convert_to_grpc(description, &description_utf8);
        response->set_description(description_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_description()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetExtCalLastDateAndTime(::grpc::ServerContext* context, const GetExtCalLastDateAndTimeRequest* request, GetExtCalLastDateAndTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 year {};
      ViInt32 month {};
      ViInt32 day {};
      ViInt32 hour {};
      ViInt32 minute {};
      auto status = library_->GetExtCalLastDateAndTime(vi, &year, &month, &day, &hour, &minute);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_year(year);
      response->set_month(month);
      response->set_day(day);
      response->set_hour(hour);
      response->set_minute(minute);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetExtCalLastTemp(::grpc::ServerContext* context, const GetExtCalLastTempRequest* request, GetExtCalLastTempResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViReal64 temperature {};
      auto status = library_->GetExtCalLastTemp(vi, &temperature);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_temperature(temperature);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetExtCalRecommendedInterval(::grpc::ServerContext* context, const GetExtCalRecommendedIntervalRequest* request, GetExtCalRecommendedIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 months {};
      auto status = library_->GetExtCalRecommendedInterval(vi, &months);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_months(months);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetLCRCompensationLastDateAndTime(::grpc::ServerContext* context, const GetLCRCompensationLastDateAndTimeRequest* request, GetLCRCompensationLastDateAndTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 compensation_type;
      switch (request->compensation_type_enum_case()) {
        case nidcpower_grpc::GetLCRCompensationLastDateAndTimeRequest::CompensationTypeEnumCase::kCompensationType: {
          compensation_type = static_cast<ViInt32>(request->compensation_type());
          break;
        }
        case nidcpower_grpc::GetLCRCompensationLastDateAndTimeRequest::CompensationTypeEnumCase::kCompensationTypeRaw: {
          compensation_type = static_cast<ViInt32>(request->compensation_type_raw());
          break;
        }
        case nidcpower_grpc::GetLCRCompensationLastDateAndTimeRequest::CompensationTypeEnumCase::COMPENSATION_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for compensation_type was not specified or out of range");
          break;
        }
      }

      ViInt32 year {};
      ViInt32 month {};
      ViInt32 day {};
      ViInt32 hour {};
      ViInt32 minute {};
      auto status = library_->GetLCRCompensationLastDateAndTime(vi, channel_name, compensation_type, &year, &month, &day, &hour, &minute);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_year(year);
      response->set_month(month);
      response->set_day(day);
      response->set_hour(hour);
      response->set_minute(minute);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetLCRCustomCableCompensationData(::grpc::ServerContext* context, const GetLCRCustomCableCompensationDataRequest* request, GetLCRCustomCableCompensationDataResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();

      while (true) {
        auto status = library_->GetLCRCustomCableCompensationData(vi, channel_name, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 custom_cable_compensation_data_size = status;

        std::string custom_cable_compensation_data(custom_cable_compensation_data_size, '\0');
        status = library_->GetLCRCustomCableCompensationData(vi, channel_name, custom_cable_compensation_data_size, (ViInt8*)custom_cable_compensation_data.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(custom_cable_compensation_data_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        response->set_custom_cable_compensation_data(custom_cable_compensation_data);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetNextCoercionRecord(::grpc::ServerContext* context, const GetNextCoercionRecordRequest* request, GetNextCoercionRecordResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());

      while (true) {
        auto status = library_->GetNextCoercionRecord(vi, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string coercion_record;
        if (buffer_size > 0) {
            coercion_record.resize(buffer_size - 1);
        }
        status = library_->GetNextCoercionRecord(vi, buffer_size, (ViChar*)coercion_record.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        std::string coercion_record_utf8;
        convert_to_grpc(coercion_record, &coercion_record_utf8);
        response->set_coercion_record(coercion_record_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_coercion_record()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetNextInterchangeWarning(::grpc::ServerContext* context, const GetNextInterchangeWarningRequest* request, GetNextInterchangeWarningResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());

      while (true) {
        auto status = library_->GetNextInterchangeWarning(vi, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        ViInt32 buffer_size = status;

        std::string interchange_warning;
        if (buffer_size > 0) {
            interchange_warning.resize(buffer_size - 1);
        }
        status = library_->GetNextInterchangeWarning(vi, buffer_size, (ViChar*)interchange_warning.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, vi);
        }
        response->set_status(status);
        std::string interchange_warning_utf8;
        convert_to_grpc(interchange_warning, &interchange_warning_utf8);
        response->set_interchange_warning(interchange_warning_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_interchange_warning()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetSelfCalLastDateAndTime(::grpc::ServerContext* context, const GetSelfCalLastDateAndTimeRequest* request, GetSelfCalLastDateAndTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 year {};
      ViInt32 month {};
      ViInt32 day {};
      ViInt32 hour {};
      ViInt32 minute {};
      auto status = library_->GetSelfCalLastDateAndTime(vi, &year, &month, &day, &hour, &minute);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_year(year);
      response->set_month(month);
      response->set_day(day);
      response->set_hour(hour);
      response->set_minute(minute);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::GetSelfCalLastTemp(::grpc::ServerContext* context, const GetSelfCalLastTempRequest* request, GetSelfCalLastTempResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViReal64 temperature {};
      auto status = library_->GetSelfCalLastTemp(vi, &temperature);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_temperature(temperature);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ImportAttributeConfigurationBuffer(::grpc::ServerContext* context, const ImportAttributeConfigurationBufferRequest* request, ImportAttributeConfigurationBufferResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 size = static_cast<ViInt32>(request->configuration().size());
      ViInt8* configuration = (ViInt8*)request->configuration().c_str();
      auto status = library_->ImportAttributeConfigurationBuffer(vi, size, configuration);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ImportAttributeConfigurationFile(::grpc::ServerContext* context, const ImportAttributeConfigurationFileRequest* request, ImportAttributeConfigurationFileResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto file_path_mbcs = convert_from_grpc<std::string>(request->file_path());
      auto file_path = file_path_mbcs.c_str();
      auto status = library_->ImportAttributeConfigurationFile(vi, file_path);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::InitializeWithChannels(::grpc::ServerContext* context, const InitializeWithChannelsRequest* request, InitializeWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto resource_name_mbcs = convert_from_grpc<std::string>(request->resource_name());
      ViRsrc resource_name = (ViRsrc)resource_name_mbcs.c_str();
      auto channels_mbcs = convert_from_grpc<std::string>(request->channels());
      auto channels = channels_mbcs.c_str();
      ViBoolean reset = request->reset();
      auto option_string_mbcs = convert_from_grpc<std::string>(request->option_string());
      auto option_string = option_string_mbcs.c_str();
      auto initialization_behavior = request->initialization_behavior();

      bool new_session_initialized {};
      auto init_lambda = [&] () {
        ViSession vi;
        auto status = library_->InitializeWithChannels(resource_name, channels, reset, option_string, &vi);
        return std::make_tuple(status, vi);
      };
      std::string grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->mutable_vi()->set_name(grpc_device_session_name);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::InitializeWithIndependentChannels(::grpc::ServerContext* context, const InitializeWithIndependentChannelsRequest* request, InitializeWithIndependentChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto resource_name_mbcs = convert_from_grpc<std::string>(request->resource_name());
      ViRsrc resource_name = (ViRsrc)resource_name_mbcs.c_str();
      ViBoolean reset = request->reset();
      auto option_string_mbcs = convert_from_grpc<std::string>(request->option_string());
      auto option_string = option_string_mbcs.c_str();
      auto initialization_behavior = request->initialization_behavior();

      bool new_session_initialized {};
      auto init_lambda = [&] () {
        ViSession vi;
        auto status = library_->InitializeWithIndependentChannels(resource_name, reset, option_string, &vi);
        return std::make_tuple(status, vi);
      };
      std::string grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (ViSession id) { library_->Close(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, 0);
      }
      response->set_status(status);
      response->mutable_vi()->set_name(grpc_device_session_name);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::Initiate(::grpc::ServerContext* context, const InitiateRequest* request, InitiateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Initiate(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::InitiateWithChannels(::grpc::ServerContext* context, const InitiateWithChannelsRequest* request, InitiateWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->InitiateWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::InvalidateAllAttributes(::grpc::ServerContext* context, const InvalidateAllAttributesRequest* request, InvalidateAllAttributesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->InvalidateAllAttributes(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::Measure(::grpc::ServerContext* context, const MeasureRequest* request, MeasureResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 measurement_type;
      switch (request->measurement_type_enum_case()) {
        case nidcpower_grpc::MeasureRequest::MeasurementTypeEnumCase::kMeasurementType: {
          measurement_type = static_cast<ViInt32>(request->measurement_type());
          break;
        }
        case nidcpower_grpc::MeasureRequest::MeasurementTypeEnumCase::kMeasurementTypeRaw: {
          measurement_type = static_cast<ViInt32>(request->measurement_type_raw());
          break;
        }
        case nidcpower_grpc::MeasureRequest::MeasurementTypeEnumCase::MEASUREMENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurement_type was not specified or out of range");
          break;
        }
      }

      ViReal64 measurement {};
      auto status = library_->Measure(vi, channel_name, measurement_type, &measurement);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_measurement(measurement);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::PerformLCRLoadCompensation(::grpc::ServerContext* context, const PerformLCRLoadCompensationRequest* request, PerformLCRLoadCompensationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 num_compensation_spots = static_cast<ViInt32>(request->compensation_spots().size());
      auto compensation_spots = convert_from_grpc<NILCRLoadCompensationSpot_struct>(request->compensation_spots());
      auto status = library_->PerformLCRLoadCompensation(vi, channel_name, num_compensation_spots, compensation_spots.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::PerformLCROpenCompensation(::grpc::ServerContext* context, const PerformLCROpenCompensationRequest* request, PerformLCROpenCompensationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 num_frequencies = static_cast<ViInt32>(request->additional_frequencies().size());
      auto additional_frequencies = const_cast<ViReal64*>(request->additional_frequencies().data());
      auto status = library_->PerformLCROpenCompensation(vi, channel_name, num_frequencies, additional_frequencies);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::PerformLCROpenCustomCableCompensation(::grpc::ServerContext* context, const PerformLCROpenCustomCableCompensationRequest* request, PerformLCROpenCustomCableCompensationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->PerformLCROpenCustomCableCompensation(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::PerformLCRShortCompensation(::grpc::ServerContext* context, const PerformLCRShortCompensationRequest* request, PerformLCRShortCompensationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 num_frequencies = static_cast<ViInt32>(request->additional_frequencies().size());
      auto additional_frequencies = const_cast<ViReal64*>(request->additional_frequencies().data());
      auto status = library_->PerformLCRShortCompensation(vi, channel_name, num_frequencies, additional_frequencies);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::PerformLCRShortCustomCableCompensation(::grpc::ServerContext* context, const PerformLCRShortCustomCableCompensationRequest* request, PerformLCRShortCustomCableCompensationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->PerformLCRShortCustomCableCompensation(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::QueryInCompliance(::grpc::ServerContext* context, const QueryInComplianceRequest* request, QueryInComplianceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViBoolean in_compliance {};
      auto status = library_->QueryInCompliance(vi, channel_name, &in_compliance);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_in_compliance(in_compliance);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::QueryLatchedOutputCutoffState(::grpc::ServerContext* context, const QueryLatchedOutputCutoffStateRequest* request, QueryLatchedOutputCutoffStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 output_cutoff_reason;
      switch (request->output_cutoff_reason_enum_case()) {
        case nidcpower_grpc::QueryLatchedOutputCutoffStateRequest::OutputCutoffReasonEnumCase::kOutputCutoffReason: {
          output_cutoff_reason = static_cast<ViInt32>(request->output_cutoff_reason());
          break;
        }
        case nidcpower_grpc::QueryLatchedOutputCutoffStateRequest::OutputCutoffReasonEnumCase::kOutputCutoffReasonRaw: {
          output_cutoff_reason = static_cast<ViInt32>(request->output_cutoff_reason_raw());
          break;
        }
        case nidcpower_grpc::QueryLatchedOutputCutoffStateRequest::OutputCutoffReasonEnumCase::OUTPUT_CUTOFF_REASON_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for output_cutoff_reason was not specified or out of range");
          break;
        }
      }

      ViBoolean output_cutoff_state {};
      auto status = library_->QueryLatchedOutputCutoffState(vi, channel_name, output_cutoff_reason, &output_cutoff_state);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_output_cutoff_state(output_cutoff_state);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::QueryMaxCurrentLimit(::grpc::ServerContext* context, const QueryMaxCurrentLimitRequest* request, QueryMaxCurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 voltage_level = request->voltage_level();
      ViReal64 max_current_limit {};
      auto status = library_->QueryMaxCurrentLimit(vi, channel_name, voltage_level, &max_current_limit);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_max_current_limit(max_current_limit);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::QueryMaxVoltageLevel(::grpc::ServerContext* context, const QueryMaxVoltageLevelRequest* request, QueryMaxVoltageLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 current_limit = request->current_limit();
      ViReal64 max_voltage_level {};
      auto status = library_->QueryMaxVoltageLevel(vi, channel_name, current_limit, &max_voltage_level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_max_voltage_level(max_voltage_level);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::QueryMinCurrentLimit(::grpc::ServerContext* context, const QueryMinCurrentLimitRequest* request, QueryMinCurrentLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViReal64 voltage_level = request->voltage_level();
      ViReal64 min_current_limit {};
      auto status = library_->QueryMinCurrentLimit(vi, channel_name, voltage_level, &min_current_limit);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_min_current_limit(min_current_limit);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::QueryOutputState(::grpc::ServerContext* context, const QueryOutputStateRequest* request, QueryOutputStateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 output_state;
      switch (request->output_state_enum_case()) {
        case nidcpower_grpc::QueryOutputStateRequest::OutputStateEnumCase::kOutputState: {
          output_state = static_cast<ViInt32>(request->output_state());
          break;
        }
        case nidcpower_grpc::QueryOutputStateRequest::OutputStateEnumCase::kOutputStateRaw: {
          output_state = static_cast<ViInt32>(request->output_state_raw());
          break;
        }
        case nidcpower_grpc::QueryOutputStateRequest::OutputStateEnumCase::OUTPUT_STATE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for output_state was not specified or out of range");
          break;
        }
      }

      ViBoolean in_state {};
      auto status = library_->QueryOutputState(vi, channel_name, output_state, &in_state);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_in_state(in_state);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ReadCurrentTemperature(::grpc::ServerContext* context, const ReadCurrentTemperatureRequest* request, ReadCurrentTemperatureResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViReal64 temperature {};
      auto status = library_->ReadCurrentTemperature(vi, &temperature);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_temperature(temperature);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::Reset(::grpc::ServerContext* context, const ResetRequest* request, ResetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Reset(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ResetDevice(::grpc::ServerContext* context, const ResetDeviceRequest* request, ResetDeviceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ResetDevice(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ResetInterchangeCheck(::grpc::ServerContext* context, const ResetInterchangeCheckRequest* request, ResetInterchangeCheckResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ResetInterchangeCheck(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ResetWithChannels(::grpc::ServerContext* context, const ResetWithChannelsRequest* request, ResetWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto status = library_->ResetWithChannels(vi, channel_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::ResetWithDefaults(::grpc::ServerContext* context, const ResetWithDefaultsRequest* request, ResetWithDefaultsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->ResetWithDefaults(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::RevisionQuery(::grpc::ServerContext* context, const RevisionQueryRequest* request, RevisionQueryResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      std::string instrument_driver_revision(256 - 1, '\0');
      std::string firmware_revision(256 - 1, '\0');
      auto status = library_->RevisionQuery(vi, (ViChar*)instrument_driver_revision.data(), (ViChar*)firmware_revision.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      std::string instrument_driver_revision_utf8;
      convert_to_grpc(instrument_driver_revision, &instrument_driver_revision_utf8);
      response->set_instrument_driver_revision(instrument_driver_revision_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_instrument_driver_revision()));
      std::string firmware_revision_utf8;
      convert_to_grpc(firmware_revision, &firmware_revision_utf8);
      response->set_firmware_revision(firmware_revision_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_firmware_revision()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::SelfTest(::grpc::ServerContext* context, const SelfTestRequest* request, SelfTestResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 self_test_result {};
      std::string self_test_message(256 - 1, '\0');
      auto status = library_->SelfTest(vi, &self_test_result, (ViChar*)self_test_message.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_self_test_result(self_test_result);
      std::string self_test_message_utf8;
      convert_to_grpc(self_test_message, &self_test_message_utf8);
      response->set_self_test_message(self_test_message_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_self_test_message()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::SendSoftwareEdgeTrigger(::grpc::ServerContext* context, const SendSoftwareEdgeTriggerRequest* request, SendSoftwareEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 trigger;
      switch (request->trigger_enum_case()) {
        case nidcpower_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::kTrigger: {
          trigger = static_cast<ViInt32>(request->trigger());
          break;
        }
        case nidcpower_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::kTriggerRaw: {
          trigger = static_cast<ViInt32>(request->trigger_raw());
          break;
        }
        case nidcpower_grpc::SendSoftwareEdgeTriggerRequest::TriggerEnumCase::TRIGGER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger was not specified or out of range");
          break;
        }
      }

      auto status = library_->SendSoftwareEdgeTrigger(vi, trigger);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::SendSoftwareEdgeTriggerWithChannels(::grpc::ServerContext* context, const SendSoftwareEdgeTriggerWithChannelsRequest* request, SendSoftwareEdgeTriggerWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 trigger;
      switch (request->trigger_enum_case()) {
        case nidcpower_grpc::SendSoftwareEdgeTriggerWithChannelsRequest::TriggerEnumCase::kTrigger: {
          trigger = static_cast<ViInt32>(request->trigger());
          break;
        }
        case nidcpower_grpc::SendSoftwareEdgeTriggerWithChannelsRequest::TriggerEnumCase::kTriggerRaw: {
          trigger = static_cast<ViInt32>(request->trigger_raw());
          break;
        }
        case nidcpower_grpc::SendSoftwareEdgeTriggerWithChannelsRequest::TriggerEnumCase::TRIGGER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger was not specified or out of range");
          break;
        }
      }

      auto status = library_->SendSoftwareEdgeTriggerWithChannels(vi, channel_name, trigger);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::SetAttributeViBoolean(::grpc::ServerContext* context, const SetAttributeViBooleanRequest* request, SetAttributeViBooleanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViBoolean attribute_value = request->attribute_value();
      auto status = library_->SetAttributeViBoolean(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::SetAttributeViInt32(::grpc::ServerContext* context, const SetAttributeViInt32Request* request, SetAttributeViInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt32 attribute_value;
      switch (request->attribute_value_enum_case()) {
        case nidcpower_grpc::SetAttributeViInt32Request::AttributeValueEnumCase::kAttributeValue: {
          attribute_value = static_cast<ViInt32>(request->attribute_value());
          break;
        }
        case nidcpower_grpc::SetAttributeViInt32Request::AttributeValueEnumCase::kAttributeValueRaw: {
          attribute_value = static_cast<ViInt32>(request->attribute_value_raw());
          break;
        }
        case nidcpower_grpc::SetAttributeViInt32Request::AttributeValueEnumCase::ATTRIBUTE_VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute_value was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeViInt32(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::SetAttributeViInt64(::grpc::ServerContext* context, const SetAttributeViInt64Request* request, SetAttributeViInt64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViInt64 attribute_value = request->attribute_value_raw();
      auto status = library_->SetAttributeViInt64(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::SetAttributeViReal64(::grpc::ServerContext* context, const SetAttributeViReal64Request* request, SetAttributeViReal64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      ViReal64 attribute_value;
      switch (request->attribute_value_enum_case()) {
        case nidcpower_grpc::SetAttributeViReal64Request::AttributeValueEnumCase::kAttributeValue: {
          attribute_value = static_cast<ViReal64>(request->attribute_value());
          break;
        }
        case nidcpower_grpc::SetAttributeViReal64Request::AttributeValueEnumCase::kAttributeValueRaw: {
          attribute_value = static_cast<ViReal64>(request->attribute_value_raw());
          break;
        }
        case nidcpower_grpc::SetAttributeViReal64Request::AttributeValueEnumCase::ATTRIBUTE_VALUE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute_value was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeViReal64(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::SetAttributeViSession(::grpc::ServerContext* context, const SetAttributeViSessionRequest* request, SetAttributeViSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      auto attribute_value_grpc_session = request->attribute_value();
      ViSession attribute_value = session_repository_->access_session(attribute_value_grpc_session.name());
      auto status = library_->SetAttributeViSession(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::SetAttributeViString(::grpc::ServerContext* context, const SetAttributeViStringRequest* request, SetAttributeViStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      auto attribute_value_mbcs = convert_from_grpc<std::string>(request->attribute_value_raw());
      auto attribute_value = attribute_value_mbcs.c_str();
      auto status = library_->SetAttributeViString(vi, channel_name, attribute_id, attribute_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::SetSequence(::grpc::ServerContext* context, const SetSequenceRequest* request, SetSequenceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      auto values = const_cast<ViReal64*>(request->values().data());
      auto source_delays = const_cast<ViReal64*>(request->source_delays().data());
      auto size_determine_from_sizes = std::array<int, 2>
      {
        request->values_size(),
        request->source_delays_size()
      };
      const auto size_size_calculation = calculate_linked_array_size(size_determine_from_sizes, false);

      if (size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [values, source_delays] do not match");
      }
      auto size = size_size_calculation.size;

      auto status = library_->SetSequence(vi, channel_name, values, source_delays, size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::WaitForEvent(::grpc::ServerContext* context, const WaitForEventRequest* request, WaitForEventResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 event_id;
      switch (request->event_id_enum_case()) {
        case nidcpower_grpc::WaitForEventRequest::EventIdEnumCase::kEventId: {
          event_id = static_cast<ViInt32>(request->event_id());
          break;
        }
        case nidcpower_grpc::WaitForEventRequest::EventIdEnumCase::kEventIdRaw: {
          event_id = static_cast<ViInt32>(request->event_id_raw());
          break;
        }
        case nidcpower_grpc::WaitForEventRequest::EventIdEnumCase::EVENT_ID_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_id was not specified or out of range");
          break;
        }
      }

      ViReal64 timeout = request->timeout();
      auto status = library_->WaitForEvent(vi, event_id, timeout);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDCPowerService::WaitForEventWithChannels(::grpc::ServerContext* context, const WaitForEventWithChannelsRequest* request, WaitForEventWithChannelsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      auto channel_name = channel_name_mbcs.c_str();
      ViInt32 event_id;
      switch (request->event_id_enum_case()) {
        case nidcpower_grpc::WaitForEventWithChannelsRequest::EventIdEnumCase::kEventId: {
          event_id = static_cast<ViInt32>(request->event_id());
          break;
        }
        case nidcpower_grpc::WaitForEventWithChannelsRequest::EventIdEnumCase::kEventIdRaw: {
          event_id = static_cast<ViInt32>(request->event_id_raw());
          break;
        }
        case nidcpower_grpc::WaitForEventWithChannelsRequest::EventIdEnumCase::EVENT_ID_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_id was not specified or out of range");
          break;
        }
      }

      ViReal64 timeout = request->timeout();
      auto status = library_->WaitForEventWithChannels(vi, channel_name, event_id, timeout);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  NiDCPowerFeatureToggles::NiDCPowerFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nidcpower", CodeReadiness::kRelease))
  {
  }
} // namespace nidcpower_grpc

namespace nidevice_grpc {
namespace converters {
template <>
NILCRLoadCompensationSpot_struct convert_from_grpc(const nidcpower_grpc::NILCRLoadCompensationSpot& input) 
{
  auto output = NILCRLoadCompensationSpot_struct();  
  output.frequency = input.frequency();
  output.referenceValueType = input.reference_value_type();
  output.referenceValueA = input.reference_value_a();
  output.referenceValueB = input.reference_value_b();
  return output;
}

template <>
void convert_to_grpc(const NILCRMeasurement_struct& input, nidcpower_grpc::NILCRMeasurement* output) 
{
  output->set_vdc(input.Vdc);
  output->set_idc(input.Idc);
  output->set_stimulus_frequency(input.stimulusFrequency);
  convert_to_grpc(input.ACVoltage, output->mutable_ac_voltage());
  convert_to_grpc(input.ACCurrent, output->mutable_ac_current());
  convert_to_grpc(input.Z, output->mutable_z());
  output->set_z_magnitude(input.ZMagnitude);
  output->set_z_phase(input.ZPhase);
  convert_to_grpc(input.Y, output->mutable_y());
  output->set_y_magnitude(input.YMagnitude);
  output->set_y_phase(input.YPhase);
  output->set_ls(input.Ls);
  output->set_cs(input.Cs);
  output->set_rs(input.Rs);
  output->set_lp(input.Lp);
  output->set_cp(input.Cp);
  output->set_rp(input.Rp);
  output->set_d(input.D);
  output->set_q(input.Q);
  output->set_measurement_mode(input.measurementMode);
  output->set_dc_in_compliance(input.dcInCompliance);
  output->set_ac_in_compliance(input.acInCompliance);
  output->set_unbalanced(input.unbalanced);
}

} // converters
} // nidevice_grpc

