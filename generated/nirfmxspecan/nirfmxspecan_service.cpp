
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-RFMXSPECAN Metadata
//---------------------------------------------------------------------
#include "nirfmxspecan_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/nirfmx_errors.h"
#include <server/converters.h>

namespace nirfmxspecan_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiRFmxSpecAnService::NiRFmxSpecAnService(
      LibrarySharedPtr library,
      ResourceRepositorySharedPtr resource_repository,
      ViSessionResourceRepositorySharedPtr vi_session_resource_repository,
      const NiRFmxSpecAnFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      vi_session_resource_repository_(vi_session_resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiRFmxSpecAnService::~NiRFmxSpecAnService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgAveraging(::grpc::ServerContext* context, const ACPCfgAveragingRequest* request, ACPCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      int32 averaging_type;
      switch (request->averaging_type_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgAveragingRequest::AveragingTypeEnumCase::kAveragingType: {
          averaging_type = static_cast<int32>(request->averaging_type());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgAveragingRequest::AveragingTypeEnumCase::kAveragingTypeRaw: {
          averaging_type = static_cast<int32>(request->averaging_type_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgAveragingRequest::AveragingTypeEnumCase::AVERAGING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->ACPCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count, averaging_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgCarrierAndOffsets(::grpc::ServerContext* context, const ACPCfgCarrierAndOffsetsRequest* request, ACPCfgCarrierAndOffsetsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 integration_bandwidth = request->integration_bandwidth();
      int32 number_of_offsets = request->number_of_offsets();
      float64 channel_spacing = request->channel_spacing();
      auto status = library_->ACPCfgCarrierAndOffsets(instrument, selector_string, integration_bandwidth, number_of_offsets, channel_spacing);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgCarrierFrequency(::grpc::ServerContext* context, const ACPCfgCarrierFrequencyRequest* request, ACPCfgCarrierFrequencyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 carrier_frequency = request->carrier_frequency();
      auto status = library_->ACPCfgCarrierFrequency(instrument, selector_string, carrier_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgCarrierIntegrationBandwidth(::grpc::ServerContext* context, const ACPCfgCarrierIntegrationBandwidthRequest* request, ACPCfgCarrierIntegrationBandwidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 integration_bandwidth = request->integration_bandwidth();
      auto status = library_->ACPCfgCarrierIntegrationBandwidth(instrument, selector_string, integration_bandwidth);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgCarrierMode(::grpc::ServerContext* context, const ACPCfgCarrierModeRequest* request, ACPCfgCarrierModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 carrier_mode;
      switch (request->carrier_mode_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgCarrierModeRequest::CarrierModeEnumCase::kCarrierMode: {
          carrier_mode = static_cast<int32>(request->carrier_mode());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgCarrierModeRequest::CarrierModeEnumCase::kCarrierModeRaw: {
          carrier_mode = static_cast<int32>(request->carrier_mode_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgCarrierModeRequest::CarrierModeEnumCase::CARRIER_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for carrier_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->ACPCfgCarrierMode(instrument, selector_string, carrier_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgCarrierRRCFilter(::grpc::ServerContext* context, const ACPCfgCarrierRRCFilterRequest* request, ACPCfgCarrierRRCFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rrc_filter_enabled;
      switch (request->rrc_filter_enabled_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgCarrierRRCFilterRequest::RrcFilterEnabledEnumCase::kRrcFilterEnabled: {
          rrc_filter_enabled = static_cast<int32>(request->rrc_filter_enabled());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgCarrierRRCFilterRequest::RrcFilterEnabledEnumCase::kRrcFilterEnabledRaw: {
          rrc_filter_enabled = static_cast<int32>(request->rrc_filter_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgCarrierRRCFilterRequest::RrcFilterEnabledEnumCase::RRC_FILTER_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rrc_filter_enabled was not specified or out of range");
          break;
        }
      }

      float64 rrc_alpha = request->rrc_alpha();
      auto status = library_->ACPCfgCarrierRRCFilter(instrument, selector_string, rrc_filter_enabled, rrc_alpha);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgDetector(::grpc::ServerContext* context, const ACPCfgDetectorRequest* request, ACPCfgDetectorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 detector_type;
      switch (request->detector_type_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgDetectorRequest::DetectorTypeEnumCase::kDetectorType: {
          detector_type = static_cast<int32>(request->detector_type());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgDetectorRequest::DetectorTypeEnumCase::kDetectorTypeRaw: {
          detector_type = static_cast<int32>(request->detector_type_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgDetectorRequest::DetectorTypeEnumCase::DETECTOR_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for detector_type was not specified or out of range");
          break;
        }
      }

      int32 detector_points = request->detector_points();
      auto status = library_->ACPCfgDetector(instrument, selector_string, detector_type, detector_points);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgFFT(::grpc::ServerContext* context, const ACPCfgFFTRequest* request, ACPCfgFFTResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 fft_window;
      switch (request->fft_window_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgFFTRequest::FftWindowEnumCase::kFftWindow: {
          fft_window = static_cast<int32>(request->fft_window());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgFFTRequest::FftWindowEnumCase::kFftWindowRaw: {
          fft_window = static_cast<int32>(request->fft_window_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgFFTRequest::FftWindowEnumCase::FFT_WINDOW_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fft_window was not specified or out of range");
          break;
        }
      }

      float64 fft_padding = request->fft_padding();
      auto status = library_->ACPCfgFFT(instrument, selector_string, fft_window, fft_padding);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgMeasurementMethod(::grpc::ServerContext* context, const ACPCfgMeasurementMethodRequest* request, ACPCfgMeasurementMethodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 measurement_method;
      switch (request->measurement_method_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgMeasurementMethodRequest::MeasurementMethodEnumCase::kMeasurementMethod: {
          measurement_method = static_cast<int32>(request->measurement_method());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgMeasurementMethodRequest::MeasurementMethodEnumCase::kMeasurementMethodRaw: {
          measurement_method = static_cast<int32>(request->measurement_method_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgMeasurementMethodRequest::MeasurementMethodEnumCase::MEASUREMENT_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurement_method was not specified or out of range");
          break;
        }
      }

      auto status = library_->ACPCfgMeasurementMethod(instrument, selector_string, measurement_method);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgNoiseCompensationEnabled(::grpc::ServerContext* context, const ACPCfgNoiseCompensationEnabledRequest* request, ACPCfgNoiseCompensationEnabledResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 noise_compensation_enabled;
      switch (request->noise_compensation_enabled_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgNoiseCompensationEnabledRequest::NoiseCompensationEnabledEnumCase::kNoiseCompensationEnabled: {
          noise_compensation_enabled = static_cast<int32>(request->noise_compensation_enabled());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgNoiseCompensationEnabledRequest::NoiseCompensationEnabledEnumCase::kNoiseCompensationEnabledRaw: {
          noise_compensation_enabled = static_cast<int32>(request->noise_compensation_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgNoiseCompensationEnabledRequest::NoiseCompensationEnabledEnumCase::NOISE_COMPENSATION_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for noise_compensation_enabled was not specified or out of range");
          break;
        }
      }

      auto status = library_->ACPCfgNoiseCompensationEnabled(instrument, selector_string, noise_compensation_enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgNumberOfCarriers(::grpc::ServerContext* context, const ACPCfgNumberOfCarriersRequest* request, ACPCfgNumberOfCarriersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_carriers = request->number_of_carriers();
      auto status = library_->ACPCfgNumberOfCarriers(instrument, selector_string, number_of_carriers);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgNumberOfOffsets(::grpc::ServerContext* context, const ACPCfgNumberOfOffsetsRequest* request, ACPCfgNumberOfOffsetsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_offsets = request->number_of_offsets();
      auto status = library_->ACPCfgNumberOfOffsets(instrument, selector_string, number_of_offsets);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffset(::grpc::ServerContext* context, const ACPCfgOffsetRequest* request, ACPCfgOffsetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 offset_frequency = request->offset_frequency();
      int32 offset_sideband;
      switch (request->offset_sideband_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgOffsetRequest::OffsetSidebandEnumCase::kOffsetSideband: {
          offset_sideband = static_cast<int32>(request->offset_sideband());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgOffsetRequest::OffsetSidebandEnumCase::kOffsetSidebandRaw: {
          offset_sideband = static_cast<int32>(request->offset_sideband_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgOffsetRequest::OffsetSidebandEnumCase::OFFSET_SIDEBAND_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for offset_sideband was not specified or out of range");
          break;
        }
      }

      int32 offset_enabled;
      switch (request->offset_enabled_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgOffsetRequest::OffsetEnabledEnumCase::kOffsetEnabled: {
          offset_enabled = static_cast<int32>(request->offset_enabled());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgOffsetRequest::OffsetEnabledEnumCase::kOffsetEnabledRaw: {
          offset_enabled = static_cast<int32>(request->offset_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgOffsetRequest::OffsetEnabledEnumCase::OFFSET_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for offset_enabled was not specified or out of range");
          break;
        }
      }

      auto status = library_->ACPCfgOffset(instrument, selector_string, offset_frequency, offset_sideband, offset_enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffsetArray(::grpc::ServerContext* context, const ACPCfgOffsetArrayRequest* request, ACPCfgOffsetArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto offset_frequency = const_cast<float64*>(request->offset_frequency().data());
      auto offset_sideband_vector = std::vector<int32>();
      offset_sideband_vector.reserve(request->offset_sideband().size());
      std::transform(
        request->offset_sideband().begin(),
        request->offset_sideband().end(),
        std::back_inserter(offset_sideband_vector),
        [](auto x) { return x; });
      auto offset_sideband = offset_sideband_vector.data();

      auto offset_enabled_vector = std::vector<int32>();
      offset_enabled_vector.reserve(request->offset_enabled().size());
      std::transform(
        request->offset_enabled().begin(),
        request->offset_enabled().end(),
        std::back_inserter(offset_enabled_vector),
        [](auto x) { return x; });
      auto offset_enabled = offset_enabled_vector.data();

      auto number_of_elements_determine_from_sizes = std::array<int, 3>
      {
        request->offset_frequency_size(),
        request->offset_sideband_size(),
        request->offset_enabled_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [offset_frequency, offset_sideband, offset_enabled] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        offset_frequency = request->offset_frequency_size() ? std::move(offset_frequency) : nullptr;
        offset_sideband = request->offset_sideband_size() ? std::move(offset_sideband) : nullptr;
        offset_enabled = request->offset_enabled_size() ? std::move(offset_enabled) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->ACPCfgOffsetArray(instrument, selector_string, offset_frequency, offset_sideband, offset_enabled, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffsetFrequencyDefinition(::grpc::ServerContext* context, const ACPCfgOffsetFrequencyDefinitionRequest* request, ACPCfgOffsetFrequencyDefinitionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 offset_frequency_definition;
      switch (request->offset_frequency_definition_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgOffsetFrequencyDefinitionRequest::OffsetFrequencyDefinitionEnumCase::kOffsetFrequencyDefinition: {
          offset_frequency_definition = static_cast<int32>(request->offset_frequency_definition());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgOffsetFrequencyDefinitionRequest::OffsetFrequencyDefinitionEnumCase::kOffsetFrequencyDefinitionRaw: {
          offset_frequency_definition = static_cast<int32>(request->offset_frequency_definition_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgOffsetFrequencyDefinitionRequest::OffsetFrequencyDefinitionEnumCase::OFFSET_FREQUENCY_DEFINITION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for offset_frequency_definition was not specified or out of range");
          break;
        }
      }

      auto status = library_->ACPCfgOffsetFrequencyDefinition(instrument, selector_string, offset_frequency_definition);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffsetIntegrationBandwidth(::grpc::ServerContext* context, const ACPCfgOffsetIntegrationBandwidthRequest* request, ACPCfgOffsetIntegrationBandwidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 integration_bandwidth = request->integration_bandwidth();
      auto status = library_->ACPCfgOffsetIntegrationBandwidth(instrument, selector_string, integration_bandwidth);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffsetIntegrationBandwidthArray(::grpc::ServerContext* context, const ACPCfgOffsetIntegrationBandwidthArrayRequest* request, ACPCfgOffsetIntegrationBandwidthArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto integration_bandwidth = const_cast<float64*>(request->integration_bandwidth().data());
      int32 number_of_elements = static_cast<int32>(request->integration_bandwidth().size());
      auto status = library_->ACPCfgOffsetIntegrationBandwidthArray(instrument, selector_string, integration_bandwidth, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffsetPowerReference(::grpc::ServerContext* context, const ACPCfgOffsetPowerReferenceRequest* request, ACPCfgOffsetPowerReferenceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 offset_reference_carrier;
      switch (request->offset_reference_carrier_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgOffsetPowerReferenceRequest::OffsetReferenceCarrierEnumCase::kOffsetReferenceCarrier: {
          offset_reference_carrier = static_cast<int32>(request->offset_reference_carrier());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgOffsetPowerReferenceRequest::OffsetReferenceCarrierEnumCase::kOffsetReferenceCarrierRaw: {
          offset_reference_carrier = static_cast<int32>(request->offset_reference_carrier_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgOffsetPowerReferenceRequest::OffsetReferenceCarrierEnumCase::OFFSET_REFERENCE_CARRIER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for offset_reference_carrier was not specified or out of range");
          break;
        }
      }

      int32 offset_reference_specific = request->offset_reference_specific();
      auto status = library_->ACPCfgOffsetPowerReference(instrument, selector_string, offset_reference_carrier, offset_reference_specific);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffsetPowerReferenceArray(::grpc::ServerContext* context, const ACPCfgOffsetPowerReferenceArrayRequest* request, ACPCfgOffsetPowerReferenceArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto offset_power_reference_carrier_vector = std::vector<int32>();
      offset_power_reference_carrier_vector.reserve(request->offset_power_reference_carrier().size());
      std::transform(
        request->offset_power_reference_carrier().begin(),
        request->offset_power_reference_carrier().end(),
        std::back_inserter(offset_power_reference_carrier_vector),
        [](auto x) { return x; });
      auto offset_power_reference_carrier = offset_power_reference_carrier_vector.data();

      auto offset_power_reference_specific = const_cast<int32*>(reinterpret_cast<const int32*>(request->offset_power_reference_specific().data()));
      auto number_of_elements_determine_from_sizes = std::array<int, 2>
      {
        request->offset_power_reference_carrier_size(),
        request->offset_power_reference_specific_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [offset_power_reference_carrier, offset_power_reference_specific] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        offset_power_reference_carrier = request->offset_power_reference_carrier_size() ? std::move(offset_power_reference_carrier) : nullptr;
        offset_power_reference_specific = request->offset_power_reference_specific_size() ? std::move(offset_power_reference_specific) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->ACPCfgOffsetPowerReferenceArray(instrument, selector_string, offset_power_reference_carrier, offset_power_reference_specific, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffsetRRCFilter(::grpc::ServerContext* context, const ACPCfgOffsetRRCFilterRequest* request, ACPCfgOffsetRRCFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rrc_filter_enabled;
      switch (request->rrc_filter_enabled_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgOffsetRRCFilterRequest::RrcFilterEnabledEnumCase::kRrcFilterEnabled: {
          rrc_filter_enabled = static_cast<int32>(request->rrc_filter_enabled());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgOffsetRRCFilterRequest::RrcFilterEnabledEnumCase::kRrcFilterEnabledRaw: {
          rrc_filter_enabled = static_cast<int32>(request->rrc_filter_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgOffsetRRCFilterRequest::RrcFilterEnabledEnumCase::RRC_FILTER_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rrc_filter_enabled was not specified or out of range");
          break;
        }
      }

      float64 rrc_alpha = request->rrc_alpha();
      auto status = library_->ACPCfgOffsetRRCFilter(instrument, selector_string, rrc_filter_enabled, rrc_alpha);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffsetRRCFilterArray(::grpc::ServerContext* context, const ACPCfgOffsetRRCFilterArrayRequest* request, ACPCfgOffsetRRCFilterArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto rrc_filter_enabled_vector = std::vector<int32>();
      rrc_filter_enabled_vector.reserve(request->rrc_filter_enabled().size());
      std::transform(
        request->rrc_filter_enabled().begin(),
        request->rrc_filter_enabled().end(),
        std::back_inserter(rrc_filter_enabled_vector),
        [](auto x) { return x; });
      auto rrc_filter_enabled = rrc_filter_enabled_vector.data();

      auto rrc_alpha = const_cast<float64*>(request->rrc_alpha().data());
      auto number_of_elements_determine_from_sizes = std::array<int, 2>
      {
        request->rrc_filter_enabled_size(),
        request->rrc_alpha_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [rrc_filter_enabled, rrc_alpha] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        rrc_filter_enabled = request->rrc_filter_enabled_size() ? std::move(rrc_filter_enabled) : nullptr;
        rrc_alpha = request->rrc_alpha_size() ? std::move(rrc_alpha) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->ACPCfgOffsetRRCFilterArray(instrument, selector_string, rrc_filter_enabled, rrc_alpha, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffsetRelativeAttenuation(::grpc::ServerContext* context, const ACPCfgOffsetRelativeAttenuationRequest* request, ACPCfgOffsetRelativeAttenuationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 relative_attenuation = request->relative_attenuation();
      auto status = library_->ACPCfgOffsetRelativeAttenuation(instrument, selector_string, relative_attenuation);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgOffsetRelativeAttenuationArray(::grpc::ServerContext* context, const ACPCfgOffsetRelativeAttenuationArrayRequest* request, ACPCfgOffsetRelativeAttenuationArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto relative_attenuation = const_cast<float64*>(request->relative_attenuation().data());
      int32 number_of_elements = static_cast<int32>(request->relative_attenuation().size());
      auto status = library_->ACPCfgOffsetRelativeAttenuationArray(instrument, selector_string, relative_attenuation, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgPowerUnits(::grpc::ServerContext* context, const ACPCfgPowerUnitsRequest* request, ACPCfgPowerUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 power_units;
      switch (request->power_units_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgPowerUnitsRequest::PowerUnitsEnumCase::kPowerUnits: {
          power_units = static_cast<int32>(request->power_units());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgPowerUnitsRequest::PowerUnitsEnumCase::kPowerUnitsRaw: {
          power_units = static_cast<int32>(request->power_units_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgPowerUnitsRequest::PowerUnitsEnumCase::POWER_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for power_units was not specified or out of range");
          break;
        }
      }

      auto status = library_->ACPCfgPowerUnits(instrument, selector_string, power_units);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgRBWFilter(::grpc::ServerContext* context, const ACPCfgRBWFilterRequest* request, ACPCfgRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rbw_auto;
      switch (request->rbw_auto_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgRBWFilterRequest::RbwAutoEnumCase::kRbwAuto: {
          rbw_auto = static_cast<int32>(request->rbw_auto());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgRBWFilterRequest::RbwAutoEnumCase::kRbwAutoRaw: {
          rbw_auto = static_cast<int32>(request->rbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgRBWFilterRequest::RbwAutoEnumCase::RBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_auto was not specified or out of range");
          break;
        }
      }

      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->ACPCfgRBWFilter(instrument, selector_string, rbw_auto, rbw, rbw_filter_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPCfgSweepTime(::grpc::ServerContext* context, const ACPCfgSweepTimeRequest* request, ACPCfgSweepTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 sweep_time_auto;
      switch (request->sweep_time_auto_enum_case()) {
        case nirfmxspecan_grpc::ACPCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAuto: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAutoRaw: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::ACPCfgSweepTimeRequest::SweepTimeAutoEnumCase::SWEEP_TIME_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sweep_time_auto was not specified or out of range");
          break;
        }
      }

      float64 sweep_time_interval = request->sweep_time_interval();
      auto status = library_->ACPCfgSweepTime(instrument, selector_string, sweep_time_auto, sweep_time_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPFetchAbsolutePowersTrace(::grpc::ServerContext* context, const ACPFetchAbsolutePowersTraceRequest* request, ACPFetchAbsolutePowersTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 trace_index = request->trace_index();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ACPFetchAbsolutePowersTrace(instrument, selector_string, timeout, trace_index, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_absolute_powers_trace()->Resize(actual_array_size, 0);
        float32* absolute_powers_trace = response->mutable_absolute_powers_trace()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ACPFetchAbsolutePowersTrace(instrument, selector_string, timeout, trace_index, &x0, &dx, absolute_powers_trace, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_absolute_powers_trace()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPFetchCarrierMeasurement(::grpc::ServerContext* context, const ACPFetchCarrierMeasurementRequest* request, ACPFetchCarrierMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 absolute_power {};
      float64 total_relative_power {};
      float64 carrier_offset {};
      float64 integration_bandwidth {};
      auto status = library_->ACPFetchCarrierMeasurement(instrument, selector_string, timeout, &absolute_power, &total_relative_power, &carrier_offset, &integration_bandwidth);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_absolute_power(absolute_power);
      response->set_total_relative_power(total_relative_power);
      response->set_carrier_offset(carrier_offset);
      response->set_integration_bandwidth(integration_bandwidth);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPFetchFrequencyResolution(::grpc::ServerContext* context, const ACPFetchFrequencyResolutionRequest* request, ACPFetchFrequencyResolutionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 frequency_resolution {};
      auto status = library_->ACPFetchFrequencyResolution(instrument, selector_string, timeout, &frequency_resolution);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_frequency_resolution(frequency_resolution);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPFetchOffsetMeasurement(::grpc::ServerContext* context, const ACPFetchOffsetMeasurementRequest* request, ACPFetchOffsetMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 lower_relative_power {};
      float64 upper_relative_power {};
      float64 lower_absolute_power {};
      float64 upper_absolute_power {};
      auto status = library_->ACPFetchOffsetMeasurement(instrument, selector_string, timeout, &lower_relative_power, &upper_relative_power, &lower_absolute_power, &upper_absolute_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_lower_relative_power(lower_relative_power);
      response->set_upper_relative_power(upper_relative_power);
      response->set_lower_absolute_power(lower_absolute_power);
      response->set_upper_absolute_power(upper_absolute_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPFetchOffsetMeasurementArray(::grpc::ServerContext* context, const ACPFetchOffsetMeasurementArrayRequest* request, ACPFetchOffsetMeasurementArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ACPFetchOffsetMeasurementArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_lower_relative_power()->Resize(actual_array_size, 0);
        float64* lower_relative_power = response->mutable_lower_relative_power()->mutable_data();
        response->mutable_upper_relative_power()->Resize(actual_array_size, 0);
        float64* upper_relative_power = response->mutable_upper_relative_power()->mutable_data();
        response->mutable_lower_absolute_power()->Resize(actual_array_size, 0);
        float64* lower_absolute_power = response->mutable_lower_absolute_power()->mutable_data();
        response->mutable_upper_absolute_power()->Resize(actual_array_size, 0);
        float64* upper_absolute_power = response->mutable_upper_absolute_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ACPFetchOffsetMeasurementArray(instrument, selector_string, timeout, lower_relative_power, upper_relative_power, lower_absolute_power, upper_absolute_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_lower_relative_power()->Resize(actual_array_size, 0);
        response->mutable_upper_relative_power()->Resize(actual_array_size, 0);
        response->mutable_lower_absolute_power()->Resize(actual_array_size, 0);
        response->mutable_upper_absolute_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPFetchRelativePowersTrace(::grpc::ServerContext* context, const ACPFetchRelativePowersTraceRequest* request, ACPFetchRelativePowersTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 trace_index = request->trace_index();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ACPFetchRelativePowersTrace(instrument, selector_string, timeout, trace_index, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_relative_powers_trace()->Resize(actual_array_size, 0);
        float32* relative_powers_trace = response->mutable_relative_powers_trace()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ACPFetchRelativePowersTrace(instrument, selector_string, timeout, trace_index, &x0, &dx, relative_powers_trace, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_relative_powers_trace()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPFetchSpectrum(::grpc::ServerContext* context, const ACPFetchSpectrumRequest* request, ACPFetchSpectrumResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->ACPFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        float32* spectrum = response->mutable_spectrum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->ACPFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, spectrum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPFetchTotalCarrierPower(::grpc::ServerContext* context, const ACPFetchTotalCarrierPowerRequest* request, ACPFetchTotalCarrierPowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 total_carrier_power {};
      auto status = library_->ACPFetchTotalCarrierPower(instrument, selector_string, timeout, &total_carrier_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_total_carrier_power(total_carrier_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPRead(::grpc::ServerContext* context, const ACPReadRequest* request, ACPReadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 carrier_absolute_power {};
      float64 offset_ch0_lower_relative_power {};
      float64 offset_ch0_upper_relative_power {};
      float64 offset_ch1_lower_relative_power {};
      float64 offset_ch1_upper_relative_power {};
      auto status = library_->ACPRead(instrument, selector_string, timeout, &carrier_absolute_power, &offset_ch0_lower_relative_power, &offset_ch0_upper_relative_power, &offset_ch1_lower_relative_power, &offset_ch1_upper_relative_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_carrier_absolute_power(carrier_absolute_power);
      response->set_offset_ch0_lower_relative_power(offset_ch0_lower_relative_power);
      response->set_offset_ch0_upper_relative_power(offset_ch0_upper_relative_power);
      response->set_offset_ch1_lower_relative_power(offset_ch1_lower_relative_power);
      response->set_offset_ch1_upper_relative_power(offset_ch1_upper_relative_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ACPValidateNoiseCalibrationData(::grpc::ServerContext* context, const ACPValidateNoiseCalibrationDataRequest* request, ACPValidateNoiseCalibrationDataResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 noise_calibration_data_valid {};
      auto status = library_->ACPValidateNoiseCalibrationData(instrument, selector_string, &noise_calibration_data_valid);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_noise_calibration_data_valid(static_cast<nirfmxspecan_grpc::AcpNoiseCalibrationDataValid>(noise_calibration_data_valid));
      response->set_noise_calibration_data_valid_raw(noise_calibration_data_valid);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgAMToAMCurveFit(::grpc::ServerContext* context, const AMPMCfgAMToAMCurveFitRequest* request, AMPMCfgAMToAMCurveFitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 am_to_am_curve_fit_order = request->am_to_am_curve_fit_order();
      int32 am_to_am_curve_fit_type;
      switch (request->am_to_am_curve_fit_type_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgAMToAMCurveFitRequest::AmToAmCurveFitTypeEnumCase::kAmToAmCurveFitType: {
          am_to_am_curve_fit_type = static_cast<int32>(request->am_to_am_curve_fit_type());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgAMToAMCurveFitRequest::AmToAmCurveFitTypeEnumCase::kAmToAmCurveFitTypeRaw: {
          am_to_am_curve_fit_type = static_cast<int32>(request->am_to_am_curve_fit_type_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgAMToAMCurveFitRequest::AmToAmCurveFitTypeEnumCase::AM_TO_AM_CURVE_FIT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for am_to_am_curve_fit_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->AMPMCfgAMToAMCurveFit(instrument, selector_string, am_to_am_curve_fit_order, am_to_am_curve_fit_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgAMToPMCurveFit(::grpc::ServerContext* context, const AMPMCfgAMToPMCurveFitRequest* request, AMPMCfgAMToPMCurveFitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 am_to_pm_curve_fit_order = request->am_to_pm_curve_fit_order();
      int32 am_to_pm_curve_fit_type;
      switch (request->am_to_pm_curve_fit_type_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgAMToPMCurveFitRequest::AmToPmCurveFitTypeEnumCase::kAmToPmCurveFitType: {
          am_to_pm_curve_fit_type = static_cast<int32>(request->am_to_pm_curve_fit_type());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgAMToPMCurveFitRequest::AmToPmCurveFitTypeEnumCase::kAmToPmCurveFitTypeRaw: {
          am_to_pm_curve_fit_type = static_cast<int32>(request->am_to_pm_curve_fit_type_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgAMToPMCurveFitRequest::AmToPmCurveFitTypeEnumCase::AM_TO_PM_CURVE_FIT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for am_to_pm_curve_fit_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->AMPMCfgAMToPMCurveFit(instrument, selector_string, am_to_pm_curve_fit_order, am_to_pm_curve_fit_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgAveraging(::grpc::ServerContext* context, const AMPMCfgAveragingRequest* request, AMPMCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      auto status = library_->AMPMCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgCompressionPoints(::grpc::ServerContext* context, const AMPMCfgCompressionPointsRequest* request, AMPMCfgCompressionPointsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 compression_point_enabled;
      switch (request->compression_point_enabled_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgCompressionPointsRequest::CompressionPointEnabledEnumCase::kCompressionPointEnabled: {
          compression_point_enabled = static_cast<int32>(request->compression_point_enabled());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgCompressionPointsRequest::CompressionPointEnabledEnumCase::kCompressionPointEnabledRaw: {
          compression_point_enabled = static_cast<int32>(request->compression_point_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgCompressionPointsRequest::CompressionPointEnabledEnumCase::COMPRESSION_POINT_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for compression_point_enabled was not specified or out of range");
          break;
        }
      }

      auto compression_level = const_cast<float64*>(request->compression_level().data());
      int32 array_size = static_cast<int32>(request->compression_level().size());
      auto status = library_->AMPMCfgCompressionPoints(instrument, selector_string, compression_point_enabled, compression_level, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgDUTAverageInputPower(::grpc::ServerContext* context, const AMPMCfgDUTAverageInputPowerRequest* request, AMPMCfgDUTAverageInputPowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 dut_average_input_power = request->dut_average_input_power();
      auto status = library_->AMPMCfgDUTAverageInputPower(instrument, selector_string, dut_average_input_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgMeasurementInterval(::grpc::ServerContext* context, const AMPMCfgMeasurementIntervalRequest* request, AMPMCfgMeasurementIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 measurement_interval = request->measurement_interval();
      auto status = library_->AMPMCfgMeasurementInterval(instrument, selector_string, measurement_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgMeasurementSampleRate(::grpc::ServerContext* context, const AMPMCfgMeasurementSampleRateRequest* request, AMPMCfgMeasurementSampleRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 sample_rate_mode;
      switch (request->sample_rate_mode_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgMeasurementSampleRateRequest::SampleRateModeEnumCase::kSampleRateMode: {
          sample_rate_mode = static_cast<int32>(request->sample_rate_mode());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgMeasurementSampleRateRequest::SampleRateModeEnumCase::kSampleRateModeRaw: {
          sample_rate_mode = static_cast<int32>(request->sample_rate_mode_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgMeasurementSampleRateRequest::SampleRateModeEnumCase::SAMPLE_RATE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_rate_mode was not specified or out of range");
          break;
        }
      }

      float64 sample_rate = request->sample_rate();
      auto status = library_->AMPMCfgMeasurementSampleRate(instrument, selector_string, sample_rate_mode, sample_rate);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgReferencePowerType(::grpc::ServerContext* context, const AMPMCfgReferencePowerTypeRequest* request, AMPMCfgReferencePowerTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 reference_power_type;
      switch (request->reference_power_type_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgReferencePowerTypeRequest::ReferencePowerTypeEnumCase::kReferencePowerType: {
          reference_power_type = static_cast<int32>(request->reference_power_type());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgReferencePowerTypeRequest::ReferencePowerTypeEnumCase::kReferencePowerTypeRaw: {
          reference_power_type = static_cast<int32>(request->reference_power_type_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgReferencePowerTypeRequest::ReferencePowerTypeEnumCase::REFERENCE_POWER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for reference_power_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->AMPMCfgReferencePowerType(instrument, selector_string, reference_power_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgReferenceWaveform(::grpc::ServerContext* context, const AMPMCfgReferenceWaveformRequest* request, AMPMCfgReferenceWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 x0 = request->x0();
      float64 dx = request->dx();
      auto reference_waveform = convert_from_grpc<NIComplexSingle>(request->reference_waveform());
      int32 array_size = static_cast<int32>(request->reference_waveform().size());
      int32 idle_duration_present;
      switch (request->idle_duration_present_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgReferenceWaveformRequest::IdleDurationPresentEnumCase::kIdleDurationPresent: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgReferenceWaveformRequest::IdleDurationPresentEnumCase::kIdleDurationPresentRaw: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgReferenceWaveformRequest::IdleDurationPresentEnumCase::IDLE_DURATION_PRESENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_duration_present was not specified or out of range");
          break;
        }
      }

      int32 signal_type;
      switch (request->signal_type_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgReferenceWaveformRequest::SignalTypeEnumCase::kSignalType: {
          signal_type = static_cast<int32>(request->signal_type());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgReferenceWaveformRequest::SignalTypeEnumCase::kSignalTypeRaw: {
          signal_type = static_cast<int32>(request->signal_type_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgReferenceWaveformRequest::SignalTypeEnumCase::SIGNAL_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->AMPMCfgReferenceWaveform(instrument, selector_string, x0, dx, reference_waveform.data(), array_size, idle_duration_present, signal_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgSynchronizationMethod(::grpc::ServerContext* context, const AMPMCfgSynchronizationMethodRequest* request, AMPMCfgSynchronizationMethodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 synchronization_method;
      switch (request->synchronization_method_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgSynchronizationMethodRequest::SynchronizationMethodEnumCase::kSynchronizationMethod: {
          synchronization_method = static_cast<int32>(request->synchronization_method());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgSynchronizationMethodRequest::SynchronizationMethodEnumCase::kSynchronizationMethodRaw: {
          synchronization_method = static_cast<int32>(request->synchronization_method_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgSynchronizationMethodRequest::SynchronizationMethodEnumCase::SYNCHRONIZATION_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for synchronization_method was not specified or out of range");
          break;
        }
      }

      auto status = library_->AMPMCfgSynchronizationMethod(instrument, selector_string, synchronization_method);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMCfgThreshold(::grpc::ServerContext* context, const AMPMCfgThresholdRequest* request, AMPMCfgThresholdResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 threshold_enabled;
      switch (request->threshold_enabled_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabled: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabledRaw: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgThresholdRequest::ThresholdEnabledEnumCase::THRESHOLD_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_enabled was not specified or out of range");
          break;
        }
      }

      float64 threshold_level = request->threshold_level();
      int32 threshold_type;
      switch (request->threshold_type_enum_case()) {
        case nirfmxspecan_grpc::AMPMCfgThresholdRequest::ThresholdTypeEnumCase::kThresholdType: {
          threshold_type = static_cast<int32>(request->threshold_type());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgThresholdRequest::ThresholdTypeEnumCase::kThresholdTypeRaw: {
          threshold_type = static_cast<int32>(request->threshold_type_raw());
          break;
        }
        case nirfmxspecan_grpc::AMPMCfgThresholdRequest::ThresholdTypeEnumCase::THRESHOLD_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->AMPMCfgThreshold(instrument, selector_string, threshold_enabled, threshold_level, threshold_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchAMToAMTrace(::grpc::ServerContext* context, const AMPMFetchAMToAMTraceRequest* request, AMPMFetchAMToAMTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->AMPMFetchAMToAMTrace(instrument, selector_string, timeout, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_reference_powers()->Resize(actual_array_size, 0);
        float32* reference_powers = response->mutable_reference_powers()->mutable_data();
        response->mutable_measured_am_to_am()->Resize(actual_array_size, 0);
        float32* measured_am_to_am = response->mutable_measured_am_to_am()->mutable_data();
        response->mutable_curve_fit_am_to_am()->Resize(actual_array_size, 0);
        float32* curve_fit_am_to_am = response->mutable_curve_fit_am_to_am()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->AMPMFetchAMToAMTrace(instrument, selector_string, timeout, reference_powers, measured_am_to_am, curve_fit_am_to_am, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_reference_powers()->Resize(actual_array_size, 0);
        response->mutable_measured_am_to_am()->Resize(actual_array_size, 0);
        response->mutable_curve_fit_am_to_am()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchAMToPMTrace(::grpc::ServerContext* context, const AMPMFetchAMToPMTraceRequest* request, AMPMFetchAMToPMTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->AMPMFetchAMToPMTrace(instrument, selector_string, timeout, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_reference_powers()->Resize(actual_array_size, 0);
        float32* reference_powers = response->mutable_reference_powers()->mutable_data();
        response->mutable_measured_am_to_pm()->Resize(actual_array_size, 0);
        float32* measured_am_to_pm = response->mutable_measured_am_to_pm()->mutable_data();
        response->mutable_curve_fit_am_to_pm()->Resize(actual_array_size, 0);
        float32* curve_fit_am_to_pm = response->mutable_curve_fit_am_to_pm()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->AMPMFetchAMToPMTrace(instrument, selector_string, timeout, reference_powers, measured_am_to_pm, curve_fit_am_to_pm, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_reference_powers()->Resize(actual_array_size, 0);
        response->mutable_measured_am_to_pm()->Resize(actual_array_size, 0);
        response->mutable_curve_fit_am_to_pm()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchCompressionPoints(::grpc::ServerContext* context, const AMPMFetchCompressionPointsRequest* request, AMPMFetchCompressionPointsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->AMPMFetchCompressionPoints(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_input_compression_point()->Resize(actual_array_size, 0);
        float64* input_compression_point = response->mutable_input_compression_point()->mutable_data();
        response->mutable_output_compression_point()->Resize(actual_array_size, 0);
        float64* output_compression_point = response->mutable_output_compression_point()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->AMPMFetchCompressionPoints(instrument, selector_string, timeout, input_compression_point, output_compression_point, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_input_compression_point()->Resize(actual_array_size, 0);
        response->mutable_output_compression_point()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchCurveFitCoefficients(::grpc::ServerContext* context, const AMPMFetchCurveFitCoefficientsRequest* request, AMPMFetchCurveFitCoefficientsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->AMPMFetchCurveFitCoefficients(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_am_to_am_coefficients()->Resize(actual_array_size, 0);
        float32* am_to_am_coefficients = response->mutable_am_to_am_coefficients()->mutable_data();
        response->mutable_am_to_pm_coefficients()->Resize(actual_array_size, 0);
        float32* am_to_pm_coefficients = response->mutable_am_to_pm_coefficients()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->AMPMFetchCurveFitCoefficients(instrument, selector_string, timeout, am_to_am_coefficients, am_to_pm_coefficients, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_am_to_am_coefficients()->Resize(actual_array_size, 0);
        response->mutable_am_to_pm_coefficients()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchCurveFitResidual(::grpc::ServerContext* context, const AMPMFetchCurveFitResidualRequest* request, AMPMFetchCurveFitResidualResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 am_to_am_residual {};
      float64 am_to_pm_residual {};
      auto status = library_->AMPMFetchCurveFitResidual(instrument, selector_string, timeout, &am_to_am_residual, &am_to_pm_residual);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_am_to_am_residual(am_to_am_residual);
      response->set_am_to_pm_residual(am_to_pm_residual);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchDUTCharacteristics(::grpc::ServerContext* context, const AMPMFetchDUTCharacteristicsRequest* request, AMPMFetchDUTCharacteristicsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 mean_linear_gain {};
      float64 one_db_compression_point {};
      float64 mean_rms_evm {};
      auto status = library_->AMPMFetchDUTCharacteristics(instrument, selector_string, timeout, &mean_linear_gain, &one_db_compression_point, &mean_rms_evm);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_mean_linear_gain(mean_linear_gain);
      response->set_one_db_compression_point(one_db_compression_point);
      response->set_mean_rms_evm(mean_rms_evm);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchError(::grpc::ServerContext* context, const AMPMFetchErrorRequest* request, AMPMFetchErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 gain_error_range {};
      float64 phase_error_range {};
      float64 mean_phase_error {};
      auto status = library_->AMPMFetchError(instrument, selector_string, timeout, &gain_error_range, &phase_error_range, &mean_phase_error);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_gain_error_range(gain_error_range);
      response->set_phase_error_range(phase_error_range);
      response->set_mean_phase_error(mean_phase_error);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchProcessedMeanAcquiredWaveform(::grpc::ServerContext* context, const AMPMFetchProcessedMeanAcquiredWaveformRequest* request, AMPMFetchProcessedMeanAcquiredWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->AMPMFetchProcessedMeanAcquiredWaveform(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> processed_mean_acquired_waveform(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->AMPMFetchProcessedMeanAcquiredWaveform(instrument, selector_string, timeout, &x0, &dx, processed_mean_acquired_waveform.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        convert_to_grpc(processed_mean_acquired_waveform, response->mutable_processed_mean_acquired_waveform());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_processed_mean_acquired_waveform()->size();
          if (shrunk_size != current_size) {
            response->mutable_processed_mean_acquired_waveform()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchProcessedReferenceWaveform(::grpc::ServerContext* context, const AMPMFetchProcessedReferenceWaveformRequest* request, AMPMFetchProcessedReferenceWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->AMPMFetchProcessedReferenceWaveform(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> processed_reference_waveform(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->AMPMFetchProcessedReferenceWaveform(instrument, selector_string, timeout, &x0, &dx, processed_reference_waveform.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        convert_to_grpc(processed_reference_waveform, response->mutable_processed_reference_waveform());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_processed_reference_waveform()->size();
          if (shrunk_size != current_size) {
            response->mutable_processed_reference_waveform()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchRelativePhaseTrace(::grpc::ServerContext* context, const AMPMFetchRelativePhaseTraceRequest* request, AMPMFetchRelativePhaseTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->AMPMFetchRelativePhaseTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_relative_phase()->Resize(actual_array_size, 0);
        float32* relative_phase = response->mutable_relative_phase()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->AMPMFetchRelativePhaseTrace(instrument, selector_string, timeout, &x0, &dx, relative_phase, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_relative_phase()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AMPMFetchRelativePowerTrace(::grpc::ServerContext* context, const AMPMFetchRelativePowerTraceRequest* request, AMPMFetchRelativePowerTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->AMPMFetchRelativePowerTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_relative_power()->Resize(actual_array_size, 0);
        float32* relative_power = response->mutable_relative_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->AMPMFetchRelativePowerTrace(instrument, selector_string, timeout, &x0, &dx, relative_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_relative_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AbortMeasurements(::grpc::ServerContext* context, const AbortMeasurementsRequest* request, AbortMeasurementsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto status = library_->AbortMeasurements(instrument, selector_string);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AnalyzeIQ1Waveform(::grpc::ServerContext* context, const AnalyzeIQ1WaveformRequest* request, AnalyzeIQ1WaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto result_name_mbcs = convert_from_grpc<std::string>(request->result_name());
      char* result_name = (char*)result_name_mbcs.c_str();
      float64 x0 = request->x0();
      float64 dx = request->dx();
      auto iq = convert_from_grpc<NIComplexSingle>(request->iq());
      int32 array_size = static_cast<int32>(request->iq().size());
      int32 reset = request->reset();
      auto reserved = 0;
      auto status = library_->AnalyzeIQ1Waveform(instrument, selector_string, result_name, x0, dx, iq.data(), array_size, reset, reserved);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AnalyzeSpectrum1Waveform(::grpc::ServerContext* context, const AnalyzeSpectrum1WaveformRequest* request, AnalyzeSpectrum1WaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto result_name_mbcs = convert_from_grpc<std::string>(request->result_name());
      char* result_name = (char*)result_name_mbcs.c_str();
      float64 x0 = request->x0();
      float64 dx = request->dx();
      auto spectrum = const_cast<float32*>(request->spectrum().data());
      int32 array_size = static_cast<int32>(request->spectrum().size());
      int32 reset = request->reset();
      auto reserved = 0;
      auto status = library_->AnalyzeSpectrum1Waveform(instrument, selector_string, result_name, x0, dx, spectrum, array_size, reset, reserved);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::AutoLevel(::grpc::ServerContext* context, const AutoLevelRequest* request, AutoLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 bandwidth = request->bandwidth();
      float64 measurement_interval = request->measurement_interval();
      float64 reference_level {};
      auto status = library_->AutoLevel(instrument, selector_string, bandwidth, measurement_interval, &reference_level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_reference_level(reference_level);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildCarrierString(::grpc::ServerContext* context, const BuildCarrierStringRequest* request, BuildCarrierStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 carrier_number = request->carrier_number();

      while (true) {
        auto status = library_->BuildCarrierString(selector_string, carrier_number, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_out_length = status;

        std::string selector_string_out;
        if (selector_string_out_length > 0) {
            selector_string_out.resize(selector_string_out_length - 1);
        }
        status = library_->BuildCarrierString(selector_string, carrier_number, selector_string_out_length, (char*)selector_string_out.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_out_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_out_utf8;
        convert_to_grpc(selector_string_out, &selector_string_out_utf8);
        response->set_selector_string_out(selector_string_out_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string_out()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildHarmonicString(::grpc::ServerContext* context, const BuildHarmonicStringRequest* request, BuildHarmonicStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 harmonic_number = request->harmonic_number();

      while (true) {
        auto status = library_->BuildHarmonicString(selector_string, harmonic_number, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_out_length = status;

        std::string selector_string_out;
        if (selector_string_out_length > 0) {
            selector_string_out.resize(selector_string_out_length - 1);
        }
        status = library_->BuildHarmonicString(selector_string, harmonic_number, selector_string_out_length, (char*)selector_string_out.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_out_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_out_utf8;
        convert_to_grpc(selector_string_out, &selector_string_out_utf8);
        response->set_selector_string_out(selector_string_out_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string_out()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildIntermodString(::grpc::ServerContext* context, const BuildIntermodStringRequest* request, BuildIntermodStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 intermod_number = request->intermod_number();

      while (true) {
        auto status = library_->BuildIntermodString(selector_string, intermod_number, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_out_length = status;

        std::string selector_string_out;
        if (selector_string_out_length > 0) {
            selector_string_out.resize(selector_string_out_length - 1);
        }
        status = library_->BuildIntermodString(selector_string, intermod_number, selector_string_out_length, (char*)selector_string_out.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_out_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_out_utf8;
        convert_to_grpc(selector_string_out, &selector_string_out_utf8);
        response->set_selector_string_out(selector_string_out_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string_out()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildListStepString(::grpc::ServerContext* context, const BuildListStepStringRequest* request, BuildListStepStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto list_name_mbcs = convert_from_grpc<std::string>(request->list_name());
      char* list_name = (char*)list_name_mbcs.c_str();
      auto result_name_mbcs = convert_from_grpc<std::string>(request->result_name());
      char* result_name = (char*)result_name_mbcs.c_str();
      int32 step_number = request->step_number();

      while (true) {
        auto status = library_->BuildListStepString(list_name, result_name, step_number, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_length = status;

        std::string selector_string;
        if (selector_string_length > 0) {
            selector_string.resize(selector_string_length - 1);
        }
        status = library_->BuildListStepString(list_name, result_name, step_number, selector_string_length, (char*)selector_string.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_utf8;
        convert_to_grpc(selector_string, &selector_string_utf8);
        response->set_selector_string(selector_string_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildListString(::grpc::ServerContext* context, const BuildListStringRequest* request, BuildListStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto list_name_mbcs = convert_from_grpc<std::string>(request->list_name());
      char* list_name = (char*)list_name_mbcs.c_str();
      auto result_name_mbcs = convert_from_grpc<std::string>(request->result_name());
      char* result_name = (char*)result_name_mbcs.c_str();

      while (true) {
        auto status = library_->BuildListString(list_name, result_name, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_length = status;

        std::string selector_string;
        if (selector_string_length > 0) {
            selector_string.resize(selector_string_length - 1);
        }
        status = library_->BuildListString(list_name, result_name, selector_string_length, (char*)selector_string.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_utf8;
        convert_to_grpc(selector_string, &selector_string_utf8);
        response->set_selector_string(selector_string_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildMarkerString(::grpc::ServerContext* context, const BuildMarkerStringRequest* request, BuildMarkerStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 marker_number = request->marker_number();

      while (true) {
        auto status = library_->BuildMarkerString(selector_string, marker_number, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_out_length = status;

        std::string selector_string_out;
        if (selector_string_out_length > 0) {
            selector_string_out.resize(selector_string_out_length - 1);
        }
        status = library_->BuildMarkerString(selector_string, marker_number, selector_string_out_length, (char*)selector_string_out.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_out_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_out_utf8;
        convert_to_grpc(selector_string_out, &selector_string_out_utf8);
        response->set_selector_string_out(selector_string_out_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string_out()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildOffsetString(::grpc::ServerContext* context, const BuildOffsetStringRequest* request, BuildOffsetStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 offset_number = request->offset_number();

      while (true) {
        auto status = library_->BuildOffsetString(selector_string, offset_number, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_out_length = status;

        std::string selector_string_out;
        if (selector_string_out_length > 0) {
            selector_string_out.resize(selector_string_out_length - 1);
        }
        status = library_->BuildOffsetString(selector_string, offset_number, selector_string_out_length, (char*)selector_string_out.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_out_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_out_utf8;
        convert_to_grpc(selector_string_out, &selector_string_out_utf8);
        response->set_selector_string_out(selector_string_out_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string_out()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildRangeSpurString(::grpc::ServerContext* context, const BuildRangeSpurStringRequest* request, BuildRangeSpurStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto signal_name_mbcs = convert_from_grpc<std::string>(request->signal_name());
      char* signal_name = (char*)signal_name_mbcs.c_str();
      auto result_name_mbcs = convert_from_grpc<std::string>(request->result_name());
      char* result_name = (char*)result_name_mbcs.c_str();
      int32 range_number = request->range_number();
      int32 spur_number = request->spur_number();

      while (true) {
        auto status = library_->BuildRangeSpurString(signal_name, result_name, range_number, spur_number, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_length = status;

        std::string selector_string;
        if (selector_string_length > 0) {
            selector_string.resize(selector_string_length - 1);
        }
        status = library_->BuildRangeSpurString(signal_name, result_name, range_number, spur_number, selector_string_length, (char*)selector_string.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_utf8;
        convert_to_grpc(selector_string, &selector_string_utf8);
        response->set_selector_string(selector_string_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildRangeString(::grpc::ServerContext* context, const BuildRangeStringRequest* request, BuildRangeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 range_number = request->range_number();

      while (true) {
        auto status = library_->BuildRangeString(selector_string, range_number, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_out_length = status;

        std::string selector_string_out;
        if (selector_string_out_length > 0) {
            selector_string_out.resize(selector_string_out_length - 1);
        }
        status = library_->BuildRangeString(selector_string, range_number, selector_string_out_length, (char*)selector_string_out.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_out_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_out_utf8;
        convert_to_grpc(selector_string_out, &selector_string_out_utf8);
        response->set_selector_string_out(selector_string_out_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string_out()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildSegmentString(::grpc::ServerContext* context, const BuildSegmentStringRequest* request, BuildSegmentStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 segment_number = request->segment_number();

      while (true) {
        auto status = library_->BuildSegmentString(selector_string, segment_number, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_out_length = status;

        std::string selector_string_out;
        if (selector_string_out_length > 0) {
            selector_string_out.resize(selector_string_out_length - 1);
        }
        status = library_->BuildSegmentString(selector_string, segment_number, selector_string_out_length, (char*)selector_string_out.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_out_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_out_utf8;
        convert_to_grpc(selector_string_out, &selector_string_out_utf8);
        response->set_selector_string_out(selector_string_out_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string_out()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildSignalString(::grpc::ServerContext* context, const BuildSignalStringRequest* request, BuildSignalStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto signal_name_mbcs = convert_from_grpc<std::string>(request->signal_name());
      char* signal_name = (char*)signal_name_mbcs.c_str();
      auto result_name_mbcs = convert_from_grpc<std::string>(request->result_name());
      char* result_name = (char*)result_name_mbcs.c_str();

      while (true) {
        auto status = library_->BuildSignalString(signal_name, result_name, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_length = status;

        std::string selector_string;
        if (selector_string_length > 0) {
            selector_string.resize(selector_string_length - 1);
        }
        status = library_->BuildSignalString(signal_name, result_name, selector_string_length, (char*)selector_string.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_utf8;
        convert_to_grpc(selector_string, &selector_string_utf8);
        response->set_selector_string(selector_string_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::BuildSpurString(::grpc::ServerContext* context, const BuildSpurStringRequest* request, BuildSpurStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 spur_number = request->spur_number();

      while (true) {
        auto status = library_->BuildSpurString(selector_string, spur_number, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        int32 selector_string_out_length = status;

        std::string selector_string_out;
        if (selector_string_out_length > 0) {
            selector_string_out.resize(selector_string_out_length - 1);
        }
        status = library_->BuildSpurString(selector_string, spur_number, selector_string_out_length, (char*)selector_string_out.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(selector_string_out_length)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
        }
        response->set_status(status);
        std::string selector_string_out_utf8;
        convert_to_grpc(selector_string_out, &selector_string_out_utf8);
        response->set_selector_string_out(selector_string_out_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_selector_string_out()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CCDFCfgMeasurementInterval(::grpc::ServerContext* context, const CCDFCfgMeasurementIntervalRequest* request, CCDFCfgMeasurementIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 measurement_interval = request->measurement_interval();
      auto status = library_->CCDFCfgMeasurementInterval(instrument, selector_string, measurement_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CCDFCfgNumberOfRecords(::grpc::ServerContext* context, const CCDFCfgNumberOfRecordsRequest* request, CCDFCfgNumberOfRecordsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_records = request->number_of_records();
      auto status = library_->CCDFCfgNumberOfRecords(instrument, selector_string, number_of_records);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CCDFCfgRBWFilter(::grpc::ServerContext* context, const CCDFCfgRBWFilterRequest* request, CCDFCfgRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::CCDFCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::CCDFCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::CCDFCfgRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      float64 rrc_alpha = request->rrc_alpha();
      auto status = library_->CCDFCfgRBWFilter(instrument, selector_string, rbw, rbw_filter_type, rrc_alpha);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CCDFCfgThreshold(::grpc::ServerContext* context, const CCDFCfgThresholdRequest* request, CCDFCfgThresholdResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 threshold_enabled;
      switch (request->threshold_enabled_enum_case()) {
        case nirfmxspecan_grpc::CCDFCfgThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabled: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled());
          break;
        }
        case nirfmxspecan_grpc::CCDFCfgThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabledRaw: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::CCDFCfgThresholdRequest::ThresholdEnabledEnumCase::THRESHOLD_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_enabled was not specified or out of range");
          break;
        }
      }

      float64 threshold_level = request->threshold_level();
      int32 threshold_type;
      switch (request->threshold_type_enum_case()) {
        case nirfmxspecan_grpc::CCDFCfgThresholdRequest::ThresholdTypeEnumCase::kThresholdType: {
          threshold_type = static_cast<int32>(request->threshold_type());
          break;
        }
        case nirfmxspecan_grpc::CCDFCfgThresholdRequest::ThresholdTypeEnumCase::kThresholdTypeRaw: {
          threshold_type = static_cast<int32>(request->threshold_type_raw());
          break;
        }
        case nirfmxspecan_grpc::CCDFCfgThresholdRequest::ThresholdTypeEnumCase::THRESHOLD_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->CCDFCfgThreshold(instrument, selector_string, threshold_enabled, threshold_level, threshold_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CCDFFetchBasicPowerProbabilities(::grpc::ServerContext* context, const CCDFFetchBasicPowerProbabilitiesRequest* request, CCDFFetchBasicPowerProbabilitiesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 ten_percent_power {};
      float64 one_percent_power {};
      float64 one_tenth_percent_power {};
      float64 one_hundredth_percent_power {};
      float64 one_thousandth_percent_power {};
      float64 one_ten_thousandth_percent_power {};
      auto status = library_->CCDFFetchBasicPowerProbabilities(instrument, selector_string, timeout, &ten_percent_power, &one_percent_power, &one_tenth_percent_power, &one_hundredth_percent_power, &one_thousandth_percent_power, &one_ten_thousandth_percent_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_ten_percent_power(ten_percent_power);
      response->set_one_percent_power(one_percent_power);
      response->set_one_tenth_percent_power(one_tenth_percent_power);
      response->set_one_hundredth_percent_power(one_hundredth_percent_power);
      response->set_one_thousandth_percent_power(one_thousandth_percent_power);
      response->set_one_ten_thousandth_percent_power(one_ten_thousandth_percent_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CCDFFetchGaussianProbabilitiesTrace(::grpc::ServerContext* context, const CCDFFetchGaussianProbabilitiesTraceRequest* request, CCDFFetchGaussianProbabilitiesTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->CCDFFetchGaussianProbabilitiesTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_gaussian_probabilities()->Resize(actual_array_size, 0);
        float32* gaussian_probabilities = response->mutable_gaussian_probabilities()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->CCDFFetchGaussianProbabilitiesTrace(instrument, selector_string, timeout, &x0, &dx, gaussian_probabilities, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_gaussian_probabilities()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CCDFFetchPower(::grpc::ServerContext* context, const CCDFFetchPowerRequest* request, CCDFFetchPowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 mean_power {};
      float64 mean_power_percentile {};
      float64 peak_power {};
      int32 measured_samples_count {};
      auto status = library_->CCDFFetchPower(instrument, selector_string, timeout, &mean_power, &mean_power_percentile, &peak_power, &measured_samples_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_mean_power(mean_power);
      response->set_mean_power_percentile(mean_power_percentile);
      response->set_peak_power(peak_power);
      response->set_measured_samples_count(measured_samples_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CCDFFetchProbabilitiesTrace(::grpc::ServerContext* context, const CCDFFetchProbabilitiesTraceRequest* request, CCDFFetchProbabilitiesTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->CCDFFetchProbabilitiesTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_probabilities()->Resize(actual_array_size, 0);
        float32* probabilities = response->mutable_probabilities()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->CCDFFetchProbabilitiesTrace(instrument, selector_string, timeout, &x0, &dx, probabilities, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_probabilities()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CCDFRead(::grpc::ServerContext* context, const CCDFReadRequest* request, CCDFReadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 mean_power {};
      float64 mean_power_percentile {};
      float64 peak_power {};
      int32 measured_samples_count {};
      auto status = library_->CCDFRead(instrument, selector_string, timeout, &mean_power, &mean_power_percentile, &peak_power, &measured_samples_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_mean_power(mean_power);
      response->set_mean_power_percentile(mean_power_percentile);
      response->set_peak_power(peak_power);
      response->set_measured_samples_count(measured_samples_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPCfgAveraging(::grpc::ServerContext* context, const CHPCfgAveragingRequest* request, CHPCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::CHPCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      int32 averaging_type;
      switch (request->averaging_type_enum_case()) {
        case nirfmxspecan_grpc::CHPCfgAveragingRequest::AveragingTypeEnumCase::kAveragingType: {
          averaging_type = static_cast<int32>(request->averaging_type());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgAveragingRequest::AveragingTypeEnumCase::kAveragingTypeRaw: {
          averaging_type = static_cast<int32>(request->averaging_type_raw());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgAveragingRequest::AveragingTypeEnumCase::AVERAGING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->CHPCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count, averaging_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPCfgCarrierOffset(::grpc::ServerContext* context, const CHPCfgCarrierOffsetRequest* request, CHPCfgCarrierOffsetResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 carrier_frequency = request->carrier_frequency();
      auto status = library_->CHPCfgCarrierOffset(instrument, selector_string, carrier_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPCfgDetector(::grpc::ServerContext* context, const CHPCfgDetectorRequest* request, CHPCfgDetectorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 detector_type;
      switch (request->detector_type_enum_case()) {
        case nirfmxspecan_grpc::CHPCfgDetectorRequest::DetectorTypeEnumCase::kDetectorType: {
          detector_type = static_cast<int32>(request->detector_type());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgDetectorRequest::DetectorTypeEnumCase::kDetectorTypeRaw: {
          detector_type = static_cast<int32>(request->detector_type_raw());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgDetectorRequest::DetectorTypeEnumCase::DETECTOR_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for detector_type was not specified or out of range");
          break;
        }
      }

      int32 detector_points = request->detector_points();
      auto status = library_->CHPCfgDetector(instrument, selector_string, detector_type, detector_points);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPCfgFFT(::grpc::ServerContext* context, const CHPCfgFFTRequest* request, CHPCfgFFTResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 fft_window;
      switch (request->fft_window_enum_case()) {
        case nirfmxspecan_grpc::CHPCfgFFTRequest::FftWindowEnumCase::kFftWindow: {
          fft_window = static_cast<int32>(request->fft_window());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgFFTRequest::FftWindowEnumCase::kFftWindowRaw: {
          fft_window = static_cast<int32>(request->fft_window_raw());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgFFTRequest::FftWindowEnumCase::FFT_WINDOW_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fft_window was not specified or out of range");
          break;
        }
      }

      float64 fft_padding = request->fft_padding();
      auto status = library_->CHPCfgFFT(instrument, selector_string, fft_window, fft_padding);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPCfgIntegrationBandwidth(::grpc::ServerContext* context, const CHPCfgIntegrationBandwidthRequest* request, CHPCfgIntegrationBandwidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 integration_bandwidth = request->integration_bandwidth();
      auto status = library_->CHPCfgIntegrationBandwidth(instrument, selector_string, integration_bandwidth);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPCfgNumberOfCarriers(::grpc::ServerContext* context, const CHPCfgNumberOfCarriersRequest* request, CHPCfgNumberOfCarriersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_carriers = request->number_of_carriers();
      auto status = library_->CHPCfgNumberOfCarriers(instrument, selector_string, number_of_carriers);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPCfgRBWFilter(::grpc::ServerContext* context, const CHPCfgRBWFilterRequest* request, CHPCfgRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rbw_auto;
      switch (request->rbw_auto_enum_case()) {
        case nirfmxspecan_grpc::CHPCfgRBWFilterRequest::RbwAutoEnumCase::kRbwAuto: {
          rbw_auto = static_cast<int32>(request->rbw_auto());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgRBWFilterRequest::RbwAutoEnumCase::kRbwAutoRaw: {
          rbw_auto = static_cast<int32>(request->rbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgRBWFilterRequest::RbwAutoEnumCase::RBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_auto was not specified or out of range");
          break;
        }
      }

      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::CHPCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->CHPCfgRBWFilter(instrument, selector_string, rbw_auto, rbw, rbw_filter_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPCfgRRCFilter(::grpc::ServerContext* context, const CHPCfgRRCFilterRequest* request, CHPCfgRRCFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rrc_filter_enabled;
      switch (request->rrc_filter_enabled_enum_case()) {
        case nirfmxspecan_grpc::CHPCfgRRCFilterRequest::RrcFilterEnabledEnumCase::kRrcFilterEnabled: {
          rrc_filter_enabled = static_cast<int32>(request->rrc_filter_enabled());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgRRCFilterRequest::RrcFilterEnabledEnumCase::kRrcFilterEnabledRaw: {
          rrc_filter_enabled = static_cast<int32>(request->rrc_filter_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgRRCFilterRequest::RrcFilterEnabledEnumCase::RRC_FILTER_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rrc_filter_enabled was not specified or out of range");
          break;
        }
      }

      float64 rrc_alpha = request->rrc_alpha();
      auto status = library_->CHPCfgRRCFilter(instrument, selector_string, rrc_filter_enabled, rrc_alpha);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPCfgSpan(::grpc::ServerContext* context, const CHPCfgSpanRequest* request, CHPCfgSpanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 span = request->span();
      auto status = library_->CHPCfgSpan(instrument, selector_string, span);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPCfgSweepTime(::grpc::ServerContext* context, const CHPCfgSweepTimeRequest* request, CHPCfgSweepTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 sweep_time_auto;
      switch (request->sweep_time_auto_enum_case()) {
        case nirfmxspecan_grpc::CHPCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAuto: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAutoRaw: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::CHPCfgSweepTimeRequest::SweepTimeAutoEnumCase::SWEEP_TIME_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sweep_time_auto was not specified or out of range");
          break;
        }
      }

      float64 sweep_time_interval = request->sweep_time_interval();
      auto status = library_->CHPCfgSweepTime(instrument, selector_string, sweep_time_auto, sweep_time_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPFetchCarrierMeasurement(::grpc::ServerContext* context, const CHPFetchCarrierMeasurementRequest* request, CHPFetchCarrierMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 absolute_power {};
      float64 psd {};
      float64 relative_power {};
      auto status = library_->CHPFetchCarrierMeasurement(instrument, selector_string, timeout, &absolute_power, &psd, &relative_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_absolute_power(absolute_power);
      response->set_psd(psd);
      response->set_relative_power(relative_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPFetchSpectrum(::grpc::ServerContext* context, const CHPFetchSpectrumRequest* request, CHPFetchSpectrumResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->CHPFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        float32* spectrum = response->mutable_spectrum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->CHPFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, spectrum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPFetchTotalCarrierPower(::grpc::ServerContext* context, const CHPFetchTotalCarrierPowerRequest* request, CHPFetchTotalCarrierPowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 total_carrier_power {};
      auto status = library_->CHPFetchTotalCarrierPower(instrument, selector_string, timeout, &total_carrier_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_total_carrier_power(total_carrier_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPRead(::grpc::ServerContext* context, const CHPReadRequest* request, CHPReadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 absolute_power {};
      float64 psd {};
      auto status = library_->CHPRead(instrument, selector_string, timeout, &absolute_power, &psd);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_absolute_power(absolute_power);
      response->set_psd(psd);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CHPValidateNoiseCalibrationData(::grpc::ServerContext* context, const CHPValidateNoiseCalibrationDataRequest* request, CHPValidateNoiseCalibrationDataResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 noise_calibration_data_valid {};
      auto status = library_->CHPValidateNoiseCalibrationData(instrument, selector_string, &noise_calibration_data_valid);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_noise_calibration_data_valid(static_cast<nirfmxspecan_grpc::ChpNoiseCalibrationDataValid>(noise_calibration_data_valid));
      response->set_noise_calibration_data_valid_raw(noise_calibration_data_valid);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CfgDigitalEdgeTrigger(::grpc::ServerContext* context, const CfgDigitalEdgeTriggerRequest* request, CfgDigitalEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      char* digital_edge_source;
      std::string digital_edge_source_buffer;
      switch (request->digital_edge_source_enum_case()) {
        case nirfmxspecan_grpc::CfgDigitalEdgeTriggerRequest::DigitalEdgeSourceEnumCase::kDigitalEdgeSourceMapped: {
          auto digital_edge_source_imap_it = digitaledgetriggersource_input_map_.find(request->digital_edge_source_mapped());
          if (digital_edge_source_imap_it == digitaledgetriggersource_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for digital_edge_source_mapped was not specified or out of range.");
          }
          digital_edge_source = const_cast<char*>((digital_edge_source_imap_it->second).c_str());
          break;
        }
        case nirfmxspecan_grpc::CfgDigitalEdgeTriggerRequest::DigitalEdgeSourceEnumCase::kDigitalEdgeSourceRaw: {
          digital_edge_source_buffer = convert_from_grpc<std::string>(request->digital_edge_source_raw());
          digital_edge_source = const_cast<char*>(digital_edge_source_buffer.c_str());
          break;
        }
        case nirfmxspecan_grpc::CfgDigitalEdgeTriggerRequest::DigitalEdgeSourceEnumCase::DIGITAL_EDGE_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for digital_edge_source was not specified or out of range");
          break;
        }
      }

      int32 digital_edge;
      switch (request->digital_edge_enum_case()) {
        case nirfmxspecan_grpc::CfgDigitalEdgeTriggerRequest::DigitalEdgeEnumCase::kDigitalEdge: {
          digital_edge = static_cast<int32>(request->digital_edge());
          break;
        }
        case nirfmxspecan_grpc::CfgDigitalEdgeTriggerRequest::DigitalEdgeEnumCase::kDigitalEdgeRaw: {
          digital_edge = static_cast<int32>(request->digital_edge_raw());
          break;
        }
        case nirfmxspecan_grpc::CfgDigitalEdgeTriggerRequest::DigitalEdgeEnumCase::DIGITAL_EDGE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for digital_edge was not specified or out of range");
          break;
        }
      }

      float64 trigger_delay = request->trigger_delay();
      int32 enable_trigger = request->enable_trigger();
      auto status = library_->CfgDigitalEdgeTrigger(instrument, selector_string, digital_edge_source, digital_edge, trigger_delay, enable_trigger);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CfgExternalAttenuation(::grpc::ServerContext* context, const CfgExternalAttenuationRequest* request, CfgExternalAttenuationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 external_attenuation = request->external_attenuation();
      auto status = library_->CfgExternalAttenuation(instrument, selector_string, external_attenuation);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CfgFrequency(::grpc::ServerContext* context, const CfgFrequencyRequest* request, CfgFrequencyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 center_frequency = request->center_frequency();
      auto status = library_->CfgFrequency(instrument, selector_string, center_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CfgFrequencyReference(::grpc::ServerContext* context, const CfgFrequencyReferenceRequest* request, CfgFrequencyReferenceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      char* channel_name = (char*)channel_name_mbcs.c_str();
      char* frequency_reference_source;
      std::string frequency_reference_source_buffer;
      switch (request->frequency_reference_source_enum_case()) {
        case nirfmxspecan_grpc::CfgFrequencyReferenceRequest::FrequencyReferenceSourceEnumCase::kFrequencyReferenceSourceMapped: {
          auto frequency_reference_source_imap_it = frequencyreferencesource_input_map_.find(request->frequency_reference_source_mapped());
          if (frequency_reference_source_imap_it == frequencyreferencesource_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for frequency_reference_source_mapped was not specified or out of range.");
          }
          frequency_reference_source = const_cast<char*>((frequency_reference_source_imap_it->second).c_str());
          break;
        }
        case nirfmxspecan_grpc::CfgFrequencyReferenceRequest::FrequencyReferenceSourceEnumCase::kFrequencyReferenceSourceRaw: {
          frequency_reference_source_buffer = convert_from_grpc<std::string>(request->frequency_reference_source_raw());
          frequency_reference_source = const_cast<char*>(frequency_reference_source_buffer.c_str());
          break;
        }
        case nirfmxspecan_grpc::CfgFrequencyReferenceRequest::FrequencyReferenceSourceEnumCase::FREQUENCY_REFERENCE_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for frequency_reference_source was not specified or out of range");
          break;
        }
      }

      float64 frequency_reference_frequency = request->frequency_reference_frequency();
      auto status = library_->CfgFrequencyReference(instrument, channel_name, frequency_reference_source, frequency_reference_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CfgIQPowerEdgeTrigger(::grpc::ServerContext* context, const CfgIQPowerEdgeTriggerRequest* request, CfgIQPowerEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto iq_power_edge_source_mbcs = convert_from_grpc<std::string>(request->iq_power_edge_source());
      char* iq_power_edge_source = (char*)iq_power_edge_source_mbcs.c_str();
      float64 iq_power_edge_level = request->iq_power_edge_level();
      int32 iq_power_edge_slope;
      switch (request->iq_power_edge_slope_enum_case()) {
        case nirfmxspecan_grpc::CfgIQPowerEdgeTriggerRequest::IqPowerEdgeSlopeEnumCase::kIqPowerEdgeSlope: {
          iq_power_edge_slope = static_cast<int32>(request->iq_power_edge_slope());
          break;
        }
        case nirfmxspecan_grpc::CfgIQPowerEdgeTriggerRequest::IqPowerEdgeSlopeEnumCase::kIqPowerEdgeSlopeRaw: {
          iq_power_edge_slope = static_cast<int32>(request->iq_power_edge_slope_raw());
          break;
        }
        case nirfmxspecan_grpc::CfgIQPowerEdgeTriggerRequest::IqPowerEdgeSlopeEnumCase::IQ_POWER_EDGE_SLOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for iq_power_edge_slope was not specified or out of range");
          break;
        }
      }

      float64 trigger_delay = request->trigger_delay();
      int32 trigger_min_quiet_time_mode;
      switch (request->trigger_min_quiet_time_mode_enum_case()) {
        case nirfmxspecan_grpc::CfgIQPowerEdgeTriggerRequest::TriggerMinQuietTimeModeEnumCase::kTriggerMinQuietTimeMode: {
          trigger_min_quiet_time_mode = static_cast<int32>(request->trigger_min_quiet_time_mode());
          break;
        }
        case nirfmxspecan_grpc::CfgIQPowerEdgeTriggerRequest::TriggerMinQuietTimeModeEnumCase::kTriggerMinQuietTimeModeRaw: {
          trigger_min_quiet_time_mode = static_cast<int32>(request->trigger_min_quiet_time_mode_raw());
          break;
        }
        case nirfmxspecan_grpc::CfgIQPowerEdgeTriggerRequest::TriggerMinQuietTimeModeEnumCase::TRIGGER_MIN_QUIET_TIME_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_min_quiet_time_mode was not specified or out of range");
          break;
        }
      }

      float64 trigger_min_quiet_time_duration = request->trigger_min_quiet_time_duration();
      int32 enable_trigger = request->enable_trigger();
      auto status = library_->CfgIQPowerEdgeTrigger(instrument, selector_string, iq_power_edge_source, iq_power_edge_level, iq_power_edge_slope, trigger_delay, trigger_min_quiet_time_mode, trigger_min_quiet_time_duration, enable_trigger);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CfgMechanicalAttenuation(::grpc::ServerContext* context, const CfgMechanicalAttenuationRequest* request, CfgMechanicalAttenuationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      char* channel_name = (char*)channel_name_mbcs.c_str();
      int32 mechanical_attenuation_auto;
      switch (request->mechanical_attenuation_auto_enum_case()) {
        case nirfmxspecan_grpc::CfgMechanicalAttenuationRequest::MechanicalAttenuationAutoEnumCase::kMechanicalAttenuationAuto: {
          mechanical_attenuation_auto = static_cast<int32>(request->mechanical_attenuation_auto());
          break;
        }
        case nirfmxspecan_grpc::CfgMechanicalAttenuationRequest::MechanicalAttenuationAutoEnumCase::kMechanicalAttenuationAutoRaw: {
          mechanical_attenuation_auto = static_cast<int32>(request->mechanical_attenuation_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::CfgMechanicalAttenuationRequest::MechanicalAttenuationAutoEnumCase::MECHANICAL_ATTENUATION_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mechanical_attenuation_auto was not specified or out of range");
          break;
        }
      }

      float64 mechanical_attenuation_value = request->mechanical_attenuation_value();
      auto status = library_->CfgMechanicalAttenuation(instrument, channel_name, mechanical_attenuation_auto, mechanical_attenuation_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CfgRF(::grpc::ServerContext* context, const CfgRFRequest* request, CfgRFResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 center_frequency = request->center_frequency();
      float64 reference_level = request->reference_level();
      float64 external_attenuation = request->external_attenuation();
      auto status = library_->CfgRF(instrument, selector_string, center_frequency, reference_level, external_attenuation);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CfgRFAttenuation(::grpc::ServerContext* context, const CfgRFAttenuationRequest* request, CfgRFAttenuationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto channel_name_mbcs = convert_from_grpc<std::string>(request->channel_name());
      char* channel_name = (char*)channel_name_mbcs.c_str();
      int32 rf_attenuation_auto;
      switch (request->rf_attenuation_auto_enum_case()) {
        case nirfmxspecan_grpc::CfgRFAttenuationRequest::RfAttenuationAutoEnumCase::kRfAttenuationAuto: {
          rf_attenuation_auto = static_cast<int32>(request->rf_attenuation_auto());
          break;
        }
        case nirfmxspecan_grpc::CfgRFAttenuationRequest::RfAttenuationAutoEnumCase::kRfAttenuationAutoRaw: {
          rf_attenuation_auto = static_cast<int32>(request->rf_attenuation_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::CfgRFAttenuationRequest::RfAttenuationAutoEnumCase::RF_ATTENUATION_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rf_attenuation_auto was not specified or out of range");
          break;
        }
      }

      float64 rf_attenuation_value = request->rf_attenuation_value();
      auto status = library_->CfgRFAttenuation(instrument, channel_name, rf_attenuation_auto, rf_attenuation_value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CfgReferenceLevel(::grpc::ServerContext* context, const CfgReferenceLevelRequest* request, CfgReferenceLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 reference_level = request->reference_level();
      auto status = library_->CfgReferenceLevel(instrument, selector_string, reference_level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CfgSoftwareEdgeTrigger(::grpc::ServerContext* context, const CfgSoftwareEdgeTriggerRequest* request, CfgSoftwareEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 trigger_delay = request->trigger_delay();
      int32 enable_trigger = request->enable_trigger();
      auto status = library_->CfgSoftwareEdgeTrigger(instrument, selector_string, trigger_delay, enable_trigger);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CheckMeasurementStatus(::grpc::ServerContext* context, const CheckMeasurementStatusRequest* request, CheckMeasurementStatusResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 is_done {};
      auto status = library_->CheckMeasurementStatus(instrument, selector_string, &is_done);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_is_done(is_done);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ClearAllNamedResults(::grpc::ServerContext* context, const ClearAllNamedResultsRequest* request, ClearAllNamedResultsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto status = library_->ClearAllNamedResults(instrument, selector_string);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ClearNamedResult(::grpc::ServerContext* context, const ClearNamedResultRequest* request, ClearNamedResultResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto status = library_->ClearNamedResult(instrument, selector_string);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ClearNoiseCalibrationDatabase(::grpc::ServerContext* context, const ClearNoiseCalibrationDatabaseRequest* request, ClearNoiseCalibrationDatabaseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto status = library_->ClearNoiseCalibrationDatabase(instrument, selector_string);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CloneSignalConfiguration(::grpc::ServerContext* context, const CloneSignalConfigurationRequest* request, CloneSignalConfigurationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto old_signal_name_mbcs = convert_from_grpc<std::string>(request->old_signal_name());
      char* old_signal_name = (char*)old_signal_name_mbcs.c_str();
      auto new_signal_name_mbcs = convert_from_grpc<std::string>(request->new_signal_name());
      char* new_signal_name = (char*)new_signal_name_mbcs.c_str();
      auto status = library_->CloneSignalConfiguration(instrument, old_signal_name, new_signal_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::Close(::grpc::ServerContext* context, const CloseRequest* request, CloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      int32 force_destroy = request->force_destroy();
      session_repository_->remove_session(instrument_grpc_session.name());
      auto status = library_->Close(instrument, force_destroy);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::Commit(::grpc::ServerContext* context, const CommitRequest* request, CommitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto status = library_->Commit(instrument, selector_string);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CreateList(::grpc::ServerContext* context, const CreateListRequest* request, CreateListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto list_name_mbcs = convert_from_grpc<std::string>(request->list_name());
      char* list_name = (char*)list_name_mbcs.c_str();
      auto status = library_->CreateList(instrument, list_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CreateListStep(::grpc::ServerContext* context, const CreateListStepRequest* request, CreateListStepResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 created_step_index {};
      auto status = library_->CreateListStep(instrument, selector_string, &created_step_index);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_created_step_index(created_step_index);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::CreateSignalConfiguration(::grpc::ServerContext* context, const CreateSignalConfigurationRequest* request, CreateSignalConfigurationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto signal_name_mbcs = convert_from_grpc<std::string>(request->signal_name());
      char* signal_name = (char*)signal_name_mbcs.c_str();
      auto status = library_->CreateSignalConfiguration(instrument, signal_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDApplyDigitalPredistortion(::grpc::ServerContext* context, const DPDApplyDigitalPredistortionRequest* request, DPDApplyDigitalPredistortionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 x0_in = request->x0_in();
      float64 dx_in = request->dx_in();
      auto waveform_in = convert_from_grpc<NIComplexSingle>(request->waveform_in());
      int32 array_size_in = static_cast<int32>(request->waveform_in().size());
      int32 idle_duration_present;
      switch (request->idle_duration_present_enum_case()) {
        case nirfmxspecan_grpc::DPDApplyDigitalPredistortionRequest::IdleDurationPresentEnumCase::kIdleDurationPresent: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present());
          break;
        }
        case nirfmxspecan_grpc::DPDApplyDigitalPredistortionRequest::IdleDurationPresentEnumCase::kIdleDurationPresentRaw: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDApplyDigitalPredistortionRequest::IdleDurationPresentEnumCase::IDLE_DURATION_PRESENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_duration_present was not specified or out of range");
          break;
        }
      }

      float64 measurement_timeout = request->measurement_timeout();
      float64 x0_out {};
      float64 dx_out {};
      int32 actual_array_size {};
      float64 papr {};
      float64 power_offset {};
      while (true) {
        auto status = library_->DPDApplyDigitalPredistortion(instrument, selector_string, x0_in, dx_in, waveform_in.data(), array_size_in, idle_duration_present, measurement_timeout, &x0_out, &dx_out, nullptr, 0, &actual_array_size, &papr, &power_offset);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> waveform_out(actual_array_size, NIComplexSingle());
        auto array_size_out = actual_array_size;
        status = library_->DPDApplyDigitalPredistortion(instrument, selector_string, x0_in, dx_in, waveform_in.data(), array_size_in, idle_duration_present, measurement_timeout, &x0_out, &dx_out, waveform_out.data(), array_size_out, &actual_array_size, &papr, &power_offset);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0_out(x0_out);
        response->set_dx_out(dx_out);
        convert_to_grpc(waveform_out, response->mutable_waveform_out());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_waveform_out()->size();
          if (shrunk_size != current_size) {
            response->mutable_waveform_out()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        response->set_papr(papr);
        response->set_power_offset(power_offset);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDApplyPreDPDSignalConditioning(::grpc::ServerContext* context, const DPDApplyPreDPDSignalConditioningRequest* request, DPDApplyPreDPDSignalConditioningResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 x0_in = request->x0_in();
      float64 dx_in = request->dx_in();
      auto waveform_in = convert_from_grpc<NIComplexSingle>(request->waveform_in());
      int32 array_size_in = static_cast<int32>(request->waveform_in().size());
      int32 idle_duration_present;
      switch (request->idle_duration_present_enum_case()) {
        case nirfmxspecan_grpc::DPDApplyPreDPDSignalConditioningRequest::IdleDurationPresentEnumCase::kIdleDurationPresent: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present());
          break;
        }
        case nirfmxspecan_grpc::DPDApplyPreDPDSignalConditioningRequest::IdleDurationPresentEnumCase::kIdleDurationPresentRaw: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDApplyPreDPDSignalConditioningRequest::IdleDurationPresentEnumCase::IDLE_DURATION_PRESENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_duration_present was not specified or out of range");
          break;
        }
      }

      float64 x0_out {};
      float64 dx_out {};
      int32 actual_array_size {};
      float64 papr {};
      while (true) {
        auto status = library_->DPDApplyPreDPDSignalConditioning(instrument, selector_string, x0_in, dx_in, waveform_in.data(), array_size_in, idle_duration_present, &x0_out, &dx_out, nullptr, 0, &actual_array_size, &papr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> waveform_out(actual_array_size, NIComplexSingle());
        auto array_size_out = actual_array_size;
        status = library_->DPDApplyPreDPDSignalConditioning(instrument, selector_string, x0_in, dx_in, waveform_in.data(), array_size_in, idle_duration_present, &x0_out, &dx_out, waveform_out.data(), array_size_out, &actual_array_size, &papr);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0_out(x0_out);
        response->set_dx_out(dx_out);
        convert_to_grpc(waveform_out, response->mutable_waveform_out());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_waveform_out()->size();
          if (shrunk_size != current_size) {
            response->mutable_waveform_out()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        response->set_papr(papr);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgApplyDPDConfigurationInput(::grpc::ServerContext* context, const DPDCfgApplyDPDConfigurationInputRequest* request, DPDCfgApplyDPDConfigurationInputResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 configuration_input;
      switch (request->configuration_input_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgApplyDPDConfigurationInputRequest::ConfigurationInputEnumCase::kConfigurationInput: {
          configuration_input = static_cast<int32>(request->configuration_input());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgApplyDPDConfigurationInputRequest::ConfigurationInputEnumCase::kConfigurationInputRaw: {
          configuration_input = static_cast<int32>(request->configuration_input_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgApplyDPDConfigurationInputRequest::ConfigurationInputEnumCase::CONFIGURATION_INPUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for configuration_input was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgApplyDPDConfigurationInput(instrument, selector_string, configuration_input);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgApplyDPDLookupTableCorrectionType(::grpc::ServerContext* context, const DPDCfgApplyDPDLookupTableCorrectionTypeRequest* request, DPDCfgApplyDPDLookupTableCorrectionTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 lut_correction_type;
      switch (request->lut_correction_type_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgApplyDPDLookupTableCorrectionTypeRequest::LutCorrectionTypeEnumCase::kLutCorrectionType: {
          lut_correction_type = static_cast<int32>(request->lut_correction_type());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgApplyDPDLookupTableCorrectionTypeRequest::LutCorrectionTypeEnumCase::kLutCorrectionTypeRaw: {
          lut_correction_type = static_cast<int32>(request->lut_correction_type_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgApplyDPDLookupTableCorrectionTypeRequest::LutCorrectionTypeEnumCase::LUT_CORRECTION_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for lut_correction_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgApplyDPDLookupTableCorrectionType(instrument, selector_string, lut_correction_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgApplyDPDMemoryModelCorrectionType(::grpc::ServerContext* context, const DPDCfgApplyDPDMemoryModelCorrectionTypeRequest* request, DPDCfgApplyDPDMemoryModelCorrectionTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 memory_model_correction_type;
      switch (request->memory_model_correction_type_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgApplyDPDMemoryModelCorrectionTypeRequest::MemoryModelCorrectionTypeEnumCase::kMemoryModelCorrectionType: {
          memory_model_correction_type = static_cast<int32>(request->memory_model_correction_type());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgApplyDPDMemoryModelCorrectionTypeRequest::MemoryModelCorrectionTypeEnumCase::kMemoryModelCorrectionTypeRaw: {
          memory_model_correction_type = static_cast<int32>(request->memory_model_correction_type_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgApplyDPDMemoryModelCorrectionTypeRequest::MemoryModelCorrectionTypeEnumCase::MEMORY_MODEL_CORRECTION_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for memory_model_correction_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgApplyDPDMemoryModelCorrectionType(instrument, selector_string, memory_model_correction_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgApplyDPDUserDPDPolynomial(::grpc::ServerContext* context, const DPDCfgApplyDPDUserDPDPolynomialRequest* request, DPDCfgApplyDPDUserDPDPolynomialResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto dpd_polynomial = convert_from_grpc<NIComplexSingle>(request->dpd_polynomial());
      int32 array_size = static_cast<int32>(request->dpd_polynomial().size());
      auto status = library_->DPDCfgApplyDPDUserDPDPolynomial(instrument, selector_string, dpd_polynomial.data(), array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgApplyDPDUserLookupTable(::grpc::ServerContext* context, const DPDCfgApplyDPDUserLookupTableRequest* request, DPDCfgApplyDPDUserLookupTableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto lut_input_powers = const_cast<float32*>(request->lut_input_powers().data());
      auto lut_complex_gains = convert_from_grpc<NIComplexSingle>(request->lut_complex_gains());
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->lut_input_powers_size(),
        request->lut_complex_gains_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, true);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [lut_input_powers, lut_complex_gains] do not match");
      }
      // NULL out optional params with zero sizes.
      if (array_size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        lut_input_powers = request->lut_input_powers_size() ? std::move(lut_input_powers) : nullptr;
        lut_complex_gains = request->lut_complex_gains_size() ? std::move(lut_complex_gains) : nullptr;
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->DPDCfgApplyDPDUserLookupTable(instrument, selector_string, lut_input_powers, lut_complex_gains.data(), array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgAveraging(::grpc::ServerContext* context, const DPDCfgAveragingRequest* request, DPDCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      auto status = library_->DPDCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgDPDModel(::grpc::ServerContext* context, const DPDCfgDPDModelRequest* request, DPDCfgDPDModelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 dpd_model;
      switch (request->dpd_model_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgDPDModelRequest::DpdModelEnumCase::kDpdModel: {
          dpd_model = static_cast<int32>(request->dpd_model());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgDPDModelRequest::DpdModelEnumCase::kDpdModelRaw: {
          dpd_model = static_cast<int32>(request->dpd_model_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgDPDModelRequest::DpdModelEnumCase::DPD_MODEL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for dpd_model was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgDPDModel(instrument, selector_string, dpd_model);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgDUTAverageInputPower(::grpc::ServerContext* context, const DPDCfgDUTAverageInputPowerRequest* request, DPDCfgDUTAverageInputPowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 dut_average_input_power = request->dut_average_input_power();
      auto status = library_->DPDCfgDUTAverageInputPower(instrument, selector_string, dut_average_input_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgGeneralizedMemoryPolynomialCrossTerms(::grpc::ServerContext* context, const DPDCfgGeneralizedMemoryPolynomialCrossTermsRequest* request, DPDCfgGeneralizedMemoryPolynomialCrossTermsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 memory_polynomial_lead_order = request->memory_polynomial_lead_order();
      int32 memory_polynomial_lag_order = request->memory_polynomial_lag_order();
      int32 memory_polynomial_lead_memory_depth = request->memory_polynomial_lead_memory_depth();
      int32 memory_polynomial_lag_memory_depth = request->memory_polynomial_lag_memory_depth();
      int32 memory_polynomial_maximum_lead = request->memory_polynomial_maximum_lead();
      int32 memory_polynomial_maximum_lag = request->memory_polynomial_maximum_lag();
      auto status = library_->DPDCfgGeneralizedMemoryPolynomialCrossTerms(instrument, selector_string, memory_polynomial_lead_order, memory_polynomial_lag_order, memory_polynomial_lead_memory_depth, memory_polynomial_lag_memory_depth, memory_polynomial_maximum_lead, memory_polynomial_maximum_lag);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgIterativeDPDEnabled(::grpc::ServerContext* context, const DPDCfgIterativeDPDEnabledRequest* request, DPDCfgIterativeDPDEnabledResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 iterative_dpd_enabled;
      switch (request->iterative_dpd_enabled_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgIterativeDPDEnabledRequest::IterativeDpdEnabledEnumCase::kIterativeDpdEnabled: {
          iterative_dpd_enabled = static_cast<int32>(request->iterative_dpd_enabled());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgIterativeDPDEnabledRequest::IterativeDpdEnabledEnumCase::kIterativeDpdEnabledRaw: {
          iterative_dpd_enabled = static_cast<int32>(request->iterative_dpd_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgIterativeDPDEnabledRequest::IterativeDpdEnabledEnumCase::ITERATIVE_DPD_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for iterative_dpd_enabled was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgIterativeDPDEnabled(instrument, selector_string, iterative_dpd_enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgLookupTableAMToAMCurveFit(::grpc::ServerContext* context, const DPDCfgLookupTableAMToAMCurveFitRequest* request, DPDCfgLookupTableAMToAMCurveFitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 am_to_am_curve_fit_order = request->am_to_am_curve_fit_order();
      int32 am_to_am_curve_fit_type;
      switch (request->am_to_am_curve_fit_type_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgLookupTableAMToAMCurveFitRequest::AmToAmCurveFitTypeEnumCase::kAmToAmCurveFitType: {
          am_to_am_curve_fit_type = static_cast<int32>(request->am_to_am_curve_fit_type());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgLookupTableAMToAMCurveFitRequest::AmToAmCurveFitTypeEnumCase::kAmToAmCurveFitTypeRaw: {
          am_to_am_curve_fit_type = static_cast<int32>(request->am_to_am_curve_fit_type_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgLookupTableAMToAMCurveFitRequest::AmToAmCurveFitTypeEnumCase::AM_TO_AM_CURVE_FIT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for am_to_am_curve_fit_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgLookupTableAMToAMCurveFit(instrument, selector_string, am_to_am_curve_fit_order, am_to_am_curve_fit_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgLookupTableAMToPMCurveFit(::grpc::ServerContext* context, const DPDCfgLookupTableAMToPMCurveFitRequest* request, DPDCfgLookupTableAMToPMCurveFitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 am_to_pm_curve_fit_order = request->am_to_pm_curve_fit_order();
      int32 am_to_pm_curve_fit_type;
      switch (request->am_to_pm_curve_fit_type_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgLookupTableAMToPMCurveFitRequest::AmToPmCurveFitTypeEnumCase::kAmToPmCurveFitType: {
          am_to_pm_curve_fit_type = static_cast<int32>(request->am_to_pm_curve_fit_type());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgLookupTableAMToPMCurveFitRequest::AmToPmCurveFitTypeEnumCase::kAmToPmCurveFitTypeRaw: {
          am_to_pm_curve_fit_type = static_cast<int32>(request->am_to_pm_curve_fit_type_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgLookupTableAMToPMCurveFitRequest::AmToPmCurveFitTypeEnumCase::AM_TO_PM_CURVE_FIT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for am_to_pm_curve_fit_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgLookupTableAMToPMCurveFit(instrument, selector_string, am_to_pm_curve_fit_order, am_to_pm_curve_fit_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgLookupTableStepSize(::grpc::ServerContext* context, const DPDCfgLookupTableStepSizeRequest* request, DPDCfgLookupTableStepSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 step_size = request->step_size();
      auto status = library_->DPDCfgLookupTableStepSize(instrument, selector_string, step_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgLookupTableThreshold(::grpc::ServerContext* context, const DPDCfgLookupTableThresholdRequest* request, DPDCfgLookupTableThresholdResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 threshold_enabled;
      switch (request->threshold_enabled_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgLookupTableThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabled: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgLookupTableThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabledRaw: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgLookupTableThresholdRequest::ThresholdEnabledEnumCase::THRESHOLD_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_enabled was not specified or out of range");
          break;
        }
      }

      float64 threshold_level = request->threshold_level();
      int32 threshold_type;
      switch (request->threshold_type_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgLookupTableThresholdRequest::ThresholdTypeEnumCase::kThresholdType: {
          threshold_type = static_cast<int32>(request->threshold_type());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgLookupTableThresholdRequest::ThresholdTypeEnumCase::kThresholdTypeRaw: {
          threshold_type = static_cast<int32>(request->threshold_type_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgLookupTableThresholdRequest::ThresholdTypeEnumCase::THRESHOLD_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgLookupTableThreshold(instrument, selector_string, threshold_enabled, threshold_level, threshold_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgLookupTableType(::grpc::ServerContext* context, const DPDCfgLookupTableTypeRequest* request, DPDCfgLookupTableTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 lookup_table_type;
      switch (request->lookup_table_type_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgLookupTableTypeRequest::LookupTableTypeEnumCase::kLookupTableType: {
          lookup_table_type = static_cast<int32>(request->lookup_table_type());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgLookupTableTypeRequest::LookupTableTypeEnumCase::kLookupTableTypeRaw: {
          lookup_table_type = static_cast<int32>(request->lookup_table_type_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgLookupTableTypeRequest::LookupTableTypeEnumCase::LOOKUP_TABLE_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for lookup_table_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgLookupTableType(instrument, selector_string, lookup_table_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgMeasurementInterval(::grpc::ServerContext* context, const DPDCfgMeasurementIntervalRequest* request, DPDCfgMeasurementIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 measurement_interval = request->measurement_interval();
      auto status = library_->DPDCfgMeasurementInterval(instrument, selector_string, measurement_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgMeasurementSampleRate(::grpc::ServerContext* context, const DPDCfgMeasurementSampleRateRequest* request, DPDCfgMeasurementSampleRateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 sample_rate_mode;
      switch (request->sample_rate_mode_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgMeasurementSampleRateRequest::SampleRateModeEnumCase::kSampleRateMode: {
          sample_rate_mode = static_cast<int32>(request->sample_rate_mode());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgMeasurementSampleRateRequest::SampleRateModeEnumCase::kSampleRateModeRaw: {
          sample_rate_mode = static_cast<int32>(request->sample_rate_mode_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgMeasurementSampleRateRequest::SampleRateModeEnumCase::SAMPLE_RATE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sample_rate_mode was not specified or out of range");
          break;
        }
      }

      float64 sample_rate = request->sample_rate();
      auto status = library_->DPDCfgMeasurementSampleRate(instrument, selector_string, sample_rate_mode, sample_rate);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgMemoryPolynomial(::grpc::ServerContext* context, const DPDCfgMemoryPolynomialRequest* request, DPDCfgMemoryPolynomialResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 memory_polynomial_order = request->memory_polynomial_order();
      int32 memory_polynomial_memory_depth = request->memory_polynomial_memory_depth();
      auto status = library_->DPDCfgMemoryPolynomial(instrument, selector_string, memory_polynomial_order, memory_polynomial_memory_depth);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgPreviousDPDPolynomial(::grpc::ServerContext* context, const DPDCfgPreviousDPDPolynomialRequest* request, DPDCfgPreviousDPDPolynomialResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto previous_dpd_polynomial = convert_from_grpc<NIComplexSingle>(request->previous_dpd_polynomial());
      int32 array_size = static_cast<int32>(request->previous_dpd_polynomial().size());
      auto status = library_->DPDCfgPreviousDPDPolynomial(instrument, selector_string, previous_dpd_polynomial.data(), array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgReferenceWaveform(::grpc::ServerContext* context, const DPDCfgReferenceWaveformRequest* request, DPDCfgReferenceWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 x0 = request->x0();
      float64 dx = request->dx();
      auto reference_waveform = convert_from_grpc<NIComplexSingle>(request->reference_waveform());
      int32 array_size = static_cast<int32>(request->reference_waveform().size());
      int32 idle_duration_present;
      switch (request->idle_duration_present_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgReferenceWaveformRequest::IdleDurationPresentEnumCase::kIdleDurationPresent: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgReferenceWaveformRequest::IdleDurationPresentEnumCase::kIdleDurationPresentRaw: {
          idle_duration_present = static_cast<int32>(request->idle_duration_present_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgReferenceWaveformRequest::IdleDurationPresentEnumCase::IDLE_DURATION_PRESENT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for idle_duration_present was not specified or out of range");
          break;
        }
      }

      int32 signal_type;
      switch (request->signal_type_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgReferenceWaveformRequest::SignalTypeEnumCase::kSignalType: {
          signal_type = static_cast<int32>(request->signal_type());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgReferenceWaveformRequest::SignalTypeEnumCase::kSignalTypeRaw: {
          signal_type = static_cast<int32>(request->signal_type_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgReferenceWaveformRequest::SignalTypeEnumCase::SIGNAL_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for signal_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgReferenceWaveform(instrument, selector_string, x0, dx, reference_waveform.data(), array_size, idle_duration_present, signal_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDCfgSynchronizationMethod(::grpc::ServerContext* context, const DPDCfgSynchronizationMethodRequest* request, DPDCfgSynchronizationMethodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 synchronization_method;
      switch (request->synchronization_method_enum_case()) {
        case nirfmxspecan_grpc::DPDCfgSynchronizationMethodRequest::SynchronizationMethodEnumCase::kSynchronizationMethod: {
          synchronization_method = static_cast<int32>(request->synchronization_method());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgSynchronizationMethodRequest::SynchronizationMethodEnumCase::kSynchronizationMethodRaw: {
          synchronization_method = static_cast<int32>(request->synchronization_method_raw());
          break;
        }
        case nirfmxspecan_grpc::DPDCfgSynchronizationMethodRequest::SynchronizationMethodEnumCase::SYNCHRONIZATION_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for synchronization_method was not specified or out of range");
          break;
        }
      }

      auto status = library_->DPDCfgSynchronizationMethod(instrument, selector_string, synchronization_method);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDFetchApplyDPDPreCFRPAPR(::grpc::ServerContext* context, const DPDFetchApplyDPDPreCFRPAPRRequest* request, DPDFetchApplyDPDPreCFRPAPRResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 pre_cfr_papr {};
      auto status = library_->DPDFetchApplyDPDPreCFRPAPR(instrument, selector_string, timeout, &pre_cfr_papr);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_pre_cfr_papr(pre_cfr_papr);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDFetchAverageGain(::grpc::ServerContext* context, const DPDFetchAverageGainRequest* request, DPDFetchAverageGainResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 average_gain {};
      auto status = library_->DPDFetchAverageGain(instrument, selector_string, timeout, &average_gain);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_average_gain(average_gain);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDFetchDPDPolynomial(::grpc::ServerContext* context, const DPDFetchDPDPolynomialRequest* request, DPDFetchDPDPolynomialResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->DPDFetchDPDPolynomial(instrument, selector_string, timeout, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> dpd_polynomial(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->DPDFetchDPDPolynomial(instrument, selector_string, timeout, dpd_polynomial.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        convert_to_grpc(dpd_polynomial, response->mutable_dpd_polynomial());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_dpd_polynomial()->size();
          if (shrunk_size != current_size) {
            response->mutable_dpd_polynomial()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDFetchLookupTable(::grpc::ServerContext* context, const DPDFetchLookupTableRequest* request, DPDFetchLookupTableResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->DPDFetchLookupTable(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_input_powers()->Resize(actual_array_size, 0);
        float32* input_powers = response->mutable_input_powers()->mutable_data();
        std::vector<NIComplexSingle> complex_gains(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->DPDFetchLookupTable(instrument, selector_string, timeout, input_powers, complex_gains.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_input_powers()->Resize(actual_array_size, 0);
        convert_to_grpc(complex_gains, response->mutable_complex_gains());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_complex_gains()->size();
          if (shrunk_size != current_size) {
            response->mutable_complex_gains()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDFetchNMSE(::grpc::ServerContext* context, const DPDFetchNMSERequest* request, DPDFetchNMSEResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 nmse {};
      auto status = library_->DPDFetchNMSE(instrument, selector_string, timeout, &nmse);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_nmse(nmse);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDFetchProcessedMeanAcquiredWaveform(::grpc::ServerContext* context, const DPDFetchProcessedMeanAcquiredWaveformRequest* request, DPDFetchProcessedMeanAcquiredWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->DPDFetchProcessedMeanAcquiredWaveform(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> processed_mean_acquired_waveform(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->DPDFetchProcessedMeanAcquiredWaveform(instrument, selector_string, timeout, &x0, &dx, processed_mean_acquired_waveform.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        convert_to_grpc(processed_mean_acquired_waveform, response->mutable_processed_mean_acquired_waveform());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_processed_mean_acquired_waveform()->size();
          if (shrunk_size != current_size) {
            response->mutable_processed_mean_acquired_waveform()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DPDFetchProcessedReferenceWaveform(::grpc::ServerContext* context, const DPDFetchProcessedReferenceWaveformRequest* request, DPDFetchProcessedReferenceWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->DPDFetchProcessedReferenceWaveform(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> processed_reference_waveform(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->DPDFetchProcessedReferenceWaveform(instrument, selector_string, timeout, &x0, &dx, processed_reference_waveform.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        convert_to_grpc(processed_reference_waveform, response->mutable_processed_reference_waveform());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_processed_reference_waveform()->size();
          if (shrunk_size != current_size) {
            response->mutable_processed_reference_waveform()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DeleteList(::grpc::ServerContext* context, const DeleteListRequest* request, DeleteListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto list_name_mbcs = convert_from_grpc<std::string>(request->list_name());
      char* list_name = (char*)list_name_mbcs.c_str();
      auto status = library_->DeleteList(instrument, list_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DeleteSignalConfiguration(::grpc::ServerContext* context, const DeleteSignalConfigurationRequest* request, DeleteSignalConfigurationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto signal_name_mbcs = convert_from_grpc<std::string>(request->signal_name());
      char* signal_name = (char*)signal_name_mbcs.c_str();
      auto status = library_->DeleteSignalConfiguration(instrument, signal_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::DisableTrigger(::grpc::ServerContext* context, const DisableTriggerRequest* request, DisableTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto status = library_->DisableTrigger(instrument, selector_string);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::FCntCfgAveraging(::grpc::ServerContext* context, const FCntCfgAveragingRequest* request, FCntCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::FCntCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::FCntCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::FCntCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      int32 averaging_type;
      switch (request->averaging_type_enum_case()) {
        case nirfmxspecan_grpc::FCntCfgAveragingRequest::AveragingTypeEnumCase::kAveragingType: {
          averaging_type = static_cast<int32>(request->averaging_type());
          break;
        }
        case nirfmxspecan_grpc::FCntCfgAveragingRequest::AveragingTypeEnumCase::kAveragingTypeRaw: {
          averaging_type = static_cast<int32>(request->averaging_type_raw());
          break;
        }
        case nirfmxspecan_grpc::FCntCfgAveragingRequest::AveragingTypeEnumCase::AVERAGING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->FCntCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count, averaging_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::FCntCfgMeasurementInterval(::grpc::ServerContext* context, const FCntCfgMeasurementIntervalRequest* request, FCntCfgMeasurementIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 measurement_interval = request->measurement_interval();
      auto status = library_->FCntCfgMeasurementInterval(instrument, selector_string, measurement_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::FCntCfgRBWFilter(::grpc::ServerContext* context, const FCntCfgRBWFilterRequest* request, FCntCfgRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::FCntCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::FCntCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::FCntCfgRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      float64 rrc_alpha = request->rrc_alpha();
      auto status = library_->FCntCfgRBWFilter(instrument, selector_string, rbw, rbw_filter_type, rrc_alpha);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::FCntCfgThreshold(::grpc::ServerContext* context, const FCntCfgThresholdRequest* request, FCntCfgThresholdResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 threshold_enabled;
      switch (request->threshold_enabled_enum_case()) {
        case nirfmxspecan_grpc::FCntCfgThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabled: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled());
          break;
        }
        case nirfmxspecan_grpc::FCntCfgThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabledRaw: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::FCntCfgThresholdRequest::ThresholdEnabledEnumCase::THRESHOLD_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_enabled was not specified or out of range");
          break;
        }
      }

      float64 threshold_level = request->threshold_level();
      int32 threshold_type;
      switch (request->threshold_type_enum_case()) {
        case nirfmxspecan_grpc::FCntCfgThresholdRequest::ThresholdTypeEnumCase::kThresholdType: {
          threshold_type = static_cast<int32>(request->threshold_type());
          break;
        }
        case nirfmxspecan_grpc::FCntCfgThresholdRequest::ThresholdTypeEnumCase::kThresholdTypeRaw: {
          threshold_type = static_cast<int32>(request->threshold_type_raw());
          break;
        }
        case nirfmxspecan_grpc::FCntCfgThresholdRequest::ThresholdTypeEnumCase::THRESHOLD_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->FCntCfgThreshold(instrument, selector_string, threshold_enabled, threshold_level, threshold_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::FCntFetchAllanDeviation(::grpc::ServerContext* context, const FCntFetchAllanDeviationRequest* request, FCntFetchAllanDeviationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 allan_deviation {};
      auto status = library_->FCntFetchAllanDeviation(instrument, selector_string, timeout, &allan_deviation);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_allan_deviation(allan_deviation);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::FCntFetchFrequencyTrace(::grpc::ServerContext* context, const FCntFetchFrequencyTraceRequest* request, FCntFetchFrequencyTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->FCntFetchFrequencyTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_frequency_trace()->Resize(actual_array_size, 0);
        float32* frequency_trace = response->mutable_frequency_trace()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->FCntFetchFrequencyTrace(instrument, selector_string, timeout, &x0, &dx, frequency_trace, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_frequency_trace()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::FCntFetchMeasurement(::grpc::ServerContext* context, const FCntFetchMeasurementRequest* request, FCntFetchMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 average_relative_frequency {};
      float64 average_absolute_frequency {};
      float64 mean_phase {};
      auto status = library_->FCntFetchMeasurement(instrument, selector_string, timeout, &average_relative_frequency, &average_absolute_frequency, &mean_phase);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_average_relative_frequency(average_relative_frequency);
      response->set_average_absolute_frequency(average_absolute_frequency);
      response->set_mean_phase(mean_phase);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::FCntFetchPhaseTrace(::grpc::ServerContext* context, const FCntFetchPhaseTraceRequest* request, FCntFetchPhaseTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->FCntFetchPhaseTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_phase_trace()->Resize(actual_array_size, 0);
        float32* phase_trace = response->mutable_phase_trace()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->FCntFetchPhaseTrace(instrument, selector_string, timeout, &x0, &dx, phase_trace, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_phase_trace()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::FCntFetchPowerTrace(::grpc::ServerContext* context, const FCntFetchPowerTraceRequest* request, FCntFetchPowerTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->FCntFetchPowerTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_power_trace()->Resize(actual_array_size, 0);
        float32* power_trace = response->mutable_power_trace()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->FCntFetchPowerTrace(instrument, selector_string, timeout, &x0, &dx, power_trace, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_power_trace()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::FCntRead(::grpc::ServerContext* context, const FCntReadRequest* request, FCntReadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 average_relative_frequency {};
      float64 average_absolute_frequency {};
      float64 mean_phase {};
      auto status = library_->FCntRead(instrument, selector_string, timeout, &average_relative_frequency, &average_absolute_frequency, &mean_phase);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_average_relative_frequency(average_relative_frequency);
      response->set_average_absolute_frequency(average_absolute_frequency);
      response->set_mean_phase(mean_phase);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAllNamedResultNames(::grpc::ServerContext* context, const GetAllNamedResultNamesRequest* request, GetAllNamedResultNamesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 actual_result_names_size {};
      int32 default_result_exists {};
      while (true) {
        auto status = library_->GetAllNamedResultNames(instrument, selector_string, nullptr, 0, &actual_result_names_size, &default_result_exists);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::string result_names;
        if (actual_result_names_size > 0) {
            result_names.resize(actual_result_names_size - 1);
        }
        auto result_names_buffer_size = actual_result_names_size;
        status = library_->GetAllNamedResultNames(instrument, selector_string, (char*)result_names.data(), result_names_buffer_size, &actual_result_names_size, &default_result_exists);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        std::string result_names_utf8;
        convert_to_grpc(result_names, &result_names_utf8);
        response->set_result_names(result_names_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_result_names()));
        response->set_actual_result_names_size(actual_result_names_size);
        response->set_default_result_exists(default_result_exists);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeF32(::grpc::ServerContext* context, const GetAttributeF32Request* request, GetAttributeF32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      float32 attr_val {};
      auto status = library_->GetAttributeF32(instrument, selector_string, attribute_id, &attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_attr_val(attr_val);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeF32Array(::grpc::ServerContext* context, const GetAttributeF32ArrayRequest* request, GetAttributeF32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeF32Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        float32* attr_val = response->mutable_attr_val()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->GetAttributeF32Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeF64(::grpc::ServerContext* context, const GetAttributeF64Request* request, GetAttributeF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      float64 attr_val {};
      auto status = library_->GetAttributeF64(instrument, selector_string, attribute_id, &attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_attr_val(attr_val);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeF64Array(::grpc::ServerContext* context, const GetAttributeF64ArrayRequest* request, GetAttributeF64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeF64Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        float64* attr_val = response->mutable_attr_val()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->GetAttributeF64Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeI16(::grpc::ServerContext* context, const GetAttributeI16Request* request, GetAttributeI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int16 attr_val {};
      auto status = library_->GetAttributeI16(instrument, selector_string, attribute_id, &attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_attr_val(attr_val);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeI32(::grpc::ServerContext* context, const GetAttributeI32Request* request, GetAttributeI32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 attr_val {};
      auto status = library_->GetAttributeI32(instrument, selector_string, attribute_id, &attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      auto checked_convert_attr_val = [](auto raw_value) {
        bool raw_value_is_valid = nirfmxspecan_grpc::NiRFmxSpecAnInt32AttributeValues_IsValid(raw_value);
        auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
        return static_cast<nirfmxspecan_grpc::NiRFmxSpecAnInt32AttributeValues>(valid_enum_value);
      };
      response->set_attr_val(checked_convert_attr_val(attr_val));
      response->set_attr_val_raw(attr_val);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeI32Array(::grpc::ServerContext* context, const GetAttributeI32ArrayRequest* request, GetAttributeI32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeI32Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_attr_val_raw()->Resize(actual_array_size, 0);
        int32* attr_val = reinterpret_cast<int32*>(response->mutable_attr_val_raw()->mutable_data());
        auto array_size = actual_array_size;
        status = library_->GetAttributeI32Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        auto checked_convert_attr_val = [](auto raw_value) {
          bool raw_value_is_valid = nirfmxspecan_grpc::NiRFmxSpecAnInt32AttributeValues_IsValid(raw_value);
          auto valid_enum_value = raw_value_is_valid ? raw_value : 0;
          return static_cast<nirfmxspecan_grpc::NiRFmxSpecAnInt32AttributeValues>(valid_enum_value);
        };
          response->mutable_attr_val()->Clear();
          response->mutable_attr_val()->Reserve(actual_array_size);
          std::transform(
            response->attr_val_raw().begin(),
            response->attr_val_raw().begin() + actual_array_size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_attr_val()),
            [&](auto x) {
                return checked_convert_attr_val(x);
            });
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeI64(::grpc::ServerContext* context, const GetAttributeI64Request* request, GetAttributeI64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int64 attr_val {};
      auto status = library_->GetAttributeI64(instrument, selector_string, attribute_id, &attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_attr_val(attr_val);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeI64Array(::grpc::ServerContext* context, const GetAttributeI64ArrayRequest* request, GetAttributeI64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeI64Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        int64* attr_val = reinterpret_cast<int64*>(response->mutable_attr_val()->mutable_data());
        auto array_size = actual_array_size;
        status = library_->GetAttributeI64Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeI8(::grpc::ServerContext* context, const GetAttributeI8Request* request, GetAttributeI8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int8 attr_val {};
      auto status = library_->GetAttributeI8(instrument, selector_string, attribute_id, &attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_attr_val(attr_val);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeI8Array(::grpc::ServerContext* context, const GetAttributeI8ArrayRequest* request, GetAttributeI8ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeI8Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<int8> attr_val(actual_array_size);
        auto array_size = actual_array_size;
        status = library_->GetAttributeI8Array(instrument, selector_string, attribute_id, attr_val.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
          response->mutable_attr_val()->Clear();
          response->mutable_attr_val()->Reserve(actual_array_size);
          std::transform(
            attr_val.begin(),
            attr_val.begin() + actual_array_size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_attr_val()),
            [&](auto x) {
                return x;
            });
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeNIComplexDoubleArray(::grpc::ServerContext* context, const GetAttributeNIComplexDoubleArrayRequest* request, GetAttributeNIComplexDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeNIComplexDoubleArray(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexDouble> attr_val(actual_array_size, NIComplexDouble());
        auto array_size = actual_array_size;
        status = library_->GetAttributeNIComplexDoubleArray(instrument, selector_string, attribute_id, attr_val.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        convert_to_grpc(attr_val, response->mutable_attr_val());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_attr_val()->size();
          if (shrunk_size != current_size) {
            response->mutable_attr_val()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeNIComplexSingleArray(::grpc::ServerContext* context, const GetAttributeNIComplexSingleArrayRequest* request, GetAttributeNIComplexSingleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeNIComplexSingleArray(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> attr_val(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->GetAttributeNIComplexSingleArray(instrument, selector_string, attribute_id, attr_val.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        convert_to_grpc(attr_val, response->mutable_attr_val());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_attr_val()->size();
          if (shrunk_size != current_size) {
            response->mutable_attr_val()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeString(::grpc::ServerContext* context, const GetAttributeStringRequest* request, GetAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();

      while (true) {
        auto status = library_->GetAttributeString(instrument, selector_string, attribute_id, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        int32 array_size = status;

        std::string attr_val;
        if (array_size > 0) {
            attr_val.resize(array_size - 1);
        }
        status = library_->GetAttributeString(instrument, selector_string, attribute_id, array_size, (char*)attr_val.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(array_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        std::string attr_val_utf8;
        convert_to_grpc(attr_val, &attr_val_utf8);
        response->set_attr_val(attr_val_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_attr_val()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeU16(::grpc::ServerContext* context, const GetAttributeU16Request* request, GetAttributeU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      uInt16 attr_val {};
      auto status = library_->GetAttributeU16(instrument, selector_string, attribute_id, &attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_attr_val(attr_val);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeU32(::grpc::ServerContext* context, const GetAttributeU32Request* request, GetAttributeU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      uInt32 attr_val {};
      auto status = library_->GetAttributeU32(instrument, selector_string, attribute_id, &attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_attr_val(attr_val);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeU32Array(::grpc::ServerContext* context, const GetAttributeU32ArrayRequest* request, GetAttributeU32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeU32Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        uInt32* attr_val = reinterpret_cast<uInt32*>(response->mutable_attr_val()->mutable_data());
        auto array_size = actual_array_size;
        status = library_->GetAttributeU32Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeU64Array(::grpc::ServerContext* context, const GetAttributeU64ArrayRequest* request, GetAttributeU64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeU64Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        uInt64* attr_val = reinterpret_cast<uInt64*>(response->mutable_attr_val()->mutable_data());
        auto array_size = actual_array_size;
        status = library_->GetAttributeU64Array(instrument, selector_string, attribute_id, attr_val, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_attr_val()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeU8(::grpc::ServerContext* context, const GetAttributeU8Request* request, GetAttributeU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      uInt8 attr_val {};
      auto status = library_->GetAttributeU8(instrument, selector_string, attribute_id, &attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_attr_val(attr_val);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetAttributeU8Array(::grpc::ServerContext* context, const GetAttributeU8ArrayRequest* request, GetAttributeU8ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->GetAttributeU8Array(instrument, selector_string, attribute_id, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::string attr_val(actual_array_size, '\0');
        auto array_size = actual_array_size;
        status = library_->GetAttributeU8Array(instrument, selector_string, attribute_id, (uInt8*)attr_val.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_attr_val(attr_val);
        response->mutable_attr_val()->resize(actual_array_size);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetError(::grpc::ServerContext* context, const GetErrorRequest* request, GetErrorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());

      while (true) {
        auto status = library_->GetError(instrument, nullptr, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        int32 error_description_buffer_size = status;

        int32 error_code {};
        std::string error_description;
        if (error_description_buffer_size > 0) {
            error_description.resize(error_description_buffer_size - 1);
        }
        status = library_->GetError(instrument, &error_code, error_description_buffer_size, (char*)error_description.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(error_description_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_error_code(error_code);
        std::string error_description_utf8;
        convert_to_grpc(error_description, &error_description_utf8);
        response->set_error_description(error_description_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_description()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::GetErrorString(::grpc::ServerContext* context, const GetErrorStringRequest* request, GetErrorStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      int32 error_code = request->error_code();

      while (true) {
        auto status = library_->GetErrorString(instrument, error_code, 0, nullptr);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        int32 error_description_buffer_size = status;

        std::string error_description;
        if (error_description_buffer_size > 0) {
            error_description.resize(error_description_buffer_size - 1);
        }
        status = library_->GetErrorString(instrument, error_code, error_description_buffer_size, (char*)error_description.data());
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer || status > static_cast<decltype(status)>(error_description_buffer_size)) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        std::string error_description_utf8;
        convert_to_grpc(error_description, &error_description_utf8);
        response->set_error_description(error_description_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_error_description()));
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmCfgAutoHarmonics(::grpc::ServerContext* context, const HarmCfgAutoHarmonicsRequest* request, HarmCfgAutoHarmonicsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 auto_harmonics_setup_enabled;
      switch (request->auto_harmonics_setup_enabled_enum_case()) {
        case nirfmxspecan_grpc::HarmCfgAutoHarmonicsRequest::AutoHarmonicsSetupEnabledEnumCase::kAutoHarmonicsSetupEnabled: {
          auto_harmonics_setup_enabled = static_cast<int32>(request->auto_harmonics_setup_enabled());
          break;
        }
        case nirfmxspecan_grpc::HarmCfgAutoHarmonicsRequest::AutoHarmonicsSetupEnabledEnumCase::kAutoHarmonicsSetupEnabledRaw: {
          auto_harmonics_setup_enabled = static_cast<int32>(request->auto_harmonics_setup_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::HarmCfgAutoHarmonicsRequest::AutoHarmonicsSetupEnabledEnumCase::AUTO_HARMONICS_SETUP_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for auto_harmonics_setup_enabled was not specified or out of range");
          break;
        }
      }

      auto status = library_->HarmCfgAutoHarmonics(instrument, selector_string, auto_harmonics_setup_enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmCfgAveraging(::grpc::ServerContext* context, const HarmCfgAveragingRequest* request, HarmCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::HarmCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::HarmCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::HarmCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      int32 averaging_type;
      switch (request->averaging_type_enum_case()) {
        case nirfmxspecan_grpc::HarmCfgAveragingRequest::AveragingTypeEnumCase::kAveragingType: {
          averaging_type = static_cast<int32>(request->averaging_type());
          break;
        }
        case nirfmxspecan_grpc::HarmCfgAveragingRequest::AveragingTypeEnumCase::kAveragingTypeRaw: {
          averaging_type = static_cast<int32>(request->averaging_type_raw());
          break;
        }
        case nirfmxspecan_grpc::HarmCfgAveragingRequest::AveragingTypeEnumCase::AVERAGING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->HarmCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count, averaging_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmCfgFundamentalMeasurementInterval(::grpc::ServerContext* context, const HarmCfgFundamentalMeasurementIntervalRequest* request, HarmCfgFundamentalMeasurementIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 measurement_interval = request->measurement_interval();
      auto status = library_->HarmCfgFundamentalMeasurementInterval(instrument, selector_string, measurement_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmCfgFundamentalRBW(::grpc::ServerContext* context, const HarmCfgFundamentalRBWRequest* request, HarmCfgFundamentalRBWResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::HarmCfgFundamentalRBWRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::HarmCfgFundamentalRBWRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::HarmCfgFundamentalRBWRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      float64 rrc_alpha = request->rrc_alpha();
      auto status = library_->HarmCfgFundamentalRBW(instrument, selector_string, rbw, rbw_filter_type, rrc_alpha);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmCfgHarmonic(::grpc::ServerContext* context, const HarmCfgHarmonicRequest* request, HarmCfgHarmonicResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 harmonic_order = request->harmonic_order();
      float64 harmonic_bandwidth = request->harmonic_bandwidth();
      int32 harmonic_enabled;
      switch (request->harmonic_enabled_enum_case()) {
        case nirfmxspecan_grpc::HarmCfgHarmonicRequest::HarmonicEnabledEnumCase::kHarmonicEnabled: {
          harmonic_enabled = static_cast<int32>(request->harmonic_enabled());
          break;
        }
        case nirfmxspecan_grpc::HarmCfgHarmonicRequest::HarmonicEnabledEnumCase::kHarmonicEnabledRaw: {
          harmonic_enabled = static_cast<int32>(request->harmonic_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::HarmCfgHarmonicRequest::HarmonicEnabledEnumCase::HARMONIC_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for harmonic_enabled was not specified or out of range");
          break;
        }
      }

      float64 harmonic_measurement_interval = request->harmonic_measurement_interval();
      auto status = library_->HarmCfgHarmonic(instrument, selector_string, harmonic_order, harmonic_bandwidth, harmonic_enabled, harmonic_measurement_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmCfgHarmonicArray(::grpc::ServerContext* context, const HarmCfgHarmonicArrayRequest* request, HarmCfgHarmonicArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto harmonic_order = const_cast<int32*>(reinterpret_cast<const int32*>(request->harmonic_order().data()));
      auto harmonic_bandwidth = const_cast<float64*>(request->harmonic_bandwidth().data());
      auto harmonic_enabled_vector = std::vector<int32>();
      harmonic_enabled_vector.reserve(request->harmonic_enabled().size());
      std::transform(
        request->harmonic_enabled().begin(),
        request->harmonic_enabled().end(),
        std::back_inserter(harmonic_enabled_vector),
        [](auto x) { return x; });
      auto harmonic_enabled = harmonic_enabled_vector.data();

      auto harmonic_measurement_interval = const_cast<float64*>(request->harmonic_measurement_interval().data());
      auto number_of_elements_determine_from_sizes = std::array<int, 4>
      {
        request->harmonic_order_size(),
        request->harmonic_bandwidth_size(),
        request->harmonic_enabled_size(),
        request->harmonic_measurement_interval_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [harmonic_order, harmonic_bandwidth, harmonic_enabled, harmonic_measurement_interval] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        harmonic_order = request->harmonic_order_size() ? std::move(harmonic_order) : nullptr;
        harmonic_bandwidth = request->harmonic_bandwidth_size() ? std::move(harmonic_bandwidth) : nullptr;
        harmonic_enabled = request->harmonic_enabled_size() ? std::move(harmonic_enabled) : nullptr;
        harmonic_measurement_interval = request->harmonic_measurement_interval_size() ? std::move(harmonic_measurement_interval) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->HarmCfgHarmonicArray(instrument, selector_string, harmonic_order, harmonic_bandwidth, harmonic_enabled, harmonic_measurement_interval, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmCfgNumberOfHarmonics(::grpc::ServerContext* context, const HarmCfgNumberOfHarmonicsRequest* request, HarmCfgNumberOfHarmonicsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_harmonics = request->number_of_harmonics();
      auto status = library_->HarmCfgNumberOfHarmonics(instrument, selector_string, number_of_harmonics);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmFetchHarmonicMeasurement(::grpc::ServerContext* context, const HarmFetchHarmonicMeasurementRequest* request, HarmFetchHarmonicMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 average_relative_power {};
      float64 average_absolute_power {};
      float64 rbw {};
      float64 frequency {};
      auto status = library_->HarmFetchHarmonicMeasurement(instrument, selector_string, timeout, &average_relative_power, &average_absolute_power, &rbw, &frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_average_relative_power(average_relative_power);
      response->set_average_absolute_power(average_absolute_power);
      response->set_rbw(rbw);
      response->set_frequency(frequency);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmFetchHarmonicMeasurementArray(::grpc::ServerContext* context, const HarmFetchHarmonicMeasurementArrayRequest* request, HarmFetchHarmonicMeasurementArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->HarmFetchHarmonicMeasurementArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_average_relative_power()->Resize(actual_array_size, 0);
        float64* average_relative_power = response->mutable_average_relative_power()->mutable_data();
        response->mutable_average_absolute_power()->Resize(actual_array_size, 0);
        float64* average_absolute_power = response->mutable_average_absolute_power()->mutable_data();
        response->mutable_rbw()->Resize(actual_array_size, 0);
        float64* rbw = response->mutable_rbw()->mutable_data();
        response->mutable_frequency()->Resize(actual_array_size, 0);
        float64* frequency = response->mutable_frequency()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->HarmFetchHarmonicMeasurementArray(instrument, selector_string, timeout, average_relative_power, average_absolute_power, rbw, frequency, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_average_relative_power()->Resize(actual_array_size, 0);
        response->mutable_average_absolute_power()->Resize(actual_array_size, 0);
        response->mutable_rbw()->Resize(actual_array_size, 0);
        response->mutable_frequency()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmFetchHarmonicPowerTrace(::grpc::ServerContext* context, const HarmFetchHarmonicPowerTraceRequest* request, HarmFetchHarmonicPowerTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->HarmFetchHarmonicPowerTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_power()->Resize(actual_array_size, 0);
        float32* power = response->mutable_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->HarmFetchHarmonicPowerTrace(instrument, selector_string, timeout, &x0, &dx, power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmFetchTHD(::grpc::ServerContext* context, const HarmFetchTHDRequest* request, HarmFetchTHDResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 total_harmonic_distortion {};
      float64 average_fundamental_power {};
      float64 fundamental_frequency {};
      auto status = library_->HarmFetchTHD(instrument, selector_string, timeout, &total_harmonic_distortion, &average_fundamental_power, &fundamental_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_total_harmonic_distortion(total_harmonic_distortion);
      response->set_average_fundamental_power(average_fundamental_power);
      response->set_fundamental_frequency(fundamental_frequency);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::HarmRead(::grpc::ServerContext* context, const HarmReadRequest* request, HarmReadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 total_harmonic_distortion {};
      float64 average_fundamental_power {};
      auto status = library_->HarmRead(instrument, selector_string, timeout, &total_harmonic_distortion, &average_fundamental_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_total_harmonic_distortion(total_harmonic_distortion);
      response->set_average_fundamental_power(average_fundamental_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IDPDCfgEqualizerCoefficients(::grpc::ServerContext* context, const IDPDCfgEqualizerCoefficientsRequest* request, IDPDCfgEqualizerCoefficientsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 x0 = request->x0();
      float64 dx = request->dx();
      auto equalizer_coefficients = convert_from_grpc<NIComplexSingle>(request->equalizer_coefficients());
      int32 array_size = static_cast<int32>(request->equalizer_coefficients().size());
      auto status = library_->IDPDCfgEqualizerCoefficients(instrument, selector_string, x0, dx, equalizer_coefficients.data(), array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IDPDCfgPredistortedWaveform(::grpc::ServerContext* context, const IDPDCfgPredistortedWaveformRequest* request, IDPDCfgPredistortedWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 x0 = request->x0();
      float64 dx = request->dx();
      auto predistorted_waveform = convert_from_grpc<NIComplexSingle>(request->predistorted_waveform());
      int32 array_size = static_cast<int32>(request->predistorted_waveform().size());
      float64 target_gain = request->target_gain();
      auto status = library_->IDPDCfgPredistortedWaveform(instrument, selector_string, x0, dx, predistorted_waveform.data(), array_size, target_gain);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IDPDCfgReferenceWaveform(::grpc::ServerContext* context, const IDPDCfgReferenceWaveformRequest* request, IDPDCfgReferenceWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 x0 = request->x0();
      float64 dx = request->dx();
      auto reference_waveform = convert_from_grpc<NIComplexSingle>(request->reference_waveform());
      int32 array_size = static_cast<int32>(request->reference_waveform().size());
      int32 idle_duration_present = request->idle_duration_present();
      int32 signal_type = request->signal_type();
      auto status = library_->IDPDCfgReferenceWaveform(instrument, selector_string, x0, dx, reference_waveform.data(), array_size, idle_duration_present, signal_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IDPDFetchEqualizerCoefficients(::grpc::ServerContext* context, const IDPDFetchEqualizerCoefficientsRequest* request, IDPDFetchEqualizerCoefficientsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->IDPDFetchEqualizerCoefficients(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> equalizer_coefficients(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->IDPDFetchEqualizerCoefficients(instrument, selector_string, timeout, &x0, &dx, equalizer_coefficients.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        convert_to_grpc(equalizer_coefficients, response->mutable_equalizer_coefficients());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_equalizer_coefficients()->size();
          if (shrunk_size != current_size) {
            response->mutable_equalizer_coefficients()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IDPDFetchPredistortedWaveform(::grpc::ServerContext* context, const IDPDFetchPredistortedWaveformRequest* request, IDPDFetchPredistortedWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      float64 papr {};
      float64 power_offset {};
      float64 gain {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->IDPDFetchPredistortedWaveform(instrument, selector_string, timeout, &x0, &dx, nullptr, &papr, &power_offset, &gain, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> predistorted_waveform(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->IDPDFetchPredistortedWaveform(instrument, selector_string, timeout, &x0, &dx, predistorted_waveform.data(), &papr, &power_offset, &gain, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        convert_to_grpc(predistorted_waveform, response->mutable_predistorted_waveform());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_predistorted_waveform()->size();
          if (shrunk_size != current_size) {
            response->mutable_predistorted_waveform()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_papr(papr);
        response->set_power_offset(power_offset);
        response->set_gain(gain);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IDPDFetchProcessedMeanAcquiredWaveform(::grpc::ServerContext* context, const IDPDFetchProcessedMeanAcquiredWaveformRequest* request, IDPDFetchProcessedMeanAcquiredWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->IDPDFetchProcessedMeanAcquiredWaveform(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> processed_mean_acquired_waveform(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->IDPDFetchProcessedMeanAcquiredWaveform(instrument, selector_string, timeout, &x0, &dx, processed_mean_acquired_waveform.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        convert_to_grpc(processed_mean_acquired_waveform, response->mutable_processed_mean_acquired_waveform());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_processed_mean_acquired_waveform()->size();
          if (shrunk_size != current_size) {
            response->mutable_processed_mean_acquired_waveform()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IDPDFetchProcessedReferenceWaveform(::grpc::ServerContext* context, const IDPDFetchProcessedReferenceWaveformRequest* request, IDPDFetchProcessedReferenceWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->IDPDFetchProcessedReferenceWaveform(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> processed_reference_waveform(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->IDPDFetchProcessedReferenceWaveform(instrument, selector_string, timeout, &x0, &dx, processed_reference_waveform.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        convert_to_grpc(processed_reference_waveform, response->mutable_processed_reference_waveform());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_processed_reference_waveform()->size();
          if (shrunk_size != current_size) {
            response->mutable_processed_reference_waveform()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IDPDGetEqualizerReferenceWaveform(::grpc::ServerContext* context, const IDPDGetEqualizerReferenceWaveformRequest* request, IDPDGetEqualizerReferenceWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 x0 {};
      float64 dx {};
      float64 papr {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->IDPDGetEqualizerReferenceWaveform(instrument, selector_string, &x0, &dx, nullptr, &papr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> equalizer_reference_waveform(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->IDPDGetEqualizerReferenceWaveform(instrument, selector_string, &x0, &dx, equalizer_reference_waveform.data(), &papr, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        convert_to_grpc(equalizer_reference_waveform, response->mutable_equalizer_reference_waveform());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_equalizer_reference_waveform()->size();
          if (shrunk_size != current_size) {
            response->mutable_equalizer_reference_waveform()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_papr(papr);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgAutoIntermodsSetup(::grpc::ServerContext* context, const IMCfgAutoIntermodsSetupRequest* request, IMCfgAutoIntermodsSetupResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 auto_intermods_setup_enabled;
      switch (request->auto_intermods_setup_enabled_enum_case()) {
        case nirfmxspecan_grpc::IMCfgAutoIntermodsSetupRequest::AutoIntermodsSetupEnabledEnumCase::kAutoIntermodsSetupEnabled: {
          auto_intermods_setup_enabled = static_cast<int32>(request->auto_intermods_setup_enabled());
          break;
        }
        case nirfmxspecan_grpc::IMCfgAutoIntermodsSetupRequest::AutoIntermodsSetupEnabledEnumCase::kAutoIntermodsSetupEnabledRaw: {
          auto_intermods_setup_enabled = static_cast<int32>(request->auto_intermods_setup_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgAutoIntermodsSetupRequest::AutoIntermodsSetupEnabledEnumCase::AUTO_INTERMODS_SETUP_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for auto_intermods_setup_enabled was not specified or out of range");
          break;
        }
      }

      int32 maximum_intermod_order = request->maximum_intermod_order();
      auto status = library_->IMCfgAutoIntermodsSetup(instrument, selector_string, auto_intermods_setup_enabled, maximum_intermod_order);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgAveraging(::grpc::ServerContext* context, const IMCfgAveragingRequest* request, IMCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::IMCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::IMCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      int32 averaging_type;
      switch (request->averaging_type_enum_case()) {
        case nirfmxspecan_grpc::IMCfgAveragingRequest::AveragingTypeEnumCase::kAveragingType: {
          averaging_type = static_cast<int32>(request->averaging_type());
          break;
        }
        case nirfmxspecan_grpc::IMCfgAveragingRequest::AveragingTypeEnumCase::kAveragingTypeRaw: {
          averaging_type = static_cast<int32>(request->averaging_type_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgAveragingRequest::AveragingTypeEnumCase::AVERAGING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->IMCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count, averaging_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgFFT(::grpc::ServerContext* context, const IMCfgFFTRequest* request, IMCfgFFTResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 fft_window;
      switch (request->fft_window_enum_case()) {
        case nirfmxspecan_grpc::IMCfgFFTRequest::FftWindowEnumCase::kFftWindow: {
          fft_window = static_cast<int32>(request->fft_window());
          break;
        }
        case nirfmxspecan_grpc::IMCfgFFTRequest::FftWindowEnumCase::kFftWindowRaw: {
          fft_window = static_cast<int32>(request->fft_window_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgFFTRequest::FftWindowEnumCase::FFT_WINDOW_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fft_window was not specified or out of range");
          break;
        }
      }

      float64 fft_padding = request->fft_padding();
      auto status = library_->IMCfgFFT(instrument, selector_string, fft_window, fft_padding);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgFrequencyDefinition(::grpc::ServerContext* context, const IMCfgFrequencyDefinitionRequest* request, IMCfgFrequencyDefinitionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 frequency_definition;
      switch (request->frequency_definition_enum_case()) {
        case nirfmxspecan_grpc::IMCfgFrequencyDefinitionRequest::FrequencyDefinitionEnumCase::kFrequencyDefinition: {
          frequency_definition = static_cast<int32>(request->frequency_definition());
          break;
        }
        case nirfmxspecan_grpc::IMCfgFrequencyDefinitionRequest::FrequencyDefinitionEnumCase::kFrequencyDefinitionRaw: {
          frequency_definition = static_cast<int32>(request->frequency_definition_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgFrequencyDefinitionRequest::FrequencyDefinitionEnumCase::FREQUENCY_DEFINITION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for frequency_definition was not specified or out of range");
          break;
        }
      }

      auto status = library_->IMCfgFrequencyDefinition(instrument, selector_string, frequency_definition);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgFundamentalTones(::grpc::ServerContext* context, const IMCfgFundamentalTonesRequest* request, IMCfgFundamentalTonesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 lower_tone_frequency = request->lower_tone_frequency();
      float64 upper_tone_frequency = request->upper_tone_frequency();
      auto status = library_->IMCfgFundamentalTones(instrument, selector_string, lower_tone_frequency, upper_tone_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgIntermod(::grpc::ServerContext* context, const IMCfgIntermodRequest* request, IMCfgIntermodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 intermod_order = request->intermod_order();
      float64 lower_intermod_frequency = request->lower_intermod_frequency();
      float64 upper_intermod_frequency = request->upper_intermod_frequency();
      int32 intermod_side;
      switch (request->intermod_side_enum_case()) {
        case nirfmxspecan_grpc::IMCfgIntermodRequest::IntermodSideEnumCase::kIntermodSide: {
          intermod_side = static_cast<int32>(request->intermod_side());
          break;
        }
        case nirfmxspecan_grpc::IMCfgIntermodRequest::IntermodSideEnumCase::kIntermodSideRaw: {
          intermod_side = static_cast<int32>(request->intermod_side_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgIntermodRequest::IntermodSideEnumCase::INTERMOD_SIDE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for intermod_side was not specified or out of range");
          break;
        }
      }

      int32 intermod_enabled;
      switch (request->intermod_enabled_enum_case()) {
        case nirfmxspecan_grpc::IMCfgIntermodRequest::IntermodEnabledEnumCase::kIntermodEnabled: {
          intermod_enabled = static_cast<int32>(request->intermod_enabled());
          break;
        }
        case nirfmxspecan_grpc::IMCfgIntermodRequest::IntermodEnabledEnumCase::kIntermodEnabledRaw: {
          intermod_enabled = static_cast<int32>(request->intermod_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgIntermodRequest::IntermodEnabledEnumCase::INTERMOD_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for intermod_enabled was not specified or out of range");
          break;
        }
      }

      auto status = library_->IMCfgIntermod(instrument, selector_string, intermod_order, lower_intermod_frequency, upper_intermod_frequency, intermod_side, intermod_enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgIntermodArray(::grpc::ServerContext* context, const IMCfgIntermodArrayRequest* request, IMCfgIntermodArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto intermod_order = const_cast<int32*>(reinterpret_cast<const int32*>(request->intermod_order().data()));
      auto lower_intermod_frequency = const_cast<float64*>(request->lower_intermod_frequency().data());
      auto upper_intermod_frequency = const_cast<float64*>(request->upper_intermod_frequency().data());
      auto intermod_side_vector = std::vector<int32>();
      intermod_side_vector.reserve(request->intermod_side().size());
      std::transform(
        request->intermod_side().begin(),
        request->intermod_side().end(),
        std::back_inserter(intermod_side_vector),
        [](auto x) { return x; });
      auto intermod_side = intermod_side_vector.data();

      auto intermod_enabled_vector = std::vector<int32>();
      intermod_enabled_vector.reserve(request->intermod_enabled().size());
      std::transform(
        request->intermod_enabled().begin(),
        request->intermod_enabled().end(),
        std::back_inserter(intermod_enabled_vector),
        [](auto x) { return x; });
      auto intermod_enabled = intermod_enabled_vector.data();

      auto number_of_elements_determine_from_sizes = std::array<int, 5>
      {
        request->intermod_order_size(),
        request->lower_intermod_frequency_size(),
        request->upper_intermod_frequency_size(),
        request->intermod_side_size(),
        request->intermod_enabled_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [intermod_order, lower_intermod_frequency, upper_intermod_frequency, intermod_side, intermod_enabled] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        intermod_order = request->intermod_order_size() ? std::move(intermod_order) : nullptr;
        lower_intermod_frequency = request->lower_intermod_frequency_size() ? std::move(lower_intermod_frequency) : nullptr;
        upper_intermod_frequency = request->upper_intermod_frequency_size() ? std::move(upper_intermod_frequency) : nullptr;
        intermod_side = request->intermod_side_size() ? std::move(intermod_side) : nullptr;
        intermod_enabled = request->intermod_enabled_size() ? std::move(intermod_enabled) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->IMCfgIntermodArray(instrument, selector_string, intermod_order, lower_intermod_frequency, upper_intermod_frequency, intermod_side, intermod_enabled, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgMeasurementMethod(::grpc::ServerContext* context, const IMCfgMeasurementMethodRequest* request, IMCfgMeasurementMethodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 measurement_method;
      switch (request->measurement_method_enum_case()) {
        case nirfmxspecan_grpc::IMCfgMeasurementMethodRequest::MeasurementMethodEnumCase::kMeasurementMethod: {
          measurement_method = static_cast<int32>(request->measurement_method());
          break;
        }
        case nirfmxspecan_grpc::IMCfgMeasurementMethodRequest::MeasurementMethodEnumCase::kMeasurementMethodRaw: {
          measurement_method = static_cast<int32>(request->measurement_method_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgMeasurementMethodRequest::MeasurementMethodEnumCase::MEASUREMENT_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurement_method was not specified or out of range");
          break;
        }
      }

      auto status = library_->IMCfgMeasurementMethod(instrument, selector_string, measurement_method);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgNumberOfIntermods(::grpc::ServerContext* context, const IMCfgNumberOfIntermodsRequest* request, IMCfgNumberOfIntermodsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_intermods = request->number_of_intermods();
      auto status = library_->IMCfgNumberOfIntermods(instrument, selector_string, number_of_intermods);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgRBWFilter(::grpc::ServerContext* context, const IMCfgRBWFilterRequest* request, IMCfgRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rbw_auto;
      switch (request->rbw_auto_enum_case()) {
        case nirfmxspecan_grpc::IMCfgRBWFilterRequest::RbwAutoEnumCase::kRbwAuto: {
          rbw_auto = static_cast<int32>(request->rbw_auto());
          break;
        }
        case nirfmxspecan_grpc::IMCfgRBWFilterRequest::RbwAutoEnumCase::kRbwAutoRaw: {
          rbw_auto = static_cast<int32>(request->rbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgRBWFilterRequest::RbwAutoEnumCase::RBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_auto was not specified or out of range");
          break;
        }
      }

      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::IMCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::IMCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->IMCfgRBWFilter(instrument, selector_string, rbw_auto, rbw, rbw_filter_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMCfgSweepTime(::grpc::ServerContext* context, const IMCfgSweepTimeRequest* request, IMCfgSweepTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 sweep_time_auto;
      switch (request->sweep_time_auto_enum_case()) {
        case nirfmxspecan_grpc::IMCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAuto: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto());
          break;
        }
        case nirfmxspecan_grpc::IMCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAutoRaw: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::IMCfgSweepTimeRequest::SweepTimeAutoEnumCase::SWEEP_TIME_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sweep_time_auto was not specified or out of range");
          break;
        }
      }

      float64 sweep_time_interval = request->sweep_time_interval();
      auto status = library_->IMCfgSweepTime(instrument, selector_string, sweep_time_auto, sweep_time_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMFetchFundamentalMeasurement(::grpc::ServerContext* context, const IMFetchFundamentalMeasurementRequest* request, IMFetchFundamentalMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 lower_tone_power {};
      float64 upper_tone_power {};
      auto status = library_->IMFetchFundamentalMeasurement(instrument, selector_string, timeout, &lower_tone_power, &upper_tone_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_lower_tone_power(lower_tone_power);
      response->set_upper_tone_power(upper_tone_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMFetchInterceptPower(::grpc::ServerContext* context, const IMFetchInterceptPowerRequest* request, IMFetchInterceptPowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 intermod_order {};
      float64 worst_case_output_intercept_power {};
      float64 lower_output_intercept_power {};
      float64 upper_output_intercept_power {};
      auto status = library_->IMFetchInterceptPower(instrument, selector_string, timeout, &intermod_order, &worst_case_output_intercept_power, &lower_output_intercept_power, &upper_output_intercept_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_intermod_order(intermod_order);
      response->set_worst_case_output_intercept_power(worst_case_output_intercept_power);
      response->set_lower_output_intercept_power(lower_output_intercept_power);
      response->set_upper_output_intercept_power(upper_output_intercept_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMFetchInterceptPowerArray(::grpc::ServerContext* context, const IMFetchInterceptPowerArrayRequest* request, IMFetchInterceptPowerArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->IMFetchInterceptPowerArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_intermod_order()->Resize(actual_array_size, 0);
        int32* intermod_order = reinterpret_cast<int32*>(response->mutable_intermod_order()->mutable_data());
        response->mutable_worst_case_output_intercept_power()->Resize(actual_array_size, 0);
        float64* worst_case_output_intercept_power = response->mutable_worst_case_output_intercept_power()->mutable_data();
        response->mutable_lower_output_intercept_power()->Resize(actual_array_size, 0);
        float64* lower_output_intercept_power = response->mutable_lower_output_intercept_power()->mutable_data();
        response->mutable_upper_output_intercept_power()->Resize(actual_array_size, 0);
        float64* upper_output_intercept_power = response->mutable_upper_output_intercept_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->IMFetchInterceptPowerArray(instrument, selector_string, timeout, intermod_order, worst_case_output_intercept_power, lower_output_intercept_power, upper_output_intercept_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_intermod_order()->Resize(actual_array_size, 0);
        response->mutable_worst_case_output_intercept_power()->Resize(actual_array_size, 0);
        response->mutable_lower_output_intercept_power()->Resize(actual_array_size, 0);
        response->mutable_upper_output_intercept_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMFetchIntermodMeasurement(::grpc::ServerContext* context, const IMFetchIntermodMeasurementRequest* request, IMFetchIntermodMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 intermod_order {};
      float64 lower_intermod_power {};
      float64 upper_intermod_power {};
      auto status = library_->IMFetchIntermodMeasurement(instrument, selector_string, timeout, &intermod_order, &lower_intermod_power, &upper_intermod_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_intermod_order(intermod_order);
      response->set_lower_intermod_power(lower_intermod_power);
      response->set_upper_intermod_power(upper_intermod_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMFetchIntermodMeasurementArray(::grpc::ServerContext* context, const IMFetchIntermodMeasurementArrayRequest* request, IMFetchIntermodMeasurementArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->IMFetchIntermodMeasurementArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_intermod_order()->Resize(actual_array_size, 0);
        int32* intermod_order = reinterpret_cast<int32*>(response->mutable_intermod_order()->mutable_data());
        response->mutable_lower_intermod_power()->Resize(actual_array_size, 0);
        float64* lower_intermod_power = response->mutable_lower_intermod_power()->mutable_data();
        response->mutable_upper_intermod_power()->Resize(actual_array_size, 0);
        float64* upper_intermod_power = response->mutable_upper_intermod_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->IMFetchIntermodMeasurementArray(instrument, selector_string, timeout, intermod_order, lower_intermod_power, upper_intermod_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_intermod_order()->Resize(actual_array_size, 0);
        response->mutable_lower_intermod_power()->Resize(actual_array_size, 0);
        response->mutable_upper_intermod_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IMFetchSpectrum(::grpc::ServerContext* context, const IMFetchSpectrumRequest* request, IMFetchSpectrumResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 spectrum_index = request->spectrum_index();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->IMFetchSpectrum(instrument, selector_string, timeout, spectrum_index, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        float32* spectrum = response->mutable_spectrum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->IMFetchSpectrum(instrument, selector_string, timeout, spectrum_index, &x0, &dx, spectrum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IQCfgAcquisition(::grpc::ServerContext* context, const IQCfgAcquisitionRequest* request, IQCfgAcquisitionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 sample_rate = request->sample_rate();
      int32 number_of_records = request->number_of_records();
      float64 acquisition_time = request->acquisition_time();
      float64 pretrigger_time = request->pretrigger_time();
      auto status = library_->IQCfgAcquisition(instrument, selector_string, sample_rate, number_of_records, acquisition_time, pretrigger_time);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IQCfgBandwidth(::grpc::ServerContext* context, const IQCfgBandwidthRequest* request, IQCfgBandwidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 bandwidth_auto;
      switch (request->bandwidth_auto_enum_case()) {
        case nirfmxspecan_grpc::IQCfgBandwidthRequest::BandwidthAutoEnumCase::kBandwidthAuto: {
          bandwidth_auto = static_cast<int32>(request->bandwidth_auto());
          break;
        }
        case nirfmxspecan_grpc::IQCfgBandwidthRequest::BandwidthAutoEnumCase::kBandwidthAutoRaw: {
          bandwidth_auto = static_cast<int32>(request->bandwidth_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::IQCfgBandwidthRequest::BandwidthAutoEnumCase::BANDWIDTH_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for bandwidth_auto was not specified or out of range");
          break;
        }
      }

      float64 bandwidth = request->bandwidth();
      auto status = library_->IQCfgBandwidth(instrument, selector_string, bandwidth_auto, bandwidth);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IQFetchData(::grpc::ServerContext* context, const IQFetchDataRequest* request, IQFetchDataResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 record_to_fetch = request->record_to_fetch();
      int64 samples_to_read = request->samples_to_read();
      float64 t0 {};
      float64 dt {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->IQFetchData(instrument, selector_string, timeout, record_to_fetch, samples_to_read, &t0, &dt, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        std::vector<NIComplexSingle> data(actual_array_size, NIComplexSingle());
        auto array_size = actual_array_size;
        status = library_->IQFetchData(instrument, selector_string, timeout, record_to_fetch, samples_to_read, &t0, &dt, data.data(), array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_t0(t0);
        response->set_dt(dt);
        convert_to_grpc(data, response->mutable_data());
        {
          auto shrunk_size = actual_array_size;
          auto current_size = response->mutable_data()->size();
          if (shrunk_size != current_size) {
            response->mutable_data()->DeleteSubrange(shrunk_size, current_size - shrunk_size);
          }
        }
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::IQGetRecordsDone(::grpc::ServerContext* context, const IQGetRecordsDoneRequest* request, IQGetRecordsDoneResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 records_done {};
      auto status = library_->IQGetRecordsDone(instrument, selector_string, &records_done);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_records_done(records_done);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::Initialize(::grpc::ServerContext* context, const InitializeRequest* request, InitializeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto resource_name_mbcs = convert_from_grpc<std::string>(request->resource_name());
      char* resource_name = (char*)resource_name_mbcs.c_str();
      auto option_string_mbcs = convert_from_grpc<std::string>(request->option_string());
      char* option_string = (char*)option_string_mbcs.c_str();
      auto initialization_behavior = request->initialization_behavior();

      int32 is_new_session {};
      bool new_session_initialized {};
      auto init_lambda = [&] () {
        niRFmxInstrHandle instrument;
        auto status = library_->Initialize(resource_name, option_string, &instrument, &is_new_session);
        return std::make_tuple(status, instrument);
      };
      std::string grpc_device_session_name = request->session_name();
      // Capture the library shared_ptr by value. Do not capture `this` or any references.
      LibrarySharedPtr library = library_;
      auto cleanup_lambda = [library] (niRFmxInstrHandle id) { library->Close(id, RFMXSPECAN_VAL_FALSE); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
      }
      response->set_status(status);
      response->mutable_instrument()->set_name(grpc_device_session_name);
      response->set_is_new_session(is_new_session);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::InitializeFromNIRFSASession(::grpc::ServerContext* context, const InitializeFromNIRFSASessionRequest* request, InitializeFromNIRFSASessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto nirfsa_session_grpc_session = request->nirfsa_session();
      uInt32 nirfsa_session = vi_session_resource_repository_->access_session(nirfsa_session_grpc_session.name());
      auto initialization_behavior = request->initialization_behavior();

      bool new_session_initialized {};
      auto init_lambda = [&] () {
        niRFmxInstrHandle instrument;
        auto status = library_->InitializeFromNIRFSASession(nirfsa_session, &instrument);
        return std::make_tuple(status, instrument);
      };
      std::string grpc_device_session_name = request->session_name();
      // Capture the library shared_ptr by value. Do not capture `this` or any references.
      LibrarySharedPtr library = library_;
      auto cleanup_lambda = [library] (niRFmxInstrHandle id) { library->Close(id, RFMXSPECAN_VAL_FALSE); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, initialization_behavior, &new_session_initialized);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, 0);
      }
      response->set_status(status);
      response->mutable_instrument()->set_name(grpc_device_session_name);
      response->set_new_session_initialized(new_session_initialized);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::Initiate(::grpc::ServerContext* context, const InitiateRequest* request, InitiateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto result_name_mbcs = convert_from_grpc<std::string>(request->result_name());
      char* result_name = (char*)result_name_mbcs.c_str();
      auto status = library_->Initiate(instrument, selector_string, result_name);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerCfgNumberOfMarkers(::grpc::ServerContext* context, const MarkerCfgNumberOfMarkersRequest* request, MarkerCfgNumberOfMarkersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_markers = request->number_of_markers();
      auto status = library_->MarkerCfgNumberOfMarkers(instrument, selector_string, number_of_markers);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerCfgPeakExcursion(::grpc::ServerContext* context, const MarkerCfgPeakExcursionRequest* request, MarkerCfgPeakExcursionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 peak_excursion_enabled;
      switch (request->peak_excursion_enabled_enum_case()) {
        case nirfmxspecan_grpc::MarkerCfgPeakExcursionRequest::PeakExcursionEnabledEnumCase::kPeakExcursionEnabled: {
          peak_excursion_enabled = static_cast<int32>(request->peak_excursion_enabled());
          break;
        }
        case nirfmxspecan_grpc::MarkerCfgPeakExcursionRequest::PeakExcursionEnabledEnumCase::kPeakExcursionEnabledRaw: {
          peak_excursion_enabled = static_cast<int32>(request->peak_excursion_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::MarkerCfgPeakExcursionRequest::PeakExcursionEnabledEnumCase::PEAK_EXCURSION_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for peak_excursion_enabled was not specified or out of range");
          break;
        }
      }

      float64 peak_excursion = request->peak_excursion();
      auto status = library_->MarkerCfgPeakExcursion(instrument, selector_string, peak_excursion_enabled, peak_excursion);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerCfgReferenceMarker(::grpc::ServerContext* context, const MarkerCfgReferenceMarkerRequest* request, MarkerCfgReferenceMarkerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 reference_marker = request->reference_marker();
      auto status = library_->MarkerCfgReferenceMarker(instrument, selector_string, reference_marker);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerCfgThreshold(::grpc::ServerContext* context, const MarkerCfgThresholdRequest* request, MarkerCfgThresholdResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 threshold_enabled;
      switch (request->threshold_enabled_enum_case()) {
        case nirfmxspecan_grpc::MarkerCfgThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabled: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled());
          break;
        }
        case nirfmxspecan_grpc::MarkerCfgThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabledRaw: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::MarkerCfgThresholdRequest::ThresholdEnabledEnumCase::THRESHOLD_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_enabled was not specified or out of range");
          break;
        }
      }

      float64 threshold = request->threshold();
      auto status = library_->MarkerCfgThreshold(instrument, selector_string, threshold_enabled, threshold);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerCfgTrace(::grpc::ServerContext* context, const MarkerCfgTraceRequest* request, MarkerCfgTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 trace;
      switch (request->trace_enum_case()) {
        case nirfmxspecan_grpc::MarkerCfgTraceRequest::TraceEnumCase::kTrace: {
          trace = static_cast<int32>(request->trace());
          break;
        }
        case nirfmxspecan_grpc::MarkerCfgTraceRequest::TraceEnumCase::kTraceRaw: {
          trace = static_cast<int32>(request->trace_raw());
          break;
        }
        case nirfmxspecan_grpc::MarkerCfgTraceRequest::TraceEnumCase::TRACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trace was not specified or out of range");
          break;
        }
      }

      auto status = library_->MarkerCfgTrace(instrument, selector_string, trace);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerCfgType(::grpc::ServerContext* context, const MarkerCfgTypeRequest* request, MarkerCfgTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 marker_type;
      switch (request->marker_type_enum_case()) {
        case nirfmxspecan_grpc::MarkerCfgTypeRequest::MarkerTypeEnumCase::kMarkerType: {
          marker_type = static_cast<int32>(request->marker_type());
          break;
        }
        case nirfmxspecan_grpc::MarkerCfgTypeRequest::MarkerTypeEnumCase::kMarkerTypeRaw: {
          marker_type = static_cast<int32>(request->marker_type_raw());
          break;
        }
        case nirfmxspecan_grpc::MarkerCfgTypeRequest::MarkerTypeEnumCase::MARKER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for marker_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->MarkerCfgType(instrument, selector_string, marker_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerCfgXLocation(::grpc::ServerContext* context, const MarkerCfgXLocationRequest* request, MarkerCfgXLocationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 marker_x_location = request->marker_x_location();
      auto status = library_->MarkerCfgXLocation(instrument, selector_string, marker_x_location);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerCfgYLocation(::grpc::ServerContext* context, const MarkerCfgYLocationRequest* request, MarkerCfgYLocationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 marker_y_location = request->marker_y_location();
      auto status = library_->MarkerCfgYLocation(instrument, selector_string, marker_y_location);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerFetchXY(::grpc::ServerContext* context, const MarkerFetchXYRequest* request, MarkerFetchXYResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 marker_x_location {};
      float64 marker_y_location {};
      auto status = library_->MarkerFetchXY(instrument, selector_string, &marker_x_location, &marker_y_location);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_marker_x_location(marker_x_location);
      response->set_marker_y_location(marker_y_location);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerNextPeak(::grpc::ServerContext* context, const MarkerNextPeakRequest* request, MarkerNextPeakResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 next_peak;
      switch (request->next_peak_enum_case()) {
        case nirfmxspecan_grpc::MarkerNextPeakRequest::NextPeakEnumCase::kNextPeak: {
          next_peak = static_cast<int32>(request->next_peak());
          break;
        }
        case nirfmxspecan_grpc::MarkerNextPeakRequest::NextPeakEnumCase::kNextPeakRaw: {
          next_peak = static_cast<int32>(request->next_peak_raw());
          break;
        }
        case nirfmxspecan_grpc::MarkerNextPeakRequest::NextPeakEnumCase::NEXT_PEAK_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for next_peak was not specified or out of range");
          break;
        }
      }

      int32 next_peak_found {};
      auto status = library_->MarkerNextPeak(instrument, selector_string, next_peak, &next_peak_found);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_next_peak_found(next_peak_found);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::MarkerPeakSearch(::grpc::ServerContext* context, const MarkerPeakSearchRequest* request, MarkerPeakSearchResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_peaks {};
      auto status = library_->MarkerPeakSearch(instrument, selector_string, &number_of_peaks);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_number_of_peaks(number_of_peaks);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgAveraging(::grpc::ServerContext* context, const NFCfgAveragingRequest* request, NFCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::NFCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::NFCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::NFCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      auto status = library_->NFCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgCalibrationLoss(::grpc::ServerContext* context, const NFCfgCalibrationLossRequest* request, NFCfgCalibrationLossResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 calibration_loss_compensation_enabled;
      switch (request->calibration_loss_compensation_enabled_enum_case()) {
        case nirfmxspecan_grpc::NFCfgCalibrationLossRequest::CalibrationLossCompensationEnabledEnumCase::kCalibrationLossCompensationEnabled: {
          calibration_loss_compensation_enabled = static_cast<int32>(request->calibration_loss_compensation_enabled());
          break;
        }
        case nirfmxspecan_grpc::NFCfgCalibrationLossRequest::CalibrationLossCompensationEnabledEnumCase::kCalibrationLossCompensationEnabledRaw: {
          calibration_loss_compensation_enabled = static_cast<int32>(request->calibration_loss_compensation_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::NFCfgCalibrationLossRequest::CalibrationLossCompensationEnabledEnumCase::CALIBRATION_LOSS_COMPENSATION_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for calibration_loss_compensation_enabled was not specified or out of range");
          break;
        }
      }

      auto calibration_loss_frequency = const_cast<float64*>(request->calibration_loss_frequency().data());
      auto calibration_loss = const_cast<float64*>(request->calibration_loss().data());
      float64 calibration_loss_temperature = request->calibration_loss_temperature();
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->calibration_loss_frequency_size(),
        request->calibration_loss_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, true);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [calibration_loss_frequency, calibration_loss] do not match");
      }
      // NULL out optional params with zero sizes.
      if (array_size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        calibration_loss_frequency = request->calibration_loss_frequency_size() ? std::move(calibration_loss_frequency) : nullptr;
        calibration_loss = request->calibration_loss_size() ? std::move(calibration_loss) : nullptr;
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->NFCfgCalibrationLoss(instrument, selector_string, calibration_loss_compensation_enabled, calibration_loss_frequency, calibration_loss, calibration_loss_temperature, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgColdSourceDUTSParameters(::grpc::ServerContext* context, const NFCfgColdSourceDUTSParametersRequest* request, NFCfgColdSourceDUTSParametersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto dut_s_parameters_frequency = const_cast<float64*>(request->dut_s_parameters_frequency().data());
      auto dut_s21 = const_cast<float64*>(request->dut_s21().data());
      auto dut_s12 = const_cast<float64*>(request->dut_s12().data());
      auto dut_s11 = const_cast<float64*>(request->dut_s11().data());
      auto dut_s22 = const_cast<float64*>(request->dut_s22().data());
      auto array_size_determine_from_sizes = std::array<int, 5>
      {
        request->dut_s_parameters_frequency_size(),
        request->dut_s21_size(),
        request->dut_s12_size(),
        request->dut_s11_size(),
        request->dut_s22_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, true);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [dut_s_parameters_frequency, dut_s21, dut_s12, dut_s11, dut_s22] do not match");
      }
      // NULL out optional params with zero sizes.
      if (array_size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        dut_s_parameters_frequency = request->dut_s_parameters_frequency_size() ? std::move(dut_s_parameters_frequency) : nullptr;
        dut_s21 = request->dut_s21_size() ? std::move(dut_s21) : nullptr;
        dut_s12 = request->dut_s12_size() ? std::move(dut_s12) : nullptr;
        dut_s11 = request->dut_s11_size() ? std::move(dut_s11) : nullptr;
        dut_s22 = request->dut_s22_size() ? std::move(dut_s22) : nullptr;
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->NFCfgColdSourceDUTSParameters(instrument, selector_string, dut_s_parameters_frequency, dut_s21, dut_s12, dut_s11, dut_s22, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgColdSourceInputTermination(::grpc::ServerContext* context, const NFCfgColdSourceInputTerminationRequest* request, NFCfgColdSourceInputTerminationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto termination_vswr = const_cast<float64*>(request->termination_vswr().data());
      auto termination_vswr_frequency = const_cast<float64*>(request->termination_vswr_frequency().data());
      float64 termination_temperature = request->termination_temperature();
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->termination_vswr_size(),
        request->termination_vswr_frequency_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, true);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [termination_vswr, termination_vswr_frequency] do not match");
      }
      // NULL out optional params with zero sizes.
      if (array_size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        termination_vswr = request->termination_vswr_size() ? std::move(termination_vswr) : nullptr;
        termination_vswr_frequency = request->termination_vswr_frequency_size() ? std::move(termination_vswr_frequency) : nullptr;
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->NFCfgColdSourceInputTermination(instrument, selector_string, termination_vswr, termination_vswr_frequency, termination_temperature, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgColdSourceMode(::grpc::ServerContext* context, const NFCfgColdSourceModeRequest* request, NFCfgColdSourceModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 cold_source_mode;
      switch (request->cold_source_mode_enum_case()) {
        case nirfmxspecan_grpc::NFCfgColdSourceModeRequest::ColdSourceModeEnumCase::kColdSourceMode: {
          cold_source_mode = static_cast<int32>(request->cold_source_mode());
          break;
        }
        case nirfmxspecan_grpc::NFCfgColdSourceModeRequest::ColdSourceModeEnumCase::kColdSourceModeRaw: {
          cold_source_mode = static_cast<int32>(request->cold_source_mode_raw());
          break;
        }
        case nirfmxspecan_grpc::NFCfgColdSourceModeRequest::ColdSourceModeEnumCase::COLD_SOURCE_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for cold_source_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->NFCfgColdSourceMode(instrument, selector_string, cold_source_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgDUTInputLoss(::grpc::ServerContext* context, const NFCfgDUTInputLossRequest* request, NFCfgDUTInputLossResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 dut_input_loss_compensation_enabled;
      switch (request->dut_input_loss_compensation_enabled_enum_case()) {
        case nirfmxspecan_grpc::NFCfgDUTInputLossRequest::DutInputLossCompensationEnabledEnumCase::kDutInputLossCompensationEnabled: {
          dut_input_loss_compensation_enabled = static_cast<int32>(request->dut_input_loss_compensation_enabled());
          break;
        }
        case nirfmxspecan_grpc::NFCfgDUTInputLossRequest::DutInputLossCompensationEnabledEnumCase::kDutInputLossCompensationEnabledRaw: {
          dut_input_loss_compensation_enabled = static_cast<int32>(request->dut_input_loss_compensation_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::NFCfgDUTInputLossRequest::DutInputLossCompensationEnabledEnumCase::DUT_INPUT_LOSS_COMPENSATION_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for dut_input_loss_compensation_enabled was not specified or out of range");
          break;
        }
      }

      auto dut_input_loss_frequency = const_cast<float64*>(request->dut_input_loss_frequency().data());
      auto dut_input_loss = const_cast<float64*>(request->dut_input_loss().data());
      float64 dut_input_loss_temperature = request->dut_input_loss_temperature();
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->dut_input_loss_frequency_size(),
        request->dut_input_loss_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, true);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [dut_input_loss_frequency, dut_input_loss] do not match");
      }
      // NULL out optional params with zero sizes.
      if (array_size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        dut_input_loss_frequency = request->dut_input_loss_frequency_size() ? std::move(dut_input_loss_frequency) : nullptr;
        dut_input_loss = request->dut_input_loss_size() ? std::move(dut_input_loss) : nullptr;
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->NFCfgDUTInputLoss(instrument, selector_string, dut_input_loss_compensation_enabled, dut_input_loss_frequency, dut_input_loss, dut_input_loss_temperature, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgDUTOutputLoss(::grpc::ServerContext* context, const NFCfgDUTOutputLossRequest* request, NFCfgDUTOutputLossResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 dut_output_loss_compensation_enabled;
      switch (request->dut_output_loss_compensation_enabled_enum_case()) {
        case nirfmxspecan_grpc::NFCfgDUTOutputLossRequest::DutOutputLossCompensationEnabledEnumCase::kDutOutputLossCompensationEnabled: {
          dut_output_loss_compensation_enabled = static_cast<int32>(request->dut_output_loss_compensation_enabled());
          break;
        }
        case nirfmxspecan_grpc::NFCfgDUTOutputLossRequest::DutOutputLossCompensationEnabledEnumCase::kDutOutputLossCompensationEnabledRaw: {
          dut_output_loss_compensation_enabled = static_cast<int32>(request->dut_output_loss_compensation_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::NFCfgDUTOutputLossRequest::DutOutputLossCompensationEnabledEnumCase::DUT_OUTPUT_LOSS_COMPENSATION_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for dut_output_loss_compensation_enabled was not specified or out of range");
          break;
        }
      }

      auto dut_output_loss_frequency = const_cast<float64*>(request->dut_output_loss_frequency().data());
      auto dut_output_loss = const_cast<float64*>(request->dut_output_loss().data());
      float64 dut_output_loss_temperature = request->dut_output_loss_temperature();
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->dut_output_loss_frequency_size(),
        request->dut_output_loss_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, true);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [dut_output_loss_frequency, dut_output_loss] do not match");
      }
      // NULL out optional params with zero sizes.
      if (array_size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        dut_output_loss_frequency = request->dut_output_loss_frequency_size() ? std::move(dut_output_loss_frequency) : nullptr;
        dut_output_loss = request->dut_output_loss_size() ? std::move(dut_output_loss) : nullptr;
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->NFCfgDUTOutputLoss(instrument, selector_string, dut_output_loss_compensation_enabled, dut_output_loss_frequency, dut_output_loss, dut_output_loss_temperature, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgFrequencyList(::grpc::ServerContext* context, const NFCfgFrequencyListRequest* request, NFCfgFrequencyListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto frequency_list = const_cast<float64*>(request->frequency_list().data());
      int32 array_size = static_cast<int32>(request->frequency_list().size());
      auto status = library_->NFCfgFrequencyList(instrument, selector_string, frequency_list, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgFrequencyListStartStopPoints(::grpc::ServerContext* context, const NFCfgFrequencyListStartStopPointsRequest* request, NFCfgFrequencyListStartStopPointsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 start_frequency = request->start_frequency();
      float64 stop_frequency = request->stop_frequency();
      int32 number_of_points = request->number_of_points();
      auto status = library_->NFCfgFrequencyListStartStopPoints(instrument, selector_string, start_frequency, stop_frequency, number_of_points);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgFrequencyListStartStopStep(::grpc::ServerContext* context, const NFCfgFrequencyListStartStopStepRequest* request, NFCfgFrequencyListStartStopStepResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 start_frequency = request->start_frequency();
      float64 stop_frequency = request->stop_frequency();
      float64 step_size = request->step_size();
      auto status = library_->NFCfgFrequencyListStartStopStep(instrument, selector_string, start_frequency, stop_frequency, step_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgMeasurementBandwidth(::grpc::ServerContext* context, const NFCfgMeasurementBandwidthRequest* request, NFCfgMeasurementBandwidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 measurement_bandwidth = request->measurement_bandwidth();
      auto status = library_->NFCfgMeasurementBandwidth(instrument, selector_string, measurement_bandwidth);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgMeasurementInterval(::grpc::ServerContext* context, const NFCfgMeasurementIntervalRequest* request, NFCfgMeasurementIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 measurement_interval = request->measurement_interval();
      auto status = library_->NFCfgMeasurementInterval(instrument, selector_string, measurement_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgMeasurementMethod(::grpc::ServerContext* context, const NFCfgMeasurementMethodRequest* request, NFCfgMeasurementMethodResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 measurement_method;
      switch (request->measurement_method_enum_case()) {
        case nirfmxspecan_grpc::NFCfgMeasurementMethodRequest::MeasurementMethodEnumCase::kMeasurementMethod: {
          measurement_method = static_cast<int32>(request->measurement_method());
          break;
        }
        case nirfmxspecan_grpc::NFCfgMeasurementMethodRequest::MeasurementMethodEnumCase::kMeasurementMethodRaw: {
          measurement_method = static_cast<int32>(request->measurement_method_raw());
          break;
        }
        case nirfmxspecan_grpc::NFCfgMeasurementMethodRequest::MeasurementMethodEnumCase::MEASUREMENT_METHOD_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurement_method was not specified or out of range");
          break;
        }
      }

      auto status = library_->NFCfgMeasurementMethod(instrument, selector_string, measurement_method);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgYFactorMode(::grpc::ServerContext* context, const NFCfgYFactorModeRequest* request, NFCfgYFactorModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 y_factor_mode;
      switch (request->y_factor_mode_enum_case()) {
        case nirfmxspecan_grpc::NFCfgYFactorModeRequest::YFactorModeEnumCase::kYFactorMode: {
          y_factor_mode = static_cast<int32>(request->y_factor_mode());
          break;
        }
        case nirfmxspecan_grpc::NFCfgYFactorModeRequest::YFactorModeEnumCase::kYFactorModeRaw: {
          y_factor_mode = static_cast<int32>(request->y_factor_mode_raw());
          break;
        }
        case nirfmxspecan_grpc::NFCfgYFactorModeRequest::YFactorModeEnumCase::Y_FACTOR_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for y_factor_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->NFCfgYFactorMode(instrument, selector_string, y_factor_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgYFactorNoiseSourceENR(::grpc::ServerContext* context, const NFCfgYFactorNoiseSourceENRRequest* request, NFCfgYFactorNoiseSourceENRResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto enr_frequency = const_cast<float64*>(request->enr_frequency().data());
      auto enr = const_cast<float64*>(request->enr().data());
      float64 cold_temperature = request->cold_temperature();
      float64 off_temperature = request->off_temperature();
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->enr_frequency_size(),
        request->enr_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, true);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [enr_frequency, enr] do not match");
      }
      // NULL out optional params with zero sizes.
      if (array_size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        enr_frequency = request->enr_frequency_size() ? std::move(enr_frequency) : nullptr;
        enr = request->enr_size() ? std::move(enr) : nullptr;
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->NFCfgYFactorNoiseSourceENR(instrument, selector_string, enr_frequency, enr, cold_temperature, off_temperature, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgYFactorNoiseSourceLoss(::grpc::ServerContext* context, const NFCfgYFactorNoiseSourceLossRequest* request, NFCfgYFactorNoiseSourceLossResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 noise_source_loss_compensation_enabled;
      switch (request->noise_source_loss_compensation_enabled_enum_case()) {
        case nirfmxspecan_grpc::NFCfgYFactorNoiseSourceLossRequest::NoiseSourceLossCompensationEnabledEnumCase::kNoiseSourceLossCompensationEnabled: {
          noise_source_loss_compensation_enabled = static_cast<int32>(request->noise_source_loss_compensation_enabled());
          break;
        }
        case nirfmxspecan_grpc::NFCfgYFactorNoiseSourceLossRequest::NoiseSourceLossCompensationEnabledEnumCase::kNoiseSourceLossCompensationEnabledRaw: {
          noise_source_loss_compensation_enabled = static_cast<int32>(request->noise_source_loss_compensation_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::NFCfgYFactorNoiseSourceLossRequest::NoiseSourceLossCompensationEnabledEnumCase::NOISE_SOURCE_LOSS_COMPENSATION_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for noise_source_loss_compensation_enabled was not specified or out of range");
          break;
        }
      }

      auto noise_source_loss_frequency = const_cast<float64*>(request->noise_source_loss_frequency().data());
      auto noise_source_loss = const_cast<float64*>(request->noise_source_loss().data());
      float64 noise_source_loss_temperature = request->noise_source_loss_temperature();
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->noise_source_loss_frequency_size(),
        request->noise_source_loss_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, true);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [noise_source_loss_frequency, noise_source_loss] do not match");
      }
      // NULL out optional params with zero sizes.
      if (array_size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        noise_source_loss_frequency = request->noise_source_loss_frequency_size() ? std::move(noise_source_loss_frequency) : nullptr;
        noise_source_loss = request->noise_source_loss_size() ? std::move(noise_source_loss) : nullptr;
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->NFCfgYFactorNoiseSourceLoss(instrument, selector_string, noise_source_loss_compensation_enabled, noise_source_loss_frequency, noise_source_loss, noise_source_loss_temperature, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFCfgYFactorNoiseSourceSettlingTime(::grpc::ServerContext* context, const NFCfgYFactorNoiseSourceSettlingTimeRequest* request, NFCfgYFactorNoiseSourceSettlingTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 settling_time = request->settling_time();
      auto status = library_->NFCfgYFactorNoiseSourceSettlingTime(instrument, selector_string, settling_time);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFClearCalibrationDatabase(::grpc::ServerContext* context, const NFClearCalibrationDatabaseRequest* request, NFClearCalibrationDatabaseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto calibration_setup_id_mbcs = convert_from_grpc<std::string>(request->calibration_setup_id());
      char* calibration_setup_id = (char*)calibration_setup_id_mbcs.c_str();
      auto status = library_->NFClearCalibrationDatabase(instrument, calibration_setup_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFFetchAnalyzerNoiseFigure(::grpc::ServerContext* context, const NFFetchAnalyzerNoiseFigureRequest* request, NFFetchAnalyzerNoiseFigureResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->NFFetchAnalyzerNoiseFigure(instrument, selector_string, timeout, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_analyzer_noise_figure()->Resize(actual_array_size, 0);
        float64* analyzer_noise_figure = response->mutable_analyzer_noise_figure()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->NFFetchAnalyzerNoiseFigure(instrument, selector_string, timeout, analyzer_noise_figure, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_analyzer_noise_figure()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFFetchColdSourcePower(::grpc::ServerContext* context, const NFFetchColdSourcePowerRequest* request, NFFetchColdSourcePowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->NFFetchColdSourcePower(instrument, selector_string, timeout, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_cold_source_power()->Resize(actual_array_size, 0);
        float64* cold_source_power = response->mutable_cold_source_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->NFFetchColdSourcePower(instrument, selector_string, timeout, cold_source_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_cold_source_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFFetchDUTNoiseFigureAndGain(::grpc::ServerContext* context, const NFFetchDUTNoiseFigureAndGainRequest* request, NFFetchDUTNoiseFigureAndGainResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->NFFetchDUTNoiseFigureAndGain(instrument, selector_string, timeout, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_dut_noise_figure()->Resize(actual_array_size, 0);
        float64* dut_noise_figure = response->mutable_dut_noise_figure()->mutable_data();
        response->mutable_dut_noise_temperature()->Resize(actual_array_size, 0);
        float64* dut_noise_temperature = response->mutable_dut_noise_temperature()->mutable_data();
        response->mutable_dut_gain()->Resize(actual_array_size, 0);
        float64* dut_gain = response->mutable_dut_gain()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->NFFetchDUTNoiseFigureAndGain(instrument, selector_string, timeout, dut_noise_figure, dut_noise_temperature, dut_gain, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_dut_noise_figure()->Resize(actual_array_size, 0);
        response->mutable_dut_noise_temperature()->Resize(actual_array_size, 0);
        response->mutable_dut_gain()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFFetchYFactorPowers(::grpc::ServerContext* context, const NFFetchYFactorPowersRequest* request, NFFetchYFactorPowersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->NFFetchYFactorPowers(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_hot_power()->Resize(actual_array_size, 0);
        float64* hot_power = response->mutable_hot_power()->mutable_data();
        response->mutable_cold_power()->Resize(actual_array_size, 0);
        float64* cold_power = response->mutable_cold_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->NFFetchYFactorPowers(instrument, selector_string, timeout, hot_power, cold_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_hot_power()->Resize(actual_array_size, 0);
        response->mutable_cold_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFFetchYFactors(::grpc::ServerContext* context, const NFFetchYFactorsRequest* request, NFFetchYFactorsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->NFFetchYFactors(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_measurement_y_factor()->Resize(actual_array_size, 0);
        float64* measurement_y_factor = response->mutable_measurement_y_factor()->mutable_data();
        response->mutable_calibration_y_factor()->Resize(actual_array_size, 0);
        float64* calibration_y_factor = response->mutable_calibration_y_factor()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->NFFetchYFactors(instrument, selector_string, timeout, measurement_y_factor, calibration_y_factor, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_measurement_y_factor()->Resize(actual_array_size, 0);
        response->mutable_calibration_y_factor()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFRecommendReferenceLevel(::grpc::ServerContext* context, const NFRecommendReferenceLevelRequest* request, NFRecommendReferenceLevelResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 dut_max_gain = request->dut_max_gain();
      float64 dut_max_noise_figure = request->dut_max_noise_figure();
      float64 reference_level {};
      auto status = library_->NFRecommendReferenceLevel(instrument, selector_string, dut_max_gain, dut_max_noise_figure, &reference_level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_reference_level(reference_level);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::NFValidateCalibrationData(::grpc::ServerContext* context, const NFValidateCalibrationDataRequest* request, NFValidateCalibrationDataResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 calibration_data_valid {};
      auto status = library_->NFValidateCalibrationData(instrument, selector_string, &calibration_data_valid);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_calibration_data_valid(static_cast<nirfmxspecan_grpc::NFCalibrationDataValid>(calibration_data_valid));
      response->set_calibration_data_valid_raw(calibration_data_valid);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::OBWCfgAveraging(::grpc::ServerContext* context, const OBWCfgAveragingRequest* request, OBWCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::OBWCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      int32 averaging_type;
      switch (request->averaging_type_enum_case()) {
        case nirfmxspecan_grpc::OBWCfgAveragingRequest::AveragingTypeEnumCase::kAveragingType: {
          averaging_type = static_cast<int32>(request->averaging_type());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgAveragingRequest::AveragingTypeEnumCase::kAveragingTypeRaw: {
          averaging_type = static_cast<int32>(request->averaging_type_raw());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgAveragingRequest::AveragingTypeEnumCase::AVERAGING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->OBWCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count, averaging_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::OBWCfgBandwidthPercentage(::grpc::ServerContext* context, const OBWCfgBandwidthPercentageRequest* request, OBWCfgBandwidthPercentageResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 bandwidth_percentage = request->bandwidth_percentage();
      auto status = library_->OBWCfgBandwidthPercentage(instrument, selector_string, bandwidth_percentage);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::OBWCfgFFT(::grpc::ServerContext* context, const OBWCfgFFTRequest* request, OBWCfgFFTResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 fft_window;
      switch (request->fft_window_enum_case()) {
        case nirfmxspecan_grpc::OBWCfgFFTRequest::FftWindowEnumCase::kFftWindow: {
          fft_window = static_cast<int32>(request->fft_window());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgFFTRequest::FftWindowEnumCase::kFftWindowRaw: {
          fft_window = static_cast<int32>(request->fft_window_raw());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgFFTRequest::FftWindowEnumCase::FFT_WINDOW_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fft_window was not specified or out of range");
          break;
        }
      }

      float64 fft_padding = request->fft_padding();
      auto status = library_->OBWCfgFFT(instrument, selector_string, fft_window, fft_padding);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::OBWCfgPowerUnits(::grpc::ServerContext* context, const OBWCfgPowerUnitsRequest* request, OBWCfgPowerUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 power_units;
      switch (request->power_units_enum_case()) {
        case nirfmxspecan_grpc::OBWCfgPowerUnitsRequest::PowerUnitsEnumCase::kPowerUnits: {
          power_units = static_cast<int32>(request->power_units());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgPowerUnitsRequest::PowerUnitsEnumCase::kPowerUnitsRaw: {
          power_units = static_cast<int32>(request->power_units_raw());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgPowerUnitsRequest::PowerUnitsEnumCase::POWER_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for power_units was not specified or out of range");
          break;
        }
      }

      auto status = library_->OBWCfgPowerUnits(instrument, selector_string, power_units);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::OBWCfgRBWFilter(::grpc::ServerContext* context, const OBWCfgRBWFilterRequest* request, OBWCfgRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rbw_auto;
      switch (request->rbw_auto_enum_case()) {
        case nirfmxspecan_grpc::OBWCfgRBWFilterRequest::RbwAutoEnumCase::kRbwAuto: {
          rbw_auto = static_cast<int32>(request->rbw_auto());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgRBWFilterRequest::RbwAutoEnumCase::kRbwAutoRaw: {
          rbw_auto = static_cast<int32>(request->rbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgRBWFilterRequest::RbwAutoEnumCase::RBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_auto was not specified or out of range");
          break;
        }
      }

      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::OBWCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->OBWCfgRBWFilter(instrument, selector_string, rbw_auto, rbw, rbw_filter_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::OBWCfgSpan(::grpc::ServerContext* context, const OBWCfgSpanRequest* request, OBWCfgSpanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 span = request->span();
      auto status = library_->OBWCfgSpan(instrument, selector_string, span);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::OBWCfgSweepTime(::grpc::ServerContext* context, const OBWCfgSweepTimeRequest* request, OBWCfgSweepTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 sweep_time_auto;
      switch (request->sweep_time_auto_enum_case()) {
        case nirfmxspecan_grpc::OBWCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAuto: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAutoRaw: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::OBWCfgSweepTimeRequest::SweepTimeAutoEnumCase::SWEEP_TIME_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sweep_time_auto was not specified or out of range");
          break;
        }
      }

      float64 sweep_time_interval = request->sweep_time_interval();
      auto status = library_->OBWCfgSweepTime(instrument, selector_string, sweep_time_auto, sweep_time_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::OBWFetchMeasurement(::grpc::ServerContext* context, const OBWFetchMeasurementRequest* request, OBWFetchMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 occupied_bandwidth {};
      float64 average_power {};
      float64 frequency_resolution {};
      float64 start_frequency {};
      float64 stop_frequency {};
      auto status = library_->OBWFetchMeasurement(instrument, selector_string, timeout, &occupied_bandwidth, &average_power, &frequency_resolution, &start_frequency, &stop_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_occupied_bandwidth(occupied_bandwidth);
      response->set_average_power(average_power);
      response->set_frequency_resolution(frequency_resolution);
      response->set_start_frequency(start_frequency);
      response->set_stop_frequency(stop_frequency);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::OBWFetchSpectrumTrace(::grpc::ServerContext* context, const OBWFetchSpectrumTraceRequest* request, OBWFetchSpectrumTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->OBWFetchSpectrumTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        float32* spectrum = response->mutable_spectrum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->OBWFetchSpectrumTrace(instrument, selector_string, timeout, &x0, &dx, spectrum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::OBWRead(::grpc::ServerContext* context, const OBWReadRequest* request, OBWReadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 occupied_bandwidth {};
      float64 average_power {};
      float64 frequency_resolution {};
      float64 start_frequency {};
      float64 stop_frequency {};
      auto status = library_->OBWRead(instrument, selector_string, timeout, &occupied_bandwidth, &average_power, &frequency_resolution, &start_frequency, &stop_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_occupied_bandwidth(occupied_bandwidth);
      response->set_average_power(average_power);
      response->set_frequency_resolution(frequency_resolution);
      response->set_start_frequency(start_frequency);
      response->set_stop_frequency(stop_frequency);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgMeasurementBandwidth(::grpc::ServerContext* context, const PAVTCfgMeasurementBandwidthRequest* request, PAVTCfgMeasurementBandwidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 measurement_bandwidth = request->measurement_bandwidth();
      auto status = library_->PAVTCfgMeasurementBandwidth(instrument, selector_string, measurement_bandwidth);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgMeasurementInterval(::grpc::ServerContext* context, const PAVTCfgMeasurementIntervalRequest* request, PAVTCfgMeasurementIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 measurement_offset = request->measurement_offset();
      float64 measurement_length = request->measurement_length();
      auto status = library_->PAVTCfgMeasurementInterval(instrument, selector_string, measurement_offset, measurement_length);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgMeasurementIntervalMode(::grpc::ServerContext* context, const PAVTCfgMeasurementIntervalModeRequest* request, PAVTCfgMeasurementIntervalModeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 measurement_interval_mode;
      switch (request->measurement_interval_mode_enum_case()) {
        case nirfmxspecan_grpc::PAVTCfgMeasurementIntervalModeRequest::MeasurementIntervalModeEnumCase::kMeasurementIntervalMode: {
          measurement_interval_mode = static_cast<int32>(request->measurement_interval_mode());
          break;
        }
        case nirfmxspecan_grpc::PAVTCfgMeasurementIntervalModeRequest::MeasurementIntervalModeEnumCase::kMeasurementIntervalModeRaw: {
          measurement_interval_mode = static_cast<int32>(request->measurement_interval_mode_raw());
          break;
        }
        case nirfmxspecan_grpc::PAVTCfgMeasurementIntervalModeRequest::MeasurementIntervalModeEnumCase::MEASUREMENT_INTERVAL_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurement_interval_mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->PAVTCfgMeasurementIntervalMode(instrument, selector_string, measurement_interval_mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgMeasurementLocationType(::grpc::ServerContext* context, const PAVTCfgMeasurementLocationTypeRequest* request, PAVTCfgMeasurementLocationTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 measurement_location_type;
      switch (request->measurement_location_type_enum_case()) {
        case nirfmxspecan_grpc::PAVTCfgMeasurementLocationTypeRequest::MeasurementLocationTypeEnumCase::kMeasurementLocationType: {
          measurement_location_type = static_cast<int32>(request->measurement_location_type());
          break;
        }
        case nirfmxspecan_grpc::PAVTCfgMeasurementLocationTypeRequest::MeasurementLocationTypeEnumCase::kMeasurementLocationTypeRaw: {
          measurement_location_type = static_cast<int32>(request->measurement_location_type_raw());
          break;
        }
        case nirfmxspecan_grpc::PAVTCfgMeasurementLocationTypeRequest::MeasurementLocationTypeEnumCase::MEASUREMENT_LOCATION_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurement_location_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->PAVTCfgMeasurementLocationType(instrument, selector_string, measurement_location_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgNumberOfSegments(::grpc::ServerContext* context, const PAVTCfgNumberOfSegmentsRequest* request, PAVTCfgNumberOfSegmentsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_segments = request->number_of_segments();
      auto status = library_->PAVTCfgNumberOfSegments(instrument, selector_string, number_of_segments);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgSegmentMeasurementInterval(::grpc::ServerContext* context, const PAVTCfgSegmentMeasurementIntervalRequest* request, PAVTCfgSegmentMeasurementIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 segment_measurement_offset = request->segment_measurement_offset();
      float64 segment_measurement_length = request->segment_measurement_length();
      auto status = library_->PAVTCfgSegmentMeasurementInterval(instrument, selector_string, segment_measurement_offset, segment_measurement_length);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgSegmentMeasurementIntervalArray(::grpc::ServerContext* context, const PAVTCfgSegmentMeasurementIntervalArrayRequest* request, PAVTCfgSegmentMeasurementIntervalArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto segment_measurement_offset = const_cast<float64*>(request->segment_measurement_offset().data());
      auto segment_measurement_length = const_cast<float64*>(request->segment_measurement_length().data());
      auto number_of_elements_determine_from_sizes = std::array<int, 2>
      {
        request->segment_measurement_offset_size(),
        request->segment_measurement_length_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [segment_measurement_offset, segment_measurement_length] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        segment_measurement_offset = request->segment_measurement_offset_size() ? std::move(segment_measurement_offset) : nullptr;
        segment_measurement_length = request->segment_measurement_length_size() ? std::move(segment_measurement_length) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->PAVTCfgSegmentMeasurementIntervalArray(instrument, selector_string, segment_measurement_offset, segment_measurement_length, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgSegmentStartTimeList(::grpc::ServerContext* context, const PAVTCfgSegmentStartTimeListRequest* request, PAVTCfgSegmentStartTimeListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto segment_start_time = const_cast<float64*>(request->segment_start_time().data());
      int32 number_of_elements = static_cast<int32>(request->segment_start_time().size());
      auto status = library_->PAVTCfgSegmentStartTimeList(instrument, selector_string, segment_start_time, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgSegmentStartTimeStep(::grpc::ServerContext* context, const PAVTCfgSegmentStartTimeStepRequest* request, PAVTCfgSegmentStartTimeStepResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_segments = request->number_of_segments();
      float64 segment0_start_time = request->segment0_start_time();
      float64 segment_interval = request->segment_interval();
      auto status = library_->PAVTCfgSegmentStartTimeStep(instrument, selector_string, number_of_segments, segment0_start_time, segment_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgSegmentType(::grpc::ServerContext* context, const PAVTCfgSegmentTypeRequest* request, PAVTCfgSegmentTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 segment_type;
      switch (request->segment_type_enum_case()) {
        case nirfmxspecan_grpc::PAVTCfgSegmentTypeRequest::SegmentTypeEnumCase::kSegmentType: {
          segment_type = static_cast<int32>(request->segment_type());
          break;
        }
        case nirfmxspecan_grpc::PAVTCfgSegmentTypeRequest::SegmentTypeEnumCase::kSegmentTypeRaw: {
          segment_type = static_cast<int32>(request->segment_type_raw());
          break;
        }
        case nirfmxspecan_grpc::PAVTCfgSegmentTypeRequest::SegmentTypeEnumCase::SEGMENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for segment_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->PAVTCfgSegmentType(instrument, selector_string, segment_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTCfgSegmentTypeArray(::grpc::ServerContext* context, const PAVTCfgSegmentTypeArrayRequest* request, PAVTCfgSegmentTypeArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto segment_type_vector = std::vector<int32>();
      segment_type_vector.reserve(request->segment_type().size());
      std::transform(
        request->segment_type().begin(),
        request->segment_type().end(),
        std::back_inserter(segment_type_vector),
        [](auto x) { return x; });
      auto segment_type = segment_type_vector.data();

      int32 number_of_elements = static_cast<int32>(request->segment_type().size());
      auto status = library_->PAVTCfgSegmentTypeArray(instrument, selector_string, segment_type, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTFetchAmplitudeTrace(::grpc::ServerContext* context, const PAVTFetchAmplitudeTraceRequest* request, PAVTFetchAmplitudeTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 trace_index = request->trace_index();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->PAVTFetchAmplitudeTrace(instrument, selector_string, timeout, trace_index, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_amplitude()->Resize(actual_array_size, 0);
        float32* amplitude = response->mutable_amplitude()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->PAVTFetchAmplitudeTrace(instrument, selector_string, timeout, trace_index, &x0, &dx, amplitude, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_amplitude()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTFetchPhaseAndAmplitude(::grpc::ServerContext* context, const PAVTFetchPhaseAndAmplitudeRequest* request, PAVTFetchPhaseAndAmplitudeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 mean_relative_phase {};
      float64 mean_relative_amplitude {};
      float64 mean_absolute_phase {};
      float64 mean_absolute_amplitude {};
      auto status = library_->PAVTFetchPhaseAndAmplitude(instrument, selector_string, timeout, &mean_relative_phase, &mean_relative_amplitude, &mean_absolute_phase, &mean_absolute_amplitude);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_mean_relative_phase(mean_relative_phase);
      response->set_mean_relative_amplitude(mean_relative_amplitude);
      response->set_mean_absolute_phase(mean_absolute_phase);
      response->set_mean_absolute_amplitude(mean_absolute_amplitude);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTFetchPhaseAndAmplitudeArray(::grpc::ServerContext* context, const PAVTFetchPhaseAndAmplitudeArrayRequest* request, PAVTFetchPhaseAndAmplitudeArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->PAVTFetchPhaseAndAmplitudeArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_mean_relative_phase()->Resize(actual_array_size, 0);
        float64* mean_relative_phase = response->mutable_mean_relative_phase()->mutable_data();
        response->mutable_mean_relative_amplitude()->Resize(actual_array_size, 0);
        float64* mean_relative_amplitude = response->mutable_mean_relative_amplitude()->mutable_data();
        response->mutable_mean_absolute_phase()->Resize(actual_array_size, 0);
        float64* mean_absolute_phase = response->mutable_mean_absolute_phase()->mutable_data();
        response->mutable_mean_absolute_amplitude()->Resize(actual_array_size, 0);
        float64* mean_absolute_amplitude = response->mutable_mean_absolute_amplitude()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->PAVTFetchPhaseAndAmplitudeArray(instrument, selector_string, timeout, mean_relative_phase, mean_relative_amplitude, mean_absolute_phase, mean_absolute_amplitude, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_mean_relative_phase()->Resize(actual_array_size, 0);
        response->mutable_mean_relative_amplitude()->Resize(actual_array_size, 0);
        response->mutable_mean_absolute_phase()->Resize(actual_array_size, 0);
        response->mutable_mean_absolute_amplitude()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PAVTFetchPhaseTrace(::grpc::ServerContext* context, const PAVTFetchPhaseTraceRequest* request, PAVTFetchPhaseTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 trace_index = request->trace_index();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->PAVTFetchPhaseTrace(instrument, selector_string, timeout, trace_index, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_phase()->Resize(actual_array_size, 0);
        float32* phase = response->mutable_phase()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->PAVTFetchPhaseTrace(instrument, selector_string, timeout, trace_index, &x0, &dx, phase, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_phase()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseCfgAutoRange(::grpc::ServerContext* context, const PhaseNoiseCfgAutoRangeRequest* request, PhaseNoiseCfgAutoRangeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 start_frequency = request->start_frequency();
      float64 stop_frequency = request->stop_frequency();
      float64 rbw_percentage = request->rbw_percentage();
      auto status = library_->PhaseNoiseCfgAutoRange(instrument, selector_string, start_frequency, stop_frequency, rbw_percentage);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseCfgAveragingMultiplier(::grpc::ServerContext* context, const PhaseNoiseCfgAveragingMultiplierRequest* request, PhaseNoiseCfgAveragingMultiplierResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_multiplier = request->averaging_multiplier();
      auto status = library_->PhaseNoiseCfgAveragingMultiplier(instrument, selector_string, averaging_multiplier);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseCfgCancellation(::grpc::ServerContext* context, const PhaseNoiseCfgCancellationRequest* request, PhaseNoiseCfgCancellationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 cancellation_enabled;
      switch (request->cancellation_enabled_enum_case()) {
        case nirfmxspecan_grpc::PhaseNoiseCfgCancellationRequest::CancellationEnabledEnumCase::kCancellationEnabled: {
          cancellation_enabled = static_cast<int32>(request->cancellation_enabled());
          break;
        }
        case nirfmxspecan_grpc::PhaseNoiseCfgCancellationRequest::CancellationEnabledEnumCase::kCancellationEnabledRaw: {
          cancellation_enabled = static_cast<int32>(request->cancellation_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::PhaseNoiseCfgCancellationRequest::CancellationEnabledEnumCase::CANCELLATION_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for cancellation_enabled was not specified or out of range");
          break;
        }
      }

      float64 cancellation_threshold = request->cancellation_threshold();
      auto frequency = const_cast<float32*>(request->frequency().data());
      auto reference_phase_noise = const_cast<float32*>(request->reference_phase_noise().data());
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->frequency_size(),
        request->reference_phase_noise_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, true);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [frequency, reference_phase_noise] do not match");
      }
      // NULL out optional params with zero sizes.
      if (array_size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        frequency = request->frequency_size() ? std::move(frequency) : nullptr;
        reference_phase_noise = request->reference_phase_noise_size() ? std::move(reference_phase_noise) : nullptr;
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->PhaseNoiseCfgCancellation(instrument, selector_string, cancellation_enabled, cancellation_threshold, frequency, reference_phase_noise, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseCfgIntegratedNoise(::grpc::ServerContext* context, const PhaseNoiseCfgIntegratedNoiseRequest* request, PhaseNoiseCfgIntegratedNoiseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 integrated_noise_range_definition;
      switch (request->integrated_noise_range_definition_enum_case()) {
        case nirfmxspecan_grpc::PhaseNoiseCfgIntegratedNoiseRequest::IntegratedNoiseRangeDefinitionEnumCase::kIntegratedNoiseRangeDefinition: {
          integrated_noise_range_definition = static_cast<int32>(request->integrated_noise_range_definition());
          break;
        }
        case nirfmxspecan_grpc::PhaseNoiseCfgIntegratedNoiseRequest::IntegratedNoiseRangeDefinitionEnumCase::kIntegratedNoiseRangeDefinitionRaw: {
          integrated_noise_range_definition = static_cast<int32>(request->integrated_noise_range_definition_raw());
          break;
        }
        case nirfmxspecan_grpc::PhaseNoiseCfgIntegratedNoiseRequest::IntegratedNoiseRangeDefinitionEnumCase::INTEGRATED_NOISE_RANGE_DEFINITION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for integrated_noise_range_definition was not specified or out of range");
          break;
        }
      }

      auto integrated_noise_start_frequency = const_cast<float64*>(request->integrated_noise_start_frequency().data());
      auto integrated_noise_stop_frequency = const_cast<float64*>(request->integrated_noise_stop_frequency().data());
      auto array_size_determine_from_sizes = std::array<int, 2>
      {
        request->integrated_noise_start_frequency_size(),
        request->integrated_noise_stop_frequency_size()
      };
      const auto array_size_size_calculation = calculate_linked_array_size(array_size_determine_from_sizes, true);

      if (array_size_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [integrated_noise_start_frequency, integrated_noise_stop_frequency] do not match");
      }
      // NULL out optional params with zero sizes.
      if (array_size_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        integrated_noise_start_frequency = request->integrated_noise_start_frequency_size() ? std::move(integrated_noise_start_frequency) : nullptr;
        integrated_noise_stop_frequency = request->integrated_noise_stop_frequency_size() ? std::move(integrated_noise_stop_frequency) : nullptr;
      }
      auto array_size = array_size_size_calculation.size;

      auto status = library_->PhaseNoiseCfgIntegratedNoise(instrument, selector_string, integrated_noise_range_definition, integrated_noise_start_frequency, integrated_noise_stop_frequency, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseCfgNumberOfRanges(::grpc::ServerContext* context, const PhaseNoiseCfgNumberOfRangesRequest* request, PhaseNoiseCfgNumberOfRangesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_ranges = request->number_of_ranges();
      auto status = library_->PhaseNoiseCfgNumberOfRanges(instrument, selector_string, number_of_ranges);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseCfgRangeArray(::grpc::ServerContext* context, const PhaseNoiseCfgRangeArrayRequest* request, PhaseNoiseCfgRangeArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto range_start_frequency = const_cast<float64*>(request->range_start_frequency().data());
      auto range_stop_frequency = const_cast<float64*>(request->range_stop_frequency().data());
      auto range_rbw_percentage = const_cast<float64*>(request->range_rbw_percentage().data());
      auto range_averaging_count = const_cast<int32*>(reinterpret_cast<const int32*>(request->range_averaging_count().data()));
      auto number_of_elements_determine_from_sizes = std::array<int, 4>
      {
        request->range_start_frequency_size(),
        request->range_stop_frequency_size(),
        request->range_rbw_percentage_size(),
        request->range_averaging_count_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [range_start_frequency, range_stop_frequency, range_rbw_percentage, range_averaging_count] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        range_start_frequency = request->range_start_frequency_size() ? std::move(range_start_frequency) : nullptr;
        range_stop_frequency = request->range_stop_frequency_size() ? std::move(range_stop_frequency) : nullptr;
        range_rbw_percentage = request->range_rbw_percentage_size() ? std::move(range_rbw_percentage) : nullptr;
        range_averaging_count = request->range_averaging_count_size() ? std::move(range_averaging_count) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->PhaseNoiseCfgRangeArray(instrument, selector_string, range_start_frequency, range_stop_frequency, range_rbw_percentage, range_averaging_count, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseCfgRangeDefinition(::grpc::ServerContext* context, const PhaseNoiseCfgRangeDefinitionRequest* request, PhaseNoiseCfgRangeDefinitionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 range_definition;
      switch (request->range_definition_enum_case()) {
        case nirfmxspecan_grpc::PhaseNoiseCfgRangeDefinitionRequest::RangeDefinitionEnumCase::kRangeDefinition: {
          range_definition = static_cast<int32>(request->range_definition());
          break;
        }
        case nirfmxspecan_grpc::PhaseNoiseCfgRangeDefinitionRequest::RangeDefinitionEnumCase::kRangeDefinitionRaw: {
          range_definition = static_cast<int32>(request->range_definition_raw());
          break;
        }
        case nirfmxspecan_grpc::PhaseNoiseCfgRangeDefinitionRequest::RangeDefinitionEnumCase::RANGE_DEFINITION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for range_definition was not specified or out of range");
          break;
        }
      }

      auto status = library_->PhaseNoiseCfgRangeDefinition(instrument, selector_string, range_definition);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseCfgSmoothing(::grpc::ServerContext* context, const PhaseNoiseCfgSmoothingRequest* request, PhaseNoiseCfgSmoothingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 smoothing_type;
      switch (request->smoothing_type_enum_case()) {
        case nirfmxspecan_grpc::PhaseNoiseCfgSmoothingRequest::SmoothingTypeEnumCase::kSmoothingType: {
          smoothing_type = static_cast<int32>(request->smoothing_type());
          break;
        }
        case nirfmxspecan_grpc::PhaseNoiseCfgSmoothingRequest::SmoothingTypeEnumCase::kSmoothingTypeRaw: {
          smoothing_type = static_cast<int32>(request->smoothing_type_raw());
          break;
        }
        case nirfmxspecan_grpc::PhaseNoiseCfgSmoothingRequest::SmoothingTypeEnumCase::SMOOTHING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for smoothing_type was not specified or out of range");
          break;
        }
      }

      float64 smoothing_percentage = request->smoothing_percentage();
      auto status = library_->PhaseNoiseCfgSmoothing(instrument, selector_string, smoothing_type, smoothing_percentage);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseCfgSpotNoiseFrequencyList(::grpc::ServerContext* context, const PhaseNoiseCfgSpotNoiseFrequencyListRequest* request, PhaseNoiseCfgSpotNoiseFrequencyListResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto frequency_list = const_cast<float64*>(request->frequency_list().data());
      int32 array_size = static_cast<int32>(request->frequency_list().size());
      auto status = library_->PhaseNoiseCfgSpotNoiseFrequencyList(instrument, selector_string, frequency_list, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseCfgSpurRemoval(::grpc::ServerContext* context, const PhaseNoiseCfgSpurRemovalRequest* request, PhaseNoiseCfgSpurRemovalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 spur_removal_enabled;
      switch (request->spur_removal_enabled_enum_case()) {
        case nirfmxspecan_grpc::PhaseNoiseCfgSpurRemovalRequest::SpurRemovalEnabledEnumCase::kSpurRemovalEnabled: {
          spur_removal_enabled = static_cast<int32>(request->spur_removal_enabled());
          break;
        }
        case nirfmxspecan_grpc::PhaseNoiseCfgSpurRemovalRequest::SpurRemovalEnabledEnumCase::kSpurRemovalEnabledRaw: {
          spur_removal_enabled = static_cast<int32>(request->spur_removal_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::PhaseNoiseCfgSpurRemovalRequest::SpurRemovalEnabledEnumCase::SPUR_REMOVAL_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for spur_removal_enabled was not specified or out of range");
          break;
        }
      }

      float64 peak_excursion = request->peak_excursion();
      auto status = library_->PhaseNoiseCfgSpurRemoval(instrument, selector_string, spur_removal_enabled, peak_excursion);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseFetchCarrierMeasurement(::grpc::ServerContext* context, const PhaseNoiseFetchCarrierMeasurementRequest* request, PhaseNoiseFetchCarrierMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 carrier_frequency {};
      float64 carrier_power {};
      auto status = library_->PhaseNoiseFetchCarrierMeasurement(instrument, selector_string, timeout, &carrier_frequency, &carrier_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_carrier_frequency(carrier_frequency);
      response->set_carrier_power(carrier_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseFetchIntegratedNoise(::grpc::ServerContext* context, const PhaseNoiseFetchIntegratedNoiseRequest* request, PhaseNoiseFetchIntegratedNoiseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->PhaseNoiseFetchIntegratedNoise(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_integrated_phase_noise()->Resize(actual_array_size, 0);
        float64* integrated_phase_noise = response->mutable_integrated_phase_noise()->mutable_data();
        response->mutable_residual_pm_in_radian()->Resize(actual_array_size, 0);
        float64* residual_pm_in_radian = response->mutable_residual_pm_in_radian()->mutable_data();
        response->mutable_residual_pm_in_degree()->Resize(actual_array_size, 0);
        float64* residual_pm_in_degree = response->mutable_residual_pm_in_degree()->mutable_data();
        response->mutable_residual_fm()->Resize(actual_array_size, 0);
        float64* residual_fm = response->mutable_residual_fm()->mutable_data();
        response->mutable_jitter()->Resize(actual_array_size, 0);
        float64* jitter = response->mutable_jitter()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->PhaseNoiseFetchIntegratedNoise(instrument, selector_string, timeout, integrated_phase_noise, residual_pm_in_radian, residual_pm_in_degree, residual_fm, jitter, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_integrated_phase_noise()->Resize(actual_array_size, 0);
        response->mutable_residual_pm_in_radian()->Resize(actual_array_size, 0);
        response->mutable_residual_pm_in_degree()->Resize(actual_array_size, 0);
        response->mutable_residual_fm()->Resize(actual_array_size, 0);
        response->mutable_jitter()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseFetchMeasuredLogPlotTrace(::grpc::ServerContext* context, const PhaseNoiseFetchMeasuredLogPlotTraceRequest* request, PhaseNoiseFetchMeasuredLogPlotTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->PhaseNoiseFetchMeasuredLogPlotTrace(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_frequency()->Resize(actual_array_size, 0);
        float32* frequency = response->mutable_frequency()->mutable_data();
        response->mutable_measured_phase_noise()->Resize(actual_array_size, 0);
        float32* measured_phase_noise = response->mutable_measured_phase_noise()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->PhaseNoiseFetchMeasuredLogPlotTrace(instrument, selector_string, timeout, frequency, measured_phase_noise, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_frequency()->Resize(actual_array_size, 0);
        response->mutable_measured_phase_noise()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseFetchSmoothedLogPlotTrace(::grpc::ServerContext* context, const PhaseNoiseFetchSmoothedLogPlotTraceRequest* request, PhaseNoiseFetchSmoothedLogPlotTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->PhaseNoiseFetchSmoothedLogPlotTrace(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_frequency()->Resize(actual_array_size, 0);
        float32* frequency = response->mutable_frequency()->mutable_data();
        response->mutable_smoothed_phase_noise()->Resize(actual_array_size, 0);
        float32* smoothed_phase_noise = response->mutable_smoothed_phase_noise()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->PhaseNoiseFetchSmoothedLogPlotTrace(instrument, selector_string, timeout, frequency, smoothed_phase_noise, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_frequency()->Resize(actual_array_size, 0);
        response->mutable_smoothed_phase_noise()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::PhaseNoiseFetchSpotNoise(::grpc::ServerContext* context, const PhaseNoiseFetchSpotNoiseRequest* request, PhaseNoiseFetchSpotNoiseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->PhaseNoiseFetchSpotNoise(instrument, selector_string, timeout, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_spot_phase_noise()->Resize(actual_array_size, 0);
        float64* spot_phase_noise = response->mutable_spot_phase_noise()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->PhaseNoiseFetchSpotNoise(instrument, selector_string, timeout, spot_phase_noise, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_spot_phase_noise()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ResetAttribute(::grpc::ServerContext* context, const ResetAttributeRequest* request, ResetAttributeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto status = library_->ResetAttribute(instrument, selector_string, attribute_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::ResetToDefault(::grpc::ServerContext* context, const ResetToDefaultRequest* request, ResetToDefaultResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto status = library_->ResetToDefault(instrument, selector_string);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgAveraging(::grpc::ServerContext* context, const SEMCfgAveragingRequest* request, SEMCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      int32 averaging_type;
      switch (request->averaging_type_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgAveragingRequest::AveragingTypeEnumCase::kAveragingType: {
          averaging_type = static_cast<int32>(request->averaging_type());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgAveragingRequest::AveragingTypeEnumCase::kAveragingTypeRaw: {
          averaging_type = static_cast<int32>(request->averaging_type_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgAveragingRequest::AveragingTypeEnumCase::AVERAGING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->SEMCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count, averaging_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgCarrierChannelBandwidth(::grpc::ServerContext* context, const SEMCfgCarrierChannelBandwidthRequest* request, SEMCfgCarrierChannelBandwidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 carrier_channel_bandwidth = request->carrier_channel_bandwidth();
      auto status = library_->SEMCfgCarrierChannelBandwidth(instrument, selector_string, carrier_channel_bandwidth);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgCarrierEnabled(::grpc::ServerContext* context, const SEMCfgCarrierEnabledRequest* request, SEMCfgCarrierEnabledResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 carrier_enabled;
      switch (request->carrier_enabled_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgCarrierEnabledRequest::CarrierEnabledEnumCase::kCarrierEnabled: {
          carrier_enabled = static_cast<int32>(request->carrier_enabled());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgCarrierEnabledRequest::CarrierEnabledEnumCase::kCarrierEnabledRaw: {
          carrier_enabled = static_cast<int32>(request->carrier_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgCarrierEnabledRequest::CarrierEnabledEnumCase::CARRIER_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for carrier_enabled was not specified or out of range");
          break;
        }
      }

      auto status = library_->SEMCfgCarrierEnabled(instrument, selector_string, carrier_enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgCarrierFrequency(::grpc::ServerContext* context, const SEMCfgCarrierFrequencyRequest* request, SEMCfgCarrierFrequencyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 carrier_frequency = request->carrier_frequency();
      auto status = library_->SEMCfgCarrierFrequency(instrument, selector_string, carrier_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgCarrierIntegrationBandwidth(::grpc::ServerContext* context, const SEMCfgCarrierIntegrationBandwidthRequest* request, SEMCfgCarrierIntegrationBandwidthResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 integration_bandwidth = request->integration_bandwidth();
      auto status = library_->SEMCfgCarrierIntegrationBandwidth(instrument, selector_string, integration_bandwidth);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgCarrierRBWFilter(::grpc::ServerContext* context, const SEMCfgCarrierRBWFilterRequest* request, SEMCfgCarrierRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rbw_auto;
      switch (request->rbw_auto_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgCarrierRBWFilterRequest::RbwAutoEnumCase::kRbwAuto: {
          rbw_auto = static_cast<int32>(request->rbw_auto());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgCarrierRBWFilterRequest::RbwAutoEnumCase::kRbwAutoRaw: {
          rbw_auto = static_cast<int32>(request->rbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgCarrierRBWFilterRequest::RbwAutoEnumCase::RBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_auto was not specified or out of range");
          break;
        }
      }

      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgCarrierRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgCarrierRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgCarrierRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->SEMCfgCarrierRBWFilter(instrument, selector_string, rbw_auto, rbw, rbw_filter_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgCarrierRRCFilter(::grpc::ServerContext* context, const SEMCfgCarrierRRCFilterRequest* request, SEMCfgCarrierRRCFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rrc_filter_enabled;
      switch (request->rrc_filter_enabled_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgCarrierRRCFilterRequest::RrcFilterEnabledEnumCase::kRrcFilterEnabled: {
          rrc_filter_enabled = static_cast<int32>(request->rrc_filter_enabled());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgCarrierRRCFilterRequest::RrcFilterEnabledEnumCase::kRrcFilterEnabledRaw: {
          rrc_filter_enabled = static_cast<int32>(request->rrc_filter_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgCarrierRRCFilterRequest::RrcFilterEnabledEnumCase::RRC_FILTER_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rrc_filter_enabled was not specified or out of range");
          break;
        }
      }

      float64 rrc_alpha = request->rrc_alpha();
      auto status = library_->SEMCfgCarrierRRCFilter(instrument, selector_string, rrc_filter_enabled, rrc_alpha);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgFFT(::grpc::ServerContext* context, const SEMCfgFFTRequest* request, SEMCfgFFTResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 fft_window;
      switch (request->fft_window_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgFFTRequest::FftWindowEnumCase::kFftWindow: {
          fft_window = static_cast<int32>(request->fft_window());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgFFTRequest::FftWindowEnumCase::kFftWindowRaw: {
          fft_window = static_cast<int32>(request->fft_window_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgFFTRequest::FftWindowEnumCase::FFT_WINDOW_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fft_window was not specified or out of range");
          break;
        }
      }

      float64 fft_padding = request->fft_padding();
      auto status = library_->SEMCfgFFT(instrument, selector_string, fft_window, fft_padding);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgNumberOfCarriers(::grpc::ServerContext* context, const SEMCfgNumberOfCarriersRequest* request, SEMCfgNumberOfCarriersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_carriers = request->number_of_carriers();
      auto status = library_->SEMCfgNumberOfCarriers(instrument, selector_string, number_of_carriers);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgNumberOfOffsets(::grpc::ServerContext* context, const SEMCfgNumberOfOffsetsRequest* request, SEMCfgNumberOfOffsetsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_offsets = request->number_of_offsets();
      auto status = library_->SEMCfgNumberOfOffsets(instrument, selector_string, number_of_offsets);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetAbsoluteLimit(::grpc::ServerContext* context, const SEMCfgOffsetAbsoluteLimitRequest* request, SEMCfgOffsetAbsoluteLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 absolute_limit_mode;
      switch (request->absolute_limit_mode_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgOffsetAbsoluteLimitRequest::AbsoluteLimitModeEnumCase::kAbsoluteLimitMode: {
          absolute_limit_mode = static_cast<int32>(request->absolute_limit_mode());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetAbsoluteLimitRequest::AbsoluteLimitModeEnumCase::kAbsoluteLimitModeRaw: {
          absolute_limit_mode = static_cast<int32>(request->absolute_limit_mode_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetAbsoluteLimitRequest::AbsoluteLimitModeEnumCase::ABSOLUTE_LIMIT_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for absolute_limit_mode was not specified or out of range");
          break;
        }
      }

      float64 absolute_limit_start = request->absolute_limit_start();
      float64 absolute_limit_stop = request->absolute_limit_stop();
      auto status = library_->SEMCfgOffsetAbsoluteLimit(instrument, selector_string, absolute_limit_mode, absolute_limit_start, absolute_limit_stop);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetAbsoluteLimitArray(::grpc::ServerContext* context, const SEMCfgOffsetAbsoluteLimitArrayRequest* request, SEMCfgOffsetAbsoluteLimitArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto absolute_limit_mode_vector = std::vector<int32>();
      absolute_limit_mode_vector.reserve(request->absolute_limit_mode().size());
      std::transform(
        request->absolute_limit_mode().begin(),
        request->absolute_limit_mode().end(),
        std::back_inserter(absolute_limit_mode_vector),
        [](auto x) { return x; });
      auto absolute_limit_mode = absolute_limit_mode_vector.data();

      auto absolute_limit_start = const_cast<float64*>(request->absolute_limit_start().data());
      auto absolute_limit_stop = const_cast<float64*>(request->absolute_limit_stop().data());
      auto number_of_elements_determine_from_sizes = std::array<int, 3>
      {
        request->absolute_limit_mode_size(),
        request->absolute_limit_start_size(),
        request->absolute_limit_stop_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [absolute_limit_mode, absolute_limit_start, absolute_limit_stop] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        absolute_limit_mode = request->absolute_limit_mode_size() ? std::move(absolute_limit_mode) : nullptr;
        absolute_limit_start = request->absolute_limit_start_size() ? std::move(absolute_limit_start) : nullptr;
        absolute_limit_stop = request->absolute_limit_stop_size() ? std::move(absolute_limit_stop) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SEMCfgOffsetAbsoluteLimitArray(instrument, selector_string, absolute_limit_mode, absolute_limit_start, absolute_limit_stop, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetBandwidthIntegral(::grpc::ServerContext* context, const SEMCfgOffsetBandwidthIntegralRequest* request, SEMCfgOffsetBandwidthIntegralResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 bandwidth_integral = request->bandwidth_integral();
      auto status = library_->SEMCfgOffsetBandwidthIntegral(instrument, selector_string, bandwidth_integral);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetFrequency(::grpc::ServerContext* context, const SEMCfgOffsetFrequencyRequest* request, SEMCfgOffsetFrequencyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 offset_start_frequency = request->offset_start_frequency();
      float64 offset_stop_frequency = request->offset_stop_frequency();
      int32 offset_enabled;
      switch (request->offset_enabled_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgOffsetFrequencyRequest::OffsetEnabledEnumCase::kOffsetEnabled: {
          offset_enabled = static_cast<int32>(request->offset_enabled());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetFrequencyRequest::OffsetEnabledEnumCase::kOffsetEnabledRaw: {
          offset_enabled = static_cast<int32>(request->offset_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetFrequencyRequest::OffsetEnabledEnumCase::OFFSET_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for offset_enabled was not specified or out of range");
          break;
        }
      }

      int32 offset_sideband;
      switch (request->offset_sideband_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgOffsetFrequencyRequest::OffsetSidebandEnumCase::kOffsetSideband: {
          offset_sideband = static_cast<int32>(request->offset_sideband());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetFrequencyRequest::OffsetSidebandEnumCase::kOffsetSidebandRaw: {
          offset_sideband = static_cast<int32>(request->offset_sideband_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetFrequencyRequest::OffsetSidebandEnumCase::OFFSET_SIDEBAND_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for offset_sideband was not specified or out of range");
          break;
        }
      }

      auto status = library_->SEMCfgOffsetFrequency(instrument, selector_string, offset_start_frequency, offset_stop_frequency, offset_enabled, offset_sideband);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetFrequencyArray(::grpc::ServerContext* context, const SEMCfgOffsetFrequencyArrayRequest* request, SEMCfgOffsetFrequencyArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto offset_start_frequency = const_cast<float64*>(request->offset_start_frequency().data());
      auto offset_stop_frequency = const_cast<float64*>(request->offset_stop_frequency().data());
      auto offset_enabled_vector = std::vector<int32>();
      offset_enabled_vector.reserve(request->offset_enabled().size());
      std::transform(
        request->offset_enabled().begin(),
        request->offset_enabled().end(),
        std::back_inserter(offset_enabled_vector),
        [](auto x) { return x; });
      auto offset_enabled = offset_enabled_vector.data();

      auto offset_sideband_vector = std::vector<int32>();
      offset_sideband_vector.reserve(request->offset_sideband().size());
      std::transform(
        request->offset_sideband().begin(),
        request->offset_sideband().end(),
        std::back_inserter(offset_sideband_vector),
        [](auto x) { return x; });
      auto offset_sideband = offset_sideband_vector.data();

      auto number_of_elements_determine_from_sizes = std::array<int, 4>
      {
        request->offset_start_frequency_size(),
        request->offset_stop_frequency_size(),
        request->offset_enabled_size(),
        request->offset_sideband_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [offset_start_frequency, offset_stop_frequency, offset_enabled, offset_sideband] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        offset_start_frequency = request->offset_start_frequency_size() ? std::move(offset_start_frequency) : nullptr;
        offset_stop_frequency = request->offset_stop_frequency_size() ? std::move(offset_stop_frequency) : nullptr;
        offset_enabled = request->offset_enabled_size() ? std::move(offset_enabled) : nullptr;
        offset_sideband = request->offset_sideband_size() ? std::move(offset_sideband) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SEMCfgOffsetFrequencyArray(instrument, selector_string, offset_start_frequency, offset_stop_frequency, offset_enabled, offset_sideband, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetFrequencyDefinition(::grpc::ServerContext* context, const SEMCfgOffsetFrequencyDefinitionRequest* request, SEMCfgOffsetFrequencyDefinitionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 offset_frequency_definition;
      switch (request->offset_frequency_definition_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgOffsetFrequencyDefinitionRequest::OffsetFrequencyDefinitionEnumCase::kOffsetFrequencyDefinition: {
          offset_frequency_definition = static_cast<int32>(request->offset_frequency_definition());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetFrequencyDefinitionRequest::OffsetFrequencyDefinitionEnumCase::kOffsetFrequencyDefinitionRaw: {
          offset_frequency_definition = static_cast<int32>(request->offset_frequency_definition_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetFrequencyDefinitionRequest::OffsetFrequencyDefinitionEnumCase::OFFSET_FREQUENCY_DEFINITION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for offset_frequency_definition was not specified or out of range");
          break;
        }
      }

      auto status = library_->SEMCfgOffsetFrequencyDefinition(instrument, selector_string, offset_frequency_definition);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetLimitFailMask(::grpc::ServerContext* context, const SEMCfgOffsetLimitFailMaskRequest* request, SEMCfgOffsetLimitFailMaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 limit_fail_mask;
      switch (request->limit_fail_mask_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgOffsetLimitFailMaskRequest::LimitFailMaskEnumCase::kLimitFailMask: {
          limit_fail_mask = static_cast<int32>(request->limit_fail_mask());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetLimitFailMaskRequest::LimitFailMaskEnumCase::kLimitFailMaskRaw: {
          limit_fail_mask = static_cast<int32>(request->limit_fail_mask_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetLimitFailMaskRequest::LimitFailMaskEnumCase::LIMIT_FAIL_MASK_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for limit_fail_mask was not specified or out of range");
          break;
        }
      }

      auto status = library_->SEMCfgOffsetLimitFailMask(instrument, selector_string, limit_fail_mask);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetRBWFilter(::grpc::ServerContext* context, const SEMCfgOffsetRBWFilterRequest* request, SEMCfgOffsetRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rbw_auto;
      switch (request->rbw_auto_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgOffsetRBWFilterRequest::RbwAutoEnumCase::kRbwAuto: {
          rbw_auto = static_cast<int32>(request->rbw_auto());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetRBWFilterRequest::RbwAutoEnumCase::kRbwAutoRaw: {
          rbw_auto = static_cast<int32>(request->rbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetRBWFilterRequest::RbwAutoEnumCase::RBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_auto was not specified or out of range");
          break;
        }
      }

      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgOffsetRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->SEMCfgOffsetRBWFilter(instrument, selector_string, rbw_auto, rbw, rbw_filter_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetRBWFilterArray(::grpc::ServerContext* context, const SEMCfgOffsetRBWFilterArrayRequest* request, SEMCfgOffsetRBWFilterArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto rbw_auto_vector = std::vector<int32>();
      rbw_auto_vector.reserve(request->rbw_auto().size());
      std::transform(
        request->rbw_auto().begin(),
        request->rbw_auto().end(),
        std::back_inserter(rbw_auto_vector),
        [](auto x) { return x; });
      auto rbw_auto = rbw_auto_vector.data();

      auto rbw = const_cast<float64*>(request->rbw().data());
      auto rbw_filter_type_vector = std::vector<int32>();
      rbw_filter_type_vector.reserve(request->rbw_filter_type().size());
      std::transform(
        request->rbw_filter_type().begin(),
        request->rbw_filter_type().end(),
        std::back_inserter(rbw_filter_type_vector),
        [](auto x) { return x; });
      auto rbw_filter_type = rbw_filter_type_vector.data();

      auto number_of_elements_determine_from_sizes = std::array<int, 3>
      {
        request->rbw_auto_size(),
        request->rbw_size(),
        request->rbw_filter_type_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [rbw_auto, rbw, rbw_filter_type] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        rbw_auto = request->rbw_auto_size() ? std::move(rbw_auto) : nullptr;
        rbw = request->rbw_size() ? std::move(rbw) : nullptr;
        rbw_filter_type = request->rbw_filter_type_size() ? std::move(rbw_filter_type) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SEMCfgOffsetRBWFilterArray(instrument, selector_string, rbw_auto, rbw, rbw_filter_type, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetRelativeAttenuation(::grpc::ServerContext* context, const SEMCfgOffsetRelativeAttenuationRequest* request, SEMCfgOffsetRelativeAttenuationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 relative_attenuation = request->relative_attenuation();
      auto status = library_->SEMCfgOffsetRelativeAttenuation(instrument, selector_string, relative_attenuation);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetRelativeAttenuationArray(::grpc::ServerContext* context, const SEMCfgOffsetRelativeAttenuationArrayRequest* request, SEMCfgOffsetRelativeAttenuationArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto relative_attenuation = const_cast<float64*>(request->relative_attenuation().data());
      int32 number_of_elements = static_cast<int32>(request->relative_attenuation().size());
      auto status = library_->SEMCfgOffsetRelativeAttenuationArray(instrument, selector_string, relative_attenuation, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetRelativeLimit(::grpc::ServerContext* context, const SEMCfgOffsetRelativeLimitRequest* request, SEMCfgOffsetRelativeLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 relative_limit_mode;
      switch (request->relative_limit_mode_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgOffsetRelativeLimitRequest::RelativeLimitModeEnumCase::kRelativeLimitMode: {
          relative_limit_mode = static_cast<int32>(request->relative_limit_mode());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetRelativeLimitRequest::RelativeLimitModeEnumCase::kRelativeLimitModeRaw: {
          relative_limit_mode = static_cast<int32>(request->relative_limit_mode_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgOffsetRelativeLimitRequest::RelativeLimitModeEnumCase::RELATIVE_LIMIT_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for relative_limit_mode was not specified or out of range");
          break;
        }
      }

      float64 relative_limit_start = request->relative_limit_start();
      float64 relative_limit_stop = request->relative_limit_stop();
      auto status = library_->SEMCfgOffsetRelativeLimit(instrument, selector_string, relative_limit_mode, relative_limit_start, relative_limit_stop);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgOffsetRelativeLimitArray(::grpc::ServerContext* context, const SEMCfgOffsetRelativeLimitArrayRequest* request, SEMCfgOffsetRelativeLimitArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto relative_limit_mode_vector = std::vector<int32>();
      relative_limit_mode_vector.reserve(request->relative_limit_mode().size());
      std::transform(
        request->relative_limit_mode().begin(),
        request->relative_limit_mode().end(),
        std::back_inserter(relative_limit_mode_vector),
        [](auto x) { return x; });
      auto relative_limit_mode = relative_limit_mode_vector.data();

      auto relative_limit_start = const_cast<float64*>(request->relative_limit_start().data());
      auto relative_limit_stop = const_cast<float64*>(request->relative_limit_stop().data());
      auto number_of_elements_determine_from_sizes = std::array<int, 3>
      {
        request->relative_limit_mode_size(),
        request->relative_limit_start_size(),
        request->relative_limit_stop_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [relative_limit_mode, relative_limit_start, relative_limit_stop] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        relative_limit_mode = request->relative_limit_mode_size() ? std::move(relative_limit_mode) : nullptr;
        relative_limit_start = request->relative_limit_start_size() ? std::move(relative_limit_start) : nullptr;
        relative_limit_stop = request->relative_limit_stop_size() ? std::move(relative_limit_stop) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SEMCfgOffsetRelativeLimitArray(instrument, selector_string, relative_limit_mode, relative_limit_start, relative_limit_stop, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgPowerUnits(::grpc::ServerContext* context, const SEMCfgPowerUnitsRequest* request, SEMCfgPowerUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 power_units;
      switch (request->power_units_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgPowerUnitsRequest::PowerUnitsEnumCase::kPowerUnits: {
          power_units = static_cast<int32>(request->power_units());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgPowerUnitsRequest::PowerUnitsEnumCase::kPowerUnitsRaw: {
          power_units = static_cast<int32>(request->power_units_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgPowerUnitsRequest::PowerUnitsEnumCase::POWER_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for power_units was not specified or out of range");
          break;
        }
      }

      auto status = library_->SEMCfgPowerUnits(instrument, selector_string, power_units);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgReferenceType(::grpc::ServerContext* context, const SEMCfgReferenceTypeRequest* request, SEMCfgReferenceTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 reference_type;
      switch (request->reference_type_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgReferenceTypeRequest::ReferenceTypeEnumCase::kReferenceType: {
          reference_type = static_cast<int32>(request->reference_type());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgReferenceTypeRequest::ReferenceTypeEnumCase::kReferenceTypeRaw: {
          reference_type = static_cast<int32>(request->reference_type_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgReferenceTypeRequest::ReferenceTypeEnumCase::REFERENCE_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for reference_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->SEMCfgReferenceType(instrument, selector_string, reference_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMCfgSweepTime(::grpc::ServerContext* context, const SEMCfgSweepTimeRequest* request, SEMCfgSweepTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 sweep_time_auto;
      switch (request->sweep_time_auto_enum_case()) {
        case nirfmxspecan_grpc::SEMCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAuto: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAutoRaw: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::SEMCfgSweepTimeRequest::SweepTimeAutoEnumCase::SWEEP_TIME_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sweep_time_auto was not specified or out of range");
          break;
        }
      }

      float64 sweep_time_interval = request->sweep_time_interval();
      auto status = library_->SEMCfgSweepTime(instrument, selector_string, sweep_time_auto, sweep_time_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchAbsoluteMaskTrace(::grpc::ServerContext* context, const SEMFetchAbsoluteMaskTraceRequest* request, SEMFetchAbsoluteMaskTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SEMFetchAbsoluteMaskTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_absolute_mask()->Resize(actual_array_size, 0);
        float32* absolute_mask = response->mutable_absolute_mask()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SEMFetchAbsoluteMaskTrace(instrument, selector_string, timeout, &x0, &dx, absolute_mask, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_absolute_mask()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchCarrierMeasurement(::grpc::ServerContext* context, const SEMFetchCarrierMeasurementRequest* request, SEMFetchCarrierMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 absolute_power {};
      float64 peak_absolute_power {};
      float64 peak_frequency {};
      float64 total_relative_power {};
      auto status = library_->SEMFetchCarrierMeasurement(instrument, selector_string, timeout, &absolute_power, &peak_absolute_power, &peak_frequency, &total_relative_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_absolute_power(absolute_power);
      response->set_peak_absolute_power(peak_absolute_power);
      response->set_peak_frequency(peak_frequency);
      response->set_total_relative_power(total_relative_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchCompositeMeasurementStatus(::grpc::ServerContext* context, const SEMFetchCompositeMeasurementStatusRequest* request, SEMFetchCompositeMeasurementStatusResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 composite_measurement_status {};
      auto status = library_->SEMFetchCompositeMeasurementStatus(instrument, selector_string, timeout, &composite_measurement_status);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_composite_measurement_status(static_cast<nirfmxspecan_grpc::SemCompositeMeasurementStatus>(composite_measurement_status));
      response->set_composite_measurement_status_raw(composite_measurement_status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchFrequencyResolution(::grpc::ServerContext* context, const SEMFetchFrequencyResolutionRequest* request, SEMFetchFrequencyResolutionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 frequency_resolution {};
      auto status = library_->SEMFetchFrequencyResolution(instrument, selector_string, timeout, &frequency_resolution);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_frequency_resolution(frequency_resolution);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchLowerOffsetMargin(::grpc::ServerContext* context, const SEMFetchLowerOffsetMarginRequest* request, SEMFetchLowerOffsetMarginResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 measurement_status {};
      float64 margin {};
      float64 margin_frequency {};
      float64 margin_absolute_power {};
      float64 margin_relative_power {};
      auto status = library_->SEMFetchLowerOffsetMargin(instrument, selector_string, timeout, &measurement_status, &margin, &margin_frequency, &margin_absolute_power, &margin_relative_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_measurement_status(static_cast<nirfmxspecan_grpc::SemLowerOffsetMeasurementStatus>(measurement_status));
      response->set_measurement_status_raw(measurement_status);
      response->set_margin(margin);
      response->set_margin_frequency(margin_frequency);
      response->set_margin_absolute_power(margin_absolute_power);
      response->set_margin_relative_power(margin_relative_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchLowerOffsetMarginArray(::grpc::ServerContext* context, const SEMFetchLowerOffsetMarginArrayRequest* request, SEMFetchLowerOffsetMarginArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SEMFetchLowerOffsetMarginArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_measurement_status_raw()->Resize(actual_array_size, 0);
        int32* measurement_status = reinterpret_cast<int32*>(response->mutable_measurement_status_raw()->mutable_data());
        response->mutable_margin()->Resize(actual_array_size, 0);
        float64* margin = response->mutable_margin()->mutable_data();
        response->mutable_margin_frequency()->Resize(actual_array_size, 0);
        float64* margin_frequency = response->mutable_margin_frequency()->mutable_data();
        response->mutable_margin_absolute_power()->Resize(actual_array_size, 0);
        float64* margin_absolute_power = response->mutable_margin_absolute_power()->mutable_data();
        response->mutable_margin_relative_power()->Resize(actual_array_size, 0);
        float64* margin_relative_power = response->mutable_margin_relative_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SEMFetchLowerOffsetMarginArray(instrument, selector_string, timeout, measurement_status, margin, margin_frequency, margin_absolute_power, margin_relative_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
          response->mutable_measurement_status()->Clear();
          response->mutable_measurement_status()->Reserve(actual_array_size);
          std::transform(
            response->measurement_status_raw().begin(),
            response->measurement_status_raw().begin() + actual_array_size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_measurement_status()),
            [&](auto x) {
                return static_cast<nirfmxspecan_grpc::SemLowerOffsetMeasurementStatus>(x);
            });
        response->mutable_measurement_status()->Resize(actual_array_size, 0);
        response->mutable_margin()->Resize(actual_array_size, 0);
        response->mutable_margin_frequency()->Resize(actual_array_size, 0);
        response->mutable_margin_absolute_power()->Resize(actual_array_size, 0);
        response->mutable_margin_relative_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchLowerOffsetPower(::grpc::ServerContext* context, const SEMFetchLowerOffsetPowerRequest* request, SEMFetchLowerOffsetPowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 total_absolute_power {};
      float64 total_relative_power {};
      float64 peak_absolute_power {};
      float64 peak_frequency {};
      float64 peak_relative_power {};
      auto status = library_->SEMFetchLowerOffsetPower(instrument, selector_string, timeout, &total_absolute_power, &total_relative_power, &peak_absolute_power, &peak_frequency, &peak_relative_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_total_absolute_power(total_absolute_power);
      response->set_total_relative_power(total_relative_power);
      response->set_peak_absolute_power(peak_absolute_power);
      response->set_peak_frequency(peak_frequency);
      response->set_peak_relative_power(peak_relative_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchLowerOffsetPowerArray(::grpc::ServerContext* context, const SEMFetchLowerOffsetPowerArrayRequest* request, SEMFetchLowerOffsetPowerArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SEMFetchLowerOffsetPowerArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_total_absolute_power()->Resize(actual_array_size, 0);
        float64* total_absolute_power = response->mutable_total_absolute_power()->mutable_data();
        response->mutable_total_relative_power()->Resize(actual_array_size, 0);
        float64* total_relative_power = response->mutable_total_relative_power()->mutable_data();
        response->mutable_peak_absolute_power()->Resize(actual_array_size, 0);
        float64* peak_absolute_power = response->mutable_peak_absolute_power()->mutable_data();
        response->mutable_peak_frequency()->Resize(actual_array_size, 0);
        float64* peak_frequency = response->mutable_peak_frequency()->mutable_data();
        response->mutable_peak_relative_power()->Resize(actual_array_size, 0);
        float64* peak_relative_power = response->mutable_peak_relative_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SEMFetchLowerOffsetPowerArray(instrument, selector_string, timeout, total_absolute_power, total_relative_power, peak_absolute_power, peak_frequency, peak_relative_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_total_absolute_power()->Resize(actual_array_size, 0);
        response->mutable_total_relative_power()->Resize(actual_array_size, 0);
        response->mutable_peak_absolute_power()->Resize(actual_array_size, 0);
        response->mutable_peak_frequency()->Resize(actual_array_size, 0);
        response->mutable_peak_relative_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchRelativeMaskTrace(::grpc::ServerContext* context, const SEMFetchRelativeMaskTraceRequest* request, SEMFetchRelativeMaskTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SEMFetchRelativeMaskTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_relative_mask()->Resize(actual_array_size, 0);
        float32* relative_mask = response->mutable_relative_mask()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SEMFetchRelativeMaskTrace(instrument, selector_string, timeout, &x0, &dx, relative_mask, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_relative_mask()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchSpectrum(::grpc::ServerContext* context, const SEMFetchSpectrumRequest* request, SEMFetchSpectrumResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SEMFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        float32* spectrum = response->mutable_spectrum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SEMFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, spectrum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchTotalCarrierPower(::grpc::ServerContext* context, const SEMFetchTotalCarrierPowerRequest* request, SEMFetchTotalCarrierPowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 total_carrier_power {};
      auto status = library_->SEMFetchTotalCarrierPower(instrument, selector_string, timeout, &total_carrier_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_total_carrier_power(total_carrier_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchUpperOffsetMargin(::grpc::ServerContext* context, const SEMFetchUpperOffsetMarginRequest* request, SEMFetchUpperOffsetMarginResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 measurement_status {};
      float64 margin {};
      float64 margin_frequency {};
      float64 margin_absolute_power {};
      float64 margin_relative_power {};
      auto status = library_->SEMFetchUpperOffsetMargin(instrument, selector_string, timeout, &measurement_status, &margin, &margin_frequency, &margin_absolute_power, &margin_relative_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_measurement_status(static_cast<nirfmxspecan_grpc::SemUpperOffsetMeasurementStatus>(measurement_status));
      response->set_measurement_status_raw(measurement_status);
      response->set_margin(margin);
      response->set_margin_frequency(margin_frequency);
      response->set_margin_absolute_power(margin_absolute_power);
      response->set_margin_relative_power(margin_relative_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchUpperOffsetMarginArray(::grpc::ServerContext* context, const SEMFetchUpperOffsetMarginArrayRequest* request, SEMFetchUpperOffsetMarginArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SEMFetchUpperOffsetMarginArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_measurement_status_raw()->Resize(actual_array_size, 0);
        int32* measurement_status = reinterpret_cast<int32*>(response->mutable_measurement_status_raw()->mutable_data());
        response->mutable_margin()->Resize(actual_array_size, 0);
        float64* margin = response->mutable_margin()->mutable_data();
        response->mutable_margin_frequency()->Resize(actual_array_size, 0);
        float64* margin_frequency = response->mutable_margin_frequency()->mutable_data();
        response->mutable_margin_absolute_power()->Resize(actual_array_size, 0);
        float64* margin_absolute_power = response->mutable_margin_absolute_power()->mutable_data();
        response->mutable_margin_relative_power()->Resize(actual_array_size, 0);
        float64* margin_relative_power = response->mutable_margin_relative_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SEMFetchUpperOffsetMarginArray(instrument, selector_string, timeout, measurement_status, margin, margin_frequency, margin_absolute_power, margin_relative_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
          response->mutable_measurement_status()->Clear();
          response->mutable_measurement_status()->Reserve(actual_array_size);
          std::transform(
            response->measurement_status_raw().begin(),
            response->measurement_status_raw().begin() + actual_array_size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_measurement_status()),
            [&](auto x) {
                return static_cast<nirfmxspecan_grpc::SemUpperOffsetMeasurementStatus>(x);
            });
        response->mutable_measurement_status()->Resize(actual_array_size, 0);
        response->mutable_margin()->Resize(actual_array_size, 0);
        response->mutable_margin_frequency()->Resize(actual_array_size, 0);
        response->mutable_margin_absolute_power()->Resize(actual_array_size, 0);
        response->mutable_margin_relative_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchUpperOffsetPower(::grpc::ServerContext* context, const SEMFetchUpperOffsetPowerRequest* request, SEMFetchUpperOffsetPowerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 total_absolute_power {};
      float64 total_relative_power {};
      float64 peak_absolute_power {};
      float64 peak_frequency {};
      float64 peak_relative_power {};
      auto status = library_->SEMFetchUpperOffsetPower(instrument, selector_string, timeout, &total_absolute_power, &total_relative_power, &peak_absolute_power, &peak_frequency, &peak_relative_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_total_absolute_power(total_absolute_power);
      response->set_total_relative_power(total_relative_power);
      response->set_peak_absolute_power(peak_absolute_power);
      response->set_peak_frequency(peak_frequency);
      response->set_peak_relative_power(peak_relative_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SEMFetchUpperOffsetPowerArray(::grpc::ServerContext* context, const SEMFetchUpperOffsetPowerArrayRequest* request, SEMFetchUpperOffsetPowerArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SEMFetchUpperOffsetPowerArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_total_absolute_power()->Resize(actual_array_size, 0);
        float64* total_absolute_power = response->mutable_total_absolute_power()->mutable_data();
        response->mutable_total_relative_power()->Resize(actual_array_size, 0);
        float64* total_relative_power = response->mutable_total_relative_power()->mutable_data();
        response->mutable_peak_absolute_power()->Resize(actual_array_size, 0);
        float64* peak_absolute_power = response->mutable_peak_absolute_power()->mutable_data();
        response->mutable_peak_frequency()->Resize(actual_array_size, 0);
        float64* peak_frequency = response->mutable_peak_frequency()->mutable_data();
        response->mutable_peak_relative_power()->Resize(actual_array_size, 0);
        float64* peak_relative_power = response->mutable_peak_relative_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SEMFetchUpperOffsetPowerArray(instrument, selector_string, timeout, total_absolute_power, total_relative_power, peak_absolute_power, peak_frequency, peak_relative_power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_total_absolute_power()->Resize(actual_array_size, 0);
        response->mutable_total_relative_power()->Resize(actual_array_size, 0);
        response->mutable_peak_absolute_power()->Resize(actual_array_size, 0);
        response->mutable_peak_frequency()->Resize(actual_array_size, 0);
        response->mutable_peak_relative_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SelectMeasurements(::grpc::ServerContext* context, const SelectMeasurementsRequest* request, SelectMeasurementsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      uInt32 measurements;
      switch (request->measurements_enum_case()) {
        case nirfmxspecan_grpc::SelectMeasurementsRequest::MeasurementsEnumCase::kMeasurements: {
          measurements = static_cast<uInt32>(request->measurements());
          break;
        }
        case nirfmxspecan_grpc::SelectMeasurementsRequest::MeasurementsEnumCase::kMeasurementsRaw: {
          measurements = static_cast<uInt32>(request->measurements_raw());
          break;
        }
        case nirfmxspecan_grpc::SelectMeasurementsRequest::MeasurementsEnumCase::MEASUREMENTS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for measurements was not specified or out of range");
          break;
        }
      }

      int32 enable_all_traces = request->enable_all_traces();
      auto status = library_->SelectMeasurements(instrument, selector_string, measurements, enable_all_traces);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SendSoftwareEdgeTrigger(::grpc::ServerContext* context, const SendSoftwareEdgeTriggerRequest* request, SendSoftwareEdgeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto status = library_->SendSoftwareEdgeTrigger(instrument);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeF32(::grpc::ServerContext* context, const SetAttributeF32Request* request, SetAttributeF32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      float32 attr_val = request->attr_val();
      auto status = library_->SetAttributeF32(instrument, selector_string, attribute_id, attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeF32Array(::grpc::ServerContext* context, const SetAttributeF32ArrayRequest* request, SetAttributeF32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = const_cast<float32*>(request->attr_val().data());
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeF32Array(instrument, selector_string, attribute_id, attr_val, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeF64(::grpc::ServerContext* context, const SetAttributeF64Request* request, SetAttributeF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      float64 attr_val = request->attr_val();
      auto status = library_->SetAttributeF64(instrument, selector_string, attribute_id, attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeF64Array(::grpc::ServerContext* context, const SetAttributeF64ArrayRequest* request, SetAttributeF64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = const_cast<float64*>(request->attr_val().data());
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeF64Array(instrument, selector_string, attribute_id, attr_val, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeI16(::grpc::ServerContext* context, const SetAttributeI16Request* request, SetAttributeI16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val_raw = request->attr_val();
      if (attr_val_raw < std::numeric_limits<int16>::min() || attr_val_raw > std::numeric_limits<int16>::max()) {
          std::string message("value ");
          message.append(std::to_string(attr_val_raw));
          message.append(" doesn't fit in datatype ");
          message.append("int16");
          throw nidevice_grpc::ValueOutOfRangeException(message);
      }
      auto attr_val = static_cast<int16>(attr_val_raw);

      auto status = library_->SetAttributeI16(instrument, selector_string, attribute_id, attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeI32(::grpc::ServerContext* context, const SetAttributeI32Request* request, SetAttributeI32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int32 attr_val;
      switch (request->attr_val_enum_case()) {
        case nirfmxspecan_grpc::SetAttributeI32Request::AttrValEnumCase::kAttrVal: {
          attr_val = static_cast<int32>(request->attr_val());
          break;
        }
        case nirfmxspecan_grpc::SetAttributeI32Request::AttrValEnumCase::kAttrValRaw: {
          attr_val = static_cast<int32>(request->attr_val_raw());
          break;
        }
        case nirfmxspecan_grpc::SetAttributeI32Request::AttrValEnumCase::ATTR_VAL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attr_val was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeI32(instrument, selector_string, attribute_id, attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeI32Array(::grpc::ServerContext* context, const SetAttributeI32ArrayRequest* request, SetAttributeI32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val_vector = std::vector<int32>();
      attr_val_vector.reserve(request->attr_val().size());
      std::transform(
        request->attr_val().begin(),
        request->attr_val().end(),
        std::back_inserter(attr_val_vector),
        [](auto x) { return x; });
      auto attr_val = attr_val_vector.data();

      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeI32Array(instrument, selector_string, attribute_id, attr_val, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeI64(::grpc::ServerContext* context, const SetAttributeI64Request* request, SetAttributeI64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      int64 attr_val = request->attr_val();
      auto status = library_->SetAttributeI64(instrument, selector_string, attribute_id, attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeI64Array(::grpc::ServerContext* context, const SetAttributeI64ArrayRequest* request, SetAttributeI64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = const_cast<int64*>(reinterpret_cast<const int64*>(request->attr_val().data()));
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeI64Array(instrument, selector_string, attribute_id, attr_val, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeI8(::grpc::ServerContext* context, const SetAttributeI8Request* request, SetAttributeI8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val_raw = request->attr_val();
      if (attr_val_raw < std::numeric_limits<int8>::min() || attr_val_raw > std::numeric_limits<int8>::max()) {
          std::string message("value ");
          message.append(std::to_string(attr_val_raw));
          message.append(" doesn't fit in datatype ");
          message.append("int8");
          throw nidevice_grpc::ValueOutOfRangeException(message);
      }
      auto attr_val = static_cast<int8>(attr_val_raw);

      auto status = library_->SetAttributeI8(instrument, selector_string, attribute_id, attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeI8Array(::grpc::ServerContext* context, const SetAttributeI8ArrayRequest* request, SetAttributeI8ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val_raw = request->attr_val();
      auto attr_val = std::vector<int8>();
      attr_val.reserve(attr_val_raw.size());
      std::transform(
        attr_val_raw.begin(),
        attr_val_raw.end(),
        std::back_inserter(attr_val),
        [](auto x) {
              if (x < std::numeric_limits<int8>::min() || x > std::numeric_limits<int8>::max()) {
                  std::string message("value ");
                  message.append(std::to_string(x));
                  message.append(" doesn't fit in datatype ");
                  message.append("int8");
                  throw nidevice_grpc::ValueOutOfRangeException(message);
              }
              return static_cast<int8>(x);
        });

      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeI8Array(instrument, selector_string, attribute_id, attr_val.data(), array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeNIComplexDoubleArray(::grpc::ServerContext* context, const SetAttributeNIComplexDoubleArrayRequest* request, SetAttributeNIComplexDoubleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = convert_from_grpc<NIComplexDouble>(request->attr_val());
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeNIComplexDoubleArray(instrument, selector_string, attribute_id, attr_val.data(), array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeNIComplexSingleArray(::grpc::ServerContext* context, const SetAttributeNIComplexSingleArrayRequest* request, SetAttributeNIComplexSingleArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = convert_from_grpc<NIComplexSingle>(request->attr_val());
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeNIComplexSingleArray(instrument, selector_string, attribute_id, attr_val.data(), array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeString(::grpc::ServerContext* context, const SetAttributeStringRequest* request, SetAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      char* attr_val;
      std::string attr_val_buffer;
      switch (request->attr_val_enum_case()) {
        case nirfmxspecan_grpc::SetAttributeStringRequest::AttrValEnumCase::kAttrValMapped: {
          auto attr_val_imap_it = nirfmxspecanstringattributevaluesmapped_input_map_.find(request->attr_val_mapped());
          if (attr_val_imap_it == nirfmxspecanstringattributevaluesmapped_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attr_val_mapped was not specified or out of range.");
          }
          attr_val = const_cast<char*>((attr_val_imap_it->second).c_str());
          break;
        }
        case nirfmxspecan_grpc::SetAttributeStringRequest::AttrValEnumCase::kAttrValRaw: {
          attr_val_buffer = convert_from_grpc<std::string>(request->attr_val_raw());
          attr_val = const_cast<char*>(attr_val_buffer.c_str());
          break;
        }
        case nirfmxspecan_grpc::SetAttributeStringRequest::AttrValEnumCase::ATTR_VAL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attr_val was not specified or out of range");
          break;
        }
      }

      auto status = library_->SetAttributeString(instrument, selector_string, attribute_id, attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeU16(::grpc::ServerContext* context, const SetAttributeU16Request* request, SetAttributeU16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val_raw = request->attr_val();
      if (attr_val_raw < std::numeric_limits<uInt16>::min() || attr_val_raw > std::numeric_limits<uInt16>::max()) {
          std::string message("value ");
          message.append(std::to_string(attr_val_raw));
          message.append(" doesn't fit in datatype ");
          message.append("uInt16");
          throw nidevice_grpc::ValueOutOfRangeException(message);
      }
      auto attr_val = static_cast<uInt16>(attr_val_raw);

      auto status = library_->SetAttributeU16(instrument, selector_string, attribute_id, attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeU32(::grpc::ServerContext* context, const SetAttributeU32Request* request, SetAttributeU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      uInt32 attr_val = request->attr_val();
      auto status = library_->SetAttributeU32(instrument, selector_string, attribute_id, attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeU32Array(::grpc::ServerContext* context, const SetAttributeU32ArrayRequest* request, SetAttributeU32ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = const_cast<uInt32*>(reinterpret_cast<const uInt32*>(request->attr_val().data()));
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeU32Array(instrument, selector_string, attribute_id, attr_val, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeU64Array(::grpc::ServerContext* context, const SetAttributeU64ArrayRequest* request, SetAttributeU64ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      auto attr_val = const_cast<uInt64*>(reinterpret_cast<const uInt64*>(request->attr_val().data()));
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeU64Array(instrument, selector_string, attribute_id, attr_val, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeU8(::grpc::ServerContext* context, const SetAttributeU8Request* request, SetAttributeU8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      uInt8 attr_val = request->attr_val();
      auto status = library_->SetAttributeU8(instrument, selector_string, attribute_id, attr_val);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SetAttributeU8Array(::grpc::ServerContext* context, const SetAttributeU8ArrayRequest* request, SetAttributeU8ArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 attribute_id = request->attribute_id();
      uInt8* attr_val = (uInt8*)request->attr_val().c_str();
      int32 array_size = static_cast<int32>(request->attr_val().size());
      auto status = library_->SetAttributeU8Array(instrument, selector_string, attribute_id, attr_val, array_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumCfgAveraging(::grpc::ServerContext* context, const SpectrumCfgAveragingRequest* request, SpectrumCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::SpectrumCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      int32 averaging_type;
      switch (request->averaging_type_enum_case()) {
        case nirfmxspecan_grpc::SpectrumCfgAveragingRequest::AveragingTypeEnumCase::kAveragingType: {
          averaging_type = static_cast<int32>(request->averaging_type());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgAveragingRequest::AveragingTypeEnumCase::kAveragingTypeRaw: {
          averaging_type = static_cast<int32>(request->averaging_type_raw());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgAveragingRequest::AveragingTypeEnumCase::AVERAGING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->SpectrumCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count, averaging_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumCfgDetector(::grpc::ServerContext* context, const SpectrumCfgDetectorRequest* request, SpectrumCfgDetectorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 detector_type;
      switch (request->detector_type_enum_case()) {
        case nirfmxspecan_grpc::SpectrumCfgDetectorRequest::DetectorTypeEnumCase::kDetectorType: {
          detector_type = static_cast<int32>(request->detector_type());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgDetectorRequest::DetectorTypeEnumCase::kDetectorTypeRaw: {
          detector_type = static_cast<int32>(request->detector_type_raw());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgDetectorRequest::DetectorTypeEnumCase::DETECTOR_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for detector_type was not specified or out of range");
          break;
        }
      }

      int32 detector_points = request->detector_points();
      auto status = library_->SpectrumCfgDetector(instrument, selector_string, detector_type, detector_points);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumCfgFFT(::grpc::ServerContext* context, const SpectrumCfgFFTRequest* request, SpectrumCfgFFTResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 fft_window;
      switch (request->fft_window_enum_case()) {
        case nirfmxspecan_grpc::SpectrumCfgFFTRequest::FftWindowEnumCase::kFftWindow: {
          fft_window = static_cast<int32>(request->fft_window());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgFFTRequest::FftWindowEnumCase::kFftWindowRaw: {
          fft_window = static_cast<int32>(request->fft_window_raw());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgFFTRequest::FftWindowEnumCase::FFT_WINDOW_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fft_window was not specified or out of range");
          break;
        }
      }

      float64 fft_padding = request->fft_padding();
      auto status = library_->SpectrumCfgFFT(instrument, selector_string, fft_window, fft_padding);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumCfgFrequencyStartStop(::grpc::ServerContext* context, const SpectrumCfgFrequencyStartStopRequest* request, SpectrumCfgFrequencyStartStopResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 start_frequency = request->start_frequency();
      float64 stop_frequency = request->stop_frequency();
      auto status = library_->SpectrumCfgFrequencyStartStop(instrument, selector_string, start_frequency, stop_frequency);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumCfgNoiseCompensationEnabled(::grpc::ServerContext* context, const SpectrumCfgNoiseCompensationEnabledRequest* request, SpectrumCfgNoiseCompensationEnabledResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 noise_compensation_enabled;
      switch (request->noise_compensation_enabled_enum_case()) {
        case nirfmxspecan_grpc::SpectrumCfgNoiseCompensationEnabledRequest::NoiseCompensationEnabledEnumCase::kNoiseCompensationEnabled: {
          noise_compensation_enabled = static_cast<int32>(request->noise_compensation_enabled());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgNoiseCompensationEnabledRequest::NoiseCompensationEnabledEnumCase::kNoiseCompensationEnabledRaw: {
          noise_compensation_enabled = static_cast<int32>(request->noise_compensation_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgNoiseCompensationEnabledRequest::NoiseCompensationEnabledEnumCase::NOISE_COMPENSATION_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for noise_compensation_enabled was not specified or out of range");
          break;
        }
      }

      auto status = library_->SpectrumCfgNoiseCompensationEnabled(instrument, selector_string, noise_compensation_enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumCfgPowerUnits(::grpc::ServerContext* context, const SpectrumCfgPowerUnitsRequest* request, SpectrumCfgPowerUnitsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 spectrum_power_units;
      switch (request->spectrum_power_units_enum_case()) {
        case nirfmxspecan_grpc::SpectrumCfgPowerUnitsRequest::SpectrumPowerUnitsEnumCase::kSpectrumPowerUnits: {
          spectrum_power_units = static_cast<int32>(request->spectrum_power_units());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgPowerUnitsRequest::SpectrumPowerUnitsEnumCase::kSpectrumPowerUnitsRaw: {
          spectrum_power_units = static_cast<int32>(request->spectrum_power_units_raw());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgPowerUnitsRequest::SpectrumPowerUnitsEnumCase::SPECTRUM_POWER_UNITS_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for spectrum_power_units was not specified or out of range");
          break;
        }
      }

      auto status = library_->SpectrumCfgPowerUnits(instrument, selector_string, spectrum_power_units);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumCfgRBWFilter(::grpc::ServerContext* context, const SpectrumCfgRBWFilterRequest* request, SpectrumCfgRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rbw_auto;
      switch (request->rbw_auto_enum_case()) {
        case nirfmxspecan_grpc::SpectrumCfgRBWFilterRequest::RbwAutoEnumCase::kRbwAuto: {
          rbw_auto = static_cast<int32>(request->rbw_auto());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgRBWFilterRequest::RbwAutoEnumCase::kRbwAutoRaw: {
          rbw_auto = static_cast<int32>(request->rbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgRBWFilterRequest::RbwAutoEnumCase::RBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_auto was not specified or out of range");
          break;
        }
      }

      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::SpectrumCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->SpectrumCfgRBWFilter(instrument, selector_string, rbw_auto, rbw, rbw_filter_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumCfgSpan(::grpc::ServerContext* context, const SpectrumCfgSpanRequest* request, SpectrumCfgSpanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 span = request->span();
      auto status = library_->SpectrumCfgSpan(instrument, selector_string, span);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumCfgSweepTime(::grpc::ServerContext* context, const SpectrumCfgSweepTimeRequest* request, SpectrumCfgSweepTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 sweep_time_auto;
      switch (request->sweep_time_auto_enum_case()) {
        case nirfmxspecan_grpc::SpectrumCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAuto: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAutoRaw: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgSweepTimeRequest::SweepTimeAutoEnumCase::SWEEP_TIME_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sweep_time_auto was not specified or out of range");
          break;
        }
      }

      float64 sweep_time_interval = request->sweep_time_interval();
      auto status = library_->SpectrumCfgSweepTime(instrument, selector_string, sweep_time_auto, sweep_time_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumCfgVBWFilter(::grpc::ServerContext* context, const SpectrumCfgVBWFilterRequest* request, SpectrumCfgVBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 vbw_auto;
      switch (request->vbw_auto_enum_case()) {
        case nirfmxspecan_grpc::SpectrumCfgVBWFilterRequest::VbwAutoEnumCase::kVbwAuto: {
          vbw_auto = static_cast<int32>(request->vbw_auto());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgVBWFilterRequest::VbwAutoEnumCase::kVbwAutoRaw: {
          vbw_auto = static_cast<int32>(request->vbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::SpectrumCfgVBWFilterRequest::VbwAutoEnumCase::VBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for vbw_auto was not specified or out of range");
          break;
        }
      }

      float64 vbw = request->vbw();
      float64 vbw_to_rbw_ratio = request->vbw_to_rbw_ratio();
      auto status = library_->SpectrumCfgVBWFilter(instrument, selector_string, vbw_auto, vbw, vbw_to_rbw_ratio);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumFetchMeasurement(::grpc::ServerContext* context, const SpectrumFetchMeasurementRequest* request, SpectrumFetchMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 peak_amplitude {};
      float64 peak_frequency {};
      float64 frequency_resolution {};
      auto status = library_->SpectrumFetchMeasurement(instrument, selector_string, timeout, &peak_amplitude, &peak_frequency, &frequency_resolution);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_peak_amplitude(peak_amplitude);
      response->set_peak_frequency(peak_frequency);
      response->set_frequency_resolution(frequency_resolution);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumFetchPowerTrace(::grpc::ServerContext* context, const SpectrumFetchPowerTraceRequest* request, SpectrumFetchPowerTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SpectrumFetchPowerTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_power()->Resize(actual_array_size, 0);
        float32* power = response->mutable_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SpectrumFetchPowerTrace(instrument, selector_string, timeout, &x0, &dx, power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumFetchSpectrum(::grpc::ServerContext* context, const SpectrumFetchSpectrumRequest* request, SpectrumFetchSpectrumResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SpectrumFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        float32* spectrum = response->mutable_spectrum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SpectrumFetchSpectrum(instrument, selector_string, timeout, &x0, &dx, spectrum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumRead(::grpc::ServerContext* context, const SpectrumReadRequest* request, SpectrumReadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SpectrumRead(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        float32* spectrum = response->mutable_spectrum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SpectrumRead(instrument, selector_string, timeout, &x0, &dx, spectrum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_spectrum()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpectrumValidateNoiseCalibrationData(::grpc::ServerContext* context, const SpectrumValidateNoiseCalibrationDataRequest* request, SpectrumValidateNoiseCalibrationDataResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 noise_calibration_data_valid {};
      auto status = library_->SpectrumValidateNoiseCalibrationData(instrument, selector_string, &noise_calibration_data_valid);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_noise_calibration_data_valid(static_cast<nirfmxspecan_grpc::SpectrumNoiseCalibrationDataValid>(noise_calibration_data_valid));
      response->set_noise_calibration_data_valid_raw(noise_calibration_data_valid);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgAveraging(::grpc::ServerContext* context, const SpurCfgAveragingRequest* request, SpurCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::SpurCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      int32 averaging_type;
      switch (request->averaging_type_enum_case()) {
        case nirfmxspecan_grpc::SpurCfgAveragingRequest::AveragingTypeEnumCase::kAveragingType: {
          averaging_type = static_cast<int32>(request->averaging_type());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgAveragingRequest::AveragingTypeEnumCase::kAveragingTypeRaw: {
          averaging_type = static_cast<int32>(request->averaging_type_raw());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgAveragingRequest::AveragingTypeEnumCase::AVERAGING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->SpurCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count, averaging_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgFFTWindowType(::grpc::ServerContext* context, const SpurCfgFFTWindowTypeRequest* request, SpurCfgFFTWindowTypeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 fft_window;
      switch (request->fft_window_enum_case()) {
        case nirfmxspecan_grpc::SpurCfgFFTWindowTypeRequest::FftWindowEnumCase::kFftWindow: {
          fft_window = static_cast<int32>(request->fft_window());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgFFTWindowTypeRequest::FftWindowEnumCase::kFftWindowRaw: {
          fft_window = static_cast<int32>(request->fft_window_raw());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgFFTWindowTypeRequest::FftWindowEnumCase::FFT_WINDOW_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for fft_window was not specified or out of range");
          break;
        }
      }

      auto status = library_->SpurCfgFFTWindowType(instrument, selector_string, fft_window);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgNumberOfRanges(::grpc::ServerContext* context, const SpurCfgNumberOfRangesRequest* request, SpurCfgNumberOfRangesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_ranges = request->number_of_ranges();
      auto status = library_->SpurCfgNumberOfRanges(instrument, selector_string, number_of_ranges);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeAbsoluteLimit(::grpc::ServerContext* context, const SpurCfgRangeAbsoluteLimitRequest* request, SpurCfgRangeAbsoluteLimitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 absolute_limit_mode;
      switch (request->absolute_limit_mode_enum_case()) {
        case nirfmxspecan_grpc::SpurCfgRangeAbsoluteLimitRequest::AbsoluteLimitModeEnumCase::kAbsoluteLimitMode: {
          absolute_limit_mode = static_cast<int32>(request->absolute_limit_mode());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeAbsoluteLimitRequest::AbsoluteLimitModeEnumCase::kAbsoluteLimitModeRaw: {
          absolute_limit_mode = static_cast<int32>(request->absolute_limit_mode_raw());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeAbsoluteLimitRequest::AbsoluteLimitModeEnumCase::ABSOLUTE_LIMIT_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for absolute_limit_mode was not specified or out of range");
          break;
        }
      }

      float64 absolute_limit_start = request->absolute_limit_start();
      float64 absolute_limit_stop = request->absolute_limit_stop();
      auto status = library_->SpurCfgRangeAbsoluteLimit(instrument, selector_string, absolute_limit_mode, absolute_limit_start, absolute_limit_stop);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeAbsoluteLimitArray(::grpc::ServerContext* context, const SpurCfgRangeAbsoluteLimitArrayRequest* request, SpurCfgRangeAbsoluteLimitArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto absolute_limit_mode_vector = std::vector<int32>();
      absolute_limit_mode_vector.reserve(request->absolute_limit_mode().size());
      std::transform(
        request->absolute_limit_mode().begin(),
        request->absolute_limit_mode().end(),
        std::back_inserter(absolute_limit_mode_vector),
        [](auto x) { return x; });
      auto absolute_limit_mode = absolute_limit_mode_vector.data();

      auto absolute_limit_start = const_cast<float64*>(request->absolute_limit_start().data());
      auto absolute_limit_stop = const_cast<float64*>(request->absolute_limit_stop().data());
      auto number_of_elements_determine_from_sizes = std::array<int, 3>
      {
        request->absolute_limit_mode_size(),
        request->absolute_limit_start_size(),
        request->absolute_limit_stop_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [absolute_limit_mode, absolute_limit_start, absolute_limit_stop] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        absolute_limit_mode = request->absolute_limit_mode_size() ? std::move(absolute_limit_mode) : nullptr;
        absolute_limit_start = request->absolute_limit_start_size() ? std::move(absolute_limit_start) : nullptr;
        absolute_limit_stop = request->absolute_limit_stop_size() ? std::move(absolute_limit_stop) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SpurCfgRangeAbsoluteLimitArray(instrument, selector_string, absolute_limit_mode, absolute_limit_start, absolute_limit_stop, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeDetector(::grpc::ServerContext* context, const SpurCfgRangeDetectorRequest* request, SpurCfgRangeDetectorResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 detector_type;
      switch (request->detector_type_enum_case()) {
        case nirfmxspecan_grpc::SpurCfgRangeDetectorRequest::DetectorTypeEnumCase::kDetectorType: {
          detector_type = static_cast<int32>(request->detector_type());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeDetectorRequest::DetectorTypeEnumCase::kDetectorTypeRaw: {
          detector_type = static_cast<int32>(request->detector_type_raw());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeDetectorRequest::DetectorTypeEnumCase::DETECTOR_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for detector_type was not specified or out of range");
          break;
        }
      }

      int32 detector_points = request->detector_points();
      auto status = library_->SpurCfgRangeDetector(instrument, selector_string, detector_type, detector_points);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeDetectorArray(::grpc::ServerContext* context, const SpurCfgRangeDetectorArrayRequest* request, SpurCfgRangeDetectorArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto detector_type_vector = std::vector<int32>();
      detector_type_vector.reserve(request->detector_type().size());
      std::transform(
        request->detector_type().begin(),
        request->detector_type().end(),
        std::back_inserter(detector_type_vector),
        [](auto x) { return x; });
      auto detector_type = detector_type_vector.data();

      auto detector_points = const_cast<int32*>(reinterpret_cast<const int32*>(request->detector_points().data()));
      auto number_of_elements_determine_from_sizes = std::array<int, 2>
      {
        request->detector_type_size(),
        request->detector_points_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [detector_type, detector_points] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        detector_type = request->detector_type_size() ? std::move(detector_type) : nullptr;
        detector_points = request->detector_points_size() ? std::move(detector_points) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SpurCfgRangeDetectorArray(instrument, selector_string, detector_type, detector_points, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeFrequency(::grpc::ServerContext* context, const SpurCfgRangeFrequencyRequest* request, SpurCfgRangeFrequencyResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 start_frequency = request->start_frequency();
      float64 stop_frequency = request->stop_frequency();
      int32 range_enabled;
      switch (request->range_enabled_enum_case()) {
        case nirfmxspecan_grpc::SpurCfgRangeFrequencyRequest::RangeEnabledEnumCase::kRangeEnabled: {
          range_enabled = static_cast<int32>(request->range_enabled());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeFrequencyRequest::RangeEnabledEnumCase::kRangeEnabledRaw: {
          range_enabled = static_cast<int32>(request->range_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeFrequencyRequest::RangeEnabledEnumCase::RANGE_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for range_enabled was not specified or out of range");
          break;
        }
      }

      auto status = library_->SpurCfgRangeFrequency(instrument, selector_string, start_frequency, stop_frequency, range_enabled);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeFrequencyArray(::grpc::ServerContext* context, const SpurCfgRangeFrequencyArrayRequest* request, SpurCfgRangeFrequencyArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto start_frequency = const_cast<float64*>(request->start_frequency().data());
      auto stop_frequency = const_cast<float64*>(request->stop_frequency().data());
      auto range_enabled_vector = std::vector<int32>();
      range_enabled_vector.reserve(request->range_enabled().size());
      std::transform(
        request->range_enabled().begin(),
        request->range_enabled().end(),
        std::back_inserter(range_enabled_vector),
        [](auto x) { return x; });
      auto range_enabled = range_enabled_vector.data();

      auto number_of_elements_determine_from_sizes = std::array<int, 3>
      {
        request->start_frequency_size(),
        request->stop_frequency_size(),
        request->range_enabled_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [start_frequency, stop_frequency, range_enabled] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        start_frequency = request->start_frequency_size() ? std::move(start_frequency) : nullptr;
        stop_frequency = request->stop_frequency_size() ? std::move(stop_frequency) : nullptr;
        range_enabled = request->range_enabled_size() ? std::move(range_enabled) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SpurCfgRangeFrequencyArray(instrument, selector_string, start_frequency, stop_frequency, range_enabled, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeNumberOfSpursToReport(::grpc::ServerContext* context, const SpurCfgRangeNumberOfSpursToReportRequest* request, SpurCfgRangeNumberOfSpursToReportResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 number_of_spurs_to_report = request->number_of_spurs_to_report();
      auto status = library_->SpurCfgRangeNumberOfSpursToReport(instrument, selector_string, number_of_spurs_to_report);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeNumberOfSpursToReportArray(::grpc::ServerContext* context, const SpurCfgRangeNumberOfSpursToReportArrayRequest* request, SpurCfgRangeNumberOfSpursToReportArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto number_of_spurs_to_report = const_cast<int32*>(reinterpret_cast<const int32*>(request->number_of_spurs_to_report().data()));
      int32 number_of_elements = static_cast<int32>(request->number_of_spurs_to_report().size());
      auto status = library_->SpurCfgRangeNumberOfSpursToReportArray(instrument, selector_string, number_of_spurs_to_report, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangePeakCriteria(::grpc::ServerContext* context, const SpurCfgRangePeakCriteriaRequest* request, SpurCfgRangePeakCriteriaResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 threshold = request->threshold();
      float64 excursion = request->excursion();
      auto status = library_->SpurCfgRangePeakCriteria(instrument, selector_string, threshold, excursion);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangePeakCriteriaArray(::grpc::ServerContext* context, const SpurCfgRangePeakCriteriaArrayRequest* request, SpurCfgRangePeakCriteriaArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto threshold = const_cast<float64*>(request->threshold().data());
      auto excursion = const_cast<float64*>(request->excursion().data());
      auto number_of_elements_determine_from_sizes = std::array<int, 2>
      {
        request->threshold_size(),
        request->excursion_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [threshold, excursion] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        threshold = request->threshold_size() ? std::move(threshold) : nullptr;
        excursion = request->excursion_size() ? std::move(excursion) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SpurCfgRangePeakCriteriaArray(instrument, selector_string, threshold, excursion, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeRBWArray(::grpc::ServerContext* context, const SpurCfgRangeRBWArrayRequest* request, SpurCfgRangeRBWArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto rbw_auto_vector = std::vector<int32>();
      rbw_auto_vector.reserve(request->rbw_auto().size());
      std::transform(
        request->rbw_auto().begin(),
        request->rbw_auto().end(),
        std::back_inserter(rbw_auto_vector),
        [](auto x) { return x; });
      auto rbw_auto = rbw_auto_vector.data();

      auto rbw = const_cast<float64*>(request->rbw().data());
      auto rbw_filter_type_vector = std::vector<int32>();
      rbw_filter_type_vector.reserve(request->rbw_filter_type().size());
      std::transform(
        request->rbw_filter_type().begin(),
        request->rbw_filter_type().end(),
        std::back_inserter(rbw_filter_type_vector),
        [](auto x) { return x; });
      auto rbw_filter_type = rbw_filter_type_vector.data();

      auto number_of_elements_determine_from_sizes = std::array<int, 3>
      {
        request->rbw_auto_size(),
        request->rbw_size(),
        request->rbw_filter_type_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [rbw_auto, rbw, rbw_filter_type] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        rbw_auto = request->rbw_auto_size() ? std::move(rbw_auto) : nullptr;
        rbw = request->rbw_size() ? std::move(rbw) : nullptr;
        rbw_filter_type = request->rbw_filter_type_size() ? std::move(rbw_filter_type) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SpurCfgRangeRBWArray(instrument, selector_string, rbw_auto, rbw, rbw_filter_type, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeRBWFilter(::grpc::ServerContext* context, const SpurCfgRangeRBWFilterRequest* request, SpurCfgRangeRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 rbw_auto;
      switch (request->rbw_auto_enum_case()) {
        case nirfmxspecan_grpc::SpurCfgRangeRBWFilterRequest::RbwAutoEnumCase::kRbwAuto: {
          rbw_auto = static_cast<int32>(request->rbw_auto());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeRBWFilterRequest::RbwAutoEnumCase::kRbwAutoRaw: {
          rbw_auto = static_cast<int32>(request->rbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeRBWFilterRequest::RbwAutoEnumCase::RBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_auto was not specified or out of range");
          break;
        }
      }

      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::SpurCfgRangeRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->SpurCfgRangeRBWFilter(instrument, selector_string, rbw_auto, rbw, rbw_filter_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeRelativeAttenuation(::grpc::ServerContext* context, const SpurCfgRangeRelativeAttenuationRequest* request, SpurCfgRangeRelativeAttenuationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 relative_attenuation = request->relative_attenuation();
      auto status = library_->SpurCfgRangeRelativeAttenuation(instrument, selector_string, relative_attenuation);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeRelativeAttenuationArray(::grpc::ServerContext* context, const SpurCfgRangeRelativeAttenuationArrayRequest* request, SpurCfgRangeRelativeAttenuationArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto relative_attenuation = const_cast<float64*>(request->relative_attenuation().data());
      int32 number_of_elements = static_cast<int32>(request->relative_attenuation().size());
      auto status = library_->SpurCfgRangeRelativeAttenuationArray(instrument, selector_string, relative_attenuation, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeSweepTime(::grpc::ServerContext* context, const SpurCfgRangeSweepTimeRequest* request, SpurCfgRangeSweepTimeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 sweep_time_auto;
      switch (request->sweep_time_auto_enum_case()) {
        case nirfmxspecan_grpc::SpurCfgRangeSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAuto: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeSweepTimeRequest::SweepTimeAutoEnumCase::kSweepTimeAutoRaw: {
          sweep_time_auto = static_cast<int32>(request->sweep_time_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeSweepTimeRequest::SweepTimeAutoEnumCase::SWEEP_TIME_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for sweep_time_auto was not specified or out of range");
          break;
        }
      }

      float64 sweep_time_interval = request->sweep_time_interval();
      auto status = library_->SpurCfgRangeSweepTime(instrument, selector_string, sweep_time_auto, sweep_time_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeSweepTimeArray(::grpc::ServerContext* context, const SpurCfgRangeSweepTimeArrayRequest* request, SpurCfgRangeSweepTimeArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto sweep_time_auto_vector = std::vector<int32>();
      sweep_time_auto_vector.reserve(request->sweep_time_auto().size());
      std::transform(
        request->sweep_time_auto().begin(),
        request->sweep_time_auto().end(),
        std::back_inserter(sweep_time_auto_vector),
        [](auto x) { return x; });
      auto sweep_time_auto = sweep_time_auto_vector.data();

      auto sweep_time_interval = const_cast<float64*>(request->sweep_time_interval().data());
      auto number_of_elements_determine_from_sizes = std::array<int, 2>
      {
        request->sweep_time_auto_size(),
        request->sweep_time_interval_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [sweep_time_auto, sweep_time_interval] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        sweep_time_auto = request->sweep_time_auto_size() ? std::move(sweep_time_auto) : nullptr;
        sweep_time_interval = request->sweep_time_interval_size() ? std::move(sweep_time_interval) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SpurCfgRangeSweepTimeArray(instrument, selector_string, sweep_time_auto, sweep_time_interval, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeVBWFilter(::grpc::ServerContext* context, const SpurCfgRangeVBWFilterRequest* request, SpurCfgRangeVBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 vbw_auto;
      switch (request->vbw_auto_enum_case()) {
        case nirfmxspecan_grpc::SpurCfgRangeVBWFilterRequest::VbwAutoEnumCase::kVbwAuto: {
          vbw_auto = static_cast<int32>(request->vbw_auto());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeVBWFilterRequest::VbwAutoEnumCase::kVbwAutoRaw: {
          vbw_auto = static_cast<int32>(request->vbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::SpurCfgRangeVBWFilterRequest::VbwAutoEnumCase::VBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for vbw_auto was not specified or out of range");
          break;
        }
      }

      float64 vbw = request->vbw();
      float64 vbw_to_rbw_ratio = request->vbw_to_rbw_ratio();
      auto status = library_->SpurCfgRangeVBWFilter(instrument, selector_string, vbw_auto, vbw, vbw_to_rbw_ratio);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgRangeVBWFilterArray(::grpc::ServerContext* context, const SpurCfgRangeVBWFilterArrayRequest* request, SpurCfgRangeVBWFilterArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      auto vbw_auto_vector = std::vector<int32>();
      vbw_auto_vector.reserve(request->vbw_auto().size());
      std::transform(
        request->vbw_auto().begin(),
        request->vbw_auto().end(),
        std::back_inserter(vbw_auto_vector),
        [](auto x) { return x; });
      auto vbw_auto = vbw_auto_vector.data();

      auto vbw = const_cast<float64*>(request->vbw().data());
      auto vbw_to_rbw_ratio = const_cast<float64*>(request->vbw_to_rbw_ratio().data());
      auto number_of_elements_determine_from_sizes = std::array<int, 3>
      {
        request->vbw_auto_size(),
        request->vbw_size(),
        request->vbw_to_rbw_ratio_size()
      };
      const auto number_of_elements_size_calculation = calculate_linked_array_size(number_of_elements_determine_from_sizes, true);

      if (number_of_elements_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [vbw_auto, vbw, vbw_to_rbw_ratio] do not match");
      }
      // NULL out optional params with zero sizes.
      if (number_of_elements_size_calculation.match_state == MatchState::MATCH_OR_ZERO) {
        vbw_auto = request->vbw_auto_size() ? std::move(vbw_auto) : nullptr;
        vbw = request->vbw_size() ? std::move(vbw) : nullptr;
        vbw_to_rbw_ratio = request->vbw_to_rbw_ratio_size() ? std::move(vbw_to_rbw_ratio) : nullptr;
      }
      auto number_of_elements = number_of_elements_size_calculation.size;

      auto status = library_->SpurCfgRangeVBWFilterArray(instrument, selector_string, vbw_auto, vbw, vbw_to_rbw_ratio, number_of_elements);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurCfgTraceRangeIndex(::grpc::ServerContext* context, const SpurCfgTraceRangeIndexRequest* request, SpurCfgTraceRangeIndexResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 trace_range_index = request->trace_range_index();
      auto status = library_->SpurCfgTraceRangeIndex(instrument, selector_string, trace_range_index);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurFetchAllSpurs(::grpc::ServerContext* context, const SpurFetchAllSpursRequest* request, SpurFetchAllSpursResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SpurFetchAllSpurs(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_spur_frequency()->Resize(actual_array_size, 0);
        float64* spur_frequency = response->mutable_spur_frequency()->mutable_data();
        response->mutable_spur_amplitude()->Resize(actual_array_size, 0);
        float64* spur_amplitude = response->mutable_spur_amplitude()->mutable_data();
        response->mutable_spur_margin()->Resize(actual_array_size, 0);
        float64* spur_margin = response->mutable_spur_margin()->mutable_data();
        response->mutable_spur_absolute_limit()->Resize(actual_array_size, 0);
        float64* spur_absolute_limit = response->mutable_spur_absolute_limit()->mutable_data();
        response->mutable_spur_range_index()->Resize(actual_array_size, 0);
        int32* spur_range_index = reinterpret_cast<int32*>(response->mutable_spur_range_index()->mutable_data());
        auto array_size = actual_array_size;
        status = library_->SpurFetchAllSpurs(instrument, selector_string, timeout, spur_frequency, spur_amplitude, spur_margin, spur_absolute_limit, spur_range_index, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_spur_frequency()->Resize(actual_array_size, 0);
        response->mutable_spur_amplitude()->Resize(actual_array_size, 0);
        response->mutable_spur_margin()->Resize(actual_array_size, 0);
        response->mutable_spur_absolute_limit()->Resize(actual_array_size, 0);
        response->mutable_spur_range_index()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurFetchMeasurementStatus(::grpc::ServerContext* context, const SpurFetchMeasurementStatusRequest* request, SpurFetchMeasurementStatusResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 measurement_status {};
      auto status = library_->SpurFetchMeasurementStatus(instrument, selector_string, timeout, &measurement_status);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_measurement_status(static_cast<nirfmxspecan_grpc::SpurMeasurementStatus>(measurement_status));
      response->set_measurement_status_raw(measurement_status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurFetchRangeAbsoluteLimitTrace(::grpc::ServerContext* context, const SpurFetchRangeAbsoluteLimitTraceRequest* request, SpurFetchRangeAbsoluteLimitTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SpurFetchRangeAbsoluteLimitTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_absolute_limit()->Resize(actual_array_size, 0);
        float32* absolute_limit = response->mutable_absolute_limit()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SpurFetchRangeAbsoluteLimitTrace(instrument, selector_string, timeout, &x0, &dx, absolute_limit, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_absolute_limit()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurFetchRangeSpectrumTrace(::grpc::ServerContext* context, const SpurFetchRangeSpectrumTraceRequest* request, SpurFetchRangeSpectrumTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SpurFetchRangeSpectrumTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_range_spectrum()->Resize(actual_array_size, 0);
        float32* range_spectrum = response->mutable_range_spectrum()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SpurFetchRangeSpectrumTrace(instrument, selector_string, timeout, &x0, &dx, range_spectrum, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_range_spectrum()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurFetchRangeStatus(::grpc::ServerContext* context, const SpurFetchRangeStatusRequest* request, SpurFetchRangeStatusResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 range_status {};
      int32 detected_spurs {};
      auto status = library_->SpurFetchRangeStatus(instrument, selector_string, timeout, &range_status, &detected_spurs);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_range_status(static_cast<nirfmxspecan_grpc::SpurRangeStatus>(range_status));
      response->set_range_status_raw(range_status);
      response->set_detected_spurs(detected_spurs);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurFetchRangeStatusArray(::grpc::ServerContext* context, const SpurFetchRangeStatusArrayRequest* request, SpurFetchRangeStatusArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SpurFetchRangeStatusArray(instrument, selector_string, timeout, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_range_status_raw()->Resize(actual_array_size, 0);
        int32* range_status = reinterpret_cast<int32*>(response->mutable_range_status_raw()->mutable_data());
        response->mutable_number_of_detected_spurs()->Resize(actual_array_size, 0);
        int32* number_of_detected_spurs = reinterpret_cast<int32*>(response->mutable_number_of_detected_spurs()->mutable_data());
        auto array_size = actual_array_size;
        status = library_->SpurFetchRangeStatusArray(instrument, selector_string, timeout, range_status, number_of_detected_spurs, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
          response->mutable_range_status()->Clear();
          response->mutable_range_status()->Reserve(actual_array_size);
          std::transform(
            response->range_status_raw().begin(),
            response->range_status_raw().begin() + actual_array_size,
            google::protobuf::RepeatedFieldBackInserter(response->mutable_range_status()),
            [&](auto x) {
                return static_cast<nirfmxspecan_grpc::SpurRangeStatus>(x);
            });
        response->mutable_range_status()->Resize(actual_array_size, 0);
        response->mutable_number_of_detected_spurs()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurFetchSpurMeasurement(::grpc::ServerContext* context, const SpurFetchSpurMeasurementRequest* request, SpurFetchSpurMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 spur_frequency {};
      float64 spur_amplitude {};
      float64 spur_margin {};
      float64 spur_absolute_limit {};
      auto status = library_->SpurFetchSpurMeasurement(instrument, selector_string, timeout, &spur_frequency, &spur_amplitude, &spur_margin, &spur_absolute_limit);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_spur_frequency(spur_frequency);
      response->set_spur_amplitude(spur_amplitude);
      response->set_spur_margin(spur_margin);
      response->set_spur_absolute_limit(spur_absolute_limit);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::SpurFetchSpurMeasurementArray(::grpc::ServerContext* context, const SpurFetchSpurMeasurementArrayRequest* request, SpurFetchSpurMeasurementArrayResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      int32 actual_array_size {};
      while (true) {
        auto status = library_->SpurFetchSpurMeasurementArray(instrument, selector_string, timeout, nullptr, nullptr, nullptr, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_spur_frequency()->Resize(actual_array_size, 0);
        float64* spur_frequency = response->mutable_spur_frequency()->mutable_data();
        response->mutable_spur_amplitude()->Resize(actual_array_size, 0);
        float64* spur_amplitude = response->mutable_spur_amplitude()->mutable_data();
        response->mutable_spur_absolute_limit()->Resize(actual_array_size, 0);
        float64* spur_absolute_limit = response->mutable_spur_absolute_limit()->mutable_data();
        response->mutable_spur_margin()->Resize(actual_array_size, 0);
        float64* spur_margin = response->mutable_spur_margin()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->SpurFetchSpurMeasurementArray(instrument, selector_string, timeout, spur_frequency, spur_amplitude, spur_absolute_limit, spur_margin, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->mutable_spur_frequency()->Resize(actual_array_size, 0);
        response->mutable_spur_amplitude()->Resize(actual_array_size, 0);
        response->mutable_spur_absolute_limit()->Resize(actual_array_size, 0);
        response->mutable_spur_margin()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::TXPCfgAveraging(::grpc::ServerContext* context, const TXPCfgAveragingRequest* request, TXPCfgAveragingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 averaging_enabled;
      switch (request->averaging_enabled_enum_case()) {
        case nirfmxspecan_grpc::TXPCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabled: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgAveragingRequest::AveragingEnabledEnumCase::kAveragingEnabledRaw: {
          averaging_enabled = static_cast<int32>(request->averaging_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgAveragingRequest::AveragingEnabledEnumCase::AVERAGING_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_enabled was not specified or out of range");
          break;
        }
      }

      int32 averaging_count = request->averaging_count();
      int32 averaging_type;
      switch (request->averaging_type_enum_case()) {
        case nirfmxspecan_grpc::TXPCfgAveragingRequest::AveragingTypeEnumCase::kAveragingType: {
          averaging_type = static_cast<int32>(request->averaging_type());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgAveragingRequest::AveragingTypeEnumCase::kAveragingTypeRaw: {
          averaging_type = static_cast<int32>(request->averaging_type_raw());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgAveragingRequest::AveragingTypeEnumCase::AVERAGING_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for averaging_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->TXPCfgAveraging(instrument, selector_string, averaging_enabled, averaging_count, averaging_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::TXPCfgMeasurementInterval(::grpc::ServerContext* context, const TXPCfgMeasurementIntervalRequest* request, TXPCfgMeasurementIntervalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 measurement_interval = request->measurement_interval();
      auto status = library_->TXPCfgMeasurementInterval(instrument, selector_string, measurement_interval);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::TXPCfgRBWFilter(::grpc::ServerContext* context, const TXPCfgRBWFilterRequest* request, TXPCfgRBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 rbw = request->rbw();
      int32 rbw_filter_type;
      switch (request->rbw_filter_type_enum_case()) {
        case nirfmxspecan_grpc::TXPCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterType: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgRBWFilterRequest::RbwFilterTypeEnumCase::kRbwFilterTypeRaw: {
          rbw_filter_type = static_cast<int32>(request->rbw_filter_type_raw());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgRBWFilterRequest::RbwFilterTypeEnumCase::RBW_FILTER_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for rbw_filter_type was not specified or out of range");
          break;
        }
      }

      float64 rrc_alpha = request->rrc_alpha();
      auto status = library_->TXPCfgRBWFilter(instrument, selector_string, rbw, rbw_filter_type, rrc_alpha);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::TXPCfgThreshold(::grpc::ServerContext* context, const TXPCfgThresholdRequest* request, TXPCfgThresholdResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 threshold_enabled;
      switch (request->threshold_enabled_enum_case()) {
        case nirfmxspecan_grpc::TXPCfgThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabled: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgThresholdRequest::ThresholdEnabledEnumCase::kThresholdEnabledRaw: {
          threshold_enabled = static_cast<int32>(request->threshold_enabled_raw());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgThresholdRequest::ThresholdEnabledEnumCase::THRESHOLD_ENABLED_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_enabled was not specified or out of range");
          break;
        }
      }

      float64 threshold_level = request->threshold_level();
      int32 threshold_type;
      switch (request->threshold_type_enum_case()) {
        case nirfmxspecan_grpc::TXPCfgThresholdRequest::ThresholdTypeEnumCase::kThresholdType: {
          threshold_type = static_cast<int32>(request->threshold_type());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgThresholdRequest::ThresholdTypeEnumCase::kThresholdTypeRaw: {
          threshold_type = static_cast<int32>(request->threshold_type_raw());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgThresholdRequest::ThresholdTypeEnumCase::THRESHOLD_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for threshold_type was not specified or out of range");
          break;
        }
      }

      auto status = library_->TXPCfgThreshold(instrument, selector_string, threshold_enabled, threshold_level, threshold_type);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::TXPCfgVBWFilter(::grpc::ServerContext* context, const TXPCfgVBWFilterRequest* request, TXPCfgVBWFilterResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      int32 vbw_auto;
      switch (request->vbw_auto_enum_case()) {
        case nirfmxspecan_grpc::TXPCfgVBWFilterRequest::VbwAutoEnumCase::kVbwAuto: {
          vbw_auto = static_cast<int32>(request->vbw_auto());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgVBWFilterRequest::VbwAutoEnumCase::kVbwAutoRaw: {
          vbw_auto = static_cast<int32>(request->vbw_auto_raw());
          break;
        }
        case nirfmxspecan_grpc::TXPCfgVBWFilterRequest::VbwAutoEnumCase::VBW_AUTO_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for vbw_auto was not specified or out of range");
          break;
        }
      }

      float64 vbw = request->vbw();
      float64 vbw_to_rbw_ratio = request->vbw_to_rbw_ratio();
      auto status = library_->TXPCfgVBWFilter(instrument, selector_string, vbw_auto, vbw, vbw_to_rbw_ratio);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::TXPFetchMeasurement(::grpc::ServerContext* context, const TXPFetchMeasurementRequest* request, TXPFetchMeasurementResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 average_mean_power {};
      float64 peak_to_average_ratio {};
      float64 maximum_power {};
      float64 minimum_power {};
      auto status = library_->TXPFetchMeasurement(instrument, selector_string, timeout, &average_mean_power, &peak_to_average_ratio, &maximum_power, &minimum_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_average_mean_power(average_mean_power);
      response->set_peak_to_average_ratio(peak_to_average_ratio);
      response->set_maximum_power(maximum_power);
      response->set_minimum_power(minimum_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::TXPFetchPowerTrace(::grpc::ServerContext* context, const TXPFetchPowerTraceRequest* request, TXPFetchPowerTraceResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 x0 {};
      float64 dx {};
      int32 actual_array_size {};
      while (true) {
        auto status = library_->TXPFetchPowerTrace(instrument, selector_string, timeout, &x0, &dx, nullptr, 0, &actual_array_size);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->mutable_power()->Resize(actual_array_size, 0);
        float32* power = response->mutable_power()->mutable_data();
        auto array_size = actual_array_size;
        status = library_->TXPFetchPowerTrace(instrument, selector_string, timeout, &x0, &dx, power, array_size, &actual_array_size);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
        }
        response->set_status(status);
        response->set_x0(x0);
        response->set_dx(dx);
        response->mutable_power()->Resize(actual_array_size, 0);
        response->set_actual_array_size(actual_array_size);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::TXPRead(::grpc::ServerContext* context, const TXPReadRequest* request, TXPReadResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      float64 average_mean_power {};
      float64 peak_to_average_ratio {};
      float64 maximum_power {};
      float64 minimum_power {};
      auto status = library_->TXPRead(instrument, selector_string, timeout, &average_mean_power, &peak_to_average_ratio, &maximum_power, &minimum_power);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      response->set_average_mean_power(average_mean_power);
      response->set_peak_to_average_ratio(peak_to_average_ratio);
      response->set_maximum_power(maximum_power);
      response->set_minimum_power(minimum_power);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::WaitForAcquisitionComplete(::grpc::ServerContext* context, const WaitForAcquisitionCompleteRequest* request, WaitForAcquisitionCompleteResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      float64 timeout = request->timeout();
      auto status = library_->WaitForAcquisitionComplete(instrument, timeout);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiRFmxSpecAnService::WaitForMeasurementComplete(::grpc::ServerContext* context, const WaitForMeasurementCompleteRequest* request, WaitForMeasurementCompleteResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto instrument_grpc_session = request->instrument();
      niRFmxInstrHandle instrument = session_repository_->access_session(instrument_grpc_session.name());
      auto selector_string_mbcs = convert_from_grpc<std::string>(request->selector_string());
      char* selector_string = (char*)selector_string_mbcs.c_str();
      float64 timeout = request->timeout();
      auto status = library_->WaitForMeasurementComplete(instrument, selector_string, timeout);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForNiRFmxInstrHandle(context, status, instrument);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  NiRFmxSpecAnFeatureToggles::NiRFmxSpecAnFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nirfmxspecan", CodeReadiness::kRelease))
  {
  }
} // namespace nirfmxspecan_grpc

