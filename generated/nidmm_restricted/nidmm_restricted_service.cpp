
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-DMM-RESTRICTED Metadata
//---------------------------------------------------------------------
#include "nidmm_restricted_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/ivi_errors.h"
#include <server/converters.h>

namespace nidmm_restricted_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  const auto kErrorReadBufferTooSmall = -200229;
  const auto kWarningCAPIStringTruncatedToFitBuffer = 200026;

  NiDmmRestrictedService::NiDmmRestrictedService(
      LibrarySharedPtr library,
      ResourceRepositorySharedPtr resource_repository,
      const NiDmmRestrictedFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiDmmRestrictedService::~NiDmmRestrictedService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDmmRestrictedService::AttributeWasSetByUser(::grpc::ServerContext* context, const AttributeWasSetByUserRequest* request, AttributeWasSetByUserResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto rep_cap_name_mbcs = convert_from_grpc<std::string>(request->rep_cap_name());
      auto rep_cap_name = rep_cap_name_mbcs.c_str();
      ViAttr attribute_id = request->attribute_id();
      auto status = library_->AttributeWasSetByUser(vi, rep_cap_name, attribute_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDmmRestrictedService::CachedReadStatus(::grpc::ServerContext* context, const CachedReadStatusRequest* request, CachedReadStatusResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 acq_backlog {};
      ViInt16 acq_status {};
      auto status = library_->CachedReadStatus(vi, &acq_backlog, &acq_status);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_acq_backlog(acq_backlog);
      response->set_acq_status(static_cast<nidmm_restricted_grpc::AcquisitionStatus>(acq_status));
      response->set_acq_status_raw(acq_status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDmmRestrictedService::FetchMultiPointWithCaching(::grpc::ServerContext* context, const FetchMultiPointWithCachingRequest* request, FetchMultiPointWithCachingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 max_time = request->max_time();
      ViInt32 array_size = request->array_size();
      ViBoolean is_monitoring = request->is_monitoring();
      response->mutable_reading_array()->Resize(array_size, 0);
      ViReal64* reading_array = response->mutable_reading_array()->mutable_data();
      ViInt32 actual_pts {};
      auto status = library_->FetchMultiPointWithCaching(vi, max_time, array_size, reading_array, &actual_pts, is_monitoring);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_actual_pts(actual_pts);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDmmRestrictedService::GetOpenSessionsInformation(::grpc::ServerContext* context, const GetOpenSessionsInformationRequest* request, GetOpenSessionsInformationResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto resource_name_mbcs = convert_from_grpc<std::string>(request->resource_name());
      ViRsrc resource_name = (ViRsrc)resource_name_mbcs.c_str();
      ViUInt64 buffer_size_needed_in_bytes {};
      while (true) {
        auto status = library_->GetOpenSessionsInformation(resource_name, nullptr, 0, &buffer_size_needed_in_bytes);
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        std::string info_json;
        if (buffer_size_needed_in_bytes > 0) {
            info_json.resize(buffer_size_needed_in_bytes - 1);
        }
        auto buffer_size = buffer_size_needed_in_bytes;
        status = library_->GetOpenSessionsInformation(resource_name, (ViChar*)info_json.data(), buffer_size, &buffer_size_needed_in_bytes);
        if (status == kErrorReadBufferTooSmall || status == kWarningCAPIStringTruncatedToFitBuffer) {
          // buffer is now too small, try again
          continue;
        }
        if (!status_ok(status)) {
          return ConvertApiErrorStatusForViSession(context, status, 0);
        }
        response->set_status(status);
        std::string info_json_utf8;
        convert_to_grpc(info_json, &info_json_utf8);
        response->set_info_json(info_json_utf8);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_info_json()));
        response->set_buffer_size_needed_in_bytes(buffer_size_needed_in_bytes);
        return ::grpc::Status::OK;
      }
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDmmRestrictedService::RequestPrivilege(::grpc::ServerContext* context, const RequestPrivilegeRequest* request, RequestPrivilegeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt32 privilege_level;
      switch (request->privilege_level_enum_case()) {
        case nidmm_restricted_grpc::RequestPrivilegeRequest::PrivilegeLevelEnumCase::kPrivilegeLevel: {
          privilege_level = static_cast<ViInt32>(request->privilege_level());
          break;
        }
        case nidmm_restricted_grpc::RequestPrivilegeRequest::PrivilegeLevelEnumCase::kPrivilegeLevelRaw: {
          privilege_level = static_cast<ViInt32>(request->privilege_level_raw());
          break;
        }
        case nidmm_restricted_grpc::RequestPrivilegeRequest::PrivilegeLevelEnumCase::PRIVILEGE_LEVEL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for privilege_level was not specified or out of range");
          break;
        }
      }

      auto status = library_->RequestPrivilege(vi, privilege_level);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  NiDmmRestrictedFeatureToggles::NiDmmRestrictedFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nidmm_restricted", CodeReadiness::kRelease))
  {
  }
} // namespace nidmm_restricted_grpc

