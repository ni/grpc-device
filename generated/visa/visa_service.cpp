
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the VISA Metadata
//---------------------------------------------------------------------
#include "visa_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include <server/converters.h>

namespace visa_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  VisaService::VisaService(
      LibrarySharedPtr library,
      ResourceRepositorySharedPtr resource_repository,
      ViObjectResourceRepositorySharedPtr vi_object_resource_repository,
      const VisaFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      vi_object_resource_repository_(vi_object_resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  VisaService::~VisaService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::AssertIntrSignal(::grpc::ServerContext* context, const AssertIntrSignalRequest* request, AssertIntrSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 mode;
      switch (request->mode_enum_case()) {
        case visa_grpc::AssertIntrSignalRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViInt16>(request->mode());
          break;
        }
        case visa_grpc::AssertIntrSignalRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViInt16>(request->mode_raw());
          break;
        }
        case visa_grpc::AssertIntrSignalRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      ViUInt32 status_id = request->status_id();
      auto status = library_->AssertIntrSignal(vi, mode, status_id);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::AssertTrigger(::grpc::ServerContext* context, const AssertTriggerRequest* request, AssertTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 protocol;
      switch (request->protocol_enum_case()) {
        case visa_grpc::AssertTriggerRequest::ProtocolEnumCase::kProtocol: {
          protocol = static_cast<ViUInt16>(request->protocol());
          break;
        }
        case visa_grpc::AssertTriggerRequest::ProtocolEnumCase::kProtocolRaw: {
          protocol = static_cast<ViUInt16>(request->protocol_raw());
          break;
        }
        case visa_grpc::AssertTriggerRequest::ProtocolEnumCase::PROTOCOL_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for protocol was not specified or out of range");
          break;
        }
      }

      auto status = library_->AssertTrigger(vi, protocol);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::AssertUtilSignal(::grpc::ServerContext* context, const AssertUtilSignalRequest* request, AssertUtilSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mode;
      switch (request->mode_enum_case()) {
        case visa_grpc::AssertUtilSignalRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViUInt16>(request->mode());
          break;
        }
        case visa_grpc::AssertUtilSignalRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViUInt16>(request->mode_raw());
          break;
        }
        case visa_grpc::AssertUtilSignalRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->AssertUtilSignal(vi, mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Clear(::grpc::ServerContext* context, const ClearRequest* request, ClearResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Clear(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::DisableEvent(::grpc::ServerContext* context, const DisableEventRequest* request, DisableEventResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViEventType event_type;
      switch (request->event_type_enum_case()) {
        case visa_grpc::DisableEventRequest::EventTypeEnumCase::kEventType: {
          event_type = static_cast<ViEventType>(request->event_type());
          break;
        }
        case visa_grpc::DisableEventRequest::EventTypeEnumCase::kEventTypeRaw: {
          event_type = static_cast<ViEventType>(request->event_type_raw());
          break;
        }
        case visa_grpc::DisableEventRequest::EventTypeEnumCase::EVENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_type was not specified or out of range");
          break;
        }
      }

      ViUInt16 event_mechanism;
      switch (request->event_mechanism_enum_case()) {
        case visa_grpc::DisableEventRequest::EventMechanismEnumCase::kEventMechanism: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism());
          break;
        }
        case visa_grpc::DisableEventRequest::EventMechanismEnumCase::kEventMechanismRaw: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism_raw());
          break;
        }
        case visa_grpc::DisableEventRequest::EventMechanismEnumCase::EVENT_MECHANISM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_mechanism was not specified or out of range");
          break;
        }
      }

      auto status = library_->DisableEvent(vi, event_type, event_mechanism);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::DiscardEvents(::grpc::ServerContext* context, const DiscardEventsRequest* request, DiscardEventsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViEventType event_type;
      switch (request->event_type_enum_case()) {
        case visa_grpc::DiscardEventsRequest::EventTypeEnumCase::kEventType: {
          event_type = static_cast<ViEventType>(request->event_type());
          break;
        }
        case visa_grpc::DiscardEventsRequest::EventTypeEnumCase::kEventTypeRaw: {
          event_type = static_cast<ViEventType>(request->event_type_raw());
          break;
        }
        case visa_grpc::DiscardEventsRequest::EventTypeEnumCase::EVENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_type was not specified or out of range");
          break;
        }
      }

      ViUInt16 event_mechanism;
      switch (request->event_mechanism_enum_case()) {
        case visa_grpc::DiscardEventsRequest::EventMechanismEnumCase::kEventMechanism: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism());
          break;
        }
        case visa_grpc::DiscardEventsRequest::EventMechanismEnumCase::kEventMechanismRaw: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism_raw());
          break;
        }
        case visa_grpc::DiscardEventsRequest::EventMechanismEnumCase::EVENT_MECHANISM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_mechanism was not specified or out of range");
          break;
        }
      }

      auto status = library_->DiscardEvents(vi, event_type, event_mechanism);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::EnableEvent(::grpc::ServerContext* context, const EnableEventRequest* request, EnableEventResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViEventType event_type;
      switch (request->event_type_enum_case()) {
        case visa_grpc::EnableEventRequest::EventTypeEnumCase::kEventType: {
          event_type = static_cast<ViEventType>(request->event_type());
          break;
        }
        case visa_grpc::EnableEventRequest::EventTypeEnumCase::kEventTypeRaw: {
          event_type = static_cast<ViEventType>(request->event_type_raw());
          break;
        }
        case visa_grpc::EnableEventRequest::EventTypeEnumCase::EVENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_type was not specified or out of range");
          break;
        }
      }

      ViUInt16 event_mechanism;
      switch (request->event_mechanism_enum_case()) {
        case visa_grpc::EnableEventRequest::EventMechanismEnumCase::kEventMechanism: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism());
          break;
        }
        case visa_grpc::EnableEventRequest::EventMechanismEnumCase::kEventMechanismRaw: {
          event_mechanism = static_cast<ViUInt16>(request->event_mechanism_raw());
          break;
        }
        case visa_grpc::EnableEventRequest::EventMechanismEnumCase::EVENT_MECHANISM_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for event_mechanism was not specified or out of range");
          break;
        }
      }

      ViEventFilter filter_context = request->filter_context();
      auto status = library_->EnableEvent(vi, event_type, event_mechanism, filter_context);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Flush(::grpc::ServerContext* context, const FlushRequest* request, FlushResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mask;
      switch (request->mask_enum_case()) {
        case visa_grpc::FlushRequest::MaskEnumCase::kMask: {
          mask = static_cast<ViUInt16>(request->mask());
          break;
        }
        case visa_grpc::FlushRequest::MaskEnumCase::kMaskRaw: {
          mask = static_cast<ViUInt16>(request->mask_raw());
          break;
        }
        case visa_grpc::FlushRequest::MaskEnumCase::MASK_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mask was not specified or out of range");
          break;
        }
      }

      auto status = library_->Flush(vi, mask);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::GpibCommand(::grpc::ServerContext* context, const GpibCommandRequest* request, GpibCommandResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViByte* buffer = (ViByte*)request->buffer().c_str();
      ViUInt32 count = static_cast<ViUInt32>(request->buffer().size());
      ViUInt32 return_count {};
      auto status = library_->GpibCommand(vi, buffer, count, &return_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_return_count(return_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::GpibControlATN(::grpc::ServerContext* context, const GpibControlATNRequest* request, GpibControlATNResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mode;
      switch (request->mode_enum_case()) {
        case visa_grpc::GpibControlATNRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViUInt16>(request->mode());
          break;
        }
        case visa_grpc::GpibControlATNRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViUInt16>(request->mode_raw());
          break;
        }
        case visa_grpc::GpibControlATNRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->GpibControlATN(vi, mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::GpibControlREN(::grpc::ServerContext* context, const GpibControlRENRequest* request, GpibControlRENResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mode;
      switch (request->mode_enum_case()) {
        case visa_grpc::GpibControlRENRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViUInt16>(request->mode());
          break;
        }
        case visa_grpc::GpibControlRENRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViUInt16>(request->mode_raw());
          break;
        }
        case visa_grpc::GpibControlRENRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      auto status = library_->GpibControlREN(vi, mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::GpibPassControl(::grpc::ServerContext* context, const GpibPassControlRequest* request, GpibPassControlResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 primary_address = request->primary_address();
      ViUInt16 secondary_address = request->secondary_address();
      auto status = library_->GpibPassControl(vi, primary_address, secondary_address);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::GpibSendIFC(::grpc::ServerContext* context, const GpibSendIFCRequest* request, GpibSendIFCResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->GpibSendIFC(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::In16(::grpc::ServerContext* context, const In16Request* request, In16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::In16Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::In16Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::In16Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt16 value {};
      auto status = library_->In16(vi, address_space, offset, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::In32(::grpc::ServerContext* context, const In32Request* request, In32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::In32Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::In32Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::In32Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt32 value {};
      auto status = library_->In32(vi, address_space, offset, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::In64(::grpc::ServerContext* context, const In64Request* request, In64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::In64Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::In64Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::In64Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt64 value {};
      auto status = library_->In64(vi, address_space, offset, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::In8(::grpc::ServerContext* context, const In8Request* request, In8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::In8Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::In8Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::In8Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt8 value {};
      auto status = library_->In8(vi, address_space, offset, &value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Lock(::grpc::ServerContext* context, const LockRequest* request, LockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAccessMode lock_type;
      switch (request->lock_type_enum_case()) {
        case visa_grpc::LockRequest::LockTypeEnumCase::kLockType: {
          lock_type = static_cast<ViAccessMode>(request->lock_type());
          break;
        }
        case visa_grpc::LockRequest::LockTypeEnumCase::kLockTypeRaw: {
          lock_type = static_cast<ViAccessMode>(request->lock_type_raw());
          break;
        }
        case visa_grpc::LockRequest::LockTypeEnumCase::LOCK_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for lock_type was not specified or out of range");
          break;
        }
      }

      ViUInt32 timeout = request->timeout();
      auto requested_key_mbcs = convert_from_grpc<std::string>(request->requested_key());
      ViConstKeyId requested_key = (ViConstKeyId)requested_key_mbcs.c_str();
      std::string access_key(256 - 1, '\0');
      auto status = library_->Lock(vi, lock_type, timeout, requested_key, (ViChar*)access_key.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      std::string access_key_utf8;
      convert_to_grpc(access_key, &access_key_utf8);
      response->set_access_key(access_key_utf8);
      nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_access_key()));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MapAddress(::grpc::ServerContext* context, const MapAddressRequest* request, MapAddressResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::MapAddressRequest::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::MapAddressRequest::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::MapAddressRequest::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize map_size = request->map_size();
      ViBoolean owner_access = request->owner_access();
      ViAddr suggested_address = reinterpret_cast<ViAddr>(request->suggested_address());
      ViAddr address {};
      auto status = library_->MapAddress(vi, address_space, offset, map_size, owner_access, suggested_address, &address);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_address(reinterpret_cast<uint64_t>(address));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MapTrigger(::grpc::ServerContext* context, const MapTriggerRequest* request, MapTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 trigger_source;
      switch (request->trigger_source_enum_case()) {
        case visa_grpc::MapTriggerRequest::TriggerSourceEnumCase::kTriggerSource: {
          trigger_source = static_cast<ViInt16>(request->trigger_source());
          break;
        }
        case visa_grpc::MapTriggerRequest::TriggerSourceEnumCase::kTriggerSourceRaw: {
          trigger_source = static_cast<ViInt16>(request->trigger_source_raw());
          break;
        }
        case visa_grpc::MapTriggerRequest::TriggerSourceEnumCase::TRIGGER_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_source was not specified or out of range");
          break;
        }
      }

      ViInt16 trigger_destination;
      switch (request->trigger_destination_enum_case()) {
        case visa_grpc::MapTriggerRequest::TriggerDestinationEnumCase::kTriggerDestination: {
          trigger_destination = static_cast<ViInt16>(request->trigger_destination());
          break;
        }
        case visa_grpc::MapTriggerRequest::TriggerDestinationEnumCase::kTriggerDestinationRaw: {
          trigger_destination = static_cast<ViInt16>(request->trigger_destination_raw());
          break;
        }
        case visa_grpc::MapTriggerRequest::TriggerDestinationEnumCase::TRIGGER_DESTINATION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_destination was not specified or out of range");
          break;
        }
      }

      ViUInt16 mode = request->mode();
      auto status = library_->MapTrigger(vi, trigger_source, trigger_destination, mode);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MemAlloc(::grpc::ServerContext* context, const MemAllocRequest* request, MemAllocResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt32 size = request->size();
      ViBusAddress offset {};
      auto status = library_->MemAlloc(vi, size, &offset);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_offset(offset);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MemAllocEx(::grpc::ServerContext* context, const MemAllocExRequest* request, MemAllocExResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViBusSize size = request->size();
      ViBusAddress64 offset {};
      auto status = library_->MemAllocEx(vi, size, &offset);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_offset(offset);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MemFree(::grpc::ServerContext* context, const MemFreeRequest* request, MemFreeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViBusAddress64 offset = request->offset();
      auto status = library_->MemFree(vi, offset);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MoveIn16(::grpc::ServerContext* context, const MoveIn16Request* request, MoveIn16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::MoveIn16Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::MoveIn16Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::MoveIn16Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = request->count();
      response->mutable_buffer()->Resize(count, 0);
      ViUInt16* buffer = reinterpret_cast<ViUInt16*>(response->mutable_buffer()->mutable_data());
      auto status = library_->MoveIn16(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MoveIn32(::grpc::ServerContext* context, const MoveIn32Request* request, MoveIn32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::MoveIn32Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::MoveIn32Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::MoveIn32Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = request->count();
      response->mutable_buffer()->Resize(count, 0);
      ViUInt32* buffer = reinterpret_cast<ViUInt32*>(response->mutable_buffer()->mutable_data());
      auto status = library_->MoveIn32(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MoveIn64(::grpc::ServerContext* context, const MoveIn64Request* request, MoveIn64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::MoveIn64Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::MoveIn64Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::MoveIn64Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = request->count();
      response->mutable_buffer()->Resize(count, 0);
      ViUInt64* buffer = response->mutable_buffer()->mutable_data();
      auto status = library_->MoveIn64(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MoveIn8(::grpc::ServerContext* context, const MoveIn8Request* request, MoveIn8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::MoveIn8Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::MoveIn8Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::MoveIn8Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = request->count();
      std::string buffer(count, '\0');
      auto status = library_->MoveIn8(vi, address_space, offset, count, (ViUInt8*)buffer.data());
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_buffer(buffer);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MoveOut16(::grpc::ServerContext* context, const MoveOut16Request* request, MoveOut16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::MoveOut16Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::MoveOut16Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::MoveOut16Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = static_cast<ViBusSize>(request->buffer().size());
      auto buffer = const_cast<ViUInt16*>(reinterpret_cast<const ViUInt16*>(request->buffer().data()));
      auto status = library_->MoveOut16(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MoveOut32(::grpc::ServerContext* context, const MoveOut32Request* request, MoveOut32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::MoveOut32Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::MoveOut32Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::MoveOut32Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = static_cast<ViBusSize>(request->buffer().size());
      auto buffer = const_cast<ViUInt32*>(reinterpret_cast<const ViUInt32*>(request->buffer().data()));
      auto status = library_->MoveOut32(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MoveOut64(::grpc::ServerContext* context, const MoveOut64Request* request, MoveOut64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::MoveOut64Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::MoveOut64Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::MoveOut64Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = static_cast<ViBusSize>(request->buffer().size());
      auto buffer = const_cast<ViUInt64*>(request->buffer().data());
      auto status = library_->MoveOut64(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::MoveOut8(::grpc::ServerContext* context, const MoveOut8Request* request, MoveOut8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::MoveOut8Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::MoveOut8Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::MoveOut8Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViBusSize count = static_cast<ViBusSize>(request->buffer().size());
      ViUInt8* buffer = (ViUInt8*)request->buffer().c_str();
      auto status = library_->MoveOut8(vi, address_space, offset, count, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Out16(::grpc::ServerContext* context, const Out16Request* request, Out16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::Out16Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::Out16Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::Out16Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt16 value = request->value();
      auto status = library_->Out16(vi, address_space, offset, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Out32(::grpc::ServerContext* context, const Out32Request* request, Out32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::Out32Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::Out32Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::Out32Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt32 value = request->value();
      auto status = library_->Out32(vi, address_space, offset, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Out64(::grpc::ServerContext* context, const Out64Request* request, Out64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::Out64Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::Out64Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::Out64Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt64 value = request->value();
      auto status = library_->Out64(vi, address_space, offset, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Out8(::grpc::ServerContext* context, const Out8Request* request, Out8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 address_space;
      switch (request->address_space_enum_case()) {
        case visa_grpc::Out8Request::AddressSpaceEnumCase::kAddressSpace: {
          address_space = static_cast<ViUInt16>(request->address_space());
          break;
        }
        case visa_grpc::Out8Request::AddressSpaceEnumCase::kAddressSpaceRaw: {
          address_space = static_cast<ViUInt16>(request->address_space_raw());
          break;
        }
        case visa_grpc::Out8Request::AddressSpaceEnumCase::ADDRESS_SPACE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for address_space was not specified or out of range");
          break;
        }
      }

      ViBusAddress64 offset = request->offset();
      ViUInt8 value = request->value();
      auto status = library_->Out8(vi, address_space, offset, value);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Peek16(::grpc::ServerContext* context, const Peek16Request* request, Peek16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = reinterpret_cast<ViAddr>(request->address());
      ViUInt16 value {};
      library_->Peek16(vi, address, &value);
      auto status = 0;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Peek32(::grpc::ServerContext* context, const Peek32Request* request, Peek32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = reinterpret_cast<ViAddr>(request->address());
      ViUInt32 value {};
      library_->Peek32(vi, address, &value);
      auto status = 0;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Peek64(::grpc::ServerContext* context, const Peek64Request* request, Peek64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = reinterpret_cast<ViAddr>(request->address());
      ViUInt64 value {};
      library_->Peek64(vi, address, &value);
      auto status = 0;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Peek8(::grpc::ServerContext* context, const Peek8Request* request, Peek8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = reinterpret_cast<ViAddr>(request->address());
      ViUInt8 value {};
      library_->Peek8(vi, address, &value);
      auto status = 0;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_value(value);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Poke16(::grpc::ServerContext* context, const Poke16Request* request, Poke16Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = reinterpret_cast<ViAddr>(request->address());
      ViUInt16 value = request->value();
      library_->Poke16(vi, address, value);
      auto status = 0;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Poke32(::grpc::ServerContext* context, const Poke32Request* request, Poke32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = reinterpret_cast<ViAddr>(request->address());
      ViUInt32 value = request->value();
      library_->Poke32(vi, address, value);
      auto status = 0;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Poke64(::grpc::ServerContext* context, const Poke64Request* request, Poke64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = reinterpret_cast<ViAddr>(request->address());
      ViUInt64 value = request->value();
      library_->Poke64(vi, address, value);
      auto status = 0;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Poke8(::grpc::ServerContext* context, const Poke8Request* request, Poke8Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViAddr address = reinterpret_cast<ViAddr>(request->address());
      ViUInt8 value = request->value();
      library_->Poke8(vi, address, value);
      auto status = 0;
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::PxiReserveTriggers(::grpc::ServerContext* context, const PxiReserveTriggersRequest* request, PxiReserveTriggersResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto cnt_determine_from_sizes = std::array<int, 2>
      {
        request->trig_buses_size(),
        request->trig_lines_size()
      };
      const auto cnt_size_calculation = calculate_linked_array_size(cnt_determine_from_sizes, false);

      if (cnt_size_calculation.match_state == MatchState::MISMATCH) {
        return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The sizes of linked repeated fields [trig_buses, trig_lines] do not match");
      }
      auto cnt = cnt_size_calculation.size;

      auto trig_buses_request = request->trig_buses();
      std::vector<ViInt16> trig_buses;
      std::transform(
        trig_buses_request.begin(),
        trig_buses_request.end(),
        std::back_inserter(trig_buses),
        [](auto x) { return (ViInt16)x; }); 
      auto trig_lines_request = request->trig_lines();
      std::vector<ViInt16> trig_lines;
      std::transform(
        trig_lines_request.begin(),
        trig_lines_request.end(),
        std::back_inserter(trig_lines),
        [](auto x) { return (ViInt16)x; }); 
      ViInt16 failure_index {};
      auto status = library_->PxiReserveTriggers(vi, cnt, trig_buses.data(), trig_lines.data(), &failure_index);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_failure_index(failure_index);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::ReadSTB(::grpc::ServerContext* context, const ReadSTBRequest* request, ReadSTBResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 status_byte {};
      auto status = library_->ReadSTB(vi, &status_byte);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_status_byte(status_byte);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::SetBuf(::grpc::ServerContext* context, const SetBufRequest* request, SetBufResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mask;
      switch (request->mask_enum_case()) {
        case visa_grpc::SetBufRequest::MaskEnumCase::kMask: {
          mask = static_cast<ViUInt16>(request->mask());
          break;
        }
        case visa_grpc::SetBufRequest::MaskEnumCase::kMaskRaw: {
          mask = static_cast<ViUInt16>(request->mask_raw());
          break;
        }
        case visa_grpc::SetBufRequest::MaskEnumCase::MASK_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mask was not specified or out of range");
          break;
        }
      }

      ViUInt32 buffer_size = request->buffer_size();
      auto status = library_->SetBuf(vi, mask, buffer_size);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Terminate(::grpc::ServerContext* context, const TerminateRequest* request, TerminateResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 degree = request->degree();
      ViJobId job_identifier = request->job_identifier();
      auto status = library_->Terminate(vi, degree, job_identifier);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Unlock(::grpc::ServerContext* context, const UnlockRequest* request, UnlockResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->Unlock(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::UnmapAddress(::grpc::ServerContext* context, const UnmapAddressRequest* request, UnmapAddressResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      auto status = library_->UnmapAddress(vi);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::UnmapTrigger(::grpc::ServerContext* context, const UnmapTriggerRequest* request, UnmapTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 trigger_source;
      switch (request->trigger_source_enum_case()) {
        case visa_grpc::UnmapTriggerRequest::TriggerSourceEnumCase::kTriggerSource: {
          trigger_source = static_cast<ViInt16>(request->trigger_source());
          break;
        }
        case visa_grpc::UnmapTriggerRequest::TriggerSourceEnumCase::kTriggerSourceRaw: {
          trigger_source = static_cast<ViInt16>(request->trigger_source_raw());
          break;
        }
        case visa_grpc::UnmapTriggerRequest::TriggerSourceEnumCase::TRIGGER_SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_source was not specified or out of range");
          break;
        }
      }

      ViInt16 trigger_destination;
      switch (request->trigger_destination_enum_case()) {
        case visa_grpc::UnmapTriggerRequest::TriggerDestinationEnumCase::kTriggerDestination: {
          trigger_destination = static_cast<ViInt16>(request->trigger_destination());
          break;
        }
        case visa_grpc::UnmapTriggerRequest::TriggerDestinationEnumCase::kTriggerDestinationRaw: {
          trigger_destination = static_cast<ViInt16>(request->trigger_destination_raw());
          break;
        }
        case visa_grpc::UnmapTriggerRequest::TriggerDestinationEnumCase::TRIGGER_DESTINATION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for trigger_destination was not specified or out of range");
          break;
        }
      }

      auto status = library_->UnmapTrigger(vi, trigger_source, trigger_destination);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::UsbControlOut(::grpc::ServerContext* context, const UsbControlOutRequest* request, UsbControlOutResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViInt16 bm_request_type = static_cast<ViInt16>(request->bm_request_type());
      ViInt16 b_request = static_cast<ViInt16>(request->b_request());
      ViUInt16 w_value = request->w_value();
      ViUInt16 w_index = request->w_index();
      ViUInt16 w_length = static_cast<ViUInt16>(request->buffer().size());
      ViByte* buffer = (ViByte*)request->buffer().c_str();
      auto status = library_->UsbControlOut(vi, bm_request_type, b_request, w_value, w_index, w_length, buffer);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::VxiCommandQuery(::grpc::ServerContext* context, const VxiCommandQueryRequest* request, VxiCommandQueryResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViUInt16 mode;
      switch (request->mode_enum_case()) {
        case visa_grpc::VxiCommandQueryRequest::ModeEnumCase::kMode: {
          mode = static_cast<ViUInt16>(request->mode());
          break;
        }
        case visa_grpc::VxiCommandQueryRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<ViUInt16>(request->mode_raw());
          break;
        }
        case visa_grpc::VxiCommandQueryRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      ViUInt32 command = request->command();
      ViUInt32 command_response {};
      auto status = library_->VxiCommandQuery(vi, mode, command, &command_response);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_command_response(command_response);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::WaitOnEvent(::grpc::ServerContext* context, const WaitOnEventRequest* request, WaitOnEventResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViEventType in_event_type;
      switch (request->in_event_type_enum_case()) {
        case visa_grpc::WaitOnEventRequest::InEventTypeEnumCase::kInEventType: {
          in_event_type = static_cast<ViEventType>(request->in_event_type());
          break;
        }
        case visa_grpc::WaitOnEventRequest::InEventTypeEnumCase::kInEventTypeRaw: {
          in_event_type = static_cast<ViEventType>(request->in_event_type_raw());
          break;
        }
        case visa_grpc::WaitOnEventRequest::InEventTypeEnumCase::IN_EVENT_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for in_event_type was not specified or out of range");
          break;
        }
      }

      ViUInt32 timeout = request->timeout();
      ViEventType out_event_type {};
      ViEvent event_handle {};
      auto status = library_->WaitOnEvent(vi, in_event_type, timeout, &out_event_type, &event_handle);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_out_event_type(static_cast<visa_grpc::EventType>(out_event_type));
      response->set_out_event_type_raw(out_event_type);
      response->set_event_handle(event_handle);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status VisaService::Write(::grpc::ServerContext* context, const WriteRequest* request, WriteResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto vi_grpc_session = request->vi();
      ViSession vi = session_repository_->access_session(vi_grpc_session.name());
      ViByte* buffer = (ViByte*)request->buffer().c_str();
      ViUInt32 count = static_cast<ViUInt32>(request->buffer().size());
      ViUInt32 return_count {};
      auto status = library_->Write(vi, buffer, count, &return_count);
      if (!status_ok(status)) {
        return ConvertApiErrorStatusForViSession(context, status, vi);
      }
      response->set_status(status);
      response->set_return_count(return_count);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::NonDriverException& ex) {
      return ex.GetStatus();
    }
  }


  VisaFeatureToggles::VisaFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("visa", CodeReadiness::kNextRelease))
  {
  }
} // namespace visa_grpc

