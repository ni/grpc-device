
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// EXPERIMENTAL Client convenience wrapper for VISA.
//---------------------------------------------------------------------
#include "visa_client.h"

#include <grpcpp/grpcpp.h>

#include <visa.grpc.pb.h>

#include <cstdint>
#include <memory>
#include <stdexcept>
#include <vector>

namespace visa_grpc::experimental::client {

AssertIntrSignalResponse
assert_intr_signal(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AssertInterruptSignalMode, pb::int32>& mode, const pb::uint32& status_id)
{
  ::grpc::ClientContext context;

  auto request = AssertIntrSignalRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto mode_ptr = mode.get_if<AssertInterruptSignalMode>();
  const auto mode_raw_ptr = mode.get_if<pb::int32>();
  if (mode_ptr) {
    request.set_mode(*mode_ptr);
  }
  else if (mode_raw_ptr) {
    request.set_mode_raw(*mode_raw_ptr);
  }
  request.set_status_id(status_id);

  auto response = AssertIntrSignalResponse{};

  raise_if_error(
      stub->AssertIntrSignal(&context, request, &response),
      context);

  return response;
}

AssertTriggerResponse
assert_trigger(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<TriggerProtocol, pb::uint32>& protocol)
{
  ::grpc::ClientContext context;

  auto request = AssertTriggerRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto protocol_ptr = protocol.get_if<TriggerProtocol>();
  const auto protocol_raw_ptr = protocol.get_if<pb::uint32>();
  if (protocol_ptr) {
    request.set_protocol(*protocol_ptr);
  }
  else if (protocol_raw_ptr) {
    request.set_protocol_raw(*protocol_raw_ptr);
  }

  auto response = AssertTriggerResponse{};

  raise_if_error(
      stub->AssertTrigger(&context, request, &response),
      context);

  return response;
}

AssertUtilSignalResponse
assert_util_signal(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AssertUtilSignalMode, pb::uint32>& mode)
{
  ::grpc::ClientContext context;

  auto request = AssertUtilSignalRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto mode_ptr = mode.get_if<AssertUtilSignalMode>();
  const auto mode_raw_ptr = mode.get_if<pb::uint32>();
  if (mode_ptr) {
    request.set_mode(*mode_ptr);
  }
  else if (mode_raw_ptr) {
    request.set_mode_raw(*mode_raw_ptr);
  }

  auto response = AssertUtilSignalResponse{};

  raise_if_error(
      stub->AssertUtilSignal(&context, request, &response),
      context);

  return response;
}

ClearResponse
clear(const StubPtr& stub, const nidevice_grpc::Session& vi)
{
  ::grpc::ClientContext context;

  auto request = ClearRequest{};
  request.mutable_vi()->CopyFrom(vi);

  auto response = ClearResponse{};

  raise_if_error(
      stub->Clear(&context, request, &response),
      context);

  return response;
}

CloseResponse
close(const StubPtr& stub, const SessionOrObjectData& object_handle)
{
  ::grpc::ClientContext context;

  auto request = CloseRequest{};
  request.mutable_object_handle()->CopyFrom(object_handle);

  auto response = CloseResponse{};

  raise_if_error(
      stub->Close(&context, request, &response),
      context);

  return response;
}

DisableEventResponse
disable_event(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<EventType, pb::uint32>& event_type, const simple_variant<EventMechanism, pb::uint32>& event_mechanism)
{
  ::grpc::ClientContext context;

  auto request = DisableEventRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto event_type_ptr = event_type.get_if<EventType>();
  const auto event_type_raw_ptr = event_type.get_if<pb::uint32>();
  if (event_type_ptr) {
    request.set_event_type(*event_type_ptr);
  }
  else if (event_type_raw_ptr) {
    request.set_event_type_raw(*event_type_raw_ptr);
  }
  const auto event_mechanism_ptr = event_mechanism.get_if<EventMechanism>();
  const auto event_mechanism_raw_ptr = event_mechanism.get_if<pb::uint32>();
  if (event_mechanism_ptr) {
    request.set_event_mechanism(*event_mechanism_ptr);
  }
  else if (event_mechanism_raw_ptr) {
    request.set_event_mechanism_raw(*event_mechanism_raw_ptr);
  }

  auto response = DisableEventResponse{};

  raise_if_error(
      stub->DisableEvent(&context, request, &response),
      context);

  return response;
}

DiscardEventsResponse
discard_events(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<EventType, pb::uint32>& event_type, const simple_variant<EventMechanism, pb::uint32>& event_mechanism)
{
  ::grpc::ClientContext context;

  auto request = DiscardEventsRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto event_type_ptr = event_type.get_if<EventType>();
  const auto event_type_raw_ptr = event_type.get_if<pb::uint32>();
  if (event_type_ptr) {
    request.set_event_type(*event_type_ptr);
  }
  else if (event_type_raw_ptr) {
    request.set_event_type_raw(*event_type_raw_ptr);
  }
  const auto event_mechanism_ptr = event_mechanism.get_if<EventMechanism>();
  const auto event_mechanism_raw_ptr = event_mechanism.get_if<pb::uint32>();
  if (event_mechanism_ptr) {
    request.set_event_mechanism(*event_mechanism_ptr);
  }
  else if (event_mechanism_raw_ptr) {
    request.set_event_mechanism_raw(*event_mechanism_raw_ptr);
  }

  auto response = DiscardEventsResponse{};

  raise_if_error(
      stub->DiscardEvents(&context, request, &response),
      context);

  return response;
}

EnableEventResponse
enable_event(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<EventType, pb::uint32>& event_type, const simple_variant<EventMechanism, pb::uint32>& event_mechanism, const pb::uint32& filter_context)
{
  ::grpc::ClientContext context;

  auto request = EnableEventRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto event_type_ptr = event_type.get_if<EventType>();
  const auto event_type_raw_ptr = event_type.get_if<pb::uint32>();
  if (event_type_ptr) {
    request.set_event_type(*event_type_ptr);
  }
  else if (event_type_raw_ptr) {
    request.set_event_type_raw(*event_type_raw_ptr);
  }
  const auto event_mechanism_ptr = event_mechanism.get_if<EventMechanism>();
  const auto event_mechanism_raw_ptr = event_mechanism.get_if<pb::uint32>();
  if (event_mechanism_ptr) {
    request.set_event_mechanism(*event_mechanism_ptr);
  }
  else if (event_mechanism_raw_ptr) {
    request.set_event_mechanism_raw(*event_mechanism_raw_ptr);
  }
  request.set_filter_context(filter_context);

  auto response = EnableEventResponse{};

  raise_if_error(
      stub->EnableEvent(&context, request, &response),
      context);

  return response;
}

FindRsrcResponse
find_rsrc(const StubPtr& stub, const std::string& expression)
{
  ::grpc::ClientContext context;

  auto request = FindRsrcRequest{};
  request.set_expression(expression);

  auto response = FindRsrcResponse{};

  raise_if_error(
      stub->FindRsrc(&context, request, &response),
      context);

  return response;
}

FlushResponse
flush(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<BufferMask, pb::uint32>& mask)
{
  ::grpc::ClientContext context;

  auto request = FlushRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto mask_ptr = mask.get_if<BufferMask>();
  const auto mask_raw_ptr = mask.get_if<pb::uint32>();
  if (mask_ptr) {
    request.set_mask(*mask_ptr);
  }
  else if (mask_raw_ptr) {
    request.set_mask_raw(*mask_raw_ptr);
  }

  auto response = FlushResponse{};

  raise_if_error(
      stub->Flush(&context, request, &response),
      context);

  return response;
}

GetAttributeResponse
get_attribute(const StubPtr& stub, const SessionOrObjectData& object_handle, const VisaAttribute& attribute_name)
{
  ::grpc::ClientContext context;

  auto request = GetAttributeRequest{};
  request.mutable_object_handle()->CopyFrom(object_handle);
  request.set_attribute_name(attribute_name);

  auto response = GetAttributeResponse{};

  raise_if_error(
      stub->GetAttribute(&context, request, &response),
      context);

  return response;
}

GpibCommandResponse
gpib_command(const StubPtr& stub, const nidevice_grpc::Session& vi, const std::string& buffer)
{
  ::grpc::ClientContext context;

  auto request = GpibCommandRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_buffer(buffer);

  auto response = GpibCommandResponse{};

  raise_if_error(
      stub->GpibCommand(&context, request, &response),
      context);

  return response;
}

GpibControlATNResponse
gpib_control_atn(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<GpibControlAtnMode, pb::uint32>& mode)
{
  ::grpc::ClientContext context;

  auto request = GpibControlATNRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto mode_ptr = mode.get_if<GpibControlAtnMode>();
  const auto mode_raw_ptr = mode.get_if<pb::uint32>();
  if (mode_ptr) {
    request.set_mode(*mode_ptr);
  }
  else if (mode_raw_ptr) {
    request.set_mode_raw(*mode_raw_ptr);
  }

  auto response = GpibControlATNResponse{};

  raise_if_error(
      stub->GpibControlATN(&context, request, &response),
      context);

  return response;
}

GpibControlRENResponse
gpib_control_ren(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<GpibControlRenMode, pb::uint32>& mode)
{
  ::grpc::ClientContext context;

  auto request = GpibControlRENRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto mode_ptr = mode.get_if<GpibControlRenMode>();
  const auto mode_raw_ptr = mode.get_if<pb::uint32>();
  if (mode_ptr) {
    request.set_mode(*mode_ptr);
  }
  else if (mode_raw_ptr) {
    request.set_mode_raw(*mode_raw_ptr);
  }

  auto response = GpibControlRENResponse{};

  raise_if_error(
      stub->GpibControlREN(&context, request, &response),
      context);

  return response;
}

GpibPassControlResponse
gpib_pass_control(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint32& primary_address, const pb::uint32& secondary_address)
{
  ::grpc::ClientContext context;

  auto request = GpibPassControlRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_primary_address(primary_address);
  request.set_secondary_address(secondary_address);

  auto response = GpibPassControlResponse{};

  raise_if_error(
      stub->GpibPassControl(&context, request, &response),
      context);

  return response;
}

GpibSendIFCResponse
gpib_send_ifc(const StubPtr& stub, const nidevice_grpc::Session& vi)
{
  ::grpc::ClientContext context;

  auto request = GpibSendIFCRequest{};
  request.mutable_vi()->CopyFrom(vi);

  auto response = GpibSendIFCResponse{};

  raise_if_error(
      stub->GpibSendIFC(&context, request, &response),
      context);

  return response;
}

In16ExResponse
in16_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset)
{
  ::grpc::ClientContext context;

  auto request = In16ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);

  auto response = In16ExResponse{};

  raise_if_error(
      stub->In16Ex(&context, request, &response),
      context);

  return response;
}

In32ExResponse
in32_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset)
{
  ::grpc::ClientContext context;

  auto request = In32ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);

  auto response = In32ExResponse{};

  raise_if_error(
      stub->In32Ex(&context, request, &response),
      context);

  return response;
}

In64ExResponse
in64_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset)
{
  ::grpc::ClientContext context;

  auto request = In64ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);

  auto response = In64ExResponse{};

  raise_if_error(
      stub->In64Ex(&context, request, &response),
      context);

  return response;
}

In8ExResponse
in8_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset)
{
  ::grpc::ClientContext context;

  auto request = In8ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);

  auto response = In8ExResponse{};

  raise_if_error(
      stub->In8Ex(&context, request, &response),
      context);

  return response;
}

LockResponse
lock(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<LockState, pb::uint32>& lock_type, const pb::uint32& timeout, const std::string& requested_key)
{
  ::grpc::ClientContext context;

  auto request = LockRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto lock_type_ptr = lock_type.get_if<LockState>();
  const auto lock_type_raw_ptr = lock_type.get_if<pb::uint32>();
  if (lock_type_ptr) {
    request.set_lock_type(*lock_type_ptr);
  }
  else if (lock_type_raw_ptr) {
    request.set_lock_type_raw(*lock_type_raw_ptr);
  }
  request.set_timeout(timeout);
  request.set_requested_key(requested_key);

  auto response = LockResponse{};

  raise_if_error(
      stub->Lock(&context, request, &response),
      context);

  return response;
}

MapAddressExResponse
map_address_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const pb::uint64& map_size, const bool& owner_access, const pb::uint64& suggested_address)
{
  ::grpc::ClientContext context;

  auto request = MapAddressExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  request.set_map_size(map_size);
  request.set_owner_access(owner_access);
  request.set_suggested_address(suggested_address);

  auto response = MapAddressExResponse{};

  raise_if_error(
      stub->MapAddressEx(&context, request, &response),
      context);

  return response;
}

MapTriggerResponse
map_trigger(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<TriggerLine, pb::int32>& trigger_source, const simple_variant<TriggerLine, pb::int32>& trigger_destination, const pb::uint32& mode)
{
  ::grpc::ClientContext context;

  auto request = MapTriggerRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto trigger_source_ptr = trigger_source.get_if<TriggerLine>();
  const auto trigger_source_raw_ptr = trigger_source.get_if<pb::int32>();
  if (trigger_source_ptr) {
    request.set_trigger_source(*trigger_source_ptr);
  }
  else if (trigger_source_raw_ptr) {
    request.set_trigger_source_raw(*trigger_source_raw_ptr);
  }
  const auto trigger_destination_ptr = trigger_destination.get_if<TriggerLine>();
  const auto trigger_destination_raw_ptr = trigger_destination.get_if<pb::int32>();
  if (trigger_destination_ptr) {
    request.set_trigger_destination(*trigger_destination_ptr);
  }
  else if (trigger_destination_raw_ptr) {
    request.set_trigger_destination_raw(*trigger_destination_raw_ptr);
  }
  request.set_mode(mode);

  auto response = MapTriggerResponse{};

  raise_if_error(
      stub->MapTrigger(&context, request, &response),
      context);

  return response;
}

MemAllocResponse
mem_alloc(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint32& size)
{
  ::grpc::ClientContext context;

  auto request = MemAllocRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_size(size);

  auto response = MemAllocResponse{};

  raise_if_error(
      stub->MemAlloc(&context, request, &response),
      context);

  return response;
}

MemAllocExResponse
mem_alloc_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint64& size)
{
  ::grpc::ClientContext context;

  auto request = MemAllocExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_size(size);

  auto response = MemAllocExResponse{};

  raise_if_error(
      stub->MemAllocEx(&context, request, &response),
      context);

  return response;
}

MemFreeExResponse
mem_free_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint64& offset)
{
  ::grpc::ClientContext context;

  auto request = MemFreeExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_offset(offset);

  auto response = MemFreeExResponse{};

  raise_if_error(
      stub->MemFreeEx(&context, request, &response),
      context);

  return response;
}

MoveIn16ExResponse
move_in16_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const pb::uint64& count)
{
  ::grpc::ClientContext context;

  auto request = MoveIn16ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  request.set_count(count);

  auto response = MoveIn16ExResponse{};

  raise_if_error(
      stub->MoveIn16Ex(&context, request, &response),
      context);

  return response;
}

MoveIn32ExResponse
move_in32_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const pb::uint64& count)
{
  ::grpc::ClientContext context;

  auto request = MoveIn32ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  request.set_count(count);

  auto response = MoveIn32ExResponse{};

  raise_if_error(
      stub->MoveIn32Ex(&context, request, &response),
      context);

  return response;
}

MoveIn64ExResponse
move_in64_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const pb::uint64& count)
{
  ::grpc::ClientContext context;

  auto request = MoveIn64ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  request.set_count(count);

  auto response = MoveIn64ExResponse{};

  raise_if_error(
      stub->MoveIn64Ex(&context, request, &response),
      context);

  return response;
}

MoveIn8ExResponse
move_in8_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const pb::uint64& count)
{
  ::grpc::ClientContext context;

  auto request = MoveIn8ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  request.set_count(count);

  auto response = MoveIn8ExResponse{};

  raise_if_error(
      stub->MoveIn8Ex(&context, request, &response),
      context);

  return response;
}

MoveOut16ExResponse
move_out16_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const std::vector<pb::uint32>& buffer)
{
  ::grpc::ClientContext context;

  auto request = MoveOut16ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  copy_array(buffer, request.mutable_buffer());

  auto response = MoveOut16ExResponse{};

  raise_if_error(
      stub->MoveOut16Ex(&context, request, &response),
      context);

  return response;
}

MoveOut32ExResponse
move_out32_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const std::vector<pb::uint32>& buffer)
{
  ::grpc::ClientContext context;

  auto request = MoveOut32ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  copy_array(buffer, request.mutable_buffer());

  auto response = MoveOut32ExResponse{};

  raise_if_error(
      stub->MoveOut32Ex(&context, request, &response),
      context);

  return response;
}

MoveOut64ExResponse
move_out64_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const std::vector<pb::uint64>& buffer)
{
  ::grpc::ClientContext context;

  auto request = MoveOut64ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  copy_array(buffer, request.mutable_buffer());

  auto response = MoveOut64ExResponse{};

  raise_if_error(
      stub->MoveOut64Ex(&context, request, &response),
      context);

  return response;
}

MoveOut8ExResponse
move_out8_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const std::string& buffer)
{
  ::grpc::ClientContext context;

  auto request = MoveOut8ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  request.set_buffer(buffer);

  auto response = MoveOut8ExResponse{};

  raise_if_error(
      stub->MoveOut8Ex(&context, request, &response),
      context);

  return response;
}

OpenResponse
open(const StubPtr& stub, const std::string& instrument_descriptor, const simple_variant<LockState, pb::uint32>& access_mode, const pb::uint32& open_timeout)
{
  ::grpc::ClientContext context;

  auto request = OpenRequest{};
  request.set_instrument_descriptor(instrument_descriptor);
  const auto access_mode_ptr = access_mode.get_if<LockState>();
  const auto access_mode_raw_ptr = access_mode.get_if<pb::uint32>();
  if (access_mode_ptr) {
    request.set_access_mode(*access_mode_ptr);
  }
  else if (access_mode_raw_ptr) {
    request.set_access_mode_raw(*access_mode_raw_ptr);
  }
  request.set_open_timeout(open_timeout);

  auto response = OpenResponse{};

  raise_if_error(
      stub->Open(&context, request, &response),
      context);

  return response;
}

Out16ExResponse
out16_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = Out16ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  request.set_value(value);

  auto response = Out16ExResponse{};

  raise_if_error(
      stub->Out16Ex(&context, request, &response),
      context);

  return response;
}

Out32ExResponse
out32_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = Out32ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  request.set_value(value);

  auto response = Out32ExResponse{};

  raise_if_error(
      stub->Out32Ex(&context, request, &response),
      context);

  return response;
}

Out64ExResponse
out64_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const pb::uint64& value)
{
  ::grpc::ClientContext context;

  auto request = Out64ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  request.set_value(value);

  auto response = Out64ExResponse{};

  raise_if_error(
      stub->Out64Ex(&context, request, &response),
      context);

  return response;
}

Out8ExResponse
out8_ex(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<AddressSpace, pb::uint32>& address_space, const pb::uint64& offset, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = Out8ExRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto address_space_ptr = address_space.get_if<AddressSpace>();
  const auto address_space_raw_ptr = address_space.get_if<pb::uint32>();
  if (address_space_ptr) {
    request.set_address_space(*address_space_ptr);
  }
  else if (address_space_raw_ptr) {
    request.set_address_space_raw(*address_space_raw_ptr);
  }
  request.set_offset(offset);
  request.set_value(value);

  auto response = Out8ExResponse{};

  raise_if_error(
      stub->Out8Ex(&context, request, &response),
      context);

  return response;
}

ParseRsrcExResponse
parse_rsrc_ex(const StubPtr& stub, const std::string& resource_name)
{
  ::grpc::ClientContext context;

  auto request = ParseRsrcExRequest{};
  request.set_resource_name(resource_name);

  auto response = ParseRsrcExResponse{};

  raise_if_error(
      stub->ParseRsrcEx(&context, request, &response),
      context);

  return response;
}

Peek16Response
peek16(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint64& address)
{
  ::grpc::ClientContext context;

  auto request = Peek16Request{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_address(address);

  auto response = Peek16Response{};

  raise_if_error(
      stub->Peek16(&context, request, &response),
      context);

  return response;
}

Peek32Response
peek32(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint64& address)
{
  ::grpc::ClientContext context;

  auto request = Peek32Request{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_address(address);

  auto response = Peek32Response{};

  raise_if_error(
      stub->Peek32(&context, request, &response),
      context);

  return response;
}

Peek64Response
peek64(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint64& address)
{
  ::grpc::ClientContext context;

  auto request = Peek64Request{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_address(address);

  auto response = Peek64Response{};

  raise_if_error(
      stub->Peek64(&context, request, &response),
      context);

  return response;
}

Peek8Response
peek8(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint64& address)
{
  ::grpc::ClientContext context;

  auto request = Peek8Request{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_address(address);

  auto response = Peek8Response{};

  raise_if_error(
      stub->Peek8(&context, request, &response),
      context);

  return response;
}

Poke16Response
poke16(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint64& address, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = Poke16Request{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_address(address);
  request.set_value(value);

  auto response = Poke16Response{};

  raise_if_error(
      stub->Poke16(&context, request, &response),
      context);

  return response;
}

Poke32Response
poke32(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint64& address, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = Poke32Request{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_address(address);
  request.set_value(value);

  auto response = Poke32Response{};

  raise_if_error(
      stub->Poke32(&context, request, &response),
      context);

  return response;
}

Poke64Response
poke64(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint64& address, const pb::uint64& value)
{
  ::grpc::ClientContext context;

  auto request = Poke64Request{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_address(address);
  request.set_value(value);

  auto response = Poke64Response{};

  raise_if_error(
      stub->Poke64(&context, request, &response),
      context);

  return response;
}

Poke8Response
poke8(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint64& address, const pb::uint32& value)
{
  ::grpc::ClientContext context;

  auto request = Poke8Request{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_address(address);
  request.set_value(value);

  auto response = Poke8Response{};

  raise_if_error(
      stub->Poke8(&context, request, &response),
      context);

  return response;
}

PxiReserveTriggersResponse
pxi_reserve_triggers(const StubPtr& stub, const nidevice_grpc::Session& vi, const std::vector<pb::int32>& trig_buses, const std::vector<pb::int32>& trig_lines)
{
  ::grpc::ClientContext context;

  auto request = PxiReserveTriggersRequest{};
  request.mutable_vi()->CopyFrom(vi);
  copy_array(trig_buses, request.mutable_trig_buses());
  copy_array(trig_lines, request.mutable_trig_lines());

  auto response = PxiReserveTriggersResponse{};

  raise_if_error(
      stub->PxiReserveTriggers(&context, request, &response),
      context);

  return response;
}

ReadResponse
read(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint32& count)
{
  ::grpc::ClientContext context;

  auto request = ReadRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_count(count);

  auto response = ReadResponse{};

  raise_if_error(
      stub->Read(&context, request, &response),
      context);

  return response;
}

ReadAsyncResponse
read_async(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint32& count)
{
  ::grpc::ClientContext context;

  auto request = ReadAsyncRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_count(count);

  auto response = ReadAsyncResponse{};

  raise_if_error(
      stub->ReadAsync(&context, request, &response),
      context);

  return response;
}

ReadSTBResponse
read_stb(const StubPtr& stub, const nidevice_grpc::Session& vi)
{
  ::grpc::ClientContext context;

  auto request = ReadSTBRequest{};
  request.mutable_vi()->CopyFrom(vi);

  auto response = ReadSTBResponse{};

  raise_if_error(
      stub->ReadSTB(&context, request, &response),
      context);

  return response;
}

SetAttributeResponse
set_attribute(const StubPtr& stub, const SessionOrObjectData& object_handle, const VisaAttribute& attribute_name, const AttributeValueData& attribute_value)
{
  ::grpc::ClientContext context;

  auto request = SetAttributeRequest{};
  request.mutable_object_handle()->CopyFrom(object_handle);
  request.set_attribute_name(attribute_name);
  request.mutable_attribute_value()->CopyFrom(attribute_value);

  auto response = SetAttributeResponse{};

  raise_if_error(
      stub->SetAttribute(&context, request, &response),
      context);

  return response;
}

SetBufResponse
set_buf(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<BufferMask, pb::uint32>& mask, const pb::uint32& buffer_size)
{
  ::grpc::ClientContext context;

  auto request = SetBufRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto mask_ptr = mask.get_if<BufferMask>();
  const auto mask_raw_ptr = mask.get_if<pb::uint32>();
  if (mask_ptr) {
    request.set_mask(*mask_ptr);
  }
  else if (mask_raw_ptr) {
    request.set_mask_raw(*mask_raw_ptr);
  }
  request.set_buffer_size(buffer_size);

  auto response = SetBufResponse{};

  raise_if_error(
      stub->SetBuf(&context, request, &response),
      context);

  return response;
}

StatusDescResponse
status_desc(const StubPtr& stub, const SessionOrObjectData& object_handle, const pb::int32& status_value)
{
  ::grpc::ClientContext context;

  auto request = StatusDescRequest{};
  request.mutable_object_handle()->CopyFrom(object_handle);
  request.set_status_value(status_value);

  auto response = StatusDescResponse{};

  raise_if_error(
      stub->StatusDesc(&context, request, &response),
      context);

  return response;
}

TerminateResponse
terminate(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::uint32& degree, const pb::uint32& job_identifier)
{
  ::grpc::ClientContext context;

  auto request = TerminateRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_degree(degree);
  request.set_job_identifier(job_identifier);

  auto response = TerminateResponse{};

  raise_if_error(
      stub->Terminate(&context, request, &response),
      context);

  return response;
}

UnlockResponse
unlock(const StubPtr& stub, const nidevice_grpc::Session& vi)
{
  ::grpc::ClientContext context;

  auto request = UnlockRequest{};
  request.mutable_vi()->CopyFrom(vi);

  auto response = UnlockResponse{};

  raise_if_error(
      stub->Unlock(&context, request, &response),
      context);

  return response;
}

UnmapAddressResponse
unmap_address(const StubPtr& stub, const nidevice_grpc::Session& vi)
{
  ::grpc::ClientContext context;

  auto request = UnmapAddressRequest{};
  request.mutable_vi()->CopyFrom(vi);

  auto response = UnmapAddressResponse{};

  raise_if_error(
      stub->UnmapAddress(&context, request, &response),
      context);

  return response;
}

UnmapTriggerResponse
unmap_trigger(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<TriggerLine, pb::int32>& trigger_source, const simple_variant<TriggerLine, pb::int32>& trigger_destination)
{
  ::grpc::ClientContext context;

  auto request = UnmapTriggerRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto trigger_source_ptr = trigger_source.get_if<TriggerLine>();
  const auto trigger_source_raw_ptr = trigger_source.get_if<pb::int32>();
  if (trigger_source_ptr) {
    request.set_trigger_source(*trigger_source_ptr);
  }
  else if (trigger_source_raw_ptr) {
    request.set_trigger_source_raw(*trigger_source_raw_ptr);
  }
  const auto trigger_destination_ptr = trigger_destination.get_if<TriggerLine>();
  const auto trigger_destination_raw_ptr = trigger_destination.get_if<pb::int32>();
  if (trigger_destination_ptr) {
    request.set_trigger_destination(*trigger_destination_ptr);
  }
  else if (trigger_destination_raw_ptr) {
    request.set_trigger_destination_raw(*trigger_destination_raw_ptr);
  }

  auto response = UnmapTriggerResponse{};

  raise_if_error(
      stub->UnmapTrigger(&context, request, &response),
      context);

  return response;
}

UsbControlInResponse
usb_control_in(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::int32& bm_request_type, const pb::int32& b_request, const pb::uint32& w_value, const pb::uint32& w_index, const pb::uint32& w_length)
{
  ::grpc::ClientContext context;

  auto request = UsbControlInRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_bm_request_type(bm_request_type);
  request.set_b_request(b_request);
  request.set_w_value(w_value);
  request.set_w_index(w_index);
  request.set_w_length(w_length);

  auto response = UsbControlInResponse{};

  raise_if_error(
      stub->UsbControlIn(&context, request, &response),
      context);

  return response;
}

UsbControlOutResponse
usb_control_out(const StubPtr& stub, const nidevice_grpc::Session& vi, const pb::int32& bm_request_type, const pb::int32& b_request, const pb::uint32& w_value, const pb::uint32& w_index, const std::string& buffer)
{
  ::grpc::ClientContext context;

  auto request = UsbControlOutRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_bm_request_type(bm_request_type);
  request.set_b_request(b_request);
  request.set_w_value(w_value);
  request.set_w_index(w_index);
  request.set_buffer(buffer);

  auto response = UsbControlOutResponse{};

  raise_if_error(
      stub->UsbControlOut(&context, request, &response),
      context);

  return response;
}

VxiCommandQueryResponse
vxi_command_query(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<VxiCmdType, pb::uint32>& mode, const pb::uint32& command)
{
  ::grpc::ClientContext context;

  auto request = VxiCommandQueryRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto mode_ptr = mode.get_if<VxiCmdType>();
  const auto mode_raw_ptr = mode.get_if<pb::uint32>();
  if (mode_ptr) {
    request.set_mode(*mode_ptr);
  }
  else if (mode_raw_ptr) {
    request.set_mode_raw(*mode_raw_ptr);
  }
  request.set_command(command);

  auto response = VxiCommandQueryResponse{};

  raise_if_error(
      stub->VxiCommandQuery(&context, request, &response),
      context);

  return response;
}

WaitOnEventResponse
wait_on_event(const StubPtr& stub, const nidevice_grpc::Session& vi, const simple_variant<EventType, pb::uint32>& in_event_type, const pb::uint32& timeout)
{
  ::grpc::ClientContext context;

  auto request = WaitOnEventRequest{};
  request.mutable_vi()->CopyFrom(vi);
  const auto in_event_type_ptr = in_event_type.get_if<EventType>();
  const auto in_event_type_raw_ptr = in_event_type.get_if<pb::uint32>();
  if (in_event_type_ptr) {
    request.set_in_event_type(*in_event_type_ptr);
  }
  else if (in_event_type_raw_ptr) {
    request.set_in_event_type_raw(*in_event_type_raw_ptr);
  }
  request.set_timeout(timeout);

  auto response = WaitOnEventResponse{};

  raise_if_error(
      stub->WaitOnEvent(&context, request, &response),
      context);

  return response;
}

WriteResponse
write(const StubPtr& stub, const nidevice_grpc::Session& vi, const std::string& buffer)
{
  ::grpc::ClientContext context;

  auto request = WriteRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_buffer(buffer);

  auto response = WriteResponse{};

  raise_if_error(
      stub->Write(&context, request, &response),
      context);

  return response;
}

WriteAsyncResponse
write_async(const StubPtr& stub, const nidevice_grpc::Session& vi, const std::string& buffer)
{
  ::grpc::ClientContext context;

  auto request = WriteAsyncRequest{};
  request.mutable_vi()->CopyFrom(vi);
  request.set_buffer(buffer);

  auto response = WriteAsyncResponse{};

  raise_if_error(
      stub->WriteAsync(&context, request, &response),
      context);

  return response;
}


} // namespace visa_grpc::experimental::client
