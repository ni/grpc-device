
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// EXPERIMENTAL Client convenience wrapper for NI-XNET.
//---------------------------------------------------------------------
#include "nixnet_client.h"

#include <grpcpp/grpcpp.h>

#include <nixnet.grpc.pb.h>

#include <cstdint>
#include <memory>
#include <stdexcept>
#include <vector>

namespace nixnet_grpc::experimental::client {

BlinkResponse
blink(const StubPtr& stub, const nidevice_grpc::Session& interface_ref, const simple_variant<BlinkMode, pb::uint32>& modifier)
{
  ::grpc::ClientContext context;

  auto request = BlinkRequest{};
  request.mutable_interface_ref()->CopyFrom(interface_ref);
  const auto modifier_ptr = modifier.get_if<BlinkMode>();
  const auto modifier_raw_ptr = modifier.get_if<pb::uint32>();
  if (modifier_ptr) {
    request.set_modifier(*modifier_ptr);
  }
  else if (modifier_raw_ptr) {
    request.set_modifier_raw(*modifier_raw_ptr);
  }

  auto response = BlinkResponse{};

  raise_if_error(
      stub->Blink(&context, request, &response));

  return response;
}

ClearResponse
clear(const StubPtr& stub, const nidevice_grpc::Session& session)
{
  ::grpc::ClientContext context;

  auto request = ClearRequest{};
  request.mutable_session()->CopyFrom(session);

  auto response = ClearResponse{};

  raise_if_error(
      stub->Clear(&context, request, &response));

  return response;
}

ConnectTerminalsResponse
connect_terminals(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<TerminalName, std::string>& source, const simple_variant<TerminalName, std::string>& destination)
{
  ::grpc::ClientContext context;

  auto request = ConnectTerminalsRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto source_ptr = source.get_if<TerminalName>();
  const auto source_raw_ptr = source.get_if<std::string>();
  if (source_ptr) {
    request.set_source_mapped(*source_ptr);
  }
  else if (source_raw_ptr) {
    request.set_source_raw(*source_raw_ptr);
  }
  const auto destination_ptr = destination.get_if<TerminalName>();
  const auto destination_raw_ptr = destination.get_if<std::string>();
  if (destination_ptr) {
    request.set_destination_mapped(*destination_ptr);
  }
  else if (destination_raw_ptr) {
    request.set_destination_raw(*destination_raw_ptr);
  }

  auto response = ConnectTerminalsResponse{};

  raise_if_error(
      stub->ConnectTerminals(&context, request, &response));

  return response;
}

ConvertByteArrayToFramesSinglePointResponse
convert_byte_array_to_frames_single_point(const StubPtr& stub, const nidevice_grpc::Session& session, const pb::string& value_buffer, const pb::uint32& number_of_frames, const pb::uint32& max_payload_per_frame, const simple_variant<Protocol, pb::uint32>& protocol)
{
  ::grpc::ClientContext context;

  auto request = ConvertByteArrayToFramesSinglePointRequest{};
  request.mutable_session()->CopyFrom(session);
  request.set_value_buffer(value_buffer);
  request.set_number_of_frames(number_of_frames);
  request.set_max_payload_per_frame(max_payload_per_frame);
  const auto protocol_ptr = protocol.get_if<Protocol>();
  const auto protocol_raw_ptr = protocol.get_if<pb::uint32>();
  if (protocol_ptr) {
    request.set_protocol(*protocol_ptr);
  }
  else if (protocol_raw_ptr) {
    request.set_protocol_raw(*protocol_raw_ptr);
  }

  auto response = ConvertByteArrayToFramesSinglePointResponse{};

  raise_if_error(
      stub->ConvertByteArrayToFramesSinglePoint(&context, request, &response));

  return response;
}

ConvertFramesToByteArraySinglePointResponse
convert_frames_to_byte_array_single_point(const StubPtr& stub, const nidevice_grpc::Session& session, const std::vector<FrameBufferRequest>& frame_buffer, const pb::uint32& size_of_value_buffer)
{
  ::grpc::ClientContext context;

  auto request = ConvertFramesToByteArraySinglePointRequest{};
  request.mutable_session()->CopyFrom(session);
  copy_array(frame_buffer, request.mutable_frame_buffer());
  request.set_size_of_value_buffer(size_of_value_buffer);

  auto response = ConvertFramesToByteArraySinglePointResponse{};

  raise_if_error(
      stub->ConvertFramesToByteArraySinglePoint(&context, request, &response));

  return response;
}

ConvertFramesToSignalsSinglePointResponse
convert_frames_to_signals_single_point(const StubPtr& stub, const nidevice_grpc::Session& session, const pb::uint32& number_of_signals, const std::vector<FrameBufferRequest>& frame_buffer)
{
  ::grpc::ClientContext context;

  auto request = ConvertFramesToSignalsSinglePointRequest{};
  request.mutable_session()->CopyFrom(session);
  request.set_number_of_signals(number_of_signals);
  copy_array(frame_buffer, request.mutable_frame_buffer());

  auto response = ConvertFramesToSignalsSinglePointResponse{};

  raise_if_error(
      stub->ConvertFramesToSignalsSinglePoint(&context, request, &response));

  return response;
}

ConvertSignalsToFramesSinglePointResponse
convert_signals_to_frames_single_point(const StubPtr& stub, const nidevice_grpc::Session& session, const std::vector<double>& value_buffer, const pb::uint32& number_of_frames, const pb::uint32& max_payload_per_frame, const simple_variant<Protocol, pb::uint32>& protocol)
{
  ::grpc::ClientContext context;

  auto request = ConvertSignalsToFramesSinglePointRequest{};
  request.mutable_session()->CopyFrom(session);
  copy_array(value_buffer, request.mutable_value_buffer());
  request.set_number_of_frames(number_of_frames);
  request.set_max_payload_per_frame(max_payload_per_frame);
  const auto protocol_ptr = protocol.get_if<Protocol>();
  const auto protocol_raw_ptr = protocol.get_if<pb::uint32>();
  if (protocol_ptr) {
    request.set_protocol(*protocol_ptr);
  }
  else if (protocol_raw_ptr) {
    request.set_protocol_raw(*protocol_raw_ptr);
  }

  auto response = ConvertSignalsToFramesSinglePointResponse{};

  raise_if_error(
      stub->ConvertSignalsToFramesSinglePoint(&context, request, &response));

  return response;
}

ConvertTimestamp100nsTo1nsResponse
convert_timestamp100ns_to1ns(const StubPtr& stub, const pb::uint64& from_timestamp_100ns)
{
  ::grpc::ClientContext context;

  auto request = ConvertTimestamp100nsTo1nsRequest{};
  request.set_from_timestamp_100ns(from_timestamp_100ns);

  auto response = ConvertTimestamp100nsTo1nsResponse{};

  raise_if_error(
      stub->ConvertTimestamp100nsTo1ns(&context, request, &response));

  return response;
}

ConvertTimestamp1nsTo100nsResponse
convert_timestamp1ns_to100ns(const StubPtr& stub, const pb::uint64& from_timestamp_1ns)
{
  ::grpc::ClientContext context;

  auto request = ConvertTimestamp1nsTo100nsRequest{};
  request.set_from_timestamp_1ns(from_timestamp_1ns);

  auto response = ConvertTimestamp1nsTo100nsResponse{};

  raise_if_error(
      stub->ConvertTimestamp1nsTo100ns(&context, request, &response));

  return response;
}

CreateSessionResponse
create_session(const StubPtr& stub, const pb::string& database_name, const pb::string& cluster_name, const pb::string& list, const pb::string& interface_name, const simple_variant<CreateSessionMode, pb::uint32>& mode)
{
  ::grpc::ClientContext context;

  auto request = CreateSessionRequest{};
  request.set_database_name(database_name);
  request.set_cluster_name(cluster_name);
  request.set_list(list);
  request.set_interface_name(interface_name);
  const auto mode_ptr = mode.get_if<CreateSessionMode>();
  const auto mode_raw_ptr = mode.get_if<pb::uint32>();
  if (mode_ptr) {
    request.set_mode(*mode_ptr);
  }
  else if (mode_raw_ptr) {
    request.set_mode_raw(*mode_raw_ptr);
  }

  auto response = CreateSessionResponse{};

  raise_if_error(
      stub->CreateSession(&context, request, &response));

  return response;
}

CreateSessionByRefResponse
create_session_by_ref(const StubPtr& stub, const std::vector<nidevice_grpc::Session>& array_of_database_ref, const pb::string& interface_name, const simple_variant<CreateSessionMode, pb::uint32>& mode)
{
  ::grpc::ClientContext context;

  auto request = CreateSessionByRefRequest{};
  copy_array(array_of_database_ref, request.mutable_array_of_database_ref());
  request.set_interface_name(interface_name);
  const auto mode_ptr = mode.get_if<CreateSessionMode>();
  const auto mode_raw_ptr = mode.get_if<pb::uint32>();
  if (mode_ptr) {
    request.set_mode(*mode_ptr);
  }
  else if (mode_raw_ptr) {
    request.set_mode_raw(*mode_raw_ptr);
  }

  auto response = CreateSessionByRefResponse{};

  raise_if_error(
      stub->CreateSessionByRef(&context, request, &response));

  return response;
}

DbAddAliasResponse
db_add_alias(const StubPtr& stub, const pb::string& database_alias, const pb::string& database_filepath, const pb::uint32& default_baud_rate)
{
  ::grpc::ClientContext context;

  auto request = DbAddAliasRequest{};
  request.set_database_alias(database_alias);
  request.set_database_filepath(database_filepath);
  request.set_default_baud_rate(default_baud_rate);

  auto response = DbAddAliasResponse{};

  raise_if_error(
      stub->DbAddAlias(&context, request, &response));

  return response;
}

DbAddAlias64Response
db_add_alias64(const StubPtr& stub, const pb::string& database_alias, const pb::string& database_filepath, const pb::uint64& default_baud_rate)
{
  ::grpc::ClientContext context;

  auto request = DbAddAlias64Request{};
  request.set_database_alias(database_alias);
  request.set_database_filepath(database_filepath);
  request.set_default_baud_rate(default_baud_rate);

  auto response = DbAddAlias64Response{};

  raise_if_error(
      stub->DbAddAlias64(&context, request, &response));

  return response;
}

DbCloseDatabaseResponse
db_close_database(const StubPtr& stub, const nidevice_grpc::Session& database, const pb::uint32& close_all_refs)
{
  ::grpc::ClientContext context;

  auto request = DbCloseDatabaseRequest{};
  request.mutable_database()->CopyFrom(database);
  request.set_close_all_refs(close_all_refs);

  auto response = DbCloseDatabaseResponse{};

  raise_if_error(
      stub->DbCloseDatabase(&context, request, &response));

  return response;
}

DbCreateObjectResponse
db_create_object(const StubPtr& stub, const nidevice_grpc::Session& parent_object, const pb::uint32& object_class, const pb::string& object_name)
{
  ::grpc::ClientContext context;

  auto request = DbCreateObjectRequest{};
  request.mutable_parent_object()->CopyFrom(parent_object);
  request.set_object_class(object_class);
  request.set_object_name(object_name);

  auto response = DbCreateObjectResponse{};

  raise_if_error(
      stub->DbCreateObject(&context, request, &response));

  return response;
}

DbDeleteObjectResponse
db_delete_object(const StubPtr& stub, const nidevice_grpc::Session& db_object)
{
  ::grpc::ClientContext context;

  auto request = DbDeleteObjectRequest{};
  request.mutable_db_object()->CopyFrom(db_object);

  auto response = DbDeleteObjectResponse{};

  raise_if_error(
      stub->DbDeleteObject(&context, request, &response));

  return response;
}

DbDeployResponse
db_deploy(const StubPtr& stub, const pb::string& ip_address, const pb::string& database_alias, const pb::uint32& wait_for_complete)
{
  ::grpc::ClientContext context;

  auto request = DbDeployRequest{};
  request.set_ip_address(ip_address);
  request.set_database_alias(database_alias);
  request.set_wait_for_complete(wait_for_complete);

  auto response = DbDeployResponse{};

  raise_if_error(
      stub->DbDeploy(&context, request, &response));

  return response;
}

DbFindObjectResponse
db_find_object(const StubPtr& stub, const nidevice_grpc::Session& parent_object, const pb::uint32& object_class, const pb::string& object_name)
{
  ::grpc::ClientContext context;

  auto request = DbFindObjectRequest{};
  request.mutable_parent_object()->CopyFrom(parent_object);
  request.set_object_class(object_class);
  request.set_object_name(object_name);

  auto response = DbFindObjectResponse{};

  raise_if_error(
      stub->DbFindObject(&context, request, &response));

  return response;
}

DbGetDBCAttributeResponse
db_get_dbc_attribute(const StubPtr& stub, const nidevice_grpc::Session& db_object, const simple_variant<GetDBCAttributeMode, pb::uint32>& mode, const pb::string& attribute_name)
{
  ::grpc::ClientContext context;

  auto request = DbGetDBCAttributeRequest{};
  request.mutable_db_object()->CopyFrom(db_object);
  const auto mode_ptr = mode.get_if<GetDBCAttributeMode>();
  const auto mode_raw_ptr = mode.get_if<pb::uint32>();
  if (mode_ptr) {
    request.set_mode(*mode_ptr);
  }
  else if (mode_raw_ptr) {
    request.set_mode_raw(*mode_raw_ptr);
  }
  request.set_attribute_name(attribute_name);

  auto response = DbGetDBCAttributeResponse{};

  raise_if_error(
      stub->DbGetDBCAttribute(&context, request, &response));

  return response;
}

DbGetDBCAttributeSizeResponse
db_get_dbc_attribute_size(const StubPtr& stub, const nidevice_grpc::Session& db_object, const simple_variant<GetDBCAttributeMode, pb::uint32>& mode, const pb::string& attribute_name)
{
  ::grpc::ClientContext context;

  auto request = DbGetDBCAttributeSizeRequest{};
  request.mutable_db_object()->CopyFrom(db_object);
  const auto mode_ptr = mode.get_if<GetDBCAttributeMode>();
  const auto mode_raw_ptr = mode.get_if<pb::uint32>();
  if (mode_ptr) {
    request.set_mode(*mode_ptr);
  }
  else if (mode_raw_ptr) {
    request.set_mode_raw(*mode_raw_ptr);
  }
  request.set_attribute_name(attribute_name);

  auto response = DbGetDBCAttributeSizeResponse{};

  raise_if_error(
      stub->DbGetDBCAttributeSize(&context, request, &response));

  return response;
}

DbGetDatabaseListSizesResponse
db_get_database_list_sizes(const StubPtr& stub, const pb::string& ip_address)
{
  ::grpc::ClientContext context;

  auto request = DbGetDatabaseListSizesRequest{};
  request.set_ip_address(ip_address);

  auto response = DbGetDatabaseListSizesResponse{};

  raise_if_error(
      stub->DbGetDatabaseListSizes(&context, request, &response));

  return response;
}

DbGetPropertySizeResponse
db_get_property_size(const StubPtr& stub, const nidevice_grpc::Session& db_object, const simple_variant<DBProperty, pb::uint32>& property_id)
{
  ::grpc::ClientContext context;

  auto request = DbGetPropertySizeRequest{};
  request.mutable_db_object()->CopyFrom(db_object);
  const auto property_id_ptr = property_id.get_if<DBProperty>();
  const auto property_id_raw_ptr = property_id.get_if<pb::uint32>();
  if (property_id_ptr) {
    request.set_property_id(*property_id_ptr);
  }
  else if (property_id_raw_ptr) {
    request.set_property_id_raw(*property_id_raw_ptr);
  }

  auto response = DbGetPropertySizeResponse{};

  raise_if_error(
      stub->DbGetPropertySize(&context, request, &response));

  return response;
}

DbMergeResponse
db_merge(const StubPtr& stub, const nidevice_grpc::Session& target_cluster, const nidevice_grpc::Session& source_obj, const simple_variant<CopyMode, pb::uint32>& copy_mode, const pb::string& prefix, const pb::uint32& wait_for_complete)
{
  ::grpc::ClientContext context;

  auto request = DbMergeRequest{};
  request.mutable_target_cluster()->CopyFrom(target_cluster);
  request.mutable_source_obj()->CopyFrom(source_obj);
  const auto copy_mode_ptr = copy_mode.get_if<CopyMode>();
  const auto copy_mode_raw_ptr = copy_mode.get_if<pb::uint32>();
  if (copy_mode_ptr) {
    request.set_copy_mode(*copy_mode_ptr);
  }
  else if (copy_mode_raw_ptr) {
    request.set_copy_mode_raw(*copy_mode_raw_ptr);
  }
  request.set_prefix(prefix);
  request.set_wait_for_complete(wait_for_complete);

  auto response = DbMergeResponse{};

  raise_if_error(
      stub->DbMerge(&context, request, &response));

  return response;
}

DbOpenDatabaseResponse
db_open_database(const StubPtr& stub, const pb::string& database_name)
{
  ::grpc::ClientContext context;

  auto request = DbOpenDatabaseRequest{};
  request.set_database_name(database_name);

  auto response = DbOpenDatabaseResponse{};

  raise_if_error(
      stub->DbOpenDatabase(&context, request, &response));

  return response;
}

DbRemoveAliasResponse
db_remove_alias(const StubPtr& stub, const pb::string& database_alias)
{
  ::grpc::ClientContext context;

  auto request = DbRemoveAliasRequest{};
  request.set_database_alias(database_alias);

  auto response = DbRemoveAliasResponse{};

  raise_if_error(
      stub->DbRemoveAlias(&context, request, &response));

  return response;
}

DbSaveDatabaseResponse
db_save_database(const StubPtr& stub, const nidevice_grpc::Session& database, const pb::string& db_filepath)
{
  ::grpc::ClientContext context;

  auto request = DbSaveDatabaseRequest{};
  request.mutable_database()->CopyFrom(database);
  request.set_db_filepath(db_filepath);

  auto response = DbSaveDatabaseResponse{};

  raise_if_error(
      stub->DbSaveDatabase(&context, request, &response));

  return response;
}

DbUndeployResponse
db_undeploy(const StubPtr& stub, const pb::string& ip_address, const pb::string& database_alias)
{
  ::grpc::ClientContext context;

  auto request = DbUndeployRequest{};
  request.set_ip_address(ip_address);
  request.set_database_alias(database_alias);

  auto response = DbUndeployResponse{};

  raise_if_error(
      stub->DbUndeploy(&context, request, &response));

  return response;
}

DisconnectTerminalsResponse
disconnect_terminals(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<TerminalName, std::string>& source, const simple_variant<TerminalName, std::string>& destination)
{
  ::grpc::ClientContext context;

  auto request = DisconnectTerminalsRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto source_ptr = source.get_if<TerminalName>();
  const auto source_raw_ptr = source.get_if<std::string>();
  if (source_ptr) {
    request.set_source_mapped(*source_ptr);
  }
  else if (source_raw_ptr) {
    request.set_source_raw(*source_raw_ptr);
  }
  const auto destination_ptr = destination.get_if<TerminalName>();
  const auto destination_raw_ptr = destination.get_if<std::string>();
  if (destination_ptr) {
    request.set_destination_mapped(*destination_ptr);
  }
  else if (destination_raw_ptr) {
    request.set_destination_raw(*destination_raw_ptr);
  }

  auto response = DisconnectTerminalsResponse{};

  raise_if_error(
      stub->DisconnectTerminals(&context, request, &response));

  return response;
}

FlushResponse
flush(const StubPtr& stub, const nidevice_grpc::Session& session)
{
  ::grpc::ClientContext context;

  auto request = FlushRequest{};
  request.mutable_session()->CopyFrom(session);

  auto response = FlushResponse{};

  raise_if_error(
      stub->Flush(&context, request, &response));

  return response;
}

FutureTimeTriggerResponse
future_time_trigger(const StubPtr& stub, const nidevice_grpc::Session& session, const pb::uint64& when, const simple_variant<TimeScale, pb::uint32>& timescale)
{
  ::grpc::ClientContext context;

  auto request = FutureTimeTriggerRequest{};
  request.mutable_session()->CopyFrom(session);
  request.set_when(when);
  const auto timescale_ptr = timescale.get_if<TimeScale>();
  const auto timescale_raw_ptr = timescale.get_if<pb::uint32>();
  if (timescale_ptr) {
    request.set_timescale(*timescale_ptr);
  }
  else if (timescale_raw_ptr) {
    request.set_timescale_raw(*timescale_raw_ptr);
  }

  auto response = FutureTimeTriggerResponse{};

  raise_if_error(
      stub->FutureTimeTrigger(&context, request, &response));

  return response;
}

GetPropertySizeResponse
get_property_size(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<Property, pb::uint32>& property_id)
{
  ::grpc::ClientContext context;

  auto request = GetPropertySizeRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto property_id_ptr = property_id.get_if<Property>();
  const auto property_id_raw_ptr = property_id.get_if<pb::uint32>();
  if (property_id_ptr) {
    request.set_property_id(*property_id_ptr);
  }
  else if (property_id_raw_ptr) {
    request.set_property_id_raw(*property_id_raw_ptr);
  }

  auto response = GetPropertySizeResponse{};

  raise_if_error(
      stub->GetPropertySize(&context, request, &response));

  return response;
}

GetSubPropertySizeResponse
get_sub_property_size(const StubPtr& stub, const nidevice_grpc::Session& session, const pb::uint32& active_index, const simple_variant<SubProperty, pb::uint32>& property_id)
{
  ::grpc::ClientContext context;

  auto request = GetSubPropertySizeRequest{};
  request.mutable_session()->CopyFrom(session);
  request.set_active_index(active_index);
  const auto property_id_ptr = property_id.get_if<SubProperty>();
  const auto property_id_raw_ptr = property_id.get_if<pb::uint32>();
  if (property_id_ptr) {
    request.set_property_id(*property_id_ptr);
  }
  else if (property_id_raw_ptr) {
    request.set_property_id_raw(*property_id_raw_ptr);
  }

  auto response = GetSubPropertySizeResponse{};

  raise_if_error(
      stub->GetSubPropertySize(&context, request, &response));

  return response;
}

ReadFrameResponse
read_frame(const StubPtr& stub, const nidevice_grpc::Session& session, const pb::int32& number_of_frames, const pb::uint32& max_payload_per_frame, const simple_variant<Protocol, pb::uint32>& protocol, const simple_variant<TimeOut, double>& timeout)
{
  ::grpc::ClientContext context;

  auto request = ReadFrameRequest{};
  request.mutable_session()->CopyFrom(session);
  request.set_number_of_frames(number_of_frames);
  request.set_max_payload_per_frame(max_payload_per_frame);
  const auto protocol_ptr = protocol.get_if<Protocol>();
  const auto protocol_raw_ptr = protocol.get_if<pb::uint32>();
  if (protocol_ptr) {
    request.set_protocol(*protocol_ptr);
  }
  else if (protocol_raw_ptr) {
    request.set_protocol_raw(*protocol_raw_ptr);
  }
  const auto timeout_ptr = timeout.get_if<TimeOut>();
  const auto timeout_raw_ptr = timeout.get_if<double>();
  if (timeout_ptr) {
    request.set_timeout(*timeout_ptr);
  }
  else if (timeout_raw_ptr) {
    request.set_timeout_raw(*timeout_raw_ptr);
  }

  auto response = ReadFrameResponse{};

  raise_if_error(
      stub->ReadFrame(&context, request, &response));

  return response;
}

ReadSignalSinglePointResponse
read_signal_single_point(const StubPtr& stub, const nidevice_grpc::Session& session, const pb::uint32& number_of_signals)
{
  ::grpc::ClientContext context;

  auto request = ReadSignalSinglePointRequest{};
  request.mutable_session()->CopyFrom(session);
  request.set_number_of_signals(number_of_signals);

  auto response = ReadSignalSinglePointResponse{};

  raise_if_error(
      stub->ReadSignalSinglePoint(&context, request, &response));

  return response;
}

ReadSignalWaveformResponse
read_signal_waveform(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<TimeOut, double>& timeout, const pb::uint32& samples_per_signal, const pb::uint32& number_of_signals)
{
  ::grpc::ClientContext context;

  auto request = ReadSignalWaveformRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto timeout_ptr = timeout.get_if<TimeOut>();
  const auto timeout_raw_ptr = timeout.get_if<double>();
  if (timeout_ptr) {
    request.set_timeout(*timeout_ptr);
  }
  else if (timeout_raw_ptr) {
    request.set_timeout_raw(*timeout_raw_ptr);
  }
  request.set_samples_per_signal(samples_per_signal);
  request.set_number_of_signals(number_of_signals);

  auto response = ReadSignalWaveformResponse{};

  raise_if_error(
      stub->ReadSignalWaveform(&context, request, &response));

  return response;
}

ReadSignalXYResponse
read_signal_xy(const StubPtr& stub, const nidevice_grpc::Session& session, const pb::uint64& time_limit, const pb::uint32& samples_per_signal, const pb::uint32& number_of_signals)
{
  ::grpc::ClientContext context;

  auto request = ReadSignalXYRequest{};
  request.mutable_session()->CopyFrom(session);
  request.set_time_limit(time_limit);
  request.set_samples_per_signal(samples_per_signal);
  request.set_number_of_signals(number_of_signals);

  auto response = ReadSignalXYResponse{};

  raise_if_error(
      stub->ReadSignalXY(&context, request, &response));

  return response;
}

ReadStateResponse
read_state(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<ReadState, pb::uint32>& state_id)
{
  ::grpc::ClientContext context;

  auto request = ReadStateRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto state_id_ptr = state_id.get_if<ReadState>();
  const auto state_id_raw_ptr = state_id.get_if<pb::uint32>();
  if (state_id_ptr) {
    request.set_state_id(*state_id_ptr);
  }
  else if (state_id_raw_ptr) {
    request.set_state_id_raw(*state_id_raw_ptr);
  }

  auto response = ReadStateResponse{};

  raise_if_error(
      stub->ReadState(&context, request, &response));

  return response;
}

ReadStateTimeTriggerResponse
read_state_time_trigger(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<TimeOut, double>& timeout)
{
  ::grpc::ClientContext context;

  auto request = ReadStateTimeTriggerRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto timeout_ptr = timeout.get_if<TimeOut>();
  const auto timeout_raw_ptr = timeout.get_if<double>();
  if (timeout_ptr) {
    request.set_timeout(*timeout_ptr);
  }
  else if (timeout_raw_ptr) {
    request.set_timeout_raw(*timeout_raw_ptr);
  }

  auto response = ReadStateTimeTriggerResponse{};

  raise_if_error(
      stub->ReadStateTimeTrigger(&context, request, &response));

  return response;
}

StartResponse
start(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<StartStopScope, pb::uint32>& scope)
{
  ::grpc::ClientContext context;

  auto request = StartRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto scope_ptr = scope.get_if<StartStopScope>();
  const auto scope_raw_ptr = scope.get_if<pb::uint32>();
  if (scope_ptr) {
    request.set_scope(*scope_ptr);
  }
  else if (scope_raw_ptr) {
    request.set_scope_raw(*scope_raw_ptr);
  }

  auto response = StartResponse{};

  raise_if_error(
      stub->Start(&context, request, &response));

  return response;
}

StatusToStringResponse
status_to_string(const StubPtr& stub, const pb::int32& status_id)
{
  ::grpc::ClientContext context;

  auto request = StatusToStringRequest{};
  request.set_status_id(status_id);

  auto response = StatusToStringResponse{};

  raise_if_error(
      stub->StatusToString(&context, request, &response));

  return response;
}

StopResponse
stop(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<StartStopScope, pb::uint32>& scope)
{
  ::grpc::ClientContext context;

  auto request = StopRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto scope_ptr = scope.get_if<StartStopScope>();
  const auto scope_raw_ptr = scope.get_if<pb::uint32>();
  if (scope_ptr) {
    request.set_scope(*scope_ptr);
  }
  else if (scope_raw_ptr) {
    request.set_scope_raw(*scope_raw_ptr);
  }

  auto response = StopResponse{};

  raise_if_error(
      stub->Stop(&context, request, &response));

  return response;
}

SystemCloseResponse
system_close(const StubPtr& stub, const nidevice_grpc::Session& system)
{
  ::grpc::ClientContext context;

  auto request = SystemCloseRequest{};
  request.mutable_system()->CopyFrom(system);

  auto response = SystemCloseResponse{};

  raise_if_error(
      stub->SystemClose(&context, request, &response));

  return response;
}

SystemOpenResponse
system_open(const StubPtr& stub)
{
  ::grpc::ClientContext context;

  auto request = SystemOpenRequest{};

  auto response = SystemOpenResponse{};

  raise_if_error(
      stub->SystemOpen(&context, request, &response));

  return response;
}

WaitResponse
wait(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<WaitCondition, pb::uint32>& condition, const pb::uint32& param_in, const double& timeout)
{
  ::grpc::ClientContext context;

  auto request = WaitRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto condition_ptr = condition.get_if<WaitCondition>();
  const auto condition_raw_ptr = condition.get_if<pb::uint32>();
  if (condition_ptr) {
    request.set_condition(*condition_ptr);
  }
  else if (condition_raw_ptr) {
    request.set_condition_raw(*condition_raw_ptr);
  }
  request.set_param_in(param_in);
  request.set_timeout(timeout);

  auto response = WaitResponse{};

  raise_if_error(
      stub->Wait(&context, request, &response));

  return response;
}

WriteFrameResponse
write_frame(const StubPtr& stub, const nidevice_grpc::Session& session, const std::vector<FrameBufferRequest>& buffer, const simple_variant<TimeOut, double>& timeout)
{
  ::grpc::ClientContext context;

  auto request = WriteFrameRequest{};
  request.mutable_session()->CopyFrom(session);
  copy_array(buffer, request.mutable_buffer());
  const auto timeout_ptr = timeout.get_if<TimeOut>();
  const auto timeout_raw_ptr = timeout.get_if<double>();
  if (timeout_ptr) {
    request.set_timeout(*timeout_ptr);
  }
  else if (timeout_raw_ptr) {
    request.set_timeout_raw(*timeout_raw_ptr);
  }

  auto response = WriteFrameResponse{};

  raise_if_error(
      stub->WriteFrame(&context, request, &response));

  return response;
}

WriteSignalSinglePointResponse
write_signal_single_point(const StubPtr& stub, const nidevice_grpc::Session& session, const std::vector<double>& value_buffer)
{
  ::grpc::ClientContext context;

  auto request = WriteSignalSinglePointRequest{};
  request.mutable_session()->CopyFrom(session);
  copy_array(value_buffer, request.mutable_value_buffer());

  auto response = WriteSignalSinglePointResponse{};

  raise_if_error(
      stub->WriteSignalSinglePoint(&context, request, &response));

  return response;
}

WriteSignalWaveformResponse
write_signal_waveform(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<TimeOut, double>& timeout, const std::vector<double>& value_buffer)
{
  ::grpc::ClientContext context;

  auto request = WriteSignalWaveformRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto timeout_ptr = timeout.get_if<TimeOut>();
  const auto timeout_raw_ptr = timeout.get_if<double>();
  if (timeout_ptr) {
    request.set_timeout(*timeout_ptr);
  }
  else if (timeout_raw_ptr) {
    request.set_timeout_raw(*timeout_raw_ptr);
  }
  copy_array(value_buffer, request.mutable_value_buffer());

  auto response = WriteSignalWaveformResponse{};

  raise_if_error(
      stub->WriteSignalWaveform(&context, request, &response));

  return response;
}

WriteSignalXYResponse
write_signal_xy(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<TimeOut, double>& timeout, const std::vector<double>& value_buffer, const std::vector<pb::uint64>& timestamp_buffer, const std::vector<pb::uint32>& num_pairs_buffer)
{
  ::grpc::ClientContext context;

  auto request = WriteSignalXYRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto timeout_ptr = timeout.get_if<TimeOut>();
  const auto timeout_raw_ptr = timeout.get_if<double>();
  if (timeout_ptr) {
    request.set_timeout(*timeout_ptr);
  }
  else if (timeout_raw_ptr) {
    request.set_timeout_raw(*timeout_raw_ptr);
  }
  copy_array(value_buffer, request.mutable_value_buffer());
  copy_array(timestamp_buffer, request.mutable_timestamp_buffer());
  copy_array(num_pairs_buffer, request.mutable_num_pairs_buffer());

  auto response = WriteSignalXYResponse{};

  raise_if_error(
      stub->WriteSignalXY(&context, request, &response));

  return response;
}

WriteStateResponse
write_state(const StubPtr& stub, const nidevice_grpc::Session& session, const simple_variant<WriteState, pb::uint32>& state_id, const WriteStateValue& state_value)
{
  ::grpc::ClientContext context;

  auto request = WriteStateRequest{};
  request.mutable_session()->CopyFrom(session);
  const auto state_id_ptr = state_id.get_if<WriteState>();
  const auto state_id_raw_ptr = state_id.get_if<pb::uint32>();
  if (state_id_ptr) {
    request.set_state_id(*state_id_ptr);
  }
  else if (state_id_raw_ptr) {
    request.set_state_id_raw(*state_id_raw_ptr);
  }
  request.mutable_state_value()->CopyFrom(state_value);

  auto response = WriteStateResponse{};

  raise_if_error(
      stub->WriteState(&context, request, &response));

  return response;
}


} // namespace nixnet_grpc::experimental::client
