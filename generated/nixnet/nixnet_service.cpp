
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-XNET Metadata
//---------------------------------------------------------------------
#include "nixnet_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>
#include "custom/nixnet_converters.h"
#include <server/converters.h>

namespace nixnet_grpc {

  using nidevice_grpc::converters::allocate_output_storage;
  using nidevice_grpc::converters::calculate_linked_array_size;
  using nidevice_grpc::converters::convert_from_grpc;
  using nidevice_grpc::converters::convert_to_grpc;
  using nidevice_grpc::converters::MatchState;

  NiXnetService::NiXnetService(
      NiXnetLibraryInterface* library,
      ResourceRepositorySharedPtr resource_repository,
      nxDatabaseRef_tResourceRepositorySharedPtr nx_database_ref_t_resource_repository,
      const NiXnetFeatureToggles& feature_toggles)
      : library_(library),
      session_repository_(resource_repository),
      nx_database_ref_t_resource_repository_(nx_database_ref_t_resource_repository),
      feature_toggles_(feature_toggles)
  {
  }

  NiXnetService::~NiXnetService()
  {
  }

  // Returns true if it's safe to use outputs of a method with the given status.
  inline bool status_ok(int32 status)
  {
    return status >= 0;
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::Blink(::grpc::ServerContext* context, const BlinkRequest* request, BlinkResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto interface_ref_grpc_session = request->interface_ref();
      nxSessionRef_t interface_ref = session_repository_->access_session(interface_ref_grpc_session.id(), interface_ref_grpc_session.name());
      u32 modifier;
      switch (request->modifier_enum_case()) {
        case nixnet_grpc::BlinkRequest::ModifierEnumCase::kModifier: {
          modifier = static_cast<u32>(request->modifier());
          break;
        }
        case nixnet_grpc::BlinkRequest::ModifierEnumCase::kModifierRaw: {
          modifier = static_cast<u32>(request->modifier_raw());
          break;
        }
        case nixnet_grpc::BlinkRequest::ModifierEnumCase::MODIFIER_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for modifier was not specified or out of range");
          break;
        }
      }

      auto status = library_->Blink(interface_ref, modifier);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::Clear(::grpc::ServerContext* context, const ClearRequest* request, ClearResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      session_repository_->remove_session(session_grpc_session.id(), session_grpc_session.name());
      auto status = library_->Clear(session);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ConnectTerminals(::grpc::ServerContext* context, const ConnectTerminalsRequest* request, ConnectTerminalsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      const char* source;
      switch (request->source_enum_case()) {
        case nixnet_grpc::ConnectTerminalsRequest::SourceEnumCase::kSourceMapped: {
          auto source_imap_it = terminalname_input_map_.find(request->source_mapped());
          if (source_imap_it == terminalname_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for source_mapped was not specified or out of range.");
          }
          source = const_cast<const char*>((source_imap_it->second).c_str());
          break;
        }
        case nixnet_grpc::ConnectTerminalsRequest::SourceEnumCase::kSourceRaw: {
          source = const_cast<const char*>(request->source_raw().c_str());
          break;
        }
        case nixnet_grpc::ConnectTerminalsRequest::SourceEnumCase::SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for source was not specified or out of range");
          break;
        }
      }

      const char* destination;
      switch (request->destination_enum_case()) {
        case nixnet_grpc::ConnectTerminalsRequest::DestinationEnumCase::kDestinationMapped: {
          auto destination_imap_it = terminalname_input_map_.find(request->destination_mapped());
          if (destination_imap_it == terminalname_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for destination_mapped was not specified or out of range.");
          }
          destination = const_cast<const char*>((destination_imap_it->second).c_str());
          break;
        }
        case nixnet_grpc::ConnectTerminalsRequest::DestinationEnumCase::kDestinationRaw: {
          destination = const_cast<const char*>(request->destination_raw().c_str());
          break;
        }
        case nixnet_grpc::ConnectTerminalsRequest::DestinationEnumCase::DESTINATION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for destination was not specified or out of range");
          break;
        }
      }

      auto status = library_->ConnectTerminals(session, source, destination);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ConvertByteArrayToFramesSinglePoint(::grpc::ServerContext* context, const ConvertByteArrayToFramesSinglePointRequest* request, ConvertByteArrayToFramesSinglePointResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      u8* value_buffer = (u8*)request->value_buffer().c_str();
      u32 size_of_value_buffer = static_cast<u32>(request->value_buffer().size() * sizeof(u8));
      u32 number_of_frames = request->number_of_frames();
      u32 max_payload_per_frame = request->max_payload_per_frame();
      u32 frame_type;
      switch (request->frame_type_enum_case()) {
        case nixnet_grpc::ConvertByteArrayToFramesSinglePointRequest::FrameTypeEnumCase::kFrameType: {
          frame_type = static_cast<u32>(request->frame_type());
          break;
        }
        case nixnet_grpc::ConvertByteArrayToFramesSinglePointRequest::FrameTypeEnumCase::kFrameTypeRaw: {
          frame_type = static_cast<u32>(request->frame_type_raw());
          break;
        }
        case nixnet_grpc::ConvertByteArrayToFramesSinglePointRequest::FrameTypeEnumCase::FRAME_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for frame_type was not specified or out of range");
          break;
        }
      }

      auto size_of_buffer = get_frame_buffer_size(number_of_frames, max_payload_per_frame, frame_type);
      std::vector<u8> buffer(size_of_buffer, u8());
      u32 number_of_bytes_returned {};
      auto status = library_->ConvertByteArrayToFramesSinglePoint(session, value_buffer, size_of_value_buffer, buffer.data(), size_of_buffer, &number_of_bytes_returned);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(buffer, response->mutable_buffer(), number_of_bytes_returned, frame_type);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ConvertFramesToByteArraySinglePoint(::grpc::ServerContext* context, const ConvertFramesToByteArraySinglePointRequest* request, ConvertFramesToByteArraySinglePointResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      auto frame_buffer = convert_from_grpc<u8>(request->frame_buffer());
      auto number_of_bytes_for_frames = frame_buffer.size();
      u32 size_of_value_buffer = request->size_of_value_buffer();
      std::string value_buffer(size_of_value_buffer, '\0');
      auto status = library_->ConvertFramesToByteArraySinglePoint(session, frame_buffer, number_of_bytes_for_frames, (u8*)value_buffer.data(), size_of_value_buffer);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_value_buffer(value_buffer);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ConvertFramesToSignalsSinglePoint(::grpc::ServerContext* context, const ConvertFramesToSignalsSinglePointRequest* request, ConvertFramesToSignalsSinglePointResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      u32 number_of_signals = request->number_of_signals();
      auto frame_buffer = convert_from_grpc<u8>(request->frame_buffer());
      auto number_of_bytes_for_frames = frame_buffer.size();
      auto size_of_value_buffer = number_of_signals * sizeof(f64);
      auto size_of_timestamp_buffer = number_of_signals * sizeof(f64);
      response->mutable_value_buffer()->Resize(number_of_signals, 0);
      f64* value_buffer = response->mutable_value_buffer()->mutable_data();
      response->mutable_timestamp_buffer()->Resize(number_of_signals, 0);
      nxTimestamp100ns_t* timestamp_buffer = reinterpret_cast<nxTimestamp100ns_t*>(response->mutable_timestamp_buffer()->mutable_data());
      auto status = library_->ConvertFramesToSignalsSinglePoint(session, frame_buffer, number_of_bytes_for_frames, value_buffer, size_of_value_buffer, timestamp_buffer, size_of_timestamp_buffer);
      response->set_status(status);
      if (status_ok(status)) {
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ConvertSignalsToFramesSinglePoint(::grpc::ServerContext* context, const ConvertSignalsToFramesSinglePointRequest* request, ConvertSignalsToFramesSinglePointResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      auto value_buffer = const_cast<f64*>(request->value_buffer().data());
      u32 size_of_value_buffer = static_cast<u32>(request->value_buffer().size() * sizeof(f64));
      u32 number_of_frames = request->number_of_frames();
      u32 max_payload_per_frame = request->max_payload_per_frame();
      u32 frame_type;
      switch (request->frame_type_enum_case()) {
        case nixnet_grpc::ConvertSignalsToFramesSinglePointRequest::FrameTypeEnumCase::kFrameType: {
          frame_type = static_cast<u32>(request->frame_type());
          break;
        }
        case nixnet_grpc::ConvertSignalsToFramesSinglePointRequest::FrameTypeEnumCase::kFrameTypeRaw: {
          frame_type = static_cast<u32>(request->frame_type_raw());
          break;
        }
        case nixnet_grpc::ConvertSignalsToFramesSinglePointRequest::FrameTypeEnumCase::FRAME_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for frame_type was not specified or out of range");
          break;
        }
      }

      auto size_of_buffer = get_frame_buffer_size(number_of_frames, max_payload_per_frame, frame_type);
      std::vector<u8> buffer(size_of_buffer, u8());
      u32 number_of_bytes_returned {};
      auto status = library_->ConvertSignalsToFramesSinglePoint(session, value_buffer, size_of_value_buffer, buffer.data(), size_of_buffer, &number_of_bytes_returned);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(buffer, response->mutable_buffer(), number_of_bytes_returned, frame_type);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ConvertTimestamp100nsTo1ns(::grpc::ServerContext* context, const ConvertTimestamp100nsTo1nsRequest* request, ConvertTimestamp100nsTo1nsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      nxTimestamp100ns_t from_timestamp_100ns = request->from_timestamp_100ns();
      nxTimestamp1ns_t to_timestamp_1ns {};
      auto status = library_->ConvertTimestamp100nsTo1ns(from_timestamp_100ns, &to_timestamp_1ns);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_to_timestamp_1ns(to_timestamp_1ns);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ConvertTimestamp1nsTo100ns(::grpc::ServerContext* context, const ConvertTimestamp1nsTo100nsRequest* request, ConvertTimestamp1nsTo100nsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      nxTimestamp1ns_t from_timestamp_1ns = request->from_timestamp_1ns();
      nxTimestamp100ns_t to_timestamp_100ns {};
      auto status = library_->ConvertTimestamp1nsTo100ns(from_timestamp_1ns, &to_timestamp_100ns);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_to_timestamp_100ns(to_timestamp_100ns);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::CreateSession(::grpc::ServerContext* context, const CreateSessionRequest* request, CreateSessionResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto database_name = request->database_name().c_str();
      auto cluster_name = request->cluster_name().c_str();
      auto list = request->list().c_str();
      auto interface_parameter = request->interface().c_str();
      u32 mode;
      switch (request->mode_enum_case()) {
        case nixnet_grpc::CreateSessionRequest::ModeEnumCase::kMode: {
          mode = static_cast<u32>(request->mode());
          break;
        }
        case nixnet_grpc::CreateSessionRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<u32>(request->mode_raw());
          break;
        }
        case nixnet_grpc::CreateSessionRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }


      auto init_lambda = [&] () {
        nxSessionRef_t session;
        auto status = library_->CreateSession(database_name, cluster_name, list, interface_parameter, mode, &session);
        return std::make_tuple(status, session);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (nxSessionRef_t id) { library_->Clear(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_session()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::CreateSessionByRef(::grpc::ServerContext* context, const CreateSessionByRefRequest* request, CreateSessionByRefResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      u32 number_of_database_ref = static_cast<u32>(request->array_of_database_ref().size());
      auto array_of_database_ref_request = request->array_of_database_ref();
      std::vector<nxDatabaseRef_t> array_of_database_ref;
      std::transform(
        array_of_database_ref_request.begin(),
        array_of_database_ref_request.end(),
        std::back_inserter(array_of_database_ref),
        [&](auto session) { return nx_database_ref_t_resource_repository_->access_session(session.id(), session.name()); }); 
      auto interface_parameter = request->interface().c_str();
      u32 mode;
      switch (request->mode_enum_case()) {
        case nixnet_grpc::CreateSessionByRefRequest::ModeEnumCase::kMode: {
          mode = static_cast<u32>(request->mode());
          break;
        }
        case nixnet_grpc::CreateSessionByRefRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<u32>(request->mode_raw());
          break;
        }
        case nixnet_grpc::CreateSessionByRefRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }


      auto init_lambda = [&] () {
        nxSessionRef_t session;
        auto status = library_->CreateSessionByRef(number_of_database_ref, array_of_database_ref.data(), interface_parameter, mode, &session);
        return std::make_tuple(status, session);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (nxSessionRef_t id) { library_->Clear(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_session()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbAddAlias(::grpc::ServerContext* context, const DbAddAliasRequest* request, DbAddAliasResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto database_alias = request->database_alias().c_str();
      auto database_filepath = request->database_filepath().c_str();
      u32 default_baud_rate = request->default_baud_rate();
      auto status = library_->DbAddAlias(database_alias, database_filepath, default_baud_rate);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbAddAlias64(::grpc::ServerContext* context, const DbAddAlias64Request* request, DbAddAlias64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto database_alias = request->database_alias().c_str();
      auto database_filepath = request->database_filepath().c_str();
      u64 default_baud_rate = request->default_baud_rate();
      auto status = library_->DbAddAlias64(database_alias, database_filepath, default_baud_rate);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbCloseDatabase(::grpc::ServerContext* context, const DbCloseDatabaseRequest* request, DbCloseDatabaseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto database_grpc_session = request->database();
      nxDatabaseRef_t database = nx_database_ref_t_resource_repository_->access_session(database_grpc_session.id(), database_grpc_session.name());
      u32 close_all_refs = request->close_all_refs();
      nx_database_ref_t_resource_repository_->remove_session(database_grpc_session.id(), database_grpc_session.name());
      auto status = library_->DbCloseDatabase(database, close_all_refs);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbCreateObject(::grpc::ServerContext* context, const DbCreateObjectRequest* request, DbCreateObjectResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto parent_object_grpc_session = request->parent_object();
      nxDatabaseRef_t parent_object = nx_database_ref_t_resource_repository_->access_session(parent_object_grpc_session.id(), parent_object_grpc_session.name());
      u32 object_class = request->object_class();
      auto object_name = request->object_name().c_str();

      auto initiating_session_id = nx_database_ref_t_resource_repository_->access_session_id(parent_object_grpc_session.id(), parent_object_grpc_session.name());
      auto init_lambda = [&] () {
        nxDatabaseRef_t db_object;
        int status = library_->DbCreateObject(parent_object, object_class, object_name, &db_object);
        return std::make_tuple(status, db_object);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      int status = nx_database_ref_t_resource_repository_->add_dependent_session(grpc_device_session_name, init_lambda, initiating_session_id, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_db_object()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbDeleteObject(::grpc::ServerContext* context, const DbDeleteObjectRequest* request, DbDeleteObjectResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto db_object_grpc_session = request->db_object();
      nxDatabaseRef_t db_object = nx_database_ref_t_resource_repository_->access_session(db_object_grpc_session.id(), db_object_grpc_session.name());
      nx_database_ref_t_resource_repository_->remove_session(db_object_grpc_session.id(), db_object_grpc_session.name());
      auto status = library_->DbDeleteObject(db_object);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbDeploy(::grpc::ServerContext* context, const DbDeployRequest* request, DbDeployResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto ip_address = request->ip_address().c_str();
      auto database_alias = request->database_alias().c_str();
      u32 wait_for_complete = request->wait_for_complete();
      u32 percent_complete {};
      auto status = library_->DbDeploy(ip_address, database_alias, wait_for_complete, &percent_complete);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_percent_complete(percent_complete);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbFindObject(::grpc::ServerContext* context, const DbFindObjectRequest* request, DbFindObjectResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto parent_object_grpc_session = request->parent_object();
      nxDatabaseRef_t parent_object = nx_database_ref_t_resource_repository_->access_session(parent_object_grpc_session.id(), parent_object_grpc_session.name());
      u32 object_class = request->object_class();
      auto object_name = request->object_name().c_str();

      auto initiating_session_id = nx_database_ref_t_resource_repository_->access_session_id(parent_object_grpc_session.id(), parent_object_grpc_session.name());
      auto init_lambda = [&] () {
        nxDatabaseRef_t db_object;
        int status = library_->DbFindObject(parent_object, object_class, object_name, &db_object);
        return std::make_tuple(status, db_object);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      int status = nx_database_ref_t_resource_repository_->add_dependent_session(grpc_device_session_name, init_lambda, initiating_session_id, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_db_object()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbGetDBCAttributeSize(::grpc::ServerContext* context, const DbGetDBCAttributeSizeRequest* request, DbGetDBCAttributeSizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto db_object_grpc_session = request->db_object();
      nxDatabaseRef_t db_object = nx_database_ref_t_resource_repository_->access_session(db_object_grpc_session.id(), db_object_grpc_session.name());
      u32 mode;
      switch (request->mode_enum_case()) {
        case nixnet_grpc::DbGetDBCAttributeSizeRequest::ModeEnumCase::kMode: {
          mode = static_cast<u32>(request->mode());
          break;
        }
        case nixnet_grpc::DbGetDBCAttributeSizeRequest::ModeEnumCase::kModeRaw: {
          mode = static_cast<u32>(request->mode_raw());
          break;
        }
        case nixnet_grpc::DbGetDBCAttributeSizeRequest::ModeEnumCase::MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for mode was not specified or out of range");
          break;
        }
      }

      auto attribute_name = request->attribute_name().c_str();
      u32 attribute_text_size {};
      auto status = library_->DbGetDBCAttributeSize(db_object, mode, attribute_name, &attribute_text_size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_attribute_text_size(attribute_text_size);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbGetDatabaseListSizes(::grpc::ServerContext* context, const DbGetDatabaseListSizesRequest* request, DbGetDatabaseListSizesResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto ip_address = request->ip_address().c_str();
      u32 sizeof_alias_buffer {};
      u32 sizeof_filepath_buffer {};
      auto status = library_->DbGetDatabaseListSizes(ip_address, &sizeof_alias_buffer, &sizeof_filepath_buffer);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_sizeof_alias_buffer(sizeof_alias_buffer);
        response->set_sizeof_filepath_buffer(sizeof_filepath_buffer);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbGetPropertySize(::grpc::ServerContext* context, const DbGetPropertySizeRequest* request, DbGetPropertySizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto db_object_grpc_session = request->db_object();
      nxDatabaseRef_t db_object = nx_database_ref_t_resource_repository_->access_session(db_object_grpc_session.id(), db_object_grpc_session.name());
      u32 property_id;
      switch (request->property_id_enum_case()) {
        case nixnet_grpc::DbGetPropertySizeRequest::PropertyIdEnumCase::kPropertyId: {
          property_id = static_cast<u32>(request->property_id());
          break;
        }
        case nixnet_grpc::DbGetPropertySizeRequest::PropertyIdEnumCase::kPropertyIdRaw: {
          property_id = static_cast<u32>(request->property_id_raw());
          break;
        }
        case nixnet_grpc::DbGetPropertySizeRequest::PropertyIdEnumCase::PROPERTY_ID_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for property_id was not specified or out of range");
          break;
        }
      }

      u32 property_size {};
      auto status = library_->DbGetPropertySize(db_object, property_id, &property_size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_property_size(property_size);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbMerge(::grpc::ServerContext* context, const DbMergeRequest* request, DbMergeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto target_cluster_grpc_session = request->target_cluster();
      nxDatabaseRef_t target_cluster = nx_database_ref_t_resource_repository_->access_session(target_cluster_grpc_session.id(), target_cluster_grpc_session.name());
      auto source_obj_grpc_session = request->source_obj();
      nxDatabaseRef_t source_obj = nx_database_ref_t_resource_repository_->access_session(source_obj_grpc_session.id(), source_obj_grpc_session.name());
      u32 copy_mode;
      switch (request->copy_mode_enum_case()) {
        case nixnet_grpc::DbMergeRequest::CopyModeEnumCase::kCopyMode: {
          copy_mode = static_cast<u32>(request->copy_mode());
          break;
        }
        case nixnet_grpc::DbMergeRequest::CopyModeEnumCase::kCopyModeRaw: {
          copy_mode = static_cast<u32>(request->copy_mode_raw());
          break;
        }
        case nixnet_grpc::DbMergeRequest::CopyModeEnumCase::COPY_MODE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for copy_mode was not specified or out of range");
          break;
        }
      }

      char* prefix = (char*)request->prefix().c_str();
      u32 wait_for_complete = request->wait_for_complete();
      u32 percent_complete {};
      auto status = library_->DbMerge(target_cluster, source_obj, copy_mode, prefix, wait_for_complete, &percent_complete);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_percent_complete(percent_complete);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbOpenDatabase(::grpc::ServerContext* context, const DbOpenDatabaseRequest* request, DbOpenDatabaseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto database_name = request->database_name().c_str();

      auto init_lambda = [&] () {
        nxDatabaseRef_t database;
        auto status = library_->DbOpenDatabase(database_name, &database);
        return std::make_tuple(status, database);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (nxDatabaseRef_t id) { library_->DbCloseDatabase(id, false); };
      int status = nx_database_ref_t_resource_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_database()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbRemoveAlias(::grpc::ServerContext* context, const DbRemoveAliasRequest* request, DbRemoveAliasResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto database_alias = request->database_alias().c_str();
      auto status = library_->DbRemoveAlias(database_alias);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbSaveDatabase(::grpc::ServerContext* context, const DbSaveDatabaseRequest* request, DbSaveDatabaseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto database_grpc_session = request->database();
      nxDatabaseRef_t database = nx_database_ref_t_resource_repository_->access_session(database_grpc_session.id(), database_grpc_session.name());
      auto db_filepath = request->db_filepath().c_str();
      auto status = library_->DbSaveDatabase(database, db_filepath);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DbUndeploy(::grpc::ServerContext* context, const DbUndeployRequest* request, DbUndeployResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto ip_address = request->ip_address().c_str();
      auto database_alias = request->database_alias().c_str();
      auto status = library_->DbUndeploy(ip_address, database_alias);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::DisconnectTerminals(::grpc::ServerContext* context, const DisconnectTerminalsRequest* request, DisconnectTerminalsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      const char* source;
      switch (request->source_enum_case()) {
        case nixnet_grpc::DisconnectTerminalsRequest::SourceEnumCase::kSourceMapped: {
          auto source_imap_it = terminalname_input_map_.find(request->source_mapped());
          if (source_imap_it == terminalname_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for source_mapped was not specified or out of range.");
          }
          source = const_cast<const char*>((source_imap_it->second).c_str());
          break;
        }
        case nixnet_grpc::DisconnectTerminalsRequest::SourceEnumCase::kSourceRaw: {
          source = const_cast<const char*>(request->source_raw().c_str());
          break;
        }
        case nixnet_grpc::DisconnectTerminalsRequest::SourceEnumCase::SOURCE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for source was not specified or out of range");
          break;
        }
      }

      const char* destination;
      switch (request->destination_enum_case()) {
        case nixnet_grpc::DisconnectTerminalsRequest::DestinationEnumCase::kDestinationMapped: {
          auto destination_imap_it = terminalname_input_map_.find(request->destination_mapped());
          if (destination_imap_it == terminalname_input_map_.end()) {
            return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for destination_mapped was not specified or out of range.");
          }
          destination = const_cast<const char*>((destination_imap_it->second).c_str());
          break;
        }
        case nixnet_grpc::DisconnectTerminalsRequest::DestinationEnumCase::kDestinationRaw: {
          destination = const_cast<const char*>(request->destination_raw().c_str());
          break;
        }
        case nixnet_grpc::DisconnectTerminalsRequest::DestinationEnumCase::DESTINATION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for destination was not specified or out of range");
          break;
        }
      }

      auto status = library_->DisconnectTerminals(session, source, destination);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::Flush(::grpc::ServerContext* context, const FlushRequest* request, FlushResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      auto status = library_->Flush(session);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::FutureTimeTrigger(::grpc::ServerContext* context, const FutureTimeTriggerRequest* request, FutureTimeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      nxTimestamp1ns_t when = request->when();
      u32 timescale;
      switch (request->timescale_enum_case()) {
        case nixnet_grpc::FutureTimeTriggerRequest::TimescaleEnumCase::kTimescale: {
          timescale = static_cast<u32>(request->timescale());
          break;
        }
        case nixnet_grpc::FutureTimeTriggerRequest::TimescaleEnumCase::kTimescaleRaw: {
          timescale = static_cast<u32>(request->timescale_raw());
          break;
        }
        case nixnet_grpc::FutureTimeTriggerRequest::TimescaleEnumCase::TIMESCALE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timescale was not specified or out of range");
          break;
        }
      }

      auto status = library_->FutureTimeTrigger(session, when, timescale);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::GetPropertySize(::grpc::ServerContext* context, const GetPropertySizeRequest* request, GetPropertySizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      u32 property_id;
      switch (request->property_id_enum_case()) {
        case nixnet_grpc::GetPropertySizeRequest::PropertyIdEnumCase::kPropertyId: {
          property_id = static_cast<u32>(request->property_id());
          break;
        }
        case nixnet_grpc::GetPropertySizeRequest::PropertyIdEnumCase::kPropertyIdRaw: {
          property_id = static_cast<u32>(request->property_id_raw());
          break;
        }
        case nixnet_grpc::GetPropertySizeRequest::PropertyIdEnumCase::PROPERTY_ID_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for property_id was not specified or out of range");
          break;
        }
      }

      u32 property_size {};
      auto status = library_->GetPropertySize(session, property_id, &property_size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_property_size(property_size);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::GetSubPropertySize(::grpc::ServerContext* context, const GetSubPropertySizeRequest* request, GetSubPropertySizeResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      u32 active_index = request->active_index();
      u32 property_id;
      switch (request->property_id_enum_case()) {
        case nixnet_grpc::GetSubPropertySizeRequest::PropertyIdEnumCase::kPropertyId: {
          property_id = static_cast<u32>(request->property_id());
          break;
        }
        case nixnet_grpc::GetSubPropertySizeRequest::PropertyIdEnumCase::kPropertyIdRaw: {
          property_id = static_cast<u32>(request->property_id_raw());
          break;
        }
        case nixnet_grpc::GetSubPropertySizeRequest::PropertyIdEnumCase::PROPERTY_ID_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for property_id was not specified or out of range");
          break;
        }
      }

      u32 property_size {};
      auto status = library_->GetSubPropertySize(session, active_index, property_id, &property_size);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_property_size(property_size);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ReadFrame(::grpc::ServerContext* context, const ReadFrameRequest* request, ReadFrameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      int32 number_of_frames = request->number_of_frames();
      u32 max_payload_per_frame = request->max_payload_per_frame();
      u32 frame_type;
      switch (request->frame_type_enum_case()) {
        case nixnet_grpc::ReadFrameRequest::FrameTypeEnumCase::kFrameType: {
          frame_type = static_cast<u32>(request->frame_type());
          break;
        }
        case nixnet_grpc::ReadFrameRequest::FrameTypeEnumCase::kFrameTypeRaw: {
          frame_type = static_cast<u32>(request->frame_type_raw());
          break;
        }
        case nixnet_grpc::ReadFrameRequest::FrameTypeEnumCase::FRAME_TYPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for frame_type was not specified or out of range");
          break;
        }
      }

      auto size_of_buffer = get_frame_buffer_size(number_of_frames, max_payload_per_frame, frame_type);
      f64 timeout;
      switch (request->timeout_enum_case()) {
        case nixnet_grpc::ReadFrameRequest::TimeoutEnumCase::kTimeout: {
          timeout = static_cast<f64>(request->timeout());
          break;
        }
        case nixnet_grpc::ReadFrameRequest::TimeoutEnumCase::kTimeoutRaw: {
          timeout = static_cast<f64>(request->timeout_raw());
          break;
        }
        case nixnet_grpc::ReadFrameRequest::TimeoutEnumCase::TIMEOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timeout was not specified or out of range");
          break;
        }
      }

      std::vector<u8> buffer(size_of_buffer, u8());
      u32 number_of_bytes_returned {};
      auto status = library_->ReadFrame(session, buffer.data(), size_of_buffer, timeout, &number_of_bytes_returned);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(buffer, response->mutable_buffer(), number_of_bytes_returned, frame_type);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ReadSignalSinglePoint(::grpc::ServerContext* context, const ReadSignalSinglePointRequest* request, ReadSignalSinglePointResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      u32 number_of_signals = request->number_of_signals();
      auto size_of_value_buffer = number_of_signals * sizeof(f64);
      auto size_of_timestamp_buffer = number_of_signals * sizeof(f64);
      response->mutable_value_buffer()->Resize(number_of_signals, 0);
      f64* value_buffer = response->mutable_value_buffer()->mutable_data();
      response->mutable_timestamp_buffer()->Resize(number_of_signals, 0);
      nxTimestamp100ns_t* timestamp_buffer = reinterpret_cast<nxTimestamp100ns_t*>(response->mutable_timestamp_buffer()->mutable_data());
      auto status = library_->ReadSignalSinglePoint(session, value_buffer, size_of_value_buffer, timestamp_buffer, size_of_timestamp_buffer);
      response->set_status(status);
      if (status_ok(status)) {
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ReadSignalWaveform(::grpc::ServerContext* context, const ReadSignalWaveformRequest* request, ReadSignalWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      f64 timeout;
      switch (request->timeout_enum_case()) {
        case nixnet_grpc::ReadSignalWaveformRequest::TimeoutEnumCase::kTimeout: {
          timeout = static_cast<f64>(request->timeout());
          break;
        }
        case nixnet_grpc::ReadSignalWaveformRequest::TimeoutEnumCase::kTimeoutRaw: {
          timeout = static_cast<f64>(request->timeout_raw());
          break;
        }
        case nixnet_grpc::ReadSignalWaveformRequest::TimeoutEnumCase::TIMEOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timeout was not specified or out of range");
          break;
        }
      }

      u32 samples_per_signal = request->samples_per_signal();
      u32 number_of_signals = request->number_of_signals();
      auto size_of_value_buffer = samples_per_signal * number_of_signals * sizeof(f64);
      nxTimestamp100ns_t start_time {};
      f64 delta_time {};
      std::vector<f64> value_buffer(samples_per_signal * number_of_signals, f64());
      u32 number_of_values_returned {};
      auto status = library_->ReadSignalWaveform(session, timeout, &start_time, &delta_time, value_buffer.data(), size_of_value_buffer, &number_of_values_returned);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_start_time(start_time);
        response->set_delta_time(delta_time);
        convert_to_grpc(value_buffer, response->mutable_value_buffer(), number_of_values_returned, number_of_signals);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ReadSignalXY(::grpc::ServerContext* context, const ReadSignalXYRequest* request, ReadSignalXYResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      nxTimestamp100ns_t time_limit = request->time_limit();
      u32 samples_per_signal = request->samples_per_signal();
      u32 number_of_signals = request->number_of_signals();
      auto size_of_value_buffer = samples_per_signal * number_of_signals * sizeof(f64);
      auto size_of_timestamp_buffer = samples_per_signal * number_of_signals * sizeof(f64);
      auto size_of_num_pairs_buffer = number_of_signals * sizeof(u32);
      response->mutable_value_buffer()->Resize(samples_per_signal * number_of_signals, 0);
      f64* value_buffer = response->mutable_value_buffer()->mutable_data();
      response->mutable_timestamp_buffer()->Resize(samples_per_signal * number_of_signals, 0);
      nxTimestamp100ns_t* timestamp_buffer = reinterpret_cast<nxTimestamp100ns_t*>(response->mutable_timestamp_buffer()->mutable_data());
      response->mutable_num_pairs_buffer()->Resize(number_of_signals, 0);
      u32* num_pairs_buffer = response->mutable_num_pairs_buffer()->mutable_data();
      auto status = library_->ReadSignalXY(session, &time_limit, value_buffer, size_of_value_buffer, timestamp_buffer, size_of_timestamp_buffer, num_pairs_buffer, size_of_num_pairs_buffer);
      response->set_status(status);
      if (status_ok(status)) {
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::ReadStateTimeTrigger(::grpc::ServerContext* context, const ReadStateTimeTriggerRequest* request, ReadStateTimeTriggerResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      f64 timeout;
      switch (request->timeout_enum_case()) {
        case nixnet_grpc::ReadStateTimeTriggerRequest::TimeoutEnumCase::kTimeout: {
          timeout = static_cast<f64>(request->timeout());
          break;
        }
        case nixnet_grpc::ReadStateTimeTriggerRequest::TimeoutEnumCase::kTimeoutRaw: {
          timeout = static_cast<f64>(request->timeout_raw());
          break;
        }
        case nixnet_grpc::ReadStateTimeTriggerRequest::TimeoutEnumCase::TIMEOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timeout was not specified or out of range");
          break;
        }
      }

      auto state_size = sizeof(nxTimeLocalNetwork_t);
      _nxTimeLocalNetwork_t state_value {};
      auto status = library_->ReadStateTimeTrigger(session, timeout, state_size, &state_value);
      response->set_status(status);
      if (status_ok(status)) {
        convert_to_grpc(state_value, response->mutable_state_value());
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::Start(::grpc::ServerContext* context, const StartRequest* request, StartResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      u32 scope;
      switch (request->scope_enum_case()) {
        case nixnet_grpc::StartRequest::ScopeEnumCase::kScope: {
          scope = static_cast<u32>(request->scope());
          break;
        }
        case nixnet_grpc::StartRequest::ScopeEnumCase::kScopeRaw: {
          scope = static_cast<u32>(request->scope_raw());
          break;
        }
        case nixnet_grpc::StartRequest::ScopeEnumCase::SCOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for scope was not specified or out of range");
          break;
        }
      }

      auto status = library_->Start(session, scope);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::StatusToString(::grpc::ServerContext* context, const StatusToStringRequest* request, StatusToStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      nxStatus_t status_id = request->status_id();
      auto sizeof_string = 2048U;
      std::string status_description(2048 - 1, '\0');
      library_->StatusToString(status_id, sizeof_string, (char*)status_description.data());
      auto status = 0;
      response->set_status(status);
      if (status_ok(status)) {
        response->set_status_description(status_description);
        nidevice_grpc::converters::trim_trailing_nulls(*(response->mutable_status_description()));
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::Stop(::grpc::ServerContext* context, const StopRequest* request, StopResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      u32 scope;
      switch (request->scope_enum_case()) {
        case nixnet_grpc::StopRequest::ScopeEnumCase::kScope: {
          scope = static_cast<u32>(request->scope());
          break;
        }
        case nixnet_grpc::StopRequest::ScopeEnumCase::kScopeRaw: {
          scope = static_cast<u32>(request->scope_raw());
          break;
        }
        case nixnet_grpc::StopRequest::ScopeEnumCase::SCOPE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for scope was not specified or out of range");
          break;
        }
      }

      auto status = library_->Stop(session, scope);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::SystemClose(::grpc::ServerContext* context, const SystemCloseRequest* request, SystemCloseResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto system_grpc_session = request->system();
      nxSessionRef_t system = session_repository_->access_session(system_grpc_session.id(), system_grpc_session.name());
      session_repository_->remove_session(system_grpc_session.id(), system_grpc_session.name());
      auto status = library_->SystemClose(system);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::SystemOpen(::grpc::ServerContext* context, const SystemOpenRequest* request, SystemOpenResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {

      auto init_lambda = [&] () {
        nxSessionRef_t system;
        auto status = library_->SystemOpen(&system);
        return std::make_tuple(status, system);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (nxSessionRef_t id) { library_->SystemClose(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status_ok(status)) {
        response->mutable_system()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::Wait(::grpc::ServerContext* context, const WaitRequest* request, WaitResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      u32 condition;
      switch (request->condition_enum_case()) {
        case nixnet_grpc::WaitRequest::ConditionEnumCase::kCondition: {
          condition = static_cast<u32>(request->condition());
          break;
        }
        case nixnet_grpc::WaitRequest::ConditionEnumCase::kConditionRaw: {
          condition = static_cast<u32>(request->condition_raw());
          break;
        }
        case nixnet_grpc::WaitRequest::ConditionEnumCase::CONDITION_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for condition was not specified or out of range");
          break;
        }
      }

      u32 param_in = request->param_in();
      f64 timeout = request->timeout();
      u32 param_out {};
      auto status = library_->Wait(session, condition, param_in, timeout, &param_out);
      response->set_status(status);
      if (status_ok(status)) {
        response->set_param_out(param_out);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::WriteFrame(::grpc::ServerContext* context, const WriteFrameRequest* request, WriteFrameResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      auto buffer = convert_from_grpc<u8>(request->buffer());
      auto number_of_bytes_for_frames = buffer.size();
      f64 timeout;
      switch (request->timeout_enum_case()) {
        case nixnet_grpc::WriteFrameRequest::TimeoutEnumCase::kTimeout: {
          timeout = static_cast<f64>(request->timeout());
          break;
        }
        case nixnet_grpc::WriteFrameRequest::TimeoutEnumCase::kTimeoutRaw: {
          timeout = static_cast<f64>(request->timeout_raw());
          break;
        }
        case nixnet_grpc::WriteFrameRequest::TimeoutEnumCase::TIMEOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timeout was not specified or out of range");
          break;
        }
      }

      auto status = library_->WriteFrame(session, buffer, number_of_bytes_for_frames, timeout);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::WriteSignalSinglePoint(::grpc::ServerContext* context, const WriteSignalSinglePointRequest* request, WriteSignalSinglePointResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      auto value_buffer = const_cast<f64*>(request->value_buffer().data());
      u32 size_of_value_buffer = static_cast<u32>(request->value_buffer().size() * sizeof(f64));
      auto status = library_->WriteSignalSinglePoint(session, value_buffer, size_of_value_buffer);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::WriteSignalWaveform(::grpc::ServerContext* context, const WriteSignalWaveformRequest* request, WriteSignalWaveformResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      f64 timeout;
      switch (request->timeout_enum_case()) {
        case nixnet_grpc::WriteSignalWaveformRequest::TimeoutEnumCase::kTimeout: {
          timeout = static_cast<f64>(request->timeout());
          break;
        }
        case nixnet_grpc::WriteSignalWaveformRequest::TimeoutEnumCase::kTimeoutRaw: {
          timeout = static_cast<f64>(request->timeout_raw());
          break;
        }
        case nixnet_grpc::WriteSignalWaveformRequest::TimeoutEnumCase::TIMEOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timeout was not specified or out of range");
          break;
        }
      }

      auto value_buffer = const_cast<f64*>(request->value_buffer().data());
      u32 size_of_value_buffer = static_cast<u32>(request->value_buffer().size() * sizeof(f64));
      auto status = library_->WriteSignalWaveform(session, timeout, value_buffer, size_of_value_buffer);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiXnetService::WriteSignalXY(::grpc::ServerContext* context, const WriteSignalXYRequest* request, WriteSignalXYResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto session_grpc_session = request->session();
      nxSessionRef_t session = session_repository_->access_session(session_grpc_session.id(), session_grpc_session.name());
      f64 timeout;
      switch (request->timeout_enum_case()) {
        case nixnet_grpc::WriteSignalXYRequest::TimeoutEnumCase::kTimeout: {
          timeout = static_cast<f64>(request->timeout());
          break;
        }
        case nixnet_grpc::WriteSignalXYRequest::TimeoutEnumCase::kTimeoutRaw: {
          timeout = static_cast<f64>(request->timeout_raw());
          break;
        }
        case nixnet_grpc::WriteSignalXYRequest::TimeoutEnumCase::TIMEOUT_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for timeout was not specified or out of range");
          break;
        }
      }

      auto value_buffer = const_cast<f64*>(request->value_buffer().data());
      u32 size_of_value_buffer = static_cast<u32>(request->value_buffer().size() * sizeof(f64));
      auto timestamp_buffer = const_cast<nxTimestamp100ns_t*>(reinterpret_cast<const nxTimestamp100ns_t*>(request->timestamp_buffer().data()));
      u32 size_of_timestamp_buffer = static_cast<u32>(request->timestamp_buffer().size() * sizeof(nxTimestamp100ns_t));
      auto num_pairs_buffer = const_cast<u32*>(request->num_pairs_buffer().data());
      u32 size_of_num_pairs_buffer = static_cast<u32>(request->num_pairs_buffer().size() * sizeof(u32));
      auto status = library_->WriteSignalXY(session, timeout, value_buffer, size_of_value_buffer, timestamp_buffer, size_of_timestamp_buffer, num_pairs_buffer, size_of_num_pairs_buffer);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }


  NiXnetFeatureToggles::NiXnetFeatureToggles(
    const nidevice_grpc::FeatureToggles& feature_toggles)
    : is_enabled(
        feature_toggles.is_feature_enabled("nixnet", CodeReadiness::kNextRelease))
  {
  }
} // namespace nixnet_grpc

namespace nidevice_grpc {
namespace converters {
template <>
void convert_to_grpc(const _nxTimeLocalNetwork_t& input, nixnet_grpc::TimeLocalNetwork* output) 
{
  output->set_local_time(input.LocalTime);
  output->set_network_time(input.NetworkTime);
  output->set_flags(input.Flags);
}

} // converters
} // nidevice_grpc

